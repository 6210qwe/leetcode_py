# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 4187
标题: Best Reachable Tower
难度: medium
链接: https://leetcode.cn/problems/best-reachable-tower/
题目类型: 其他
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3809. 最好可到达的塔 - 给你一个二维整数数组 towers，其中 towers[i] = [xi, yi, qi] 表示第 i 座塔的坐标 (xi, yi) 和质量因子 qi。 另外给你一个整数数组 center = [cx, cy] 表示你的位置，以及一个整数 radius。 如果一座塔与 center 之间的 曼哈顿距离小于或等于 radius，则称该塔是 可到达的。 在所有可到达的塔中： * 返回质量因子 最大 的塔的坐标。 * 如果存在并列的塔，返回坐标 字典序最小 的塔。如果没有塔是可到达的，返回 [-1, -1]。 两点 (xi, yi) 和 (xj, yj) 之间的 曼哈顿距离 为 |xi - xj| + |yi - yj|。 坐标 [xi, yi] 字典序小于 [xj, yj] 是指：xi < xj，或者 xi == xj 且 yi < yj。 |x| 表示 x 的 绝对值。 示例 1： 输入： towers = [[1,2,5], [2,1,7], [3,1,9]], center = [1,1], radius = 2 输出： [3,1] 解释： * 塔 [1, 2, 5]：曼哈顿距离 = |1 - 1| + |2 - 1| = 1，可到达。 * 塔 [2, 1, 7]：曼哈顿距离 = |2 - 1| + |1 - 1| = 1，可到达。 * 塔 [3, 1, 9]：曼哈顿距离 = |3 - 1| + |1 - 1| = 2，可到达。 所有塔都是可到达的。最大质量因子为 9，对应塔 [3, 1]。 示例 2： 输入： towers = [[1,3,4], [2,2,4], [4,4,7]], center = [0,0], radius = 5 输出： [1,3] 解释： * 塔 [1, 3, 4]：曼哈顿距离 = |1 - 0| + |3 - 0| = 4，可到达。 * 塔 [2, 2, 4]：曼哈顿距离 = |2 - 0| + |2 - 0| = 4，可到达。 * 塔 [4, 4, 7]：曼哈顿距离 = |4 - 0| + |4 - 0| = 8，不可到达。 在可到达的塔中，最大质量因子为 4。[1, 3] 和 [2, 2] 的质量因子相同，因此返回字典序较小的坐标 [1, 3]。 示例 3： 输入： towers = [[5,6,8], [0,3,5]], center = [1,2], radius = 1 输出： [-1,-1] 解释： * 塔 [5, 6, 8]：曼哈顿距离 = |5 - 1| + |6 - 2| = 8，不可到达。 * 塔 [0, 3, 5]：曼哈顿距离 = |0 - 1| + |3 - 2| = 2，不可到达。 在给定半径内没有可到达的塔，故返回 [-1, -1]。 提示： * 1 <= towers.length <= 105 * towers[i] = [xi, yi, qi] * center = [cx, cy] * 0 <= xi, yi, qi, cx, cy <= 105 * 0 <= radius <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 遍历所有的塔，计算每个塔与中心点的曼哈顿距离，并筛选出在给定半径内的塔。然后从这些塔中选择质量因子最大的塔，如果有多座塔具有相同的质量因子，则选择字典序最小的塔。

算法步骤:
1. 初始化结果变量 `result` 为 `[-1, -1]`，表示如果没有可到达的塔则返回此值。
2. 初始化最大质量因子 `max_quality` 为负无穷大。
3. 遍历每一座塔：
   - 计算塔与中心点的曼哈顿距离。
   - 如果曼哈顿距离小于等于给定半径，则检查当前塔的质量因子是否大于 `max_quality`，或者质量因子相等但字典序更小。
   - 更新 `max_quality` 和 `result`。
4. 返回 `result`。

关键点:
- 使用曼哈顿距离判断塔是否可到达。
- 选择质量因子最大的塔，如果有多座塔具有相同的质量因子，则选择字典序最小的塔。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是塔的数量。我们需要遍历每一座塔来计算曼哈顿距离并更新结果。
空间复杂度: O(1)，我们只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def best_reachable_tower(towers: List[List[int]], center: List[int], radius: int) -> List[int]:
    """
    返回在给定半径内质量因子最大的塔的坐标，如果有多座塔具有相同的质量因子，则返回字典序最小的塔。
    如果没有塔是可到达的，返回 [-1, -1]。
    """
    result = [-1, -1]
    max_quality = float('-inf')

    for tower in towers:
        x, y, quality = tower
        distance = abs(x - center[0]) + abs(y - center[1])
        
        if distance <= radius:
            if quality > max_quality or (quality == max_quality and [x, y] < result):
                max_quality = quality
                result = [x, y]

    return result

Solution = create_solution(best_reachable_tower)