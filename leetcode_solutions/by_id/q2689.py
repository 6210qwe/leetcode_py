# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2689
标题: Rearranging Fruits
难度: hard
链接: https://leetcode.cn/problems/rearranging-fruits/
题目类型: 贪心、排序、数组、哈希表
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2561. 重排水果 - 你有两个果篮，每个果篮中有 n 个水果。给你两个下标从 0 开始的整数数组 basket1 和 basket2 ，用以表示两个果篮中每个水果的交换成本。你想要让两个果篮相等。为此，可以根据需要多次执行下述操作： * 选中两个下标 i 和 j ，并交换 basket1 中的第 i 个水果和 basket2 中的第 j 个水果。 * 交换的成本是 min(basket1i,basket2j) 。 根据果篮中水果的成本进行排序，如果排序后结果完全相同，则认为两个果篮相等。 返回使两个果篮相等的最小交换成本，如果无法使两个果篮相等，则返回 -1 。 示例 1： 输入：basket1 = [4,2,2,2], basket2 = [1,4,1,2] 输出：1 解释：交换 basket1 中下标为 1 的水果和 basket2 中下标为 0 的水果，交换的成本为 1 。此时，basket1 = [4,1,2,2] 且 basket2 = [2,4,1,2] 。重排两个数组，发现二者相等。 示例 2： 输入：basket1 = [2,3,4,1], basket2 = [3,2,5,1] 输出：-1 解释：可以证明无法使两个果篮相等。 提示： * basket1.length == basket2.length * 1 <= basket1.length <= 105 * 1 <= basket1i,basket2i <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用贪心算法和哈希表来计算最小交换成本。

算法步骤:
1. 统计两个篮子中每种水果的数量。
2. 找出需要交换的水果种类及其数量。
3. 计算最小交换成本，优先使用成本较低的水果进行交换。

关键点:
- 使用哈希表统计每种水果的数量。
- 通过贪心算法选择成本最低的交换方式。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是篮子的长度。主要由排序操作决定。
空间复杂度: O(n)，用于存储水果数量的哈希表。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def min_cost_to_equal_baskets(basket1: List[int], basket2: List[int]) -> int:
    """
    计算使两个果篮相等的最小交换成本。
    """
    from collections import Counter
    
    # 统计两个篮子中每种水果的数量
    count1 = Counter(basket1)
    count2 = Counter(basket2)
    
    # 合并两个计数器，找出需要交换的水果种类及其数量
    diff = (count1 - count2) + (count2 - count1)
    
    # 如果有奇数个需要交换的水果，则无法使两个果篮相等
    if sum(diff.values()) % 2 != 0:
        return -1
    
    # 将需要交换的水果按成本从小到大排序
    to_swap = sorted(diff.elements())
    
    # 计算最小交换成本
    cost = 0
    half = len(to_swap) // 2
    for i in range(half):
        cost += min(to_swap[i], to_swap[-(i + 1)])
    
    return cost


Solution = create_solution(min_cost_to_equal_baskets)