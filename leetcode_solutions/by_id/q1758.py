# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1758
标题: Distribute Repeating Integers
难度: hard
链接: https://leetcode.cn/problems/distribute-repeating-integers/
题目类型: 位运算、数组、哈希表、动态规划、回溯、状态压缩、计数
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1655. 分配重复整数 - 给你一个长度为 n 的整数数组 nums ，这个数组中至多有 50 个不同的值。同时你有 m 个顾客的订单 quantity ，其中，整数 quantity[i] 是第 i 位顾客订单的数目。请你判断是否能将 nums 中的整数分配给这些顾客，且满足： * 第 i 位顾客 恰好 有 quantity[i] 个整数。 * 第 i 位顾客拿到的整数都是 相同的 。 * 每位顾客都满足上述两个要求。 如果你可以分配 nums 中的整数满足上面的要求，那么请返回 true ，否则返回 false 。 示例 1： 输入：nums = [1,2,3,4], quantity = [2] 输出：false 解释：第 0 位顾客没办法得到两个相同的整数。 示例 2： 输入：nums = [1,2,3,3], quantity = [2] 输出：true 解释：第 0 位顾客得到 [3,3] 。整数 [1,2] 都没有被使用。 示例 3： 输入：nums = [1,1,2,2], quantity = [2,2] 输出：true 解释：第 0 位顾客得到 [1,1] ，第 1 位顾客得到 [2,2] 。 提示： * n == nums.length * 1 <= n <= 105 * 1 <= nums[i] <= 1000 * m == quantity.length * 1 <= m <= 10 * 1 <= quantity[i] <= 105 * nums 中至多有 50 个不同的数字。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划和状态压缩来解决这个问题。

算法步骤:
1. 统计每个数字在 `nums` 中出现的次数。
2. 将 `quantity` 排序，从大到小处理每个顾客的需求。
3. 使用动态规划和状态压缩来检查是否可以满足所有顾客的需求。

关键点:
- 使用位掩码来表示当前状态，即哪些顾客已经被满足。
- 动态规划的状态转移方程是基于当前状态和剩余数量来更新的。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(2^m * m * k)，其中 m 是 `quantity` 的长度，k 是 `nums` 中不同数字的数量。
空间复杂度: O(2^m * k)，用于存储动态规划的状态。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from collections import Counter

def can_distribute(nums: List[int], quantity: List[int]) -> bool:
    # 统计每个数字在 nums 中出现的次数
    count = Counter(nums)
    freqs = list(count.values())
    
    # 对 quantity 进行排序，从大到小处理
    quantity.sort(reverse=True)
    
    # 状态压缩 DP
    dp = [False] * (1 << len(quantity))
    dp[0] = True
    
    for f in freqs:
        new_dp = dp[:]
        for state in range(1 << len(quantity)):
            if not dp[state]:
                continue
            total = 0
            for i in range(len(quantity)):
                if state & (1 << i):
                    total += quantity[i]
            for i in range(len(quantity)):
                if not (state & (1 << i)) and total + quantity[i] <= f:
                    new_dp[state | (1 << i)] = True
        dp = new_dp
    
    return dp[(1 << len(quantity)) - 1]

Solution = create_solution(can_distribute)