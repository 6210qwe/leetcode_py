# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1120
标题: Flower Planting With No Adjacent
难度: medium
链接: https://leetcode.cn/problems/flower-planting-with-no-adjacent/
题目类型: 深度优先搜索、广度优先搜索、图
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1042. 不邻接植花 - 有 n 个花园，按从 1 到 n 标记。另有数组 paths ，其中 paths[i] = [xi, yi] 描述了花园 xi 到花园 yi 的双向路径。在每个花园中，你打算种下四种花之一。 另外，所有花园 最多 有 3 条路径可以进入或离开. 你需要为每个花园选择一种花，使得通过路径相连的任何两个花园中的花的种类互不相同。 以数组形式返回 任一 可行的方案作为答案 answer，其中 answer[i] 为在第 (i+1) 个花园中种植的花的种类。花的种类用 1、2、3、4 表示。保证存在答案。 示例 1： 输入：n = 3, paths = [[1,2],[2,3],[3,1]] 输出：[1,2,3] 解释： 花园 1 和 2 花的种类不同。 花园 2 和 3 花的种类不同。 花园 3 和 1 花的种类不同。 因此，[1,2,3] 是一个满足题意的答案。其他满足题意的答案有 [1,2,4]、[1,4,2] 和 [3,2,1] 示例 2： 输入：n = 4, paths = [[1,2],[3,4]] 输出：[1,2,1,2] 示例 3： 输入：n = 4, paths = [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]] 输出：[1,2,3,4] 提示： * 1 <= n <= 104 * 0 <= paths.length <= 2 * 104 * paths[i].length == 2 * 1 <= xi, yi <= n * xi != yi * 每个花园 最多 有 3 条路径可以进入或离开
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用贪心算法，依次为每个花园选择一种未被相邻花园使用的花。

算法步骤:
1. 构建图的邻接表表示。
2. 初始化一个结果数组，长度为 n，初始值为 0。
3. 遍历每个花园，选择一种未被相邻花园使用的花。
4. 更新结果数组。

关键点:
- 使用集合来记录每个花园相邻的花的种类。
- 由于每个花园最多有 3 条路径，所以总能找到一种可用的花。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n + m)，其中 n 是花园的数量，m 是路径的数量。
空间复杂度: O(n + m)，存储邻接表和结果数组所需的空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def gardenNoAdj(n: int, paths: List[List[int]]) -> List[int]:
    # 构建图的邻接表表示
    graph = [[] for _ in range(n)]
    for x, y in paths:
        graph[x - 1].append(y - 1)
        graph[y - 1].append(x - 1)
    
    # 初始化结果数组
    result = [0] * n
    
    # 为每个花园选择一种未被相邻花园使用的花
    for i in range(n):
        used_flowers = {result[neighbor] for neighbor in graph[i]}
        for flower in range(1, 5):
            if flower not in used_flowers:
                result[i] = flower
                break
    
    return result

Solution = create_solution(gardenNoAdj)