# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2698
标题: Find the Array Concatenation Value
难度: easy
链接: https://leetcode.cn/problems/find-the-array-concatenation-value/
题目类型: 数组、双指针、模拟
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2562. 找出数组的串联值 - 给你一个下标从 0 开始的整数数组 nums 。 现定义两个数字的 串联 是由这两个数值串联起来形成的新数字。 * 例如，15 和 49 的串联是 1549 。 nums 的 串联值 最初等于 0 。执行下述操作直到 nums 变为空： * 如果 nums 的长度大于 1，分别选中 nums 中的第一个元素和最后一个元素，将二者串联得到的值加到 nums 的 串联值 上，然后从 nums 中删除第一个和最后一个元素。例如，如果 nums 是 [1, 2, 4, 5, 6]，将 16 添加到串联值。 * 如果 nums 中仅存在一个元素，则将该元素的值加到 nums 的串联值上，然后删除这个元素。 返回执行完所有操作后 nums 的串联值。 示例 1： 输入：nums = [7,52,2,4] 输出：596 解释：在执行任一步操作前，nums 为 [7,52,2,4] ，串联值为 0 。 - 在第一步操作中： 我们选中第一个元素 7 和最后一个元素 4 。 二者的串联是 74 ，将其加到串联值上，所以串联值等于 74 。 接着我们从 nums 中移除这两个元素，所以 nums 变为 [52,2] 。 - 在第二步操作中： 我们选中第一个元素 52 和最后一个元素 2 。 二者的串联是 522 ，将其加到串联值上，所以串联值等于 596 。 接着我们从 nums 中移除这两个元素，所以 nums 变为空。 由于串联值等于 596 ，所以答案就是 596 。 示例 2： 输入：nums = [5,14,13,8,12] 输出：673 解释：在执行任一步操作前，nums 为 [5,14,13,8,12] ，串联值为 0 。 - 在第一步操作中： 我们选中第一个元素 5 和最后一个元素 12 。 二者的串联是 512 ，将其加到串联值上，所以串联值等于 512 。 接着我们从 nums 中移除这两个元素，所以 nums 变为 [14,13,8] 。 - 在第二步操作中： 我们选中第一个元素 14 和最后一个元素 8 。 二者的串联是 148 ，将其加到串联值上，所以串联值等于 660 。 接着我们从 nums 中移除这两个元素，所以 nums 变为 [13] 。 - 在第三步操作中： nums 只有一个元素，所以我们选中 13 并将其加到串联值上，所以串联值等于 673 。 接着我们从 nums 中移除这个元素，所以 nums 变为空。 由于串联值等于 673 ，所以答案就是 673 。 提示： * 1 <= nums.length <= 1000 * 1 <= nums[i] <= 104
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用双指针方法，从数组的两端向中间遍历，每次将首尾元素串联并累加到结果中。

算法步骤:
1. 初始化结果变量 `concatenation_value` 为 0。
2. 使用双指针 `left` 和 `right` 分别指向数组的起始和末尾。
3. 当 `left` 小于 `right` 时：
   - 将 `nums[left]` 和 `nums[right]` 串联成一个新数字，并加到 `concatenation_value` 上。
   - 移动 `left` 指针向右，移动 `right` 指针向左。
4. 如果 `left` 等于 `right`，说明数组长度为奇数，直接将 `nums[left]` 加到 `concatenation_value` 上。
5. 返回 `concatenation_value`。

关键点:
- 使用字符串拼接来实现数字的串联。
- 双指针方法可以高效地处理数组的两端。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是数组的长度。每个元素最多被访问一次。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def find_array_concatenation_value(nums: List[int]) -> int:
    """
    函数式接口 - 找出数组的串联值
    """
    concatenation_value = 0
    left, right = 0, len(nums) - 1
    
    while left < right:
        # 串联首尾元素并累加
        concatenated_value = int(str(nums[left]) + str(nums[right]))
        concatenation_value += concatenated_value
        left += 1
        right -= 1
    
    # 如果数组长度为奇数，处理中间的单个元素
    if left == right:
        concatenation_value += nums[left]
    
    return concatenation_value


Solution = create_solution(find_array_concatenation_value)