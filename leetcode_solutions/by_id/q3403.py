# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3403
标题: Minimum Substring Partition of Equal Character Frequency
难度: medium
链接: https://leetcode.cn/problems/minimum-substring-partition-of-equal-character-frequency/
题目类型: 哈希表、字符串、动态规划、计数
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3144. 分割字符频率相等的最少子字符串 - 给你一个字符串 s ，你需要将它分割成一个或者更多的 平衡 子字符串。比方说，s == "ababcc" 那么 ("abab", "c", "c") ，("ab", "abc", "c") 和 ("ababcc") 都是合法分割，但是 ("a", "bab", "cc") ，("aba", "bc", "c") 和 ("ab", "abcc") 不是，不平衡的子字符串用粗体表示。 请你返回 s 最少 能分割成多少个平衡子字符串。 注意：一个 平衡 字符串指的是字符串中所有字符出现的次数都相同。 示例 1： 输入：s = "fabccddg" 输出：3 解释： 我们可以将 s 分割成 3 个子字符串：("fab, "ccdd", "g") 或者 ("fabc", "cd", "dg") 。 示例 2： 输入：s = "abababaccddb" 输出：2 解释： 我们可以将 s 分割成 2 个子字符串：("abab", "abaccddb") 。 提示： * 1 <= s.length <= 1000 * s 只包含小写英文字母。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划和哈希表来记录每个子字符串的字符频率，并检查其是否为平衡子字符串。

算法步骤:
1. 初始化一个动态规划数组 dp，其中 dp[i] 表示前 i 个字符最少能分割成多少个平衡子字符串。
2. 遍历字符串 s，对于每个位置 i，检查从 j 到 i 的子字符串是否为平衡子字符串。
3. 如果是平衡子字符串，则更新 dp[i] 为 min(dp[i], dp[j-1] + 1)。
4. 返回 dp[n]，其中 n 是字符串 s 的长度。

关键点:
- 使用哈希表来记录子字符串的字符频率。
- 动态规划数组 dp 用于存储最小分割数。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2)，其中 n 是字符串 s 的长度。我们需要遍历字符串的每个子字符串。
空间复杂度: O(n)，动态规划数组 dp 的大小为 n。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def min_substring_partition(s: str) -> int:
    """
    函数式接口 - 返回字符串 s 最少能分割成多少个平衡子字符串。
    """
    n = len(s)
    dp = [float('inf')] * (n + 1)
    dp[0] = 0

    for i in range(1, n + 1):
        freq = {}
        for j in range(i, 0, -1):
            if s[j - 1] in freq:
                freq[s[j - 1]] += 1
            else:
                freq[s[j - 1]] = 1

            if len(set(freq.values())) == 1:
                dp[i] = min(dp[i], dp[j - 1] + 1)

    return dp[n]


Solution = create_solution(min_substring_partition)