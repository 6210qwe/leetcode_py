# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 51
标题: N-Queens
难度: hard
链接: https://leetcode.cn/problems/n-queens/
题目类型: 数组、回溯
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
51. N 皇后 - 按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。 n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。 示例 1： [https://assets.leetcode.com/uploads/2020/11/13/queens.jpg] 输入：n = 4 输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]] 解释：如上图所示，4 皇后问题存在两个不同的解法。 示例 2： 输入：n = 1 输出：[["Q"]] 提示： * 1 <= n <= 9
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 回溯算法 + 位运算优化，使用位掩码快速判断位置是否可用

算法步骤:
1. 使用三个整数作为位掩码：cols、diag1、diag2，分别记录列、主对角线、副对角线
2. 回溯函数backtrack(row, cols, diag1, diag2, path)：
   - 如果row == n，说明所有行都已放置，将当前解加入结果
   - 否则，对于每一列col：
     * 计算主对角线索引：diag1_idx = row - col + n - 1
     * 计算副对角线索引：diag2_idx = row + col
     * 检查位置是否可用（使用位运算）
     * 如果可用，放置皇后并递归
     * 回溯，撤销选择
3. 将路径转换为字符串格式

关键点:
- 使用位运算进行快速判断和标记
- 主对角线：row - col为常数
- 副对角线：row + col为常数
- 位掩码更新：mask |= (1 << idx)标记，mask &= ~(1 << idx)取消标记
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n!) - 最坏情况需要尝试所有排列
空间复杂度: O(n) - 递归栈深度和路径长度
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from leetcode_solutions.utils.solution import create_solution


def solve_n_queens(n: int) -> List[List[str]]:
    """
    函数式接口 - 回溯算法 + 位运算优化
    
    实现思路:
    使用回溯算法放置皇后，通过位运算快速判断位置是否可用。
    
    Args:
        n: 棋盘大小（n×n）
        
    Returns:
        所有不同的n皇后问题的解决方案列表
        
    Example:
        >>> solve_n_queens(4)
        [['.Q..', '...Q', 'Q...', '..Q.'], ['..Q.', 'Q...', '...Q', '.Q..']]
    """
    result = []
    
    def backtrack(row: int, cols: int, diag1: int, diag2: int, path: List[int]):
        """回溯函数"""
        if row == n:
            # 所有行都已放置，转换为字符串格式
            solution = []
            for col in path:
                solution.append('.' * col + 'Q' + '.' * (n - col - 1))
            result.append(solution)
            return
        
        for col in range(n):
            # 计算对角线索引
            diag1_idx = row - col + n - 1  # 主对角线
            diag2_idx = row + col  # 副对角线
            
            # 检查位置是否可用（使用位运算）
            if (cols & (1 << col)) == 0 and \
               (diag1 & (1 << diag1_idx)) == 0 and \
               (diag2 & (1 << diag2_idx)) == 0:
                # 放置皇后
                path.append(col)
                # 标记已使用
                cols |= (1 << col)
                diag1 |= (1 << diag1_idx)
                diag2 |= (1 << diag2_idx)
                # 递归
                backtrack(row + 1, cols, diag1, diag2, path)
                # 回溯：撤销标记
                cols &= ~(1 << col)
                diag1 &= ~(1 << diag1_idx)
                diag2 &= ~(1 << diag2_idx)
                path.pop()
    
    backtrack(0, 0, 0, 0, [])
    return result


# 自动生成Solution类（无需手动编写）
Solution = create_solution(solve_n_queens)
