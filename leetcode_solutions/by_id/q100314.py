# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 100314
标题: 彩灯装饰记录 III
难度: medium
链接: https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/
题目类型: 树、广度优先搜索、二叉树
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCR 151. 彩灯装饰记录 III - 一棵圣诞树记作根节点为 root 的二叉树，节点值为该位置装饰彩灯的颜色编号。请按照如下规则记录彩灯装饰结果： * 第一层按照从左到右的顺序记录 * 除第一层外每一层的记录顺序均与上一层相反。即第一层为从左到右，第二层为从右到左。 示例 1： [https://pic.leetcode.cn/1694758674-XYrUiV-%E5%89%91%E6%8C%87%20Offer%2032%20-%20I_%E7%A4%BA%E4%BE%8B1.png] 输入：root = [8,17,21,18,null,null,6] 输出：[[8],[21,17],[18,6]] 提示： * 节点总数 <= 1000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用广度优先搜索（BFS）遍历二叉树，并在每一层根据层数的奇偶性决定记录顺序。

算法步骤:
1. 初始化一个队列，将根节点加入队列。
2. 初始化一个结果列表 `res` 用于存储每一层的节点值。
3. 使用一个变量 `level` 记录当前层数。
4. 当队列不为空时，进行以下操作：
   - 获取当前层的节点数量 `size`。
   - 初始化一个临时列表 `level_values` 用于存储当前层的节点值。
   - 遍历当前层的所有节点：
     - 从队列中取出一个节点。
     - 将节点值添加到 `level_values` 中。
     - 将节点的左右子节点依次加入队列。
   - 根据当前层数的奇偶性决定是否反转 `level_values` 列表。
   - 将 `level_values` 添加到结果列表 `res` 中。
   - 增加层数 `level`。
5. 返回结果列表 `res`。

关键点:
- 使用队列进行层次遍历。
- 根据层数的奇偶性决定记录顺序。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是二叉树的节点数。每个节点都被访问一次。
空间复杂度: O(n)，队列的最大空间复杂度为 O(n)。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(root: Optional[TreeNode]) -> List[List[int]]:
    """
    函数式接口 - 使用广度优先搜索（BFS）遍历二叉树，并在每一层根据层数的奇偶性决定记录顺序。
    """
    if not root:
        return []

    queue = [root]
    res = []
    level = 0

    while queue:
        size = len(queue)
        level_values = []

        for _ in range(size):
            node = queue.pop(0)
            level_values.append(node.val)

            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

        if level % 2 == 1:
            level_values.reverse()

        res.append(level_values)
        level += 1

    return res


Solution = create_solution(solution_function_name)