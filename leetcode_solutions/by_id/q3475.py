# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3475
标题: Minimum Operations to Make Binary Array Elements Equal to One I
难度: medium
链接: https://leetcode.cn/problems/minimum-operations-to-make-binary-array-elements-equal-to-one-i/
题目类型: 位运算、队列、数组、前缀和、滑动窗口
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3191. 使二进制数组全部等于 1 的最少操作次数 I - 给你一个二进制数组 nums 。 你可以对数组执行以下操作 任意 次（也可以 0 次）： * 选择数组中 任意连续 3 个元素，并将它们 全部反转 。 反转 一个元素指的是将它的值从 0 变 1 ，或者从 1 变 0 。 请你返回将 nums 中所有元素变为 1 的 最少 操作次数。如果无法全部变成 1 ，返回 -1 。 示例 1： 输入：nums = [0,1,1,1,0,0] 输出：3 解释： 我们可以执行以下操作： * 选择下标为 0 ，1 和 2 的元素并反转，得到 nums = [1,0,0,1,0,0] 。 * 选择下标为 1 ，2 和 3 的元素并反转，得到 nums = [1,1,1,0,0,0] 。 * 选择下标为 3 ，4 和 5 的元素并反转，得到 nums = [1,1,1,1,1,1] 。 示例 2： 输入：nums = [0,1,1,1] 输出：-1 解释： 无法将所有元素都变为 1 。 提示： * 3 <= nums.length <= 105 * 0 <= nums[i] <= 1
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们定义 dp[i] 为将 nums[0:i+1] 变为全 1 所需的最小操作次数。通过状态转移方程来更新 dp 数组。

算法步骤:
1. 初始化 dp 数组，dp[0] = dp[1] = -1，因为长度小于 3 的子数组无法进行操作。
2. 遍历数组，对于每个位置 i，根据 nums[i-2], nums[i-1], nums[i] 的值来更新 dp[i]。
3. 如果 dp[n-1] 为 -1，说明无法将整个数组变为全 1，返回 -1；否则返回 dp[n-1]。

关键点:
- 动态规划的状态转移方程需要考虑当前三个元素的组合情况。
- 通过前缀和的思想来优化状态转移方程的计算。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是数组的长度。我们只需要遍历一次数组。
空间复杂度: O(n)，我们需要一个长度为 n 的 dp 数组来存储中间结果。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def min_operations_to_one(nums: List[int]) -> int:
    n = len(nums)
    if n < 3:
        return -1
    
    # 初始化 dp 数组
    dp = [-1] * n
    dp[0] = 0 if nums[0] == 1 else 1
    dp[1] = 0 if nums[0] == 1 and nums[1] == 1 else 2
    
    for i in range(2, n):
        if nums[i] == 1:
            if dp[i-1] != -1:
                dp[i] = dp[i-1]
            elif dp[i-2] != -1:
                dp[i] = dp[i-2] + 1
            else:
                dp[i] = -1
        else:
            if dp[i-1] != -1:
                dp[i] = dp[i-1] + 1
            elif dp[i-2] != -1:
                dp[i] = dp[i-2] + 2
            else:
                dp[i] = -1
    
    return dp[n-1]

Solution = create_solution(min_operations_to_one)