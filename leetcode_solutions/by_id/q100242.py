# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 100242
标题: Sparse Array Search LCCI
难度: easy
链接: https://leetcode.cn/problems/sparse-array-search-lcci/
题目类型: 数组、字符串、二分查找
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
面试题 10.05. 稀疏数组搜索 - 稀疏数组搜索。有个排好序的字符串数组，其中散布着一些空字符串，编写一种方法，找出给定字符串的位置。 示例 1： 输入：words = ["at", "", "", "", "ball", "", "", "car", "", "","dad", "", ""], s = "ta" 输出：-1 说明：不存在返回-1。 示例 2： 输入：words = ["at", "", "", "", "ball", "", "", "car", "", "","dad", "", ""], s = "ball" 输出：4 提示: 1. words的长度在[1, 1000000]之间
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用二分查找来查找目标字符串，并跳过空字符串。

算法步骤:
1. 初始化左右指针 left 和 right。
2. 进行二分查找：
   - 计算中间位置 mid。
   - 如果 mid 位置为空字符串，向右移动 mid 直到找到非空字符串或超出范围。
   - 比较非空字符串与目标字符串：
     - 如果相等，返回 mid。
     - 如果小于目标字符串，移动左指针。
     - 如果大于目标字符串，移动右指针。
3. 如果未找到目标字符串，返回 -1。

关键点:
- 跳过空字符串以确保二分查找的有效性。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(log n) - 二分查找的时间复杂度。
空间复杂度: O(1) - 只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(words: List[str], s: str) -> int:
    """
    函数式接口 - 在稀疏数组中查找给定字符串的位置。
    """
    left, right = 0, len(words) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        # 跳过空字符串
        while mid <= right and words[mid] == "":
            mid += 1
        
        if mid > right:
            break
        
        if words[mid] == s:
            return mid
        elif words[mid] < s:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1


Solution = create_solution(solution_function_name)