# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3623
标题: Sum of Consecutive Subsequences
难度: hard
链接: https://leetcode.cn/problems/sum-of-consecutive-subsequences/
题目类型: 数组、哈希表、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3299. 连续子序列的和 - 备战技术面试？力扣提供海量技术面试资源，帮助你高效提升编程技能,轻松拿下世界 IT 名企 Dream Offer。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用前缀和与哈希表来记录每个前缀和出现的次数，从而快速计算连续子序列的和。

算法步骤:
1. 初始化一个哈希表 `prefix_sum_count` 来记录每个前缀和出现的次数，并初始化 `prefix_sum` 为 0。
2. 遍历数组，更新当前的前缀和 `prefix_sum`。
3. 对于每个前缀和 `prefix_sum`，检查 `prefix_sum - target` 是否在哈希表中，如果存在，则将其对应的计数加到结果中。
4. 更新哈希表 `prefix_sum_count`，将当前的 `prefix_sum` 计数加 1。

关键点:
- 使用前缀和可以快速计算任意子序列的和。
- 使用哈希表记录前缀和的出现次数，可以在 O(1) 时间内检查是否存在满足条件的前缀和。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是数组的长度。我们只需要遍历数组一次。
空间复杂度: O(n)，哈希表在最坏情况下需要存储 n 个不同的前缀和。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def solution_function_name(nums: List[int], target: int) -> int:
    """
    函数式接口 - 计算数组中所有和为 target 的连续子序列的数量
    """
    prefix_sum_count = {0: 1}  # 初始化前缀和为 0 的计数为 1
    prefix_sum = 0  # 当前前缀和
    count = 0  # 满足条件的子序列数量
    
    for num in nums:
        prefix_sum += num  # 更新前缀和
        if (prefix_sum - target) in prefix_sum_count:
            count += prefix_sum_count[prefix_sum - target]  # 累加满足条件的子序列数量
        prefix_sum_count[prefix_sum] = prefix_sum_count.get(prefix_sum, 0) + 1  # 更新前缀和计数
    
    return count

Solution = create_solution(solution_function_name)