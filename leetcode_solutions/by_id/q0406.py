# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 406
标题: Queue Reconstruction by Height
难度: medium
链接: https://leetcode.cn/problems/queue-reconstruction-by-height/
题目类型: 树状数组、线段树、数组、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
406. 根据身高重建队列 - 假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。 请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。 示例 1： 输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]] 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 解释： 编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。 编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。 编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。 编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。 编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。 编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。 因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。 示例 2： 输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]] 输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]] 提示： * 1 <= people.length <= 2000 * 0 <= hi <= 106 * 0 <= ki < people.length * 题目数据确保队列可以被重建
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 先按身高降序、k值升序排序，然后按k值插入到对应位置

算法步骤:
1. 按身高降序排序，身高相同时按k值升序排序
2. 按k值将每个人插入到结果列表的对应位置
3. 由于已按身高降序，插入时前面的人身高都>=当前人，k值就是插入位置

关键点:
- 贪心策略：先处理高的人
- 时间复杂度O(n^2)，空间复杂度O(n)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2) - 排序O(nlogn) + 插入O(n^2)
空间复杂度: O(n) - 结果列表空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from leetcode_solutions.utils.solution import create_solution


def queue_reconstruction_by_height(people: List[List[int]]) -> List[List[int]]:
    """
    函数式接口 - 根据身高重建队列
    
    实现思路:
    先按身高降序、k值升序排序，然后按k值插入到对应位置。
    
    Args:
        people: 人员列表，每个元素为[身高, 前面身高>=自己的人数]
        
    Returns:
        重建后的队列
        
    Example:
        >>> queue_reconstruction_by_height([[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]])
        [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
    """
    # 按身高降序，身高相同时按k值升序
    people.sort(key=lambda x: (-x[0], x[1]))
    
    result = []
    for person in people:
        # 按k值插入到对应位置
        result.insert(person[1], person)
    
    return result


# 自动生成Solution类（无需手动编写）
Solution = create_solution(queue_reconstruction_by_height)
