# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3313
标题: Maximum Strength of K Disjoint Subarrays
难度: hard
链接: https://leetcode.cn/problems/maximum-strength-of-k-disjoint-subarrays/
题目类型: 数组、动态规划、前缀和
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3077. K 个不相交子数组的最大能量值 - 给你一个长度为 n 下标从 0 开始的整数数组 nums 和一个 正奇数 整数 k 。 x 个子数组的能量值定义为 strength = sum[1] * x - sum[2] * (x - 1) + sum[3] * (x - 2) - sum[4] * (x - 3) + ... + sum[x] * 1 ，其中 sum[i] 是第 i 个子数组的和。更正式的，能量值是满足 1 <= i <= x 的所有 i 对应的 (-1)i+1 * sum[i] * (x - i + 1) 之和。 你需要在 nums 中选择 k 个 不相交子数组 ，使得 能量值最大 。 请你返回可以得到的 最大能量值 。 注意，选出来的所有子数组 不 需要覆盖整个数组。 示例 1： 输入：nums = [1,2,3,-1,2], k = 3 输出：22 解释：选择 3 个子数组的最好方式是选择：nums[0..2] ，nums[3..3] 和 nums[4..4] 。能量值为 (1 + 2 + 3) * 3 - (-1) * 2 + 2 * 1 = 22 。 示例 2： 输入：nums = [12,-2,-2,-2,-2], k = 5 输出：64 解释：唯一一种选 5 个不相交子数组的方案是：nums[0..0] ，nums[1..1] ，nums[2..2] ，nums[3..3] 和 nums[4..4] 。能量值为 12 * 5 - (-2) * 4 + (-2) * 3 - (-2) * 2 + (-2) * 1 = 64 。 示例 3： 输入：nums = [-1,-2,-3], k = 1 输出：-1 解释：选择 1 个子数组的最优方案是：nums[0..0] 。能量值为 -1 。 提示： * 1 <= n <= 104 * -109 <= nums[i] <= 109 * 1 <= k <= n * 1 <= n * k <= 106 * k 是奇数。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们定义 dp[i][j] 表示前 i 个元素中选择 j 个不相交子数组的最大能量值。通过状态转移方程来更新 dp 数组。

算法步骤:
1. 初始化 dp 数组，dp[i][j] 表示前 i 个元素中选择 j 个不相交子数组的最大能量值。
2. 遍历数组，对于每个元素，考虑是否将其加入当前子数组或开始一个新的子数组。
3. 更新 dp 数组，计算当前子数组的能量值，并更新最大能量值。

关键点:
- 动态规划的状态转移方程
- 处理子数组的选择和能量值的计算
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * k)
空间复杂度: O(n * k)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def max_strength_of_k_disjoint_subarrays(nums: List[int], k: int) -> int:
    n = len(nums)
    dp = [[float('-inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0

    for i in range(1, n + 1):
        for j in range(1, k + 1):
            # 不选择当前元素
            dp[i][j] = dp[i - 1][j]
            # 选择当前元素
            current_sum = 0
            for l in range(i, 0, -1):
                current_sum += nums[l - 1]
                sign = 1 if (i - l + 1) % 2 == 1 else -1
                dp[i][j] = max(dp[i][j], dp[l - 1][j - 1] + sign * current_sum * (k - j + 1))

    return dp[n][k]


Solution = create_solution(max_strength_of_k_disjoint_subarrays)