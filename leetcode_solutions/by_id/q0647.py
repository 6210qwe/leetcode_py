# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 647
标题: Palindromic Substrings
难度: medium
链接: https://leetcode.cn/problems/palindromic-substrings/
题目类型: 双指针、字符串、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
647. 回文子串 - 给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。 回文字符串 是正着读和倒过来读一样的字符串。 子字符串 是字符串中的由连续字符组成的一个序列。 示例 1： 输入：s = "abc" 输出：3 解释：三个回文子串: "a", "b", "c" 示例 2： 输入：s = "aaa" 输出：6 解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa" 提示： * 1 <= s.length <= 1000 * s 由小写英文字母组成
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用中心扩展法来检查每个可能的回文中心，并统计回文子串的数量。

算法步骤:
1. 初始化计数器 `count` 为 0。
2. 遍历字符串的每一个字符，将其作为回文中心（奇数长度的回文）。
3. 对于每一对相邻字符，将其作为回文中心（偶数长度的回文）。
4. 在每个回文中心处，使用双指针向两边扩展，直到不再构成回文为止。
5. 每次找到一个回文子串时，增加计数器 `count`。

关键点:
- 使用双指针从中心向两边扩展，可以有效地检查回文子串。
- 通过遍历所有可能的回文中心，确保不会遗漏任何回文子串。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2) - 每个字符最多被检查两次（一次作为奇数长度回文中心，一次作为偶数长度回文中心），每次检查的时间复杂度为 O(n)。
空间复杂度: O(1) - 只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def countSubstrings(s: str) -> int:
    """
    函数式接口 - 统计字符串中的回文子串数量
    """
    def expand_around_center(left: int, right: int) -> int:
        count = 0
        while left >= 0 and right < len(s) and s[left] == s[right]:
            count += 1
            left -= 1
            right += 1
        return count

    total_count = 0
    for i in range(len(s)):
        # 奇数长度的回文
        total_count += expand_around_center(i, i)
        # 偶数长度的回文
        if i + 1 < len(s):
            total_count += expand_around_center(i, i + 1)

    return total_count


Solution = create_solution(countSubstrings)