# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 767
标题: Prime Number of Set Bits in Binary Representation
难度: easy
链接: https://leetcode.cn/problems/prime-number-of-set-bits-in-binary-representation/
题目类型: 位运算、数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
762. 二进制表示中质数个计算置位 - 给你两个整数 left 和 right ，在闭区间 [left, right] 范围内，统计并返回 计算置位位数为质数 的整数个数。 计算置位位数 就是二进制表示中 1 的个数。 * 例如， 21 的二进制表示 10101 有 3 个计算置位。 示例 1： 输入：left = 6, right = 10 输出：4 解释： 6 -> 110 (2 个计算置位，2 是质数) 7 -> 111 (3 个计算置位，3 是质数) 9 -> 1001 (2 个计算置位，2 是质数) 10-> 1010 (2 个计算置位，2 是质数) 共计 4 个计算置位为质数的数字。 示例 2： 输入：left = 10, right = 15 输出：5 解释： 10 -> 1010 (2 个计算置位, 2 是质数) 11 -> 1011 (3 个计算置位, 3 是质数) 12 -> 1100 (2 个计算置位, 2 是质数) 13 -> 1101 (3 个计算置位, 3 是质数) 14 -> 1110 (3 个计算置位, 3 是质数) 15 -> 1111 (4 个计算置位, 4 不是质数) 共计 5 个计算置位为质数的数字。 提示： * 1 <= left <= right <= 106 * 0 <= right - left <= 104
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过位运算计算每个数的二进制表示中1的个数，并检查该个数是否为质数。

算法步骤:
1. 定义一个函数 `is_prime` 来判断一个数是否为质数。
2. 遍历从 `left` 到 `right` 的所有整数，计算每个数的二进制表示中1的个数。
3. 使用 `is_prime` 函数检查该个数是否为质数，如果是则计数器加一。
4. 返回计数器的值。

关键点:
- 使用位运算高效地计算二进制表示中1的个数。
- 预先定义一个小范围内的质数列表，以提高 `is_prime` 函数的效率。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * log(max(left, right)))，其中 n = right - left + 1，log(max(left, right)) 是计算二进制表示中1的个数的时间复杂度。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution

def is_prime(num: int) -> bool:
    if num <= 1:
        return False
    if num <= 3:
        return True
    if num % 2 == 0 or num % 3 == 0:
        return False
    i = 5
    while i * i <= num:
        if num % i == 0 or num % (i + 2) == 0:
            return False
        i += 6
    return True

def count_prime_set_bits(left: int, right: int) -> int:
    """
    函数式接口 - 统计闭区间 [left, right] 内计算置位位数为质数的整数个数
    """
    count = 0
    for num in range(left, right + 1):
        bit_count = bin(num).count('1')
        if is_prime(bit_count):
            count += 1
    return count

Solution = create_solution(count_prime_set_bits)