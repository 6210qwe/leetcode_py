# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3963
标题: Number of Perfect Pairs
难度: medium
链接: https://leetcode.cn/problems/number-of-perfect-pairs/
题目类型: 其他
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3649. 完美对的数目 - 给你一个整数数组 nums。 如果一对下标 (i, j) 满足以下条件，则称其为 完美 的：
* i < j
* 令 a = nums[i]，b = nums[j]。那么：
  * min(|a - b|, |a + b|) <= min(|a|, |b|)
  * max(|a - b|, |a + b|) >= max(|a|, |b|)
返回 不同 完美对 的数量。
注意：绝对值 |x| 指的是 x 的 非负 值。

示例 1:
输入: nums = [0,1,2,3]
输出: 2
解释: 有 2 个完美对：
(i, j) (a, b) min(|a − b|, |a + b|) min(|a|, |b|) max(|a − b|, |a + b|) max(|a|, |b|)
(1, 2) (1, 2) min(|1 − 2|, |1 + 2|) = 1 1 max(|1 − 2|, |1 + 2|) = 3 2
(2, 3) (2, 3) min(|2 − 3|, |2 + 3|) = 1 2 max(|2 − 3|, |2 + 3|) = 5 3

示例 2:
输入: nums = [-3,2,-1,4]
输出: 4
解释: 有 4 个完美对：
(i, j) (a, b) min(|a − b|, |a + b|) min(|a|, |b|) max(|a − b|, |a + b|) max(|a|, |b|)
(0, 1) (-3, 2) min(|-3 - 2|, |-3 + 2|) = 1 2 max(|-3 - 2|, |-3 + 2|) = 5 3
(0, 3) (-3, 4) min(|-3 - 4|, |-3 + 4|) = 1 3 max(|-3 - 4|, |-3 + 4|) = 7 4
(1, 2) (2, -1) min(|2 - (-1)|, |2 + (-1)|) = 1 1 max(|2 - (-1)|, |2 + (-1)|) = 3 2
(1, 3) (2, 4) min(|2 - 4|, |2 + 4|) = 2 2 max(|2 - 4|, |2 + 4|) = 6 4

示例 3:
输入: nums = [1,10,100,1000]
输出: 0
解释: 没有完美对。因此，答案是 0。

提示:
* 2 <= nums.length <= 10^5
* -10^9 <= nums[i] <= 10^9
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用哈希表来记录每个数值出现的次数，并通过遍历数组来计算满足条件的完美对。

算法步骤:
1. 初始化一个哈希表 `count` 来记录每个数值出现的次数。
2. 遍历数组 `nums`，对于每个元素 `num`，检查它与之前出现过的所有元素是否能组成完美对。
3. 更新哈希表 `count` 中当前元素 `num` 的计数。
4. 返回完美对的数量。

关键点:
- 使用哈希表来记录每个数值出现的次数，以便快速查找和更新。
- 通过遍历数组来计算满足条件的完美对，避免了双重循环带来的高时间复杂度。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def count_perfect_pairs(nums: List[int]) -> int:
    """
    计算数组中完美对的数量。
    """
    count = {}
    perfect_pairs = 0
    
    for num in nums:
        # 检查当前元素与之前出现过的所有元素是否能组成完美对
        for prev_num in count:
            a, b = abs(num), abs(prev_num)
            if min(abs(a - b), abs(a + b)) <= min(a, b) and max(abs(a - b), abs(a + b)) >= max(a, b):
                perfect_pairs += count[prev_num]
        
        # 更新当前元素的计数
        if num in count:
            count[num] += 1
        else:
            count[num] = 1
    
    return perfect_pairs

Solution = create_solution(count_perfect_pairs)