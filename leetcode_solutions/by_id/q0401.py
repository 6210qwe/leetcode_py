# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 401
标题: Binary Watch
难度: easy
链接: https://leetcode.cn/problems/binary-watch/
题目类型: 位运算、回溯
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
401. 二进制手表 - 二进制手表顶部有 4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。每个 LED 代表一个 0 或 1，最低位在右侧。 * 例如，下面的二进制手表读取 "4:51" 。 [https://assets.leetcode.com/uploads/2021/04/08/binarywatch.jpg] 给你一个整数 turnedOn ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 按任意顺序 返回答案。 小时不会以零开头： * 例如，"01:00" 是无效的时间，正确的写法应该是 "1:00" 。 分钟必须由两位数组成，可能会以零开头： * 例如，"10:2" 是无效的时间，正确的写法应该是 "10:02" 。 示例 1： 输入：turnedOn = 1 输出：["0:01","0:02","0:04","0:08","0:16","0:32","1:00","2:00","4:00","8:00"] 示例 2： 输入：turnedOn = 9 输出：[] 提示： * 0 <= turnedOn <= 10
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 枚举所有可能的小时和分钟组合，检查LED数量是否等于turnedOn

算法步骤:
1. 枚举0-11的所有小时和0-59的所有分钟
2. 计算每个时间组合的LED数量（二进制中1的个数）
3. 如果LED数量等于turnedOn，格式化时间并加入结果

关键点:
- 使用位运算计算1的个数
- 时间复杂度O(1)，空间复杂度O(1)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(1) - 固定枚举12*60=720种可能
空间复杂度: O(1) - 结果数组空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from leetcode_solutions.utils.solution import create_solution


def binary_watch(turnedOn: int) -> List[str]:
    """
    函数式接口 - 二进制手表
    
    实现思路:
    枚举所有可能的小时和分钟组合，检查LED数量是否等于turnedOn。
    
    Args:
        turnedOn: 亮着的LED数量
        
    Returns:
        所有可能的时间列表
        
    Example:
        >>> binary_watch(1)
        ['0:01', '0:02', '0:04', '0:08', '0:16', '0:32', '1:00', '2:00', '4:00', '8:00']
    """
    def count_bits(n):
        """计算数字n的二进制表示中1的个数"""
        count = 0
        while n:
            count += n & 1
            n >>= 1
        return count
    
    result = []
    for hour in range(12):
        for minute in range(60):
            if count_bits(hour) + count_bits(minute) == turnedOn:
                result.append(f"{hour}:{minute:02d}")
    
    return result


# 自动生成Solution类（无需手动编写）
Solution = create_solution(binary_watch)
