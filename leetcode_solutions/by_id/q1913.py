# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1913
标题: Make the XOR of All Segments Equal to Zero
难度: hard
链接: https://leetcode.cn/problems/make-the-xor-of-all-segments-equal-to-zero/
题目类型: 位运算、数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1787. 使所有区间的异或结果为零 - 给你一个整数数组 nums 和一个整数 k 。区间 [left, right]（left <= right）的 异或结果 是对下标位于 left 和 right（包括 left 和 right ）之间所有元素进行 XOR 运算的结果：nums[left] XOR nums[left+1] XOR ... XOR nums[right] 。 返回数组中 要更改的最小元素数 ，以使所有长度为 k 的区间异或结果等于零。 示例 1： 输入：nums = [1,2,0,3,0], k = 1 输出：3 解释：将数组 [1,2,0,3,0] 修改为 [0,0,0,0,0] 示例 2： 输入：nums = [3,4,5,2,1,7,3,4,7], k = 3 输出：3 解释：将数组 [3,4,5,2,1,7,3,4,7] 修改为 [3,4,7,3,4,7,3,4,7] 示例 3： 输入：nums = [1,2,4,1,2,5,1,2,6], k = 3 输出：3 解释：将数组[1,2,4,1,2,5,1,2,6] 修改为 [1,2,3,1,2,3,1,2,3] 提示： * 1 <= k <= nums.length <= 2000 * 0 <= nums[i] < 210
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来计算每个位置的最小修改次数，使得所有长度为 k 的子数组的异或结果为零。

算法步骤:
1. 初始化一个 DP 数组 dp，其中 dp[j][x] 表示将第 j 个位置的元素修改为 x 所需的最小修改次数。
2. 遍历每个位置 i，对于每个位置 i，计算从 i 开始的每 k 个位置的异或值。
3. 更新 DP 数组，计算每个位置的最小修改次数。
4. 最终返回 dp[0] 中的最小值。

关键点:
- 使用动态规划来避免重复计算。
- 通过预处理每个位置的异或值来优化计算。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * 2^10)，其中 n 是数组的长度，2^10 是可能的异或值的数量。
空间复杂度: O(k * 2^10)，其中 k 是子数组的长度，2^10 是可能的异或值的数量。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def min_changes_to_zero_xor(nums: List[int], k: int) -> int:
    """
    函数式接口 - 计算使所有长度为 k 的子数组的异或结果为零所需的最小修改次数
    """
    n = len(nums)
    MAX_VAL = 1 << 10  # 2^10
    dp = [[float('inf')] * MAX_VAL for _ in range(k)]
    
    # 初始化 dp 数组
    for i in range(n):
        dp[i % k][nums[i]] = 1
    
    # 动态规划更新 dp 数组
    for i in range(k):
        count = [0] * MAX_VAL
        for j in range(i, n, k):
            x = nums[j]
            count[x] += 1
            for y in range(MAX_VAL):
                dp[i][y] = min(dp[i][y], dp[i][(y ^ x)] + (count[y] - (j // k - count[y])))
    
    # 返回最终结果
    return min(dp[0])

Solution = create_solution(min_changes_to_zero_xor)