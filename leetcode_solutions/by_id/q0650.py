# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 650
标题: 2 Keys Keyboard
难度: medium
链接: https://leetcode.cn/problems/2-keys-keyboard/
题目类型: 数学、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
650. 两个键的键盘 - 最初记事本上只有一个字符 'A' 。你每次可以对这个记事本进行两种操作： * Copy All（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。 * Paste（粘贴）：粘贴 上一次 复制的字符。 给你一个数字 n ，你需要使用最少的操作次数，在记事本上输出 恰好 n 个 'A' 。返回能够打印出 n 个 'A' 的最少操作次数。 示例 1： 输入：3 输出：3 解释： 最初, 只有一个字符 'A'。 第 1 步, 使用 Copy All 操作。 第 2 步, 使用 Paste 操作来获得 'AA'。 第 3 步, 使用 Paste 操作来获得 'AAA'。 示例 2： 输入：n = 1 输出：0 提示： * 1 <= n <= 1000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 动态规划 + 因数分解

算法步骤:
1. 如果 n 为 1，直接返回 0。
2. 初始化 dp 数组，dp[i] 表示得到 i 个 'A' 所需的最少操作次数。
3. 对于每个 i，从 2 到 n，尝试将其分解为 j * k (j 是 i 的因数)，并更新 dp[i] 为 dp[j] + k。
4. 返回 dp[n]。

关键点:
- 使用动态规划记录每个子问题的最优解。
- 通过因数分解来优化状态转移。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * sqrt(n))
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def min_steps(n: int) -> int:
    """
    函数式接口 - 计算得到 n 个 'A' 所需的最少操作次数
    """
    if n == 1:
        return 0
    
    dp = [0] * (n + 1)
    
    for i in range(2, n + 1):
        dp[i] = i  # 最坏情况是每次只复制一个 'A'
        for j in range(2, int(i ** 0.5) + 1):
            if i % j == 0:
                dp[i] = min(dp[i], dp[j] + i // j, dp[i // j] + j)
    
    return dp[n]


Solution = create_solution(min_steps)