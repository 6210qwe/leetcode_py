# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1989
标题: Minimum XOR Sum of Two Arrays
难度: hard
链接: https://leetcode.cn/problems/minimum-xor-sum-of-two-arrays/
题目类型: 位运算、数组、动态规划、状态压缩
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1879. 两个数组最小的异或值之和 - 给你两个整数数组 nums1 和 nums2 ，它们长度都为 n 。 两个数组的 异或值之和 为 (nums1[0] XOR nums2[0]) + (nums1[1] XOR nums2[1]) + ... + (nums1[n - 1] XOR nums2[n - 1]) （下标从 0 开始）。 * 比方说，[1,2,3] 和 [3,2,1] 的 异或值之和 等于 (1 XOR 3) + (2 XOR 2) + (3 XOR 1) = 2 + 0 + 2 = 4 。 请你将 nums2 中的元素重新排列，使得 异或值之和 最小 。 请你返回重新排列之后的 异或值之和 。 示例 1： 输入：nums1 = [1,2], nums2 = [2,3] 输出：2 解释：将 nums2 重新排列得到 [3,2] 。 异或值之和为 (1 XOR 3) + (2 XOR 2) = 2 + 0 = 2 。 示例 2： 输入：nums1 = [1,0,3], nums2 = [5,3,4] 输出：8 解释：将 nums2 重新排列得到 [5,4,3] 。 异或值之和为 (1 XOR 5) + (0 XOR 4) + (3 XOR 3) = 4 + 4 + 0 = 8 。 提示： * n == nums1.length * n == nums2.length * 1 <= n <= 14 * 0 <= nums1[i], nums2[i] <= 107
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划和状态压缩来解决这个问题。我们用一个二进制掩码来表示 nums2 中哪些元素已经被使用过。通过递归和记忆化搜索，我们可以找到最小的异或值之和。

算法步骤:
1. 初始化一个字典 `dp` 来存储中间结果。
2. 定义一个递归函数 `dfs(i, mask)`，其中 `i` 表示当前处理到 nums1 的第 i 个元素，`mask` 表示 nums2 中已被使用的元素。
3. 如果 `i` 等于 `n`，说明所有元素都已处理完，返回 0。
4. 如果 `(i, mask)` 已经在 `dp` 中，直接返回 `dp[(i, mask)]`。
5. 否则，遍历 nums2 中未被使用的元素，计算当前的异或值，并递归调用 `dfs`。
6. 更新 `dp[(i, mask)]` 为最小的异或值之和。
7. 返回 `dp[(i, mask)]`。

关键点:
- 使用状态压缩来表示哪些元素已经被使用过。
- 通过记忆化搜索来避免重复计算。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * 2^n)，其中 n 是数组的长度。每个状态有 2^n 种可能，每种状态需要 O(n) 时间来处理。
空间复杂度: O(n * 2^n)，用于存储记忆化搜索的结果。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def min_xor_sum(nums1: List[int], nums2: List[int]) -> int:
    """
    函数式接口 - 计算两个数组最小的异或值之和
    """
    n = len(nums1)
    dp = {}

    def dfs(i: int, mask: int) -> int:
        if i == n:
            return 0
        if (i, mask) in dp:
            return dp[(i, mask)]
        
        res = float('inf')
        for j in range(n):
            if not (mask & (1 << j)):
                res = min(res, (nums1[i] ^ nums2[j]) + dfs(i + 1, mask | (1 << j)))
        
        dp[(i, mask)] = res
        return res

    return dfs(0, 0)


Solution = create_solution(min_xor_sum)