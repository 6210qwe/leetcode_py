# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 385
标题: Mini Parser
难度: medium
链接: https://leetcode.cn/problems/mini-parser/
题目类型: 栈、深度优先搜索、字符串
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
385. 迷你语法分析器 - 给定一个字符串 s 表示一个整数嵌套列表，实现一个解析它的语法分析器并返回解析的结果 NestedInteger 。 列表中的每个元素只可能是整数或整数嵌套列表 示例 1： 输入：s = "324", 输出：324 解释：你应该返回一个 NestedInteger 对象，其中只包含整数值 324。 示例 2： 输入：s = "[123,[456,[789]]]", 输出：[123,[456,[789]]] 解释：返回一个 NestedInteger 对象包含一个有两个元素的嵌套列表： 1. 一个 integer 包含值 123 2. 一个包含两个元素的嵌套列表： i. 一个 integer 包含值 456 ii. 一个包含一个元素的嵌套列表 a. 一个 integer 包含值 789 提示： * 1 <= s.length <= 5 * 104 * s 由数字、方括号 "[]"、负号 '-' 、逗号 ','组成 * 用例保证 s 是可解析的 NestedInteger * 输入中的所有值的范围是 [-106, 106]
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用栈或递归模拟括号嵌套结构，逐字符解析字符串，构建对应的 NestedInteger 对象树

算法步骤:
1. 如果字符串首字符不是 '['，说明整个字符串就是一个整数，直接返回包含该整数的 NestedInteger。
2. 否则使用栈迭代解析：
   - 遍历字符串，遇到 '[' 时，创建一个空的 NestedInteger 列表对象并压栈；
   - 遇到数字或 '-' 时，继续向后解析完整的整数（直到遇到 ',' 或 ']'），构造一个 NestedInteger(数值)，并将其加入当前栈顶列表；
   - 遇到 ']' 时，弹出栈顶作为一个完成的 NestedInteger 列表，如果此时栈不为空，则把它加入新的栈顶元素；若栈为空则说明这是最外层，直接作为结果返回。
3. 逗号 ',' 仅作为分隔符，可以直接跳过。
4. 也可以写成递归下降解析：为每个 '[' 调用子函数解析一段直到匹配的 ']' 为止。

关键点:
- 正确处理负号和多位数字的解析，避免把 "123" 拆成多个整数。
- 对于仅包含一个整数且无方括号的情况，需要单独判断。
- 使用栈可以自然处理多层嵌套结构，不容易出错。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 对输入字符串进行一次线性扫描，每个字符处理一次。
空间复杂度: O(n) - 栈深和构建的嵌套结构在最坏情况下与输入长度同阶。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional, Union
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution

Nested = Union[int, List["Nested"]]  # 仅用于类型注解，实际返回 Python 内置结构


def mini_parser(s: str) -> Nested:
    """
    解析题目给定格式的字符串，返回对应的嵌套 Python 结构（整数或嵌套列表）。

    由于本仓库没有 NestedInteger 类型，这里直接返回由 int 和 list 组成的嵌套结构。
    """
    if not s:
        return []

    # 纯整数
    if s[0] != '[':
        return int(s)

    stack: List[list] = []
    num = 0
    sign = 1
    in_num = False

    for ch in s:
        if ch == '[':
            stack.append([])
        elif ch == ']':
            if in_num:
                stack[-1].append(sign * num)
                num = 0
                sign = 1
                in_num = False
            last = stack.pop()
            if stack:
                stack[-1].append(last)
            else:
                return last
        elif ch == ',':
            if in_num:
                stack[-1].append(sign * num)
                num = 0
                sign = 1
                in_num = False
        elif ch == '-':
            sign = -1
            in_num = True
        else:  # 数字
            num = num * 10 + (ord(ch) - 48)
            in_num = True

    # 理论上不会走到这里
    return stack[0] if stack else []


# 自动生成Solution类（无需手动编写）
Solution = create_solution(mini_parser)
