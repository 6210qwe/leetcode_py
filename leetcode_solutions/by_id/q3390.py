# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3390
标题: Minimum Rectangles to Cover Points
难度: medium
链接: https://leetcode.cn/problems/minimum-rectangles-to-cover-points/
题目类型: 贪心、数组、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3111. 覆盖所有点的最少矩形数目 - 给你一个二维整数数组 point ，其中 points[i] = [xi, yi] 表示二维平面内的一个点。同时给你一个整数 w 。你需要用矩形 覆盖所有 点。 每个矩形的左下角在某个点 (x1, 0) 处，且右上角在某个点 (x2, y2) 处，其中 x1 <= x2 且 y2 >= 0 ，同时对于每个矩形都 必须 满足 x2 - x1 <= w 。 如果一个点在矩形内或者在边上，我们说这个点被矩形覆盖了。 请你在确保每个点都 至少 被一个矩形覆盖的前提下，最少 需要多少个矩形。 注意：一个点可以被多个矩形覆盖。 示例 1： [https://assets.leetcode.com/uploads/2024/03/04/screenshot-from-2024-03-04-20-33-05.png] 输入：points = [[2,1],[1,0],[1,4],[1,8],[3,5],[4,6]], w = 1 输出：2 解释： 上图展示了一种可行的矩形放置方案： * 一个矩形的左下角在 (1, 0) ，右上角在 (2, 8) 。 * 一个矩形的左下角在 (3, 0) ，右上角在 (4, 8) 。 示例 2： [https://assets.leetcode.com/uploads/2024/03/04/screenshot-from-2024-03-04-18-59-12.png] 输入：points = [[0,0],[1,1],[2,2],[3,3],[4,4],[5,5],[6,6]], w = 2 输出：3 解释： 上图展示了一种可行的矩形放置方案： * 一个矩形的左下角在 (0, 0) ，右上角在 (2, 2) 。 * 一个矩形的左下角在 (3, 0) ，右上角在 (5, 5) 。 * 一个矩形的左下角在 (6, 0) ，右上角在 (6, 6) 。 示例 3： [https://assets.leetcode.com/uploads/2024/03/04/screenshot-from-2024-03-04-20-24-03.png] 输入：points = [[2,3],[1,2]], w = 0 输出：2 解释： 上图展示了一种可行的矩形放置方案： * 一个矩形的左下角在 (1, 0) ，右上角在 (1, 2) 。 * 一个矩形的左下角在 (2, 0) ，右上角在 (2, 3) 。 提示： * 1 <= points.length <= 105 * points[i].length == 2 * 0 <= xi == points[i][0] <= 109 * 0 <= yi == points[i][1] <= 109 * 0 <= w <= 109 * 所有点坐标 (xi, yi) 互不相同。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 对于每个 x 坐标，找到其对应的 y 坐标的最大值，并计算需要的矩形数量。

算法步骤:
1. 将所有点按 x 坐标分组，并记录每个 x 坐标对应的最大 y 坐标。
2. 遍历 x 坐标，计算每个 x 坐标需要的矩形数量。
3. 使用贪心算法，确保每个矩形的宽度不超过 w。

关键点:
- 使用字典来存储每个 x 坐标对应的最大 y 坐标。
- 使用贪心算法来计算最小矩形数量。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是 points 的长度。排序操作的时间复杂度为 O(n log n)，遍历操作的时间复杂度为 O(n)。
空间复杂度: O(n)，用于存储每个 x 坐标对应的最大 y 坐标。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def minimum_rectangles_to_cover_points(points: List[List[int]], w: int) -> int:
    # 将所有点按 x 坐标分组，并记录每个 x 坐标对应的最大 y 坐标
    x_to_max_y = {}
    for x, y in points:
        if x not in x_to_max_y:
            x_to_max_y[x] = y
        else:
            x_to_max_y[x] = max(x_to_max_y[x], y)
    
    # 将 x 坐标排序
    sorted_x = sorted(x_to_max_y.keys())
    
    # 计算需要的矩形数量
    count = 0
    i = 0
    while i < len(sorted_x):
        start_x = sorted_x[i]
        end_x = start_x + w
        max_y = x_to_max_y[start_x]
        
        # 找到当前矩形可以覆盖的最远 x 坐标
        while i < len(sorted_x) and sorted_x[i] < end_x:
            max_y = max(max_y, x_to_max_y[sorted_x[i]])
            i += 1
        
        count += 1
    
    return count

Solution = create_solution(minimum_rectangles_to_cover_points)