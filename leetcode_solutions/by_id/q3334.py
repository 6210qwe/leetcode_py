# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3334
标题: Apple Redistribution into Boxes
难度: easy
链接: https://leetcode.cn/problems/apple-redistribution-into-boxes/
题目类型: 贪心、数组、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3074. 重新分装苹果 - 给你一个长度为 n 的数组 apple 和另一个长度为 m 的数组 capacity 。 一共有 n 个包裹，其中第 i 个包裹中装着 apple[i] 个苹果。同时，还有 m 个箱子，第 i 个箱子的容量为 capacity[i] 个苹果。 请你选择一些箱子来将这 n 个包裹中的苹果重新分装到箱子中，返回你需要选择的箱子的 最小 数量。 注意，同一个包裹中的苹果可以分装到不同的箱子中。 示例 1： 输入：apple = [1,3,2], capacity = [4,3,1,5,2] 输出：2 解释：使用容量为 4 和 5 的箱子。 总容量大于或等于苹果的总数，所以可以完成重新分装。 示例 2： 输入：apple = [5,5,5], capacity = [2,4,2,7] 输出：4 解释：需要使用所有箱子。 提示： * 1 <= n == apple.length <= 50 * 1 <= m == capacity.length <= 50 * 1 <= apple[i], capacity[i] <= 50 * 输入数据保证可以将包裹中的苹果重新分装到箱子中。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: [TODO]

算法步骤:
1. [TODO]
2. [TODO]

关键点:
- [TODO]
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O([TODO])
空间复杂度: O([TODO])
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(params):
    """
    函数式接口 - [TODO] 实现
    """
    # TODO: 实现最优解法
    pass


Solution = create_solution(solution_function_name)
