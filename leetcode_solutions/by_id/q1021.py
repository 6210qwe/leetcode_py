# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1021
标题: Distribute Coins in Binary Tree
难度: medium
链接: https://leetcode.cn/problems/distribute-coins-in-binary-tree/
题目类型: 树、深度优先搜索、二叉树
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
979. 在二叉树中分配硬币 - 给你一个有 n 个结点的二叉树的根结点 root ，其中树中每个结点 node 都对应有 node.val 枚硬币。整棵树上一共有 n 枚硬币。 在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。移动可以是从父结点到子结点，或者从子结点移动到父结点。 返回使每个结点上 只有 一枚硬币所需的 最少 移动次数。 示例 1： [https://assets.leetcode.com/uploads/2019/01/18/tree1.png] 输入：root = [3,0,0] 输出：2 解释：一枚硬币从根结点移动到左子结点，一枚硬币从根结点移动到右子结点。 示例 2： [https://assets.leetcode.com/uploads/2019/01/18/tree2.png] 输入：root = [0,3,0] 输出：3 解释：将两枚硬币从根结点的左子结点移动到根结点（两次移动）。然后，将一枚硬币从根结点移动到右子结点。 提示： * 树中节点的数目为 n * 1 <= n <= 100 * 0 <= Node.val <= n * 所有 Node.val 的值之和是 n
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用深度优先搜索 (DFS) 来计算每个节点需要或多余的硬币数，并累加移动次数。

算法步骤:
1. 定义一个递归函数 dfs(node)，返回当前节点及其子树所需或多余的硬币数。
2. 对于每个节点，计算其左子树和右子树的硬币差值。
3. 当前节点的硬币差值为 node.val + left_diff + right_diff - 1。
4. 累加左右子树的绝对差值作为移动次数。
5. 返回当前节点的硬币差值。

关键点:
- 通过递归计算每个节点的硬币差值，并累加移动次数。
- 每个节点的硬币差值为 node.val + 左右子树的硬币差值 - 1。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是树中节点的数量。每个节点只访问一次。
空间复杂度: O(h)，其中 h 是树的高度。递归调用栈的深度最多为树的高度。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import Optional
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def distribute_coins(root: Optional[TreeNode]) -> int:
    """
    函数式接口 - 计算使每个节点上只有 1 枚硬币所需的最少移动次数
    """
    moves = 0

    def dfs(node: Optional[TreeNode]) -> int:
        nonlocal moves
        if not node:
            return 0
        # 计算左子树和右子树的硬币差值
        left_diff = dfs(node.left)
        right_diff = dfs(node.right)
        # 当前节点的硬币差值
        diff = node.val + left_diff + right_diff - 1
        # 累加移动次数
        moves += abs(left_diff) + abs(right_diff)
        return diff

    dfs(root)
    return moves


Solution = create_solution(distribute_coins)