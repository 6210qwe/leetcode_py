# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2241
标题: Recover the Original Array
难度: hard
链接: https://leetcode.cn/problems/recover-the-original-array/
题目类型: 数组、哈希表、双指针、枚举、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2122. 还原原数组 - Alice 有一个下标从 0 开始的数组 arr ，由 n 个正整数组成。她会选择一个任意的 正整数 k 并按下述方式创建两个下标从 0 开始的新整数数组 lower 和 higher ： 1. 对每个满足 0 <= i < n 的下标 i ，lower[i] = arr[i] - k 2. 对每个满足 0 <= i < n 的下标 i ，higher[i] = arr[i] + k 不幸地是，Alice 丢失了全部三个数组。但是，她记住了在数组 lower 和 higher 中出现的整数，但不知道每个整数属于哪个数组。请你帮助 Alice 还原原数组。 给你一个由 2n 个整数组成的整数数组 nums ，其中 恰好 n 个整数出现在 lower ，剩下的出现在 higher ，还原并返回 原数组 arr 。如果出现答案不唯一的情况，返回 任一 有效数组。 注意：生成的测试用例保证存在 至少一个 有效数组 arr 。 示例 1： 输入：nums = [2,10,6,4,8,12] 输出：[3,7,11] 解释： 如果 arr = [3,7,11] 且 k = 1 ，那么 lower = [2,6,10] 且 higher = [4,8,12] 。 组合 lower 和 higher 得到 [2,6,10,4,8,12] ，这是 nums 的一个排列。 另一个有效的数组是 arr = [5,7,9] 且 k = 3 。在这种情况下，lower = [2,4,6] 且 higher = [8,10,12] 。 示例 2： 输入：nums = [1,1,3,3] 输出：[2,2] 解释： 如果 arr = [2,2] 且 k = 1 ，那么 lower = [1,1] 且 higher = [3,3] 。 组合 lower 和 higher 得到 [1,1,3,3] ，这是 nums 的一个排列。 注意，数组不能是 [1,3] ，因为在这种情况下，获得 [1,1,3,3] 唯一可行的方案是 k = 0 。 这种方案是无效的，k 必须是一个正整数。 示例 3： 输入：nums = [5,435] 输出：[220] 解释： 唯一可行的组合是 arr = [220] 且 k = 215 。在这种情况下，lower = [5] 且 higher = [435] 。 提示： * 2 * n == nums.length * 1 <= n <= 1000 * 1 <= nums[i] <= 109 * 生成的测试用例保证存在 至少一个 有效数组 arr
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用排序和双指针来找到合适的 k 值，并通过哈希表验证是否可以构建出原数组。

算法步骤:
1. 对输入数组进行排序。
2. 使用双指针遍历数组，尝试找到合适的 k 值。
3. 使用哈希表记录 lower 和 higher 数组中的元素。
4. 验证哈希表中的元素是否可以构建出原数组。

关键点:
- 通过排序和双指针找到合适的 k 值。
- 使用哈希表记录和验证 lower 和 higher 数组中的元素。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n) - 排序的时间复杂度。
空间复杂度: O(n) - 哈希表的空间复杂度。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(nums: List[int]) -> List[int]:
    """
    函数式接口 - 实现最优解法
    """
    nums.sort()
    n = len(nums) // 2
    for i in range(n):
        k = (nums[i + n] - nums[i]) // 2
        if k > 0 and all((x + k) in nums for x in nums[:n]):
            return [(x + k) for x in nums[:n]]
    return []

Solution = create_solution(solution_function_name)