# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2419
标题: Subarray With Elements Greater Than Varying Threshold
难度: hard
链接: https://leetcode.cn/problems/subarray-with-elements-greater-than-varying-threshold/
题目类型: 栈、并查集、数组、单调栈
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2334. 元素值大于变化阈值的子数组 - 给你一个整数数组 nums 和一个整数 threshold 。 找到长度为 k 的 nums 子数组，满足数组中 每个 元素都 大于 threshold / k 。 请你返回满足要求的 任意 子数组的 大小 。如果没有这样的子数组，返回 -1 。 子数组 是数组中一段连续非空的元素序列。 示例 1： 输入：nums = [1,3,4,3,1], threshold = 6 输出：3 解释：子数组 [3,4,3] 大小为 3 ，每个元素都大于 6 / 3 = 2 。 注意这是唯一合法的子数组。 示例 2： 输入：nums = [6,5,6,5,8], threshold = 7 输出：1 解释：子数组 [8] 大小为 1 ，且 8 > 7 / 1 = 7 。所以返回 1 。 注意子数组 [6,5] 大小为 2 ，每个元素都大于 7 / 2 = 3.5 。 类似的，子数组 [6,5,6] ，[6,5,6,5] ，[6,5,6,5,8] 都是符合条件的子数组。 所以返回 2, 3, 4 和 5 都可以。 提示： * 1 <= nums.length <= 105 * 1 <= nums[i], threshold <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用单调栈来找到每个元素作为子数组最大值时的左右边界，然后计算满足条件的子数组大小。

算法步骤:
1. 初始化两个数组 left 和 right，分别记录每个元素作为子数组最大值时的左边界和右边界。
2. 使用单调栈从左到右遍历数组，填充 left 数组。
3. 使用单调栈从右到左遍历数组，填充 right 数组。
4. 遍历每个元素，计算其作为子数组最大值时的子数组长度，并检查是否满足条件。
5. 返回满足条件的子数组长度，如果没有满足条件的子数组，返回 -1。

关键点:
- 使用单调栈高效地找到每个元素作为子数组最大值时的左右边界。
- 通过计算每个元素作为子数组最大值时的子数组长度，判断是否满足条件。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def valid_subarray_size(nums: List[int], threshold: int) -> int:
    n = len(nums)
    left, right = [-1] * n, [n] * n
    stack = []
    
    # 填充 left 数组
    for i in range(n):
        while stack and nums[stack[-1]] >= nums[i]:
            stack.pop()
        if stack:
            left[i] = stack[-1]
        stack.append(i)
    
    stack = []
    # 填充 right 数组
    for i in range(n - 1, -1, -1):
        while stack and nums[stack[-1]] >= nums[i]:
            stack.pop()
        if stack:
            right[i] = stack[-1]
        stack.append(i)
    
    # 检查每个元素作为子数组最大值时是否满足条件
    for i in range(n):
        length = right[i] - left[i] - 1
        if nums[i] > threshold // length:
            return length
    
    return -1

Solution = create_solution(valid_subarray_size)