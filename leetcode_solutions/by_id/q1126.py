# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1126
标题: Minimum Cost to Connect Sticks
难度: medium
链接: https://leetcode.cn/problems/minimum-cost-to-connect-sticks/
题目类型: 贪心、数组、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1167. 连接木棍的最低费用 - 备战技术面试？力扣提供海量技术面试资源，帮助你高效提升编程技能,轻松拿下世界 IT 名企 Dream Offer。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用最小堆（优先队列）来维护当前所有木棍的长度，并每次取出两个最短的木棍进行连接，将新的木棍长度重新加入堆中。这样可以确保每次连接的成本最小。

算法步骤:
1. 将所有木棍长度放入最小堆中。
2. 每次从堆中取出两个最短的木棍，计算它们的连接成本，并将新的木棍长度重新加入堆中。
3. 重复步骤2，直到堆中只剩下一个木棍为止。
4. 累加所有连接成本，得到最终结果。

关键点:
- 使用最小堆来高效地获取和更新当前最短的木棍。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中n是木棍的数量。每次插入和删除操作的时间复杂度是O(log n)，总共需要进行n-1次合并操作。
空间复杂度: O(n)，用于存储堆中的所有木棍长度。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def connectSticks(sticks: List[int]) -> int:
    """
    函数式接口 - 计算连接木棍的最低费用
    """
    # 将所有木棍长度放入最小堆中
    heapq.heapify(sticks)
    
    total_cost = 0
    while len(sticks) > 1:
        # 取出两个最短的木棍
        first = heapq.heappop(sticks)
        second = heapq.heappop(sticks)
        
        # 计算连接成本
        cost = first + second
        total_cost += cost
        
        # 将新的木棍长度重新加入堆中
        heapq.heappush(sticks, cost)
    
    return total_cost

Solution = create_solution(connectSticks)