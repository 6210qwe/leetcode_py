# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2721
标题: Sum of Distances
难度: medium
链接: https://leetcode.cn/problems/sum-of-distances/
题目类型: 数组、哈希表、前缀和
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2615. 等值距离和 - 给你一个下标从 0 开始的整数数组 nums 。现有一个长度等于 nums.length 的数组 arr 。对于满足 nums[j] == nums[i] 且 j != i 的所有 j ，arr[i] 等于所有 |i - j| 之和。如果不存在这样的 j ，则令 arr[i] 等于 0 。 返回数组 arr 。 示例 1： 输入：nums = [1,3,1,1,2] 输出：[5,0,3,4,0] 解释： i = 0 ，nums[0] == nums[2] 且 nums[0] == nums[3] 。因此，arr[0] = |0 - 2| + |0 - 3| = 5 。 i = 1 ，arr[1] = 0 因为不存在值等于 3 的其他下标。 i = 2 ，nums[2] == nums[0] 且 nums[2] == nums[3] 。因此，arr[2] = |2 - 0| + |2 - 3| = 3 。 i = 3 ，nums[3] == nums[0] 且 nums[3] == nums[2] 。因此，arr[3] = |3 - 0| + |3 - 2| = 4 。 i = 4 ，arr[4] = 0 因为不存在值等于 2 的其他下标。 示例 2： 输入：nums = [0,5,3] 输出：[0,0,0] 解释：因为 nums 中的元素互不相同，对于所有 i ，都有 arr[i] = 0 。 提示： * 1 <= nums.length <= 105 * 0 <= nums[i] <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用哈希表记录每个值的所有索引，然后利用前缀和计算每个索引的距离和。

算法步骤:
1. 使用哈希表 `indices` 记录每个值的所有索引。
2. 对于每个值，计算其索引的前缀和 `prefix_sum`。
3. 利用前缀和计算每个索引的距离和，并存储在结果数组 `result` 中。

关键点:
- 使用前缀和可以高效地计算每个索引的距离和。
- 哈希表用于快速查找每个值的所有索引。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def sum_of_distances(nums: List[int]) -> List[int]:
    """
    函数式接口 - 计算等值距离和
    """
    n = len(nums)
    indices = {}
    for i, num in enumerate(nums):
        if num not in indices:
            indices[num] = []
        indices[num].append(i)

    result = [0] * n
    for num, idx_list in indices.items():
        m = len(idx_list)
        prefix_sum = [0] * (m + 1)
        for i in range(m):
            prefix_sum[i + 1] = prefix_sum[i] + idx_list[i]

        for i, idx in enumerate(idx_list):
            left_sum = idx * (i + 1) - prefix_sum[i + 1]
            right_sum = prefix_sum[m] - prefix_sum[i] - idx * (m - i)
            result[idx] = left_sum + right_sum

    return result

Solution = create_solution(sum_of_distances)