# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3153
标题: Apply Operations on Array to Maximize Sum of Squares
难度: hard
链接: https://leetcode.cn/problems/apply-operations-on-array-to-maximize-sum-of-squares/
题目类型: 贪心、位运算、数组、哈希表
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2897. 对数组执行操作使平方和最大 - 给你一个下标从 0 开始的整数数组 nums 和一个 正 整数 k 。 你可以对数组执行以下操作 任意次 ： * 选择两个互不相同的下标 i 和 j ，同时 将 nums[i] 更新为 (nums[i] AND nums[j]) 且将 nums[j] 更新为 (nums[i] OR nums[j]) ，OR 表示按位 或 运算，AND 表示按位 与 运算。 你需要从最终的数组里选择 k 个元素，并计算它们的 平方 之和。 请你返回你可以得到的 最大 平方和。 由于答案可能会很大，将答案对 109 + 7 取余 后返回。 示例 1： 输入：nums = [2,6,5,8], k = 2 输出：261 解释：我们可以对数组执行以下操作： - 选择 i = 0 和 j = 3 ，同时将 nums[0] 变为 (2 AND 8) = 0 且 nums[3] 变为 (2 OR 8) = 10 ，结果数组为 nums = [0,6,5,10] 。 - 选择 i = 2 和 j = 3 ，同时将 nums[2] 变为 (5 AND 10) = 0 且 nums[3] 变为 (5 OR 10) = 15 ，结果数组为 nums = [0,6,0,15] 。 从最终数组里选择元素 15 和 6 ，平方和为 152 + 62 = 261 。 261 是可以得到的最大结果。 示例 2： 输入：nums = [4,5,4,7], k = 3 输出：90 解释：不需要执行任何操作。 选择元素 7 ，5 和 4 ，平方和为 72 + 52 + 42 = 90 。 90 是可以得到的最大结果。 提示： * 1 <= k <= nums.length <= 105 * 1 <= nums[i] <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过位运算统计每个位上1的数量，然后构造最大的k个数。

算法步骤:
1. 统计每个位上1的数量。
2. 根据每个位上1的数量，构造最大的k个数。
3. 计算这k个数的平方和并取模。

关键点:
- 使用位运算统计每个位上1的数量。
- 构造最大的k个数时，优先考虑高位。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * log(max(nums)))，其中n是数组长度，log(max(nums))是二进制位数。
空间复杂度: O(log(max(nums)))，用于存储每个位上1的数量。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def max_sum_after_operations(nums: List[int], k: int) -> int:
    MOD = 10**9 + 7
    bit_count = [0] * 32  # 统计每个位上1的数量

    # 统计每个位上1的数量
    for num in nums:
        for i in range(32):
            if num & (1 << i):
                bit_count[i] += 1

    result = 0
    # 构造最大的k个数
    for _ in range(k):
        current_num = 0
        for i in range(31, -1, -1):
            if bit_count[i] > 0:
                current_num |= (1 << i)
                bit_count[i] -= 1
        result = (result + current_num * current_num) % MOD

    return result

Solution = create_solution(max_sum_after_operations)