# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 820
标题: Find Eventual Safe States
难度: medium
链接: https://leetcode.cn/problems/find-eventual-safe-states/
题目类型: 深度优先搜索、广度优先搜索、图、拓扑排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
802. 找到最终的安全状态 - 有一个有 n 个节点的有向图，节点按 0 到 n - 1 编号。图由一个 索引从 0 开始 的 2D 整数数组 graph表示， graph[i]是与节点 i 相邻的节点的整数数组，这意味着从节点 i 到 graph[i]中的每个节点都有一条边。 如果一个节点没有连出的有向边，则该节点是 终端节点 。如果从该节点开始的所有可能路径都通向 终端节点（或另一个安全节点），则该节点为 安全节点。 返回一个由图中所有 安全节点 组成的数组作为答案。答案数组中的元素应当按 升序 排列。 示例 1： Illustration of graph [https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/17/picture1.png] 输入：graph = [[1,2],[2,3],[5],[0],[5],[],[]] 输出：[2,4,5,6] 解释：示意图如上。 节点 5 和节点 6 是终端节点，因为它们都没有出边。 从节点 2、4、5 和 6 开始的所有路径都指向节点 5 或 6 。 示例 2： 输入：graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]] 输出：[4] 解释: 只有节点 4 是终端节点，从节点 4 开始的所有路径都通向节点 4 。 提示： * n == graph.length * 1 <= n <= 104 * 0 <= graph[i].length <= n * 0 <= graph[i][j] <= n - 1 * graph[i] 按严格递增顺序排列。 * 图中可能包含自环。 * 图中边的数目在范围 [1, 4 * 104] 内。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用深度优先搜索 (DFS) 来检测图中的环，并标记安全节点。

算法步骤:
1. 初始化三个列表：visited 用于记录访问过的节点，safe 用于记录安全节点，unsafe 用于记录不安全节点。
2. 对于每个节点，如果它还没有被访问过，调用 DFS 函数。
3. 在 DFS 函数中，首先将当前节点标记为已访问。
4. 对于当前节点的每个邻居节点，如果邻居节点已经被标记为不安全，则当前节点也是不安全的；否则，递归调用 DFS 函数。
5. 如果当前节点的所有邻居节点都是安全的，则将当前节点标记为安全节点。
6. 最后，返回所有安全节点的列表。

关键点:
- 使用三色标记法来避免重复计算和处理环。
- 通过反向图进行拓扑排序可以更高效地找到所有安全节点。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(V + E)，其中 V 是节点数，E 是边数。每个节点和每条边最多访问一次。
空间复杂度: O(V + E)，存储图的反向图和辅助数据结构。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def eventual_safe_nodes(graph: List[List[int]]) -> List[int]:
    """
    函数式接口 - 找到最终的安全状态
    """
    def dfs(node: int):
        if visited[node] == 1:
            unsafe.add(node)
            return False
        if visited[node] == 2:
            return True

        visited[node] = 1
        for neighbor in graph[node]:
            if not dfs(neighbor):
                unsafe.add(node)
                return False

        visited[node] = 2
        safe.add(node)
        return True

    n = len(graph)
    visited = [0] * n  # 0: 未访问, 1: 访问中, 2: 已访问
    safe = set()
    unsafe = set()

    for i in range(n):
        if visited[i] == 0:
            dfs(i)

    return sorted(list(safe))

Solution = create_solution(eventual_safe_nodes)