# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2415
标题: Count the Number of Ideal Arrays
难度: hard
链接: https://leetcode.cn/problems/count-the-number-of-ideal-arrays/
题目类型: 数学、动态规划、组合数学、数论
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2338. 统计理想数组的数目 - 给你两个整数 n 和 maxValue ，用于描述一个 理想数组 。 对于下标从 0 开始、长度为 n 的整数数组 arr ，如果满足以下条件，则认为该数组是一个 理想数组 ： * 每个 arr[i] 都是从 1 到 maxValue 范围内的一个值，其中 0 <= i < n 。 * 每个 arr[i] 都可以被 arr[i - 1] 整除，其中 0 < i < n 。 返回长度为 n 的 不同 理想数组的数目。由于答案可能很大，返回对 109 + 7 取余的结果。 示例 1： 输入：n = 2, maxValue = 5 输出：10 解释：存在以下理想数组： - 以 1 开头的数组（5 个）：[1,1]、[1,2]、[1,3]、[1,4]、[1,5] - 以 2 开头的数组（2 个）：[2,2]、[2,4] - 以 3 开头的数组（1 个）：[3,3] - 以 4 开头的数组（1 个）：[4,4] - 以 5 开头的数组（1 个）：[5,5] 共计 5 + 2 + 1 + 1 + 1 = 10 个不同理想数组。 示例 2： 输入：n = 5, maxValue = 3 输出：11 解释：存在以下理想数组： - 以 1 开头的数组（9 个）： - 不含其他不同值（1 个）：[1,1,1,1,1] - 含一个不同值 2（4 个）：[1,1,1,1,2], [1,1,1,2,2], [1,1,2,2,2], [1,2,2,2,2] - 含一个不同值 3（4 个）：[1,1,1,1,3], [1,1,1,3,3], [1,1,3,3,3], [1,3,3,3,3] - 以 2 开头的数组（1 个）：[2,2,2,2,2] - 以 3 开头的数组（1 个）：[3,3,3,3,3] 共计 9 + 1 + 1 = 11 个不同理想数组。 提示： * 2 <= n <= 104 * 1 <= maxValue <= 104
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划和组合数学来计算理想数组的数量。

算法步骤:
1. 计算每个数字的因数，并构建一个因数图。
2. 使用动态规划来计算每个数字作为结尾的理想数组数量。
3. 使用组合数学来计算长度为 n 的理想数组数量。

关键点:
- 构建因数图来快速查找因数。
- 动态规划状态转移方程：dp[i][j] 表示长度为 i 且以 j 结尾的理想数组数量。
- 组合数学公式：C(n + k - 1, k - 1) 用于计算长度为 n 的理想数组数量。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(maxValue * log(maxValue) + n * maxValue)
空间复杂度: O(maxValue^2)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution
import math

MOD = 10**9 + 7

def combination(n, k):
    if k > n:
        return 0
    return math.comb(n, k)

def solution_function_name(n: int, maxValue: int) -> int:
    """
    函数式接口 - 实现最优解法
    """
    # 构建因数图
    factors = [[] for _ in range(maxValue + 1)]
    for i in range(1, maxValue + 1):
        for j in range(i, maxValue + 1, i):
            factors[j].append(i)

    # 动态规划初始化
    dp = [[0] * (maxValue + 1) for _ in range(n + 1)]
    for i in range(1, maxValue + 1):
        dp[1][i] = 1

    # 动态规划状态转移
    for length in range(2, n + 1):
        for end in range(1, maxValue + 1):
            for factor in factors[end]:
                dp[length][end] += dp[length - 1][factor]
                dp[length][end] %= MOD

    # 计算结果
    result = sum(dp[n]) % MOD
    return result

Solution = create_solution(solution_function_name)