# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 543
标题: Diameter of Binary Tree
难度: easy
链接: https://leetcode.cn/problems/diameter-of-binary-tree/
题目类型: 树、深度优先搜索、二叉树
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
543. 二叉树的直径 - 给你一棵二叉树的根节点，返回该树的 直径 。 二叉树的 直径 是指树中任意两个节点之间最长路径的 长度 。这条路径可能经过也可能不经过根节点 root 。 两节点之间路径的 长度 由它们之间边数表示。 示例 1： [https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg] 输入：root = [1,2,3,4,5] 输出：3 解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。 示例 2： 输入：root = [1,2] 输出：1 提示： * 树中节点数目在范围 [1, 104] 内 * -100 <= Node.val <= 100
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过深度优先搜索（DFS）遍历每个节点，计算每个节点的最大深度，并更新全局最大直径。

算法步骤:
1. 定义一个递归函数 `dfs`，用于计算从当前节点到叶子节点的最大深度。
2. 在 `dfs` 函数中，递归计算左子树和右子树的最大深度。
3. 更新全局最大直径为左子树深度 + 右子树深度。
4. 返回当前节点的最大深度（即左子树深度和右子树深度中的较大值 + 1）。
5. 在主函数中调用 `dfs` 函数，并返回全局最大直径。

关键点:
- 使用一个全局变量 `max_diameter` 来记录最大直径。
- 每个节点的直径等于其左子树深度 + 右子树深度。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是树中节点的数量。每个节点只被访问一次。
空间复杂度: O(h)，其中 h 是树的高度。递归调用栈的深度最多为树的高度。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import Optional
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution

class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        self.max_diameter = 0
        
        def dfs(node: Optional[TreeNode]) -> int:
            if not node:
                return 0
            
            left_depth = dfs(node.left)
            right_depth = dfs(node.right)
            
            # 更新最大直径
            self.max_diameter = max(self.max_diameter, left_depth + right_depth)
            
            # 返回当前节点的最大深度
            return max(left_depth, right_depth) + 1
        
        dfs(root)
        return self.max_diameter

Solution = create_solution(Solution)