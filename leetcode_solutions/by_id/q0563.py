# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 563
标题: Binary Tree Tilt
难度: easy
链接: https://leetcode.cn/problems/binary-tree-tilt/
题目类型: 树、深度优先搜索、二叉树
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
563. 二叉树的坡度 - 给你一个二叉树的根节点 root ，计算并返回 整个树 的坡度 。 一个树的 节点的坡度 定义即为，该节点左子树的节点之和和右子树节点之和的 差的绝对值 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。 整个树 的坡度就是其所有节点的坡度之和。 示例 1： [https://assets.leetcode.com/uploads/2020/10/20/tilt1.jpg] 输入：root = [1,2,3] 输出：1 解释： 节点 2 的坡度：|0-0| = 0（没有子节点） 节点 3 的坡度：|0-0| = 0（没有子节点） 节点 1 的坡度：|2-3| = 1（左子树就是左子节点，所以和是 2 ；右子树就是右子节点，所以和是 3 ） 坡度总和：0 + 0 + 1 = 1 示例 2： [https://assets.leetcode.com/uploads/2020/10/20/tilt2.jpg] 输入：root = [4,2,9,3,5,null,7] 输出：15 解释： 节点 3 的坡度：|0-0| = 0（没有子节点） 节点 5 的坡度：|0-0| = 0（没有子节点） 节点 7 的坡度：|0-0| = 0（没有子节点） 节点 2 的坡度：|3-5| = 2（左子树就是左子节点，所以和是 3 ；右子树就是右子节点，所以和是 5 ） 节点 9 的坡度：|0-7| = 7（没有左子树，所以和是 0 ；右子树正好是右子节点，所以和是 7 ） 节点 4 的坡度：|(3+5+2)-(9+7)| = |10-16| = 6（左子树值为 3、5 和 2 ，和是 10 ；右子树值为 9 和 7 ，和是 16 ） 坡度总和：0 + 0 + 0 + 2 + 7 + 6 = 15 示例 3： [https://assets.leetcode.com/uploads/2020/10/20/tilt3.jpg] 输入：root = [21,7,14,1,1,2,2,3,3] 输出：9 提示： * 树中节点数目的范围在 [0, 104] 内 * -1000 <= Node.val <= 1000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用深度优先搜索 (DFS) 来计算每个节点的坡度，并同时计算整个树的节点值之和。

算法步骤:
1. 定义一个递归函数 `dfs`，用于计算当前节点的坡度。
2. 在 `dfs` 函数中，递归计算左子树和右子树的节点值之和。
3. 计算当前节点的坡度，并将其累加到全局变量 `total_tilt` 中。
4. 返回当前节点及其子树的节点值之和。
5. 在主函数中调用 `dfs` 函数，并返回 `total_tilt`。

关键点:
- 通过一次 DFS 同时计算节点值之和和坡度，避免重复遍历。
- 使用全局变量 `total_tilt` 来记录整个树的坡度。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是树中节点的数量。每个节点只被访问一次。
空间复杂度: O(h)，其中 h 是树的高度。递归调用栈的深度最多为树的高度。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import Optional
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution

class Solution:
    def findTilt(self, root: Optional[TreeNode]) -> int:
        self.total_tilt = 0
        
        def dfs(node: Optional[TreeNode]) -> int:
            if not node:
                return 0
            
            left_sum = dfs(node.left)
            right_sum = dfs(node.right)
            
            tilt = abs(left_sum - right_sum)
            self.total_tilt += tilt
            
            return left_sum + right_sum + node.val
        
        dfs(root)
        return self.total_tilt

Solution = create_solution(Solution)