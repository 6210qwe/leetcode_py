# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3091
标题: Count of Sub-Multisets With Bounded Sum
难度: hard
链接: https://leetcode.cn/problems/count-of-sub-multisets-with-bounded-sum/
题目类型: 数组、哈希表、动态规划、滑动窗口
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2902. 和带限制的子多重集合的数目 - 给你一个下标从 0 开始的非负整数数组 nums 和两个整数 l 和 r 。 请你返回 nums 中子多重集合的和在闭区间 [l, r] 之间的 子多重集合的数目 。 由于答案可能很大，请你将答案对 109 + 7 取余后返回。 子多重集合 指的是从数组中选出一些元素构成的 无序 集合，每个元素 x 出现的次数可以是 0, 1, ..., occ[x] 次，其中 occ[x] 是元素 x 在数组中的出现次数。 注意： * 如果两个子多重集合中的元素排序后一模一样，那么它们两个是相同的 子多重集合 。 * 空 集合的和是 0 。 示例 1： 输入：nums = [1,2,2,3], l = 6, r = 6 输出：1 解释：唯一和为 6 的子集合是 {1, 2, 3} 。 示例 2： 输入：nums = [2,1,4,2,7], l = 1, r = 5 输出：7 解释：和在闭区间 [1, 5] 之间的子多重集合为 {1} ，{2} ，{4} ，{2, 2} ，{1, 2} ，{1, 4} 和 {1, 2, 2} 。 示例 3： 输入：nums = [1,2,1,3,5,2], l = 3, r = 5 输出：9 解释：和在闭区间 [3, 5] 之间的子多重集合为 {3} ，{5} ，{1, 2} ，{1, 3} ，{2, 2} ，{2, 3} ，{1, 1, 2} ，{1, 1, 3} 和 {1, 2, 2} 。 提示： * 1 <= nums.length <= 2 * 104 * 0 <= nums[i] <= 2 * 104 * nums 的和不超过 2 * 104 。 * 0 <= l <= r <= 2 * 104
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们使用一个二维数组 dp，其中 dp[i][j] 表示前 i 种元素组成的子多重集合和为 j 的数量。通过遍历每种元素及其出现次数，更新 dp 数组。

算法步骤:
1. 统计每种元素的出现次数。
2. 初始化 dp 数组，dp[0][0] = 1，表示空集合的和为 0。
3. 遍历每种元素及其出现次数，更新 dp 数组。
4. 计算和在 [l, r] 之间的子多重集合的数量。

关键点:
- 动态规划的状态转移方程：dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]] + ... + dp[i-1][j-k*nums[i]]，其中 k 是该元素的最大出现次数。
- 优化空间复杂度，使用滚动数组。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * m)，其中 n 是不同元素的数量，m 是 r+1。
空间复杂度: O(m)，使用滚动数组优化空间复杂度。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution

MOD = 10**9 + 7

def solution_function_name(nums: List[int], l: int, r: int) -> int:
    """
    函数式接口 - 返回 nums 中子多重集合的和在闭区间 [l, r] 之间的子多重集合的数目。
    """
    from collections import Counter
    count = Counter(nums)
    unique_nums = list(count.keys())
    
    dp = [0] * (r + 1)
    dp[0] = 1
    
    for num in unique_nums:
        max_count = count[num]
        for j in range(r, num - 1, -1):
            for k in range(1, max_count + 1):
                if j - k * num >= 0:
                    dp[j] = (dp[j] + dp[j - k * num]) % MOD
    
    return sum(dp[l:r + 1]) % MOD

Solution = create_solution(solution_function_name)