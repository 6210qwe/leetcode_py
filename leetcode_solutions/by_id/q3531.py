# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3531
标题: Minimum Amount of Damage Dealt to Bob
难度: hard
链接: https://leetcode.cn/problems/minimum-amount-of-damage-dealt-to-bob/
题目类型: 贪心、数组、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3273. 对 Bob 造成的最少伤害 - 给你一个整数 power 和两个整数数组 damage 和 health ，两个数组的长度都为 n 。 Bob 有 n 个敌人，如果第 i 个敌人还活着（也就是健康值 health[i] > 0 的时候），每秒钟会对 Bob 造成 damage[i] 点 伤害。 每一秒中，在敌人对 Bob 造成伤害 之后 ，Bob 会选择 一个 还活着的敌人进行攻击，该敌人的健康值减少 power 。 请你返回 Bob 将 所有 n 个敌人都消灭之前，最少 会受到多少伤害。 示例 1： 输入：power = 4, damage = [1,2,3,4], health = [4,5,6,8] 输出：39 解释： * 最开始 2 秒内都攻击敌人 3 ，然后敌人 3 会被消灭，这段时间内对 Bob 的总伤害是 10 + 10 = 20 点。 * 接下来 2 秒内都攻击敌人 2 ，然后敌人 2 会被消灭，这段时间内对 Bob 的总伤害是 6 + 6 = 12 点。 * 接下来 1 秒内都攻击敌人 0 ，然后敌人 0 会被消灭，这段时间内对 Bob 的总伤害是 3 点。 * 接下来 2 秒内都攻击敌人 1 ，然后敌人 1 会被消灭，这段时间内对 Bob 的总伤害是 2 + 2 = 4 点。 示例 2： 输入：power = 1, damage = [1,1,1,1], health = [1,2,3,4] 输出：20 解释： * 最开始 1 秒内都攻击敌人 0 ，然后敌人 0 会被消灭，这段时间对 Bob 的总伤害是 4 点。 * 接下来 2 秒内都攻击敌人 1 ，然后敌人 1 会被消灭，这段时间对 Bob 的总伤害是 3 + 3 = 6 点。 * 接下来 3 秒内都攻击敌人 2 ，然后敌人 2 会被消灭，这段时间对 Bob 的总伤害是 2 + 2 + 2 = 6 点。 * 接下来 4 秒内都攻击敌人 3 ，然后敌人 3 会被消灭，这段时间对 Bob 的总伤害是 1 + 1 + 1 + 1 = 4 点。 示例 3： 输入：power = 8, damage = [40], health = [59] 输出：320 提示： * 1 <= power <= 104 * 1 <= n == damage.length == health.length <= 105 * 1 <= damage[i], health[i] <= 104
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用贪心算法，优先消灭每次攻击后能造成最大伤害的敌人。

算法步骤:
1. 将每个敌人的伤害和健康值组合成一个列表。
2. 按照每次攻击后能造成的伤害降序排序。
3. 依次消灭敌人，计算总的伤害。

关键点:
- 优先消灭每次攻击后能造成最大伤害的敌人。
- 计算每次攻击后的总伤害。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是敌人的数量，主要由排序操作决定。
空间复杂度: O(n)，用于存储敌人的伤害和健康值组合。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def minimum_damage_dealt(power: int, damage: List[int], health: List[int]) -> int:
    """
    函数式接口 - 计算 Bob 受到的最少伤害
    """
    # 将每个敌人的伤害和健康值组合成一个列表
    enemies = [(d, h) for d, h in zip(damage, health)]
    
    # 按照每次攻击后能造成的伤害降序排序
    enemies.sort(key=lambda x: (x[0] / x[1]), reverse=True)
    
    total_damage = 0
    for d, h in enemies:
        # 计算消灭当前敌人需要的时间
        time_to_kill = (h + power - 1) // power
        # 计算在消灭当前敌人期间受到的伤害
        total_damage += d * time_to_kill
    
    return total_damage


Solution = create_solution(minimum_damage_dealt)