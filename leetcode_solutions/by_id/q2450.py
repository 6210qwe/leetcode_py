# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2450
标题: Minimum Replacements to Sort the Array
难度: hard
链接: https://leetcode.cn/problems/minimum-replacements-to-sort-the-array/
题目类型: 贪心、数组、数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2366. 将数组排序的最少替换次数 - 给你一个下标从 0 开始的整数数组 nums 。每次操作中，你可以将数组中任何一个元素替换为 任意两个 和为该元素的数字。 * 比方说，nums = [5,6,7] 。一次操作中，我们可以将 nums[1] 替换成 2 和 4 ，将 nums 转变成 [5,2,4,7] 。 请你执行上述操作，将数组变成元素按 非递减 顺序排列的数组，并返回所需的最少操作次数。 示例 1： 输入：nums = [3,9,3] 输出：2 解释：以下是将数组变成非递减顺序的步骤： - [3,9,3] ，将9 变成 3 和 6 ，得到数组 [3,3,6,3] - [3,3,6,3] ，将 6 变成 3 和 3 ，得到数组 [3,3,3,3,3] 总共需要 2 步将数组变成非递减有序，所以我们返回 2 。 示例 2： 输入：nums = [1,2,3,4,5] 输出：0 解释：数组已经是非递减顺序，所以我们返回 0 。 提示： * 1 <= nums.length <= 105 * 1 <= nums[i] <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 从后向前遍历数组，确保每个元素不超过其前一个元素。如果当前元素大于前一个元素，则将其拆分成尽可能多的小部分，使得每一部分都不超过前一个元素。

算法步骤:
1. 初始化操作次数为 0。
2. 从数组的倒数第二个元素开始向前遍历。
3. 对于每个元素，如果它大于前一个元素，则计算需要将其拆分成多少个部分，使得每一部分都不超过前一个元素。
4. 更新操作次数，并更新当前元素为前一个元素。
5. 返回总的操作次数。

关键点:
- 通过贪心策略，从后向前遍历数组，确保每个元素不超过其前一个元素。
- 计算拆分次数时，使用除法和取模运算来确定最小的操作次数。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是数组的长度。我们只需要遍历数组一次。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List


def minimum_replacement(nums: List[int]) -> int:
    """
    函数式接口 - 返回将数组变成非递减顺序所需的最少操作次数
    """
    operations = 0
    prev_bound = nums[-1]
    
    for i in range(len(nums) - 2, -1, -1):
        if nums[i] > prev_bound:
            # 计算需要拆分成多少个部分
            parts = (nums[i] + prev_bound - 1) // prev_bound
            operations += parts - 1
            # 更新前一个元素的边界
            prev_bound = nums[i] // parts
        else:
            prev_bound = nums[i]
    
    return operations


Solution = create_solution(minimum_replacement)