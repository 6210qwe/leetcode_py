# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 358
标题: Rearrange String k Distance Apart
难度: hard
链接: https://leetcode.cn/problems/rearrange-string-k-distance-apart/
题目类型: 贪心、哈希表、字符串、计数、排序、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
358. K 距离间隔重排字符串 - 备战技术面试？力扣提供海量技术面试资源，帮助你高效提升编程技能,轻松拿下世界 IT 名企 Dream Offer。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 贪心 + 最大堆 + 等待队列，使得同一字符再次出现前至少间隔 k 个位置

算法步骤:
1. 统计每个字符出现次数，将 (剩余次数, 字符) 放入最大堆中，优先使用剩余次数最多的字符。
2. 维护一个队列，用来存储刚刚使用过、尚未满足再次使用条件的字符，队列元素形如 (可再次使用的时间点, 剩余次数, 字符)。
3. 从位置 0 开始构建结果字符串：
   - 每一步先将当前时间点已经「解禁」的字符从等待队列取出，重新压入最大堆。
   - 若最大堆为空，说明已无任何可用字符而结果尚未构建完成，返回空串。
   - 从堆顶取出一个字符追加到结果，并将其剩余次数减一；若仍大于 0，则将该字符连同新的可用时间 (当前下标 + k) 放入等待队列。
4. 最终如果构建出的字符串长度等于原串长度，则返回结果，否则返回空串。

关键点:
- 使用「当前时刻 + k」记录字符解禁时间，避免每次全表扫描。
- 最大堆保证始终优先安排剩余次数多的字符，降低后续无法排布的风险。
- k 为 0 时退化为原串即可，需单独处理或在逻辑中自然覆盖。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log σ) - n 为字符串长度，σ 为字符种类数，每个字符入堆出堆次数与其出现次数同阶。
空间复杂度: O(σ) - 需要堆和等待队列存储不同字符的状态。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def rearrange_string_k_distance_apart(s: str, k: int) -> str:
    """
    重新排列字符串，使得相同字符之间至少间隔 k；若无法做到返回空串。

    使用最大堆贪心选择剩余次数最多的字符，并用等待队列维护「解禁」时间。
    """
    if k <= 1:
        return s

    from collections import Counter, deque
    import heapq

    cnt = Counter(s)
    heap: list[tuple[int, str]] = [(-c, ch) for ch, c in cnt.items()]
    heapq.heapify(heap)
    wait = deque()  # (ready_pos, -cnt, ch)

    res: list[str] = []
    pos = 0

    while heap or wait:
        # 将已解禁的字符放回堆
        while wait and wait[0][0] <= pos:
            _, neg_c, ch = wait.popleft()
            heapq.heappush(heap, (neg_c, ch))

        if not heap:
            return ""

        neg_c, ch = heapq.heappop(heap)
        res.append(ch)
        pos += 1
        neg_c += 1  # 使用一次，剩余次数减一（因为是负数）
        if neg_c < 0:
            wait.append((pos + k - 1, neg_c, ch))

    return "".join(res)


# 自动生成Solution类（无需手动编写）
Solution = create_solution(rearrange_string_k_distance_apart)
