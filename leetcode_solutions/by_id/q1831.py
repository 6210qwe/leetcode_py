# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1831
标题: Ways to Split Array Into Three Subarrays
难度: medium
链接: https://leetcode.cn/problems/ways-to-split-array-into-three-subarrays/
题目类型: 数组、双指针、二分查找、前缀和
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1712. 将数组分成三个子数组的方案数 - 我们称一个分割整数数组的方案是 好的 ，当它满足： * 数组被分成三个 非空 连续子数组，从左至右分别命名为 left ， mid ， right 。 * left 中元素和小于等于 mid 中元素和，mid 中元素和小于等于 right 中元素和。 给你一个 非负 整数数组 nums ，请你返回 好的 分割 nums 方案数目。由于答案可能会很大，请你将结果对 109 + 7 取余后返回。 示例 1： 输入：nums = [1,1,1] 输出：1 解释：唯一一种好的分割方案是将 nums 分成 [1] [1] [1] 。 示例 2： 输入：nums = [1,2,2,2,5,0] 输出：3 解释：nums 总共有 3 种好的分割方案： [1] [2] [2,2,5,0] [1] [2,2] [2,5,0] [1,2] [2,2] [5,0] 示例 3： 输入：nums = [3,2,1] 输出：0 解释：没有好的分割方案。 提示： * 3 <= nums.length <= 105 * 0 <= nums[i] <= 104
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用前缀和与双指针来找到所有可能的分割点。

算法步骤:
1. 计算前缀和数组。
2. 使用双指针遍历前缀和数组，找到所有满足条件的分割点。
3. 对于每个可能的分割点，计算符合条件的分割方案数，并累加到结果中。

关键点:
- 使用前缀和数组可以快速计算任意子数组的和。
- 使用双指针可以在 O(n) 时间复杂度内找到所有可能的分割点。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def waysToSplit(nums: List[int]) -> int:
    MOD = 10**9 + 7
    n = len(nums)
    prefix_sum = [0] * (n + 1)
    
    # 计算前缀和数组
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + nums[i]
    
    result = 0
    j, k = 1, 1
    
    # 使用双指针遍历前缀和数组
    for i in range(1, n):
        # 更新 j 指针
        j = max(j, i + 1)
        while j < n and prefix_sum[j] - prefix_sum[i] < prefix_sum[i]:
            j += 1
        
        # 更新 k 指针
        k = max(k, j)
        while k < n and prefix_sum[k] - prefix_sum[i] <= prefix_sum[-1] - prefix_sum[k]:
            k += 1
        
        # 计算符合条件的分割方案数
        if j < k:
            result = (result + k - j) % MOD
    
    return result

Solution = waysToSplit