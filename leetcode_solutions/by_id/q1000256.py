# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000256
标题: 回文子串
难度: medium
链接: https://leetcode.cn/problems/a7VOhD/
题目类型: 字符串、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCR 020. 回文子串 - 给定一个字符串 s ，请计算这个字符串中有多少个回文子字符串。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。 示例 1： 输入：s = "abc" 输出：3 解释：三个回文子串: "a", "b", "c" 示例 2： 输入：s = "aaa" 输出：6 解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa" 提示： * 1 <= s.length <= 1000 * s 由小写英文字母组成 注意：本题与主站 70 题相同：https://leetcode.cn/problems/palindromic-substrings/ [https://leetcode.cn/problems/palindromic-substrings/]
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 中心扩展，枚举每个中心并向两侧扩展

算法步骤:
1. 回文中心有两种：
   - 单中心：以 i 为中心（奇数长度）
   - 双中心：以 i 和 i+1 为中心（偶数长度）
2. 对每个中心进行扩展，满足 s[l] == s[r] 时计数 +1，并继续 l--, r++
3. 累加所有中心扩展得到的回文子串数量

关键点:
- 每个回文子串都对应唯一的中心，因此中心扩展能覆盖所有回文子串
- 复杂度 O(n^2) 但 n<=1000 可接受
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2)
空间复杂度: O(1)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def count_substrings(s: str) -> int:
    """
    函数式接口 - 回文子串
    """
    n = len(s)
    ans = 0

    def expand(l: int, r: int) -> int:
        cnt = 0
        while l >= 0 and r < n and s[l] == s[r]:
            cnt += 1
            l -= 1
            r += 1
        return cnt

    for i in range(n):
        ans += expand(i, i)       # 奇数长度
        ans += expand(i, i + 1)   # 偶数长度
    return ans


Solution = create_solution(count_substrings)
