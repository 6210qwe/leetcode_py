# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 494
标题: Target Sum
难度: medium
链接: https://leetcode.cn/problems/target-sum/
题目类型: 数组、动态规划、回溯
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
494. 目标和 - 给你一个非负整数数组 nums 和一个整数 target 。 向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ： * 例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。 示例 1： 输入：nums = [1,1,1,1,1], target = 3 输出：5 解释：一共有 5 种方法让最终目标和为 3 。 -1 + 1 + 1 + 1 + 1 = 3 +1 - 1 + 1 + 1 + 1 = 3 +1 + 1 - 1 + 1 + 1 = 3 +1 + 1 + 1 - 1 + 1 = 3 +1 + 1 + 1 + 1 - 1 = 3 示例 2： 输入：nums = [1], target = 1 输出：1 提示： * 1 <= nums.length <= 20 * 0 <= nums[i] <= 1000 * 0 <= sum(nums[i]) <= 1000 * -1000 <= target <= 1000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。将问题转换为子集和问题，即找到一个子集，使其和为 (sum(nums) + target) / 2。

算法步骤:
1. 计算数组的总和 sum(nums)。
2. 检查 (sum(nums) + target) 是否为偶数，如果不是则返回 0。
3. 定义 dp[i][j] 为使用前 i 个元素能否组成和为 j 的子集的数量。
4. 初始化 dp 数组，dp[0][0] = 1。
5. 填充 dp 数组，对于每个元素 nums[i-1]，更新 dp[i][j]。
6. 返回 dp[n][target_sum]，其中 n 是数组长度，target_sum 是 (sum(nums) + target) // 2。

关键点:
- 将问题转换为子集和问题。
- 使用二维 dp 数组来存储中间结果。
- 注意边界条件和初始化。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * m) - 其中 n 是数组长度，m 是 (sum(nums) + target) // 2。
空间复杂度: O(n * m) - 使用了二维 dp 数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def target_sum(nums: List[int], target: int) -> int:
    """
    函数式接口 - 计算通过添加 '+' 或 '-' 可以构造出目标和的不同表达式的数目。
    
    实现思路:
    使用动态规划将问题转换为子集和问题，找到一个子集，使其和为 (sum(nums) + target) / 2。
    
    Args:
        nums: 非负整数数组
        target: 目标和
        
    Returns:
        不同表达式的数目
        
    Example:
        >>> target_sum([1, 1, 1, 1, 1], 3)
        5
    """
    total_sum = sum(nums)
    if (total_sum + target) % 2 != 0 or total_sum < abs(target):
        return 0
    
    target_sum = (total_sum + target) // 2
    n = len(nums)
    dp = [[0] * (target_sum + 1) for _ in range(n + 1)]
    dp[0][0] = 1
    
    for i in range(1, n + 1):
        for j in range(target_sum + 1):
            dp[i][j] = dp[i - 1][j]
            if j >= nums[i - 1]:
                dp[i][j] += dp[i - 1][j - nums[i - 1]]
    
    return dp[n][target_sum]


# 自动生成Solution类（无需手动编写）
Solution = create_solution(target_sum)