# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 100294
标题: 训练计划 II
难度: easy
链接: https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/
题目类型: 链表、双指针
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCR 140. 训练计划 II - 给定一个头节点为 head 的链表用于记录一系列核心肌群训练项目编号，请查找并返回倒数第 cnt 个训练项目编号。 示例 1： 输入：head = [2,4,7,8], cnt = 1 输出：8 提示： * 1 <= head.length <= 100 * 0 <= head[i] <= 100 * 1 <= cnt <= head.length
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用双指针法，先让快指针前进 cnt 步，然后快慢指针同时前进直到快指针到达链表尾部，此时慢指针指向的节点即为倒数第 cnt 个节点。

算法步骤:
1. 初始化两个指针 fast 和 slow，都指向链表头节点 head。
2. 快指针 fast 先前进 cnt 步。
3. 快慢指针同时前进，直到快指针到达链表尾部。
4. 返回慢指针 slow 所指向的节点。

关键点:
- 使用双指针可以一次遍历找到倒数第 cnt 个节点。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是链表的长度，因为只需要遍历链表一次。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.solution import create_solution

def find_kth_from_end(head: Optional[ListNode], k: int) -> Optional[ListNode]:
    """
    查找并返回链表中倒数第 k 个节点。
    """
    if not head:
        return None
    
    # 初始化快慢指针
    fast = slow = head
    
    # 快指针先前进 k 步
    for _ in range(k):
        if fast:
            fast = fast.next
        else:
            return None  # 如果 k 大于链表长度，返回 None
    
    # 快慢指针同时前进，直到快指针到达链表尾部
    while fast:
        fast = fast.next
        slow = slow.next
    
    return slow

Solution = create_solution(find_kth_from_end)