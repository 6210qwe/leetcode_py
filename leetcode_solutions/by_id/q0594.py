# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 594
标题: Longest Harmonious Subsequence
难度: easy
链接: https://leetcode.cn/problems/longest-harmonious-subsequence/
题目类型: 数组、哈希表、计数、排序、滑动窗口
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
594. 最长和谐子序列 - 和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。 给你一个整数数组 nums ，请你在所有可能的 子序列 中找到最长的和谐子序列的长度。 数组的 子序列 是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。 示例 1： 输入：nums = [1,3,2,2,5,2,3,7] 输出：5 解释： 最长和谐子序列是 [3,2,2,2,3]。 示例 2： 输入：nums = [1,2,3,4] 输出：2 解释： 最长和谐子序列是 [1,2]，[2,3] 和 [3,4]，长度都为 2。 示例 3： 输入：nums = [1,1,1,1] 输出：0 解释： 不存在和谐子序列。 提示： * 1 <= nums.length <= 2 * 104 * -109 <= nums[i] <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用哈希表来记录每个数字出现的次数，然后遍历哈希表，检查每个数字及其相邻数字（即 num + 1）的出现次数之和，找到最大值。

算法步骤:
1. 使用一个哈希表 `count` 来统计每个数字的出现次数。
2. 遍历哈希表，对于每个数字 `num`，检查 `num + 1` 是否也在哈希表中。
3. 如果 `num + 1` 存在，则计算 `num` 和 `num + 1` 的出现次数之和，并更新最大和谐子序列的长度。

关键点:
- 使用哈希表进行计数，可以快速查找和更新。
- 通过遍历哈希表，避免了对数组的多次遍历。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是数组的长度。我们只需要遍历数组一次来构建哈希表，再遍历哈希表一次来找到最长和谐子序列。
空间复杂度: O(n)，哈希表的空间复杂度为 O(n)。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(nums: List[int]) -> int:
    """
    函数式接口 - 找到最长的和谐子序列的长度
    """
    # 使用哈希表记录每个数字的出现次数
    count = {}
    for num in nums:
        if num in count:
            count[num] += 1
        else:
            count[num] = 1
    
    # 初始化最长和谐子序列的长度
    max_length = 0
    
    # 遍历哈希表，检查每个数字及其相邻数字的出现次数之和
    for num in count:
        if num + 1 in count:
            max_length = max(max_length, count[num] + count[num + 1])
    
    return max_length


Solution = create_solution(solution_function_name)