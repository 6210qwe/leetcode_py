# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3249
标题: Minimum Number of Operations to Make Array XOR Equal to K
难度: medium
链接: https://leetcode.cn/problems/minimum-number-of-operations-to-make-array-xor-equal-to-k/
题目类型: 位运算、数组
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2997. 使数组异或和等于 K 的最少操作次数 - 给你一个下标从 0 开始的整数数组 nums 和一个正整数 k 。 你可以对数组执行以下操作 任意次 ： * 选择数组里的 任意 一个元素，并将它的 二进制 表示 翻转 一个数位，翻转数位表示将 0 变成 1 或者将 1 变成 0 。 你的目标是让数组里 所有 元素的按位异或和得到 k ，请你返回达成这一目标的 最少 操作次数。 注意，你也可以将一个数的前导 0 翻转。比方说，数字 (101)2 翻转第四个数位，得到 (1101)2 。 示例 1： 输入：nums = [2,1,3,4], k = 1 输出：2 解释：我们可以执行以下操作： - 选择下标为 2 的元素，也就是 3 == (011)2 ，我们翻转第一个数位得到 (010)2 == 2 。数组变为 [2,1,2,4] 。 - 选择下标为 0 的元素，也就是 2 == (010)2 ，我们翻转第三个数位得到 (110)2 == 6 。数组变为 [6,1,2,4] 。 最终数组的所有元素异或和为 (6 XOR 1 XOR 2 XOR 4) == 1 == k 。 无法用少于 2 次操作得到异或和等于 k 。 示例 2： 输入：nums = [2,0,2,0], k = 0 输出：0 解释：数组所有元素的异或和为 (2 XOR 0 XOR 2 XOR 0) == 0 == k 。所以不需要进行任何操作。 提示： * 1 <= nums.length <= 105 * 0 <= nums[i] <= 106 * 0 <= k <= 106
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 计算当前数组的异或和与目标 k 的异或结果，然后计算该结果中有多少个 1，这些 1 就是需要翻转的位数。

算法步骤:
1. 计算数组 nums 的异或和 current_xor。
2. 计算 current_xor 与 k 的异或结果 target_xor。
3. 计算 target_xor 中 1 的个数，即为最少操作次数。

关键点:
- 异或运算的性质：a ^ a = 0, a ^ 0 = a
- 计算二进制中 1 的个数可以使用内置函数 bin 和 count
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是数组 nums 的长度。我们需要遍历整个数组来计算异或和。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def min_operations_to_make_array_xor_equal(nums: List[int], k: int) -> int:
    """
    计算使数组异或和等于 k 的最少操作次数
    """
    # 计算当前数组的异或和
    current_xor = 0
    for num in nums:
        current_xor ^= num
    
    # 计算当前异或和与目标 k 的异或结果
    target_xor = current_xor ^ k
    
    # 计算 target_xor 中 1 的个数
    return bin(target_xor).count('1')

Solution = create_solution(min_operations_to_make_array_xor_equal)