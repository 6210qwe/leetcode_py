# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2261
标题: All Divisions With the Highest Score of a Binary Array
难度: medium
链接: https://leetcode.cn/problems/all-divisions-with-the-highest-score-of-a-binary-array/
题目类型: 数组
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2155. 分组得分最高的所有下标 - 给你一个下标从 0 开始的二进制数组 nums ，数组长度为 n 。nums 可以按下标 i（ 0 <= i <= n ）拆分成两个数组（可能为空）：numsleft 和 numsright 。 * numsleft 包含 nums 中从下标 0 到 i - 1 的所有元素（包括 0 和 i - 1 ），而 numsright 包含 nums 中从下标 i 到 n - 1 的所有元素（包括 i 和 n - 1 ）。 * 如果 i == 0 ，numsleft 为 空 ，而 numsright 将包含 nums 中的所有元素。 * 如果 i == n ，numsleft 将包含 nums 中的所有元素，而 numsright 为 空 。 下标 i 的 分组得分 为 numsleft 中 0 的个数和 numsright 中 1 的个数之 和 。 返回 分组得分 最高 的 所有不同下标 。你可以按 任意顺序 返回答案。 示例 1： 输入：nums = [0,0,1,0] 输出：[2,4] 解释：按下标分组 - 0 ：numsleft 为 [] 。numsright 为 [0,0,1,0] 。得分为 0 + 1 = 1 。 - 1 ：numsleft 为 [0] 。numsright 为 [0,1,0] 。得分为 1 + 1 = 2 。 - 2 ：numsleft 为 [0,0] 。numsright 为 [1,0] 。得分为 2 + 1 = 3 。 - 3 ：numsleft 为 [0,0,1] 。numsright 为 [0] 。得分为 2 + 0 = 2 。 - 4 ：numsleft 为 [0,0,1,0] 。numsright 为 [] 。得分为 3 + 0 = 3 。 下标 2 和 4 都可以得到最高的分组得分 3 。 注意，答案 [4,2] 也被视为正确答案。 示例 2： 输入：nums = [0,0,0] 输出：[3] 解释：按下标分组 - 0 ：numsleft 为 [] 。numsright 为 [0,0,0] 。得分为 0 + 0 = 0 。 - 1 ：numsleft 为 [0] 。numsright 为 [0,0] 。得分为 1 + 0 = 1 。 - 2 ：numsleft 为 [0,0] 。numsright 为 [0] 。得分为 2 + 0 = 2 。 - 3 ：numsleft 为 [0,0,0] 。numsright 为 [] 。得分为 3 + 0 = 3 。 只有下标 3 可以得到最高的分组得分 3 。 示例 3： 输入：nums = [1,1] 输出：[0] 解释：按下标分组 - 0 ：numsleft 为 [] 。numsright 为 [1,1] 。得分为 0 + 2 = 2 。 - 1 ：numsleft 为 [1] 。numsright 为 [1] 。得分为 0 + 1 = 1 。 - 2 ：numsleft 为 [1,1] 。numsright 为 [] 。得分为 0 + 0 = 0 。 只有下标 0 可以得到最高的分组得分 2 。 提示： * n == nums.length * 1 <= n <= 105 * nums[i] 为 0 或 1
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用前缀和来计算每个位置的得分，并记录最大得分的位置。

算法步骤:
1. 计算整个数组中 1 的数量。
2. 初始化当前 0 的数量和最大得分。
3. 遍历数组，更新当前 0 的数量和得分。
4. 如果当前得分大于最大得分，更新最大得分和结果列表。
5. 如果当前得分等于最大得分，将当前索引加入结果列表。

关键点:
- 使用前缀和的思想，避免重复计算。
- 通过一次遍历完成计算，时间复杂度为 O(n)。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(1)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def solution_function_name(nums: List[int]) -> List[int]:
    """
    函数式接口 - 实现最优解法
    """
    n = len(nums)
    total_ones = sum(nums)  # 计算整个数组中 1 的数量
    max_score = -1
    current_zeros = 0
    result = []

    for i in range(n + 1):
        score = current_zeros + (total_ones - (i - current_zeros))
        if score > max_score:
            max_score = score
            result = [i]
        elif score == max_score:
            result.append(i)
        
        if i < n and nums[i] == 0:
            current_zeros += 1

    return result

Solution = create_solution(solution_function_name)