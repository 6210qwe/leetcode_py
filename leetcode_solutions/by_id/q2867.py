# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2867
标题: Ways to Split Array Into Good Subarrays
难度: medium
链接: https://leetcode.cn/problems/ways-to-split-array-into-good-subarrays/
题目类型: 数组、数学、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2750. 将数组划分成若干好子数组的方式 - 给你一个二元数组 nums 。 如果数组中的某个子数组 恰好 只存在 一 个值为 1 的元素，则认为该子数组是一个 好子数组 。 请你统计将数组 nums 划分成若干 好子数组 的方法数，并以整数形式返回。由于数字可能很大，返回其对 109 + 7 取余 之后的结果。 子数组是数组中的一个连续 非空 元素序列。 示例 1： 输入：nums = [0,1,0,0,1] 输出：3 解释：存在 3 种可以将 nums 划分成若干好子数组的方式： - [0,1] [0,0,1] - [0,1,0] [0,1] - [0,1,0,0] [1] 示例 2： 输入：nums = [0,1,0] 输出：1 解释：存在 1 种可以将 nums 划分成若干好子数组的方式： - [0,1,0] 提示： * 1 <= nums.length <= 105 * 0 <= nums[i] <= 1
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来计算将数组划分成若干好子数组的方法数。

算法步骤:
1. 初始化一个变量 `mod` 为 10^9 + 7。
2. 遍历数组 `nums`，找到所有值为 1 的元素的索引，并存储在列表 `ones` 中。
3. 如果 `ones` 的长度小于 2，说明无法划分成多个好子数组，直接返回 1。
4. 初始化 `dp` 数组，`dp[i]` 表示将前 i 个 1 划分成若干好子数组的方法数。
5. 动态规划转移方程：`dp[i] = (dp[i-1] + dp[i-2]) % mod`。
6. 返回 `dp` 数组的最后一个元素。

关键点:
- 使用动态规划来避免重复计算。
- 通过存储 1 的索引来简化计算。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是数组 `nums` 的长度。遍历数组和动态规划的时间复杂度都是 O(n)。
空间复杂度: O(m)，其中 m 是数组 `nums` 中 1 的个数。需要存储 1 的索引和动态规划数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(nums: List[int]) -> int:
    """
    函数式接口 - 计算将数组划分成若干好子数组的方法数
    """
    mod = 10**9 + 7
    ones = [i for i, num in enumerate(nums) if num == 1]
    
    if len(ones) < 2:
        return 1
    
    dp = [0] * (len(ones) + 1)
    dp[0], dp[1] = 1, 1
    
    for i in range(2, len(ones) + 1):
        dp[i] = (dp[i - 1] + dp[i - 2]) % mod
    
    return dp[-1]


Solution = create_solution(solution_function_name)