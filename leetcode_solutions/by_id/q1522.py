# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1522
标题: Stone Game III
难度: hard
链接: https://leetcode.cn/problems/stone-game-iii/
题目类型: 数组、数学、动态规划、博弈
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1406. 石子游戏 III - Alice 和 Bob 继续他们的石子游戏。几堆石子 排成一行 ，每堆石子都对应一个得分，由数组 stoneValue 给出。 Alice 和 Bob 轮流取石子，Alice 总是先开始。在每个玩家的回合中，该玩家可以拿走剩下石子中的的前 1、2 或 3 堆石子 。比赛一直持续到所有石头都被拿走。 每个玩家的最终得分为他所拿到的每堆石子的对应得分之和。每个玩家的初始分数都是 0 。 比赛的目标是决出最高分，得分最高的选手将会赢得比赛，比赛也可能会出现平局。 假设 Alice 和 Bob 都采取 最优策略 。 如果 Alice 赢了就返回 "Alice" ，Bob 赢了就返回 "Bob"，分数相同返回 "Tie" 。 示例 1： 输入：values = [1,2,3,7] 输出："Bob" 解释：Alice 总是会输，她的最佳选择是拿走前三堆，得分变成 6 。但是 Bob 的得分为 7，Bob 获胜。 示例 2： 输入：values = [1,2,3,-9] 输出："Alice" 解释：Alice 要想获胜就必须在第一个回合拿走前三堆石子，给 Bob 留下负分。 如果 Alice 只拿走第一堆，那么她的得分为 1，接下来 Bob 拿走第二、三堆，得分为 5 。之后 Alice 只能拿到分数 -9 的石子堆，输掉比赛。 如果 Alice 拿走前两堆，那么她的得分为 3，接下来 Bob 拿走第三堆，得分为 3 。之后 Alice 只能拿到分数 -9 的石子堆，同样会输掉比赛。 注意，他们都应该采取 最优策略 ，所以在这里 Alice 将选择能够使她获胜的方案。 示例 3： 输入：values = [1,2,3,6] 输出："Tie" 解释：Alice 无法赢得比赛。如果她决定选择前三堆，她可以以平局结束比赛，否则她就会输。 提示： * 1 <= stoneValue.length <= 5 * 104 * -1000 <= stoneValue[i] <= 1000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们定义 dp[i] 表示从第 i 堆石子开始，当前玩家与对手的最大得分差值。通过递归和记忆化搜索，我们可以计算出最优解。

算法步骤:
1. 初始化 dp 数组，dp[i] 表示从第 i 堆石子开始，当前玩家与对手的最大得分差值。
2. 从后往前遍历石子堆，对于每个位置 i，计算当前玩家可以选择的三种情况（拿 1 堆、2 堆或 3 堆）的最大得分差值。
3. 更新 dp[i] 为这三种情况的最大值。
4. 最终结果根据 dp[0] 的值来判断。

关键点:
- 使用记忆化搜索来避免重复计算。
- 通过从后往前遍历来确保每个位置的 dp 值已经计算完毕。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是 stoneValue 的长度。我们需要遍历整个数组一次。
空间复杂度: O(n)，用于存储 dp 数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def stoneGameIII(stoneValue: List[int]) -> str:
    n = len(stoneValue)
    dp = [float('-inf')] * (n + 1)
    dp[n] = 0  # 从最后一个位置开始，没有石子可拿，得分为 0

    for i in range(n - 1, -1, -1):
        take = 0
        for j in range(3):
            if i + j < n:
                take += stoneValue[i + j]
                dp[i] = max(dp[i], take - dp[i + j + 1])

    if dp[0] > 0:
        return "Alice"
    elif dp[0] < 0:
        return "Bob"
    else:
        return "Tie"


Solution = create_solution(stoneGameIII)