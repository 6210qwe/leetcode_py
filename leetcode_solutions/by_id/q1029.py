# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1029
标题: Vertical Order Traversal of a Binary Tree
难度: hard
链接: https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/
题目类型: 树、深度优先搜索、广度优先搜索、哈希表、二叉树、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
987. 二叉树的垂序遍历 - 给你二叉树的根结点 root ，请你设计算法计算二叉树的 垂序遍历 序列。 对位于 (row, col) 的每个结点而言，其左右子结点分别位于 (row + 1, col - 1) 和 (row + 1, col + 1) 。树的根结点位于 (0, 0) 。 二叉树的 垂序遍历 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。 返回二叉树的 垂序遍历 序列。 示例 1： [https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg] 输入：root = [3,9,20,null,null,15,7] 输出：[[9],[3,15],[20],[7]] 解释： 列 -1 ：只有结点 9 在此列中。 列 0 ：只有结点 3 和 15 在此列中，按从上到下顺序。 列 1 ：只有结点 20 在此列中。 列 2 ：只有结点 7 在此列中。 示例 2： [https://assets.leetcode.com/uploads/2021/01/29/vtree2.jpg] 输入：root = [1,2,3,4,5,6,7] 输出：[[4],[2],[1,5,6],[3],[7]] 解释： 列 -2 ：只有结点 4 在此列中。 列 -1 ：只有结点 2 在此列中。 列 0 ：结点 1 、5 和 6 都在此列中。 1 在上面，所以它出现在前面。 5 和 6 位置都是 (2, 0) ，所以按值从小到大排序，5 在 6 的前面。 列 1 ：只有结点 3 在此列中。 列 2 ：只有结点 7 在此列中。 示例 3： [https://assets.leetcode.com/uploads/2021/01/29/vtree3.jpg] 输入：root = [1,2,3,4,6,5,7] 输出：[[4],[2],[1,5,6],[3],[7]] 解释： 这个示例实际上与示例 2 完全相同，只是结点 5 和 6 在树中的位置发生了交换。 因为 5 和 6 的位置仍然相同，所以答案保持不变，仍然按值从小到大排序。 提示： * 树中结点数目总数在范围 [1, 1000] 内 * 0 <= Node.val <= 1000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用广度优先搜索（BFS）遍历二叉树，并记录每个节点的行和列信息。使用字典存储每个列的所有节点及其对应的行信息，最后对结果进行排序。

算法步骤:
1. 初始化一个队列，将根节点 (0, 0, root) 加入队列。
2. 使用一个字典 `col_map` 来存储每个列的所有节点及其对应的行信息。
3. 开始广度优先搜索：
   - 从队列中取出一个节点 (row, col, node)。
   - 将该节点的信息 (row, node.val) 添加到 `col_map[col]` 中。
   - 如果左子节点存在，将其 (row + 1, col - 1, left) 加入队列。
   - 如果右子节点存在，将其 (row + 1, col + 1, right) 加入队列。
4. 遍历结束后，对 `col_map` 中的每个列进行排序，先按列排序，再按行排序，最后按节点值排序。
5. 构建最终结果并返回。

关键点:
- 使用 BFS 遍历二叉树，确保按层次遍历。
- 使用字典存储每个列的所有节点及其对应的行信息。
- 最后对结果进行排序，确保同一列内的节点按行排序，同一行内的节点按值排序。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是树中节点的数量。因为我们需要对每个节点进行排序。
空间复杂度: O(n)，用于存储节点信息和结果。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def vertical_traversal(root: Optional[TreeNode]) -> List[List[int]]:
    if not root:
        return []

    from collections import defaultdict, deque

    # 用于存储每个列的所有节点及其对应的行信息
    col_map = defaultdict(list)
    queue = deque([(0, 0, root)])

    while queue:
        row, col, node = queue.popleft()
        col_map[col].append((row, node.val))
        if node.left:
            queue.append((row + 1, col - 1, node.left))
        if node.right:
            queue.append((row + 1, col + 1, node.right))

    # 对每个列进行排序，先按列排序，再按行排序，最后按节点值排序
    result = []
    for col in sorted(col_map.keys()):
        col_nodes = sorted(col_map[col], key=lambda x: (x[0], x[1]))
        result.append([val for _, val in col_nodes])

    return result


Solution = create_solution(vertical_traversal)