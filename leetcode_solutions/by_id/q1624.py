# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1624
标题: Clone Binary Tree With Random Pointer
难度: medium
链接: https://leetcode.cn/problems/clone-binary-tree-with-random-pointer/
题目类型: 树、深度优先搜索、广度优先搜索、哈希表、二叉树
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1485. 克隆含随机指针的二叉树 - 备战技术面试？力扣提供海量技术面试资源，帮助你高效提升编程技能,轻松拿下世界 IT 名企 Dream Offer。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用深度优先搜索（DFS）和哈希表来克隆二叉树。哈希表用于存储原节点和新节点的映射关系，以避免重复创建节点。

算法步骤:
1. 定义一个递归函数 `clone_tree`，该函数接受一个节点作为参数，并返回该节点的克隆。
2. 如果节点为空，返回 None。
3. 如果节点已经在哈希表中，直接返回哈希表中对应的克隆节点。
4. 否则，创建一个新的节点，并将其添加到哈希表中。
5. 递归克隆左子节点、右子节点和随机指针，并将它们赋值给新节点的相应属性。
6. 返回新节点。

关键点:
- 使用哈希表来存储原节点和新节点的映射关系，以避免重复创建节点。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是二叉树中的节点数。每个节点只被访问一次。
空间复杂度: O(n)，哈希表需要存储 n 个节点的映射关系。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import Optional
from leetcode_solutions.utils.tree import TreeNode

class Node:
    def __init__(self, val=0, left=None, right=None, random=None):
        self.val = val
        self.left = left
        self.right = right
        self.random = random

def clone_tree(root: 'Node') -> 'Node':
    if not root:
        return None
    
    # 哈希表用于存储原节点和新节点的映射关系
    node_map = {}
    
    def dfs(node: 'Node') -> 'Node':
        if not node:
            return None
        if node in node_map:
            return node_map[node]
        
        # 创建新节点
        new_node = Node(node.val)
        node_map[node] = new_node
        
        # 递归克隆左子节点、右子节点和随机指针
        new_node.left = dfs(node.left)
        new_node.right = dfs(node.right)
        new_node.random = dfs(node.random)
        
        return new_node
    
    return dfs(root)

Solution = create_solution(clone_tree)