# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 867
标题: New 21 Game
难度: medium
链接: https://leetcode.cn/problems/new-21-game/
题目类型: 数学、动态规划、滑动窗口、概率与统计
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
837. 新 21 点 - 爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下： 爱丽丝以 0 分开始，并在她的得分少于 k 分时抽取数字。 抽取时，她从 [1, maxPts] 的范围中随机获得一个整数作为分数进行累计，其中 maxPts 是一个整数。 每次抽取都是独立的，其结果具有相同的概率。 当爱丽丝获得 k 分 或更多分 时，她就停止抽取数字。 爱丽丝的分数不超过 n 的概率是多少？ 与实际答案误差不超过 10-5 的答案将被视为正确答案。 示例 1： 输入：n = 10, k = 1, maxPts = 10 输出：1.00000 解释：爱丽丝得到一张牌，然后停止。 示例 2： 输入：n = 6, k = 1, maxPts = 10 输出：0.60000 解释：爱丽丝得到一张牌，然后停止。 在 10 种可能性中的 6 种情况下，她的得分不超过 6 分。 示例 3： 输入：n = 21, k = 17, maxPts = 10 输出：0.73278 提示： * 0 <= k <= n <= 104 * 1 <= maxPts <= 104
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划和滑动窗口来计算爱丽丝得分不超过 n 的概率。

算法步骤:
1. 初始化一个数组 dp，其中 dp[i] 表示得分为 i 的概率。
2. 使用滑动窗口来维护当前得分范围的概率和。
3. 通过动态规划更新每个得分的概率。
4. 最后返回所有不超过 n 的得分的概率和。

关键点:
- 使用滑动窗口来优化时间复杂度。
- 动态规划的状态转移方程为 dp[i] = (dp[i-1] + ... + dp[i-maxPts]) / maxPts。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def new_21_game(n: int, k: int, maxPts: int) -> float:
    """
    函数式接口 - 计算爱丽丝得分不超过 n 的概率
    """
    if k == 0 or n >= k + maxPts:
        return 1.0

    dp = [0.0] * (n + 1)
    dp[0] = 1.0
    window_sum = 1.0
    result = 0.0

    for i in range(1, n + 1):
        dp[i] = window_sum / maxPts
        if i < k:
            window_sum += dp[i]
        else:
            result += dp[i]
        if i - maxPts >= 0:
            window_sum -= dp[i - maxPts]

    return result


Solution = create_solution(new_21_game)