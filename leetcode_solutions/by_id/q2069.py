# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2069
标题: Kth Smallest Subarray Sum
难度: medium
链接: https://leetcode.cn/problems/kth-smallest-subarray-sum/
题目类型: 数组、二分查找、滑动窗口
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1918. 第 K 小的子数组和 - 备战技术面试？力扣提供海量技术面试资源，帮助你高效提升编程技能,轻松拿下世界 IT 名企 Dream Offer。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用二分查找和滑动窗口来找到第 K 小的子数组和。

算法步骤:
1. 定义一个辅助函数 `count_subarrays`，用于计算数组中所有和小于等于 `x` 的子数组数量。
2. 使用二分查找来确定第 K 小的子数组和。初始范围是 `[min(nums), sum(nums)]`。
3. 在每次二分查找的过程中，使用 `count_subarrays` 函数来判断当前中间值是否满足条件。
4. 如果 `count_subarrays` 返回的数量大于等于 K，则说明第 K 小的子数组和在左半部分；否则在右半部分。
5. 最终返回二分查找的结果。

关键点:
- 二分查找的范围是 `[min(nums), sum(nums)]`。
- 滑动窗口用于高效计算和小于等于 `x` 的子数组数量。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * log(sum(nums) - min(nums)))
空间复杂度: O(1)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def count_subarrays(nums: List[int], x: int) -> int:
    count = 0
    left = 0
    current_sum = 0
    
    for right in range(len(nums)):
        current_sum += nums[right]
        
        while current_sum > x:
            current_sum -= nums[left]
            left += 1
        
        count += right - left + 1
    
    return count

def kth_smallest_subarray_sum(nums: List[int], k: int) -> int:
    low, high = min(nums), sum(nums)
    
    while low < high:
        mid = (low + high) // 2
        if count_subarrays(nums, mid) >= k:
            high = mid
        else:
            low = mid + 1
    
    return low

Solution = kth_smallest_subarray_sum