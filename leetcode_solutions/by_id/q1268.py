# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1268
标题: Market Analysis I
难度: medium
链接: https://leetcode.cn/problems/market-analysis-i/
题目类型: 数据库
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1158. 市场分析 I - 表： Users +----------------+---------+ | Column Name | Type | +----------------+---------+ | user_id | int | | join_date | date | | favorite_brand | varchar | +----------------+---------+ user_id 是此表主键（具有唯一值的列）。 表中描述了购物网站的用户信息，用户可以在此网站上进行商品买卖。 表： Orders +---------------+---------+ | Column Name | Type | +---------------+---------+ | order_id | int | | order_date | date | | item_id | int | | buyer_id | int | | seller_id | int | +---------------+---------+ order_id 是此表主键（具有唯一值的列）。 item_id 是 Items 表的外键（reference 列）。 （buyer_id，seller_id）是 User 表的外键。 表：Items +---------------+---------+ | Column Name | Type | +---------------+---------+ | item_id | int | | item_brand | varchar | +---------------+---------+ item_id 是此表的主键（具有唯一值的列）。 编写解决方案找出每个用户的注册日期和在 2019 年作为买家的订单总数。 以 任意顺序 返回结果表。 查询结果格式如下。 示例 1: 输入： Users 表: +---------+------------+----------------+ | user_id | join_date | favorite_brand | +---------+------------+----------------+ | 1 | 2018-01-01 | Lenovo | | 2 | 2018-02-09 | Samsung | | 3 | 2018-01-19 | LG | | 4 | 2018-05-21 | HP | +---------+------------+----------------+ Orders 表: +----------+------------+---------+----------+-----------+ | order_id | order_date | item_id | buyer_id | seller_id | +----------+------------+---------+----------+-----------+ | 1 | 2019-08-01 | 4 | 1 | 2 | | 2 | 2018-08-02 | 2 | 1 | 3 | | 3 | 2019-08-03 | 3 | 2 | 3 | | 4 | 2018-08-04 | 1 | 4 | 2 | | 5 | 2018-08-04 | 1 | 3 | 4 | | 6 | 2019-08-05 | 2 | 2 | 4 | +----------+------------+---------+----------+-----------+ Items 表: +---------+------------+ | item_id | item_brand | +---------+------------+ | 1 | Samsung | | 2 | Lenovo | | 3 | LG | | 4 | HP | +---------+------------+ 输出： +-----------+------------+----------------+ | buyer_id | join_date | orders_in_2019 | +-----------+------------+----------------+ | 1 | 2018-01-01 | 1 | | 2 | 2018-02-09 | 2 | | 3 | 2018-01-19 | 0 | | 4 | 2018-05-21 | 0 | +-----------+------------+----------------+
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用 SQL 查询来实现需求

算法步骤:
1. 过滤出 2019 年的订单。
2. 将过滤后的订单与用户表进行左连接，以获取每个用户的 2019 年订单数量。
3. 使用 COALESCE 函数将 NULL 订单数量转换为 0。

关键点:
- 使用 LEFT JOIN 确保所有用户都出现在结果中，即使他们在 2019 年没有订单。
- 使用 COALESCE 处理 NULL 值。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n + m)，其中 n 是 Orders 表的行数，m 是 Users 表的行数。
空间复杂度: O(1)，不考虑输出结果的空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(users, orders):
    """
    函数式接口 - 实现市场分析 I
    """
    # 过滤出 2019 年的订单
    orders_2019 = orders[orders['order_date'].dt.year == 2019]
    
    # 计算每个用户的 2019 年订单数量
    orders_count = orders_2019.groupby('buyer_id')['order_id'].count().reset_index()
    orders_count.columns = ['user_id', 'orders_in_2019']
    
    # 将订单数量与用户表进行左连接
    result = users.merge(orders_count, on='user_id', how='left')
    
    # 处理 NULL 值
    result['orders_in_2019'] = result['orders_in_2019'].fillna(0).astype(int)
    
    # 重命名列
    result = result.rename(columns={'user_id': 'buyer_id'})
    
    return result[['buyer_id', 'join_date', 'orders_in_2019']]


Solution = create_solution(solution_function_name)