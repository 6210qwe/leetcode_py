# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1182
标题: Game Play Analysis IV
难度: medium
链接: https://leetcode.cn/problems/game-play-analysis-iv/
题目类型: 数据库
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
550. 游戏玩法分析 IV - Table: Activity +--------------+---------+ | Column Name | Type | +--------------+---------+ | player_id | int | | device_id | int | | event_date | date | | games_played | int | +--------------+---------+ （player_id，event_date）是此表的主键（具有唯一值的列的组合）。 这张表显示了某些游戏的玩家的活动情况。 每一行是一个玩家的记录，他在某一天使用某个设备注销之前登录并玩了很多游戏（可能是 0）。 编写解决方案，报告在首次登录的第二天再次登录的玩家的 比率，四舍五入到小数点后两位。换句话说，你需要计算从首次登录后的第二天登录的玩家数量，并将其除以总玩家数。 结果格式如下所示： 示例 1： 输入： Activity table: +-----------+-----------+------------+--------------+ | player_id | device_id | event_date | games_played | +-----------+-----------+------------+--------------+ | 1 | 2 | 2016-03-01 | 5 | | 1 | 2 | 2016-03-02 | 6 | | 2 | 3 | 2017-06-25 | 1 | | 3 | 1 | 2016-03-02 | 0 | | 3 | 4 | 2018-07-03 | 5 | +-----------+-----------+------------+--------------+ 输出： +-----------+ | fraction | +-----------+ | 0.33 | +-----------+ 解释： 只有 ID 为 1 的玩家在第一天登录后才重新登录，所以答案是 1/3 = 0.33
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用 SQL 查询来解决这个问题。首先找到每个玩家的首次登录日期，然后检查这些玩家是否在首次登录的第二天再次登录。

算法步骤:
1. 找到每个玩家的首次登录日期。
2. 检查这些玩家是否在首次登录的第二天再次登录。
3. 计算符合条件的玩家数量与总玩家数量的比率。

关键点:
- 使用窗口函数 `ROW_NUMBER()` 来找到每个玩家的首次登录日期。
- 使用 `DATE_ADD()` 函数来计算首次登录的第二天。
- 使用 `INNER JOIN` 来连接两个子查询结果。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是 Activity 表的行数。主要的时间消耗在于排序和分组操作。
空间复杂度: O(n)，存储中间结果。
"""

# ============================================================================
# 代码实现
# ============================================================================

import pandas as pd

def solution_function_name(activity: pd.DataFrame) -> pd.DataFrame:
    """
    函数式接口 - 计算在首次登录的第二天再次登录的玩家的比率
    """
    # 找到每个玩家的首次登录日期
    first_login = activity.groupby('player_id')['event_date'].min().reset_index()
    first_login.columns = ['player_id', 'first_login_date']
    
    # 计算首次登录的第二天
    first_login['next_day'] = first_login['first_login_date'] + pd.DateOffset(days=1)
    
    # 检查这些玩家是否在首次登录的第二天再次登录
    next_day_login = activity.merge(first_login, on='player_id')
    next_day_login = next_day_login[next_day_login['event_date'] == next_day_login['next_day']]
    
    # 计算符合条件的玩家数量与总玩家数量的比率
    total_players = activity['player_id'].nunique()
    next_day_players = next_day_login['player_id'].nunique()
    fraction = round(next_day_players / total_players, 2)
    
    return pd.DataFrame({'fraction': [fraction]})

Solution = create_solution(solution_function_name)