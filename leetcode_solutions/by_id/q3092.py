# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3092
标题: Minimum Moves to Spread Stones Over Grid
难度: medium
链接: https://leetcode.cn/problems/minimum-moves-to-spread-stones-over-grid/
题目类型: 广度优先搜索、数组、动态规划、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2850. 将石头分散到网格图的最少移动次数 - 给你一个大小为 3 * 3 ，下标从 0 开始的二维整数矩阵 grid ，分别表示每一个格子里石头的数目。网格图中总共恰好有 9 个石头，一个格子里可能会有 多个 石头。 每一次操作中，你可以将一个石头从它当前所在格子移动到一个至少有一条公共边的相邻格子。 请你返回每个格子恰好有一个石头的 最少移动次数 。 示例 1： [https://assets.leetcode.com/uploads/2023/08/23/example1-3.svg] 输入：grid = [[1,1,0],[1,1,1],[1,2,1]] 输出：3 解释：让每个格子都有一个石头的一个操作序列为： 1 - 将一个石头从格子 (2,1) 移动到 (2,2) 。 2 - 将一个石头从格子 (2,2) 移动到 (1,2) 。 3 - 将一个石头从格子 (1,2) 移动到 (0,2) 。 总共需要 3 次操作让每个格子都有一个石头。 让每个格子都有一个石头的最少操作次数为 3 。 示例 2： [https://assets.leetcode.com/uploads/2023/08/23/example2-2.svg] 输入：grid = [[1,3,0],[1,0,0],[1,0,3]] 输出：4 解释：让每个格子都有一个石头的一个操作序列为： 1 - 将一个石头从格子 (0,1) 移动到 (0,2) 。 2 - 将一个石头从格子 (0,1) 移动到 (1,1) 。 3 - 将一个石头从格子 (2,2) 移动到 (1,2) 。 4 - 将一个石头从格子 (2,2) 移动到 (2,1) 。 总共需要 4 次操作让每个格子都有一个石头。 让每个格子都有一个石头的最少操作次数为 4 。 提示： * grid.length == grid[i].length == 3 * 0 <= grid[i][j] <= 9 * grid 中元素之和为 9 。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用回溯法来找到最少的移动次数。我们首先找到所有多余的石头和空缺的位置，然后通过递归尝试将多余的石头移动到空缺的位置，记录每次移动的总步数，并更新最小步数。

算法步骤:
1. 找出所有有多余石头的格子和空缺的格子。
2. 使用回溯法尝试将多余的石头移动到空缺的位置，记录每次移动的总步数。
3. 更新最小移动次数。

关键点:
- 使用曼哈顿距离来计算移动步数。
- 通过递归和回溯来尝试所有可能的移动方案。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(9!) - 因为最多有 9 个位置需要排列。
空间复杂度: O(9!) - 递归调用栈的最大深度。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def minimum_moves_to_spread_stones(grid: List[List[int]]) -> int:
    def manhattan_distance(p1, p2):
        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])

    def backtrack(extra, empty, moves, current_move):
        nonlocal min_moves
        if not extra:
            min_moves = min(min_moves, current_move)
            return
        for i in range(len(extra)):
            for j in range(len(empty)):
                next_extra = extra[:i] + extra[i+1:]
                next_empty = empty[:j] + empty[j+1:]
                next_move = current_move + manhattan_distance(extra[i], empty[j])
                if next_move < min_moves:
                    backtrack(next_extra, next_empty, moves, next_move)

    extra = []
    empty = []
    for i in range(3):
        for j in range(3):
            if grid[i][j] > 1:
                extra.extend([(i, j)] * (grid[i][j] - 1))
            elif grid[i][j] == 0:
                empty.append((i, j))

    min_moves = float('inf')
    backtrack(extra, empty, 0, 0)
    return min_moves

Solution = create_solution(minimum_moves_to_spread_stones)