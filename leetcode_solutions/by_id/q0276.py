# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 276
标题: Paint Fence
难度: medium
链接: https://leetcode.cn/problems/paint-fence/
题目类型: 动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
276. 栅栏涂色 - 备战技术面试？力扣提供海量技术面试资源，帮助你高效提升编程技能,轻松拿下世界 IT 名企 Dream Offer。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 动态规划，相邻两个栅栏不能同色

算法步骤:
1. dp[i]表示i个栅栏的涂色方案数
2. 如果第i个栅栏与第i-1个不同色：dp[i] = dp[i-1] * (k-1)
3. 如果第i个栅栏与第i-1个同色：dp[i] = dp[i-2] * (k-1)
4. 总方案数：dp[i] = dp[i-1] * (k-1) + dp[i-2] * (k-1)

关键点:
- 动态规划
- 空间优化到O(1)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - n为栅栏数
空间复杂度: O(1) - 优化后空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def num_ways(n: int, k: int) -> int:
    """
    函数式接口 - 栅栏涂色
    
    实现思路:
    动态规划：相邻两个栅栏不能同色。
    
    Args:
        n: 栅栏数量
        k: 颜色数量
        
    Returns:
        涂色方案数
        
    Example:
        >>> num_ways(3, 2)
        6
    """
    if n == 0:
        return 0
    if n == 1:
        return k
    if n == 2:
        return k * k
    
    # dp[i] = (dp[i-1] + dp[i-2]) * (k-1)
    prev2 = k  # dp[1]
    prev1 = k * k  # dp[2]
    
    for i in range(3, n + 1):
        curr = (prev1 + prev2) * (k - 1)
        prev2 = prev1
        prev1 = curr
    
    return prev1


# 自动生成Solution类（无需手动编写）
Solution = create_solution(num_ways)
