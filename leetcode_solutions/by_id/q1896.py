# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1896
标题: Maximum Score from Performing Multiplication Operations
难度: hard
链接: https://leetcode.cn/problems/maximum-score-from-performing-multiplication-operations/
题目类型: 数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1770. 执行乘法运算的最大分数 - 给你两个长度分别 n 和 m 的整数数组 nums 和 multipliers ，其中 n >= m ，数组下标 从 1 开始 计数。 初始时，你的分数为 0 。你需要执行恰好 m 步操作。在第 i 步操作（从 1 开始 计数）中，需要： * 选择数组 nums 开头处或者末尾处 的整数 x 。 * 你获得 multipliers[i] * x 分，并累加到你的分数中。 * 将 x 从数组 nums 中移除。 在执行 m 步操作后，返回 最大 分数。 示例 1： 输入：nums = [1,2,3], multipliers = [3,2,1] 输出：14 解释：一种最优解决方案如下： - 选择末尾处的整数 3 ，[1,2,3] ，得 3 * 3 = 9 分，累加到分数中。 - 选择末尾处的整数 2 ，[1,2] ，得 2 * 2 = 4 分，累加到分数中。 - 选择末尾处的整数 1 ，[1] ，得 1 * 1 = 1 分，累加到分数中。 总分数为 9 + 4 + 1 = 14 。 示例 2： 输入：nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6] 输出：102 解释：一种最优解决方案如下： - 选择开头处的整数 -5 ，[-5,-3,-3,-2,7,1] ，得 -5 * -10 = 50 分，累加到分数中。 - 选择开头处的整数 -3 ，[-3,-3,-2,7,1] ，得 -3 * -5 = 15 分，累加到分数中。 - 选择开头处的整数 -3 ，[-3,-2,7,1] ，得 -3 * 3 = -9 分，累加到分数中。 - 选择末尾处的整数 1 ，[-2,7,1] ，得 1 * 4 = 4 分，累加到分数中。 - 选择末尾处的整数 7 ，[-2,7] ，得 7 * 6 = 42 分，累加到分数中。 总分数为 50 + 15 - 9 + 4 + 42 = 102 。 提示： * n == nums.length * m == multipliers.length * 1 <= m <= 103 * m <= n <= 105 * -1000 <= nums[i], multipliers[i] <= 1000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们定义 dp[i][j] 表示在前 i 步操作中选择了 j 个开头元素的最大分数。

算法步骤:
1. 初始化一个二维 DP 数组 dp，大小为 (m+1) x (m+1)，并将其所有值初始化为负无穷。
2. 设置 dp[0][0] = 0，表示初始状态下的分数为 0。
3. 遍历每一步操作，对于每一步操作，考虑两种情况：选择开头元素或选择末尾元素。
4. 更新 DP 数组中的值，取两种情况中的最大值。
5. 最终结果是 dp[m][0] 到 dp[m][m] 中的最大值。

关键点:
- 使用动态规划来避免重复计算。
- 通过二维 DP 数组来记录不同状态下的最大分数。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m^2)
空间复杂度: O(m^2)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def max_score(nums: List[int], multipliers: List[int]) -> int:
    """
    函数式接口 - 计算执行乘法运算的最大分数
    """
    n, m = len(nums), len(multipliers)
    dp = [[float('-inf')] * (m + 1) for _ in range(m + 1)]
    dp[0][0] = 0

    for i in range(1, m + 1):
        for j in range(i + 1):
            if j > 0:
                dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + multipliers[i - 1] * nums[j - 1])
            if i - j > 0:
                dp[i][j] = max(dp[i][j], dp[i - 1][j] + multipliers[i - 1] * nums[n - (i - j)])

    return max(dp[m])

Solution = create_solution(max_score)