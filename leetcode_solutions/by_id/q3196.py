# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3196
标题: Apply Operations to Maximize Frequency Score
难度: hard
链接: https://leetcode.cn/problems/apply-operations-to-maximize-frequency-score/
题目类型: 数组、二分查找、前缀和、排序、滑动窗口
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2968. 执行操作使频率分数最大 - 给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。 你可以对数组执行 至多 k 次操作： * 从数组中选择一个下标 i ，将 nums[i] 增加 或者 减少 1 。 最终数组的频率分数定义为数组中众数的 频率 。 请你返回你可以得到的 最大 频率分数。 众数指的是数组中出现次数最多的数。一个元素的频率指的是数组中这个元素的出现次数。 示例 1： 输入：nums = [1,2,6,4], k = 3 输出：3 解释：我们可以对数组执行以下操作： - 选择 i = 0 ，将 nums[0] 增加 1 。得到数组 [2,2,6,4] 。 - 选择 i = 3 ，将 nums[3] 减少 1 ，得到数组 [2,2,6,3] 。 - 选择 i = 3 ，将 nums[3] 减少 1 ，得到数组 [2,2,6,2] 。 元素 2 是最终数组中的众数，出现了 3 次，所以频率分数为 3 。 3 是所有可行方案里的最大频率分数。 示例 2： 输入：nums = [1,4,4,2,4], k = 0 输出：3 解释：我们无法执行任何操作，所以得到的频率分数是原数组中众数的频率 3 。 提示： * 1 <= nums.length <= 105 * 1 <= nums[i] <= 109 * 0 <= k <= 1014
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用滑动窗口和前缀和来找到可以最大化频率分数的子数组。

算法步骤:
1. 对数组进行排序。
2. 计算前缀和数组。
3. 使用滑动窗口来找到满足条件的最大子数组长度。
4. 返回最大频率分数。

关键点:
- 排序后，可以使用前缀和快速计算子数组的和。
- 滑动窗口用于找到满足条件的最大子数组长度。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是数组的长度。排序操作的时间复杂度为 O(n log n)，滑动窗口的时间复杂度为 O(n)。
空间复杂度: O(n)，用于存储前缀和数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def maximize_frequency_score(nums: List[int], k: int) -> int:
    """
    函数式接口 - 执行操作使频率分数最大
    """
    # 对数组进行排序
    nums.sort()
    
    # 计算前缀和数组
    prefix_sum = [0]
    for num in nums:
        prefix_sum.append(prefix_sum[-1] + num)
    
    max_freq = 0
    left = 0
    for right in range(len(nums)):
        while (right - left + 1) * nums[right] - (prefix_sum[right + 1] - prefix_sum[left]) > k:
            left += 1
        max_freq = max(max_freq, right - left + 1)
    
    return max_freq

Solution = create_solution(maximize_frequency_score)