# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 4172
标题: Sum of Increasing Product Blocks
难度: medium
链接: https://leetcode.cn/problems/sum-of-increasing-product-blocks/
题目类型: 数学、模拟
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3792. 递增乘积块之和 - 备战技术面试？力扣提供海量技术面试资源，帮助你高效提升编程技能,轻松拿下世界 IT 名企 Dream Offer。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来找到所有递增乘积块，并计算它们的和。

算法步骤:
1. 初始化一个数组 `dp`，其中 `dp[i]` 表示以 `i` 结尾的递增乘积块的最大值。
2. 遍历数组，对于每个元素 `nums[i]`，检查它是否可以与前面的元素形成递增乘积块。
3. 更新 `dp` 数组，并维护一个变量 `total_sum` 来记录所有递增乘积块的和。

关键点:
- 使用 `dp` 数组来存储以每个位置结尾的递增乘积块的最大值。
- 动态更新 `dp` 数组和 `total_sum`。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2)，其中 n 是数组的长度。因为我们需要遍历数组并检查每个元素之前的元素。
空间复杂度: O(n)，用于存储 `dp` 数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def solution_function_name(nums: List[int]) -> int:
    """
    函数式接口 - 计算递增乘积块之和
    """
    if not nums:
        return 0

    n = len(nums)
    dp = [1] * n  # dp[i] 表示以 i 结尾的递增乘积块的最大值
    total_sum = 0

    for i in range(n):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] * nums[i])
        total_sum += dp[i]

    return total_sum

Solution = create_solution(solution_function_name)