# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 118
标题: Pascal's Triangle
难度: easy
链接: https://leetcode.cn/problems/pascals-triangle/
题目类型: 数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
118. 杨辉三角 - 给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。 在「杨辉三角」中，每个数是它左上方和右上方的数的和。 [https://pic.leetcode.cn/1626927345-DZmfxB-PascalTriangleAnimated2.gif] 示例 1: 输入: numRows = 5 输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]] 示例 2: 输入: numRows = 1 输出: [[1]] 提示: * 1 <= numRows <= 30
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 动态规划，每行的每个数等于上一行相邻两数之和

算法步骤:
1. 第一行是[1]
2. 对于第i行，第一个和最后一个元素是1
3. 中间元素等于上一行相邻两数之和
4. 重复直到生成numRows行

关键点:
- 使用动态规划逐行生成
- 时间复杂度O(numRows^2)，空间复杂度O(numRows^2)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(numRows^2) - 需要生成numRows行，每行最多numRows个元素
空间复杂度: O(numRows^2) - 存储所有行的数据
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from leetcode_solutions.utils.solution import create_solution


def pascals_triangle(numRows: int) -> List[List[int]]:
    """
    函数式接口 - 生成杨辉三角的前numRows行
    
    实现思路:
    使用动态规划，每行的每个数等于上一行相邻两数之和。
    
    Args:
        numRows: 行数
        
    Returns:
        杨辉三角的前numRows行
        
    Example:
        >>> pascals_triangle(5)
        [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]
    """
    if numRows == 0:
        return []
    
    result = [[1]]
    
    for i in range(1, numRows):
        row = [1]
        prev_row = result[i - 1]
        
        for j in range(1, i):
            row.append(prev_row[j - 1] + prev_row[j])
        
        row.append(1)
        result.append(row)
    
    return result


# 自动生成Solution类（无需手动编写）
Solution = create_solution(pascals_triangle)
