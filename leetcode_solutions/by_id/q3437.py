# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3437
标题: Maximum Total Damage With Spell Casting
难度: medium
链接: https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/
题目类型: 数组、哈希表、双指针、二分查找、动态规划、计数、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3186. 施咒的最大总伤害 - 一个魔法师有许多不同的咒语。 给你一个数组 power ，其中每个元素表示一个咒语的伤害值，可能会有多个咒语有相同的伤害值。 已知魔法师使用伤害值为 power[i] 的咒语时，他们就 不能 使用伤害为 power[i] - 2 ，power[i] - 1 ，power[i] + 1 或者 power[i] + 2 的咒语。 每个咒语最多只能被使用 一次 。 请你返回这个魔法师可以达到的伤害值之和的 最大值 。 示例 1： 输入：power = [1,1,3,4] 输出：6 解释： 可以使用咒语 0，1，3，伤害值分别为 1，1，4，总伤害值为 6 。 示例 2： 输入：power = [7,1,6,6] 输出：13 解释： 可以使用咒语 1，2，3，伤害值分别为 1，6，6，总伤害值为 13 。 提示： * 1 <= power.length <= 105 * 1 <= power[i] <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 动态规划

算法步骤:
1. 对输入数组进行排序。
2. 使用动态规划来记录每个位置的最大伤害值。
3. 定义 dp[i] 为前 i 个咒语的最大伤害值。
4. 对于每个咒语，选择是否使用它，并更新 dp 数组。

关键点:
- 使用排序和动态规划来优化时间和空间复杂度。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n) - 排序的时间复杂度
空间复杂度: O(n) - 动态规划数组的空间复杂度
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def maximum_total_damage(power: List[int]) -> int:
    """
    函数式接口 - 计算施咒的最大总伤害
    """
    # 对输入数组进行排序
    power.sort()
    
    # 初始化动态规划数组
    n = len(power)
    dp = [0] * (n + 1)
    
    # 动态规划计算最大伤害值
    for i in range(1, n + 1):
        # 如果当前咒语与前一个咒语相同或相邻，则不能使用
        if i > 1 and power[i - 1] == power[i - 2] + 1 or power[i - 1] == power[i - 2]:
            dp[i] = dp[i - 1]
        else:
            dp[i] = max(dp[i - 1], dp[i - 2] + power[i - 1])
    
    return dp[n]

Solution = create_solution(maximum_total_damage)