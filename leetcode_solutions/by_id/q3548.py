# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3548
标题: Find the Count of Good Integers
难度: hard
链接: https://leetcode.cn/problems/find-the-count-of-good-integers/
题目类型: 哈希表、数学、组合数学、枚举
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3272. 统计好整数的数目 - 给你两个 正 整数 n 和 k 。 如果一个整数 x 满足以下条件，那么它被称为 k 回文 整数 。 * x 是一个 回文整数 。 * x 能被 k 整除。 如果一个整数的数位重新排列后能得到一个 k 回文整数 ，那么我们称这个整数为 好 整数。比方说，k = 2 ，那么 2020 可以重新排列得到 2002 ，2002 是一个 k 回文串，所以 2020 是一个好整数。而 1010 无法重新排列数位得到一个 k 回文整数。 请你返回 n 个数位的整数中，有多少个 好 整数。 注意 ，任何整数在重新排列数位之前或者之后 都不能 有前导 0 。比方说 1010 不能重排列得到 101 。 示例 1： 输入：n = 3, k = 5 输出：27 解释： 部分好整数如下： * 551 ，因为它可以重排列得到 515 。 * 525 ，因为它已经是一个 k 回文整数。 示例 2： 输入：n = 1, k = 4 输出：2 解释： 两个好整数分别是 4 和 8 。 示例 3： 输入：n = 5, k = 6 输出：2468 提示： * 1 <= n <= 10 * 1 <= k <= 9
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划和组合数学来计算满足条件的好整数的数量。

算法步骤:
1. 初始化一个动态规划数组 dp，其中 dp[i][j] 表示长度为 i 的回文数且模 k 余 j 的数量。
2. 遍历所有可能的数字组合，更新 dp 数组。
3. 计算最终结果，即所有长度为 n 且模 k 余 0 的回文数的数量。

关键点:
- 动态规划的状态转移方程。
- 使用组合数学来处理数字的排列。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * 10 * 10 * k) = O(1000 * n * k)
空间复杂度: O(n * k)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def count_good_integers(n: int, k: int) -> int:
    """
    函数式接口 - 计算 n 个数位的整数中，有多少个好整数。
    """
    MOD = 10**9 + 7
    dp = [[[0 for _ in range(k)] for _ in range(10)] for _ in range(n + 1)]
    
    # 初始化 dp 数组
    for d in range(1, 10):
        dp[1][d][d % k] = 1
    
    # 动态规划更新 dp 数组
    for length in range(2, n + 1):
        for d1 in range(1, 10):
            for d2 in range(10):
                for mod in range(k):
                    new_mod = (mod * 10 + d2) % k
                    dp[length][d1][new_mod] += dp[length - 1][d2][mod]
                    dp[length][d1][new_mod] %= MOD
    
    # 计算最终结果
    result = sum(dp[n][d][0] for d in range(1, 10)) % MOD
    return result


Solution = create_solution(count_good_integers)