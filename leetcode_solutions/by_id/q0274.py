# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 274
标题: H-Index
难度: medium
链接: https://leetcode.cn/problems/h-index/
题目类型: 数组、计数排序、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
274. H 指数 - 给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数。计算并返回该研究者的 h 指数。 根据维基百科上 h 指数的定义 [https://baike.baidu.com/item/h-index/3991452?fr=aladdin]：h 代表“高引用次数” ，一名科研人员的 h 指数 是指他（她）至少发表了 h 篇论文，并且 至少 有 h 篇论文被引用次数大于等于 h 。如果 h 有多种可能的值，h 指数 是其中最大的那个。 示例 1： 输入：citations = [3,0,6,1,5] 输出：3 解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。 由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。 示例 2： 输入：citations = [1,3,1] 输出：1 提示： * n == citations.length * 1 <= n <= 5000 * 0 <= citations[i] <= 1000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 排序后从大到小遍历，找到最大的h使得至少有h篇论文引用>=h

算法步骤:
1. 排序数组
2. 从大到小遍历，找到最大的h

关键点:
- 排序后遍历
- 时间复杂度O(n log n)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n) - 排序
空间复杂度: O(1) - 只使用常数额外空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def h_index(citations: List[int]) -> int:
    """
    函数式接口 - H 指数
    
    实现思路:
    排序后从大到小遍历，找到最大的h。
    
    Args:
        citations: 引用次数数组
        
    Returns:
        h指数
        
    Example:
        >>> h_index([3,0,6,1,5])
        3
    """
    citations.sort(reverse=True)
    h = 0
    for i, citation in enumerate(citations):
        if citation >= i + 1:
            h = i + 1
        else:
            break
    return h


# 自动生成Solution类（无需手动编写）
Solution = create_solution(h_index)
