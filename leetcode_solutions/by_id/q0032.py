# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 32
标题: Longest Valid Parentheses
难度: hard
链接: https://leetcode.cn/problems/longest-valid-parentheses/
题目类型: 栈、字符串、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
32. 最长有效括号 - 给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号 子串 的长度。 左右括号匹配，即每个左括号都有对应的右括号将其闭合的字符串是格式正确的，比如 "(()())"。 示例 1： 输入：s = "(()" 输出：2 解释：最长有效括号子串是 "()" 示例 2： 输入：s = ")()())" 输出：4 解释：最长有效括号子串是 "()()" 示例 3： 输入：s = "" 输出：0 提示： * 0 <= s.length <= 3 * 104 * s[i] 为 '(' 或 ')'
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 动态规划，dp[i]表示以s[i]结尾的最长有效括号子串长度

算法步骤:
1. 创建dp数组，dp[i]表示以s[i]结尾的最长有效括号子串长度
2. 遍历字符串，对于每个字符：
   - 如果是'('，dp[i] = 0
   - 如果是')'：
     * 如果s[i-1] == '('，则dp[i] = dp[i-2] + 2
     * 如果s[i-1] == ')'且s[i-dp[i-1]-1] == '('，则dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2
3. 返回dp数组中的最大值

关键点:
- 动态规划可以处理嵌套和连续的有效括号
- 需要处理两种情况：()和(())
- 时间复杂度O(n)，空间复杂度O(n)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 只需遍历字符串一次，n为字符串长度
空间复杂度: O(n) - dp数组的空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from leetcode_solutions.utils.solution import create_solution


def longest_valid_parentheses(s: str) -> int:
    """
    函数式接口 - 动态规划实现
    
    实现思路:
    使用动态规划，dp[i]表示以s[i]结尾的最长有效括号子串长度。
    
    Args:
        s: 只包含'('和')'的字符串
        
    Returns:
        最长有效括号子串的长度
        
    Example:
        >>> longest_valid_parentheses("(()")
        2
        >>> longest_valid_parentheses(")()())")
        4
    """
    if not s:
        return 0
    
    n = len(s)
    dp = [0] * n
    max_len = 0
    
    for i in range(1, n):
        if s[i] == ')':
            if s[i - 1] == '(':
                # 情况1: ()
                dp[i] = (dp[i - 2] if i >= 2 else 0) + 2
            elif i - dp[i - 1] > 0 and s[i - dp[i - 1] - 1] == '(':
                # 情况2: (())
                dp[i] = dp[i - 1] + (dp[i - dp[i - 1] - 2] if i - dp[i - 1] >= 2 else 0) + 2
            max_len = max(max_len, dp[i])
    
    return max_len


# 自动生成Solution类（无需手动编写）
Solution = create_solution(longest_valid_parentheses)
