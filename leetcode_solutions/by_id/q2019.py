# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2019
标题: Product of Two Run-Length Encoded Arrays
难度: medium
链接: https://leetcode.cn/problems/product-of-two-run-length-encoded-arrays/
题目类型: 数组、双指针
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1868. 两个行程编码数组的积 - 备战技术面试？力扣提供海量技术面试资源，帮助你高效提升编程技能,轻松拿下世界 IT 名企 Dream Offer。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用双指针遍历两个行程编码数组，计算对应位置的乘积，并合并结果。

算法步骤:
1. 初始化两个指针分别指向两个行程编码数组的起始位置。
2. 遍历两个数组，计算当前指针位置的乘积，并更新结果数组。
3. 根据当前指针位置的频率，移动指针。
4. 合并结果数组，返回最终的行程编码数组。

关键点:
- 使用双指针同时遍历两个数组，确保时间复杂度为 O(n + m)。
- 合并结果时，处理相同值的连续段。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n + m)，其中 n 和 m 分别是两个行程编码数组的长度。
空间复杂度: O(1)，除了输出结果外，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def findRLEArray(encoded1: List[List[int]], encoded2: List[List[int]]) -> List[List[int]]:
    """
    函数式接口 - 计算两个行程编码数组的积
    """
    i, j = 0, 0
    result = []
    
    while i < len(encoded1) and j < len(encoded2):
        val1, freq1 = encoded1[i]
        val2, freq2 = encoded2[j]
        product = val1 * val2
        min_freq = min(freq1, freq2)
        
        if result and result[-1][0] == product:
            result[-1][1] += min_freq
        else:
            result.append([product, min_freq])
        
        if freq1 == min_freq:
            i += 1
        if freq2 == min_freq:
            j += 1
    
    return result

Solution = create_solution(findRLEArray)