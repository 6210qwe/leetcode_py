# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1243
标题: Sum of Nodes with Even-Valued Grandparent
难度: medium
链接: https://leetcode.cn/problems/sum-of-nodes-with-even-valued-grandparent/
题目类型: 树、深度优先搜索、广度优先搜索、二叉树
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1315. 祖父节点值为偶数的节点和 - 给你一棵二叉树，请你返回满足以下条件的所有节点的值之和： * 该节点的祖父节点的值为偶数。（一个节点的祖父节点是指该节点的父节点的父节点。） 如果不存在祖父节点值为偶数的节点，那么返回 0 。 示例： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/01/10/1473_ex1.png] 输入：root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5] 输出：18 解释：图中红色节点的祖父节点的值为偶数，蓝色节点为这些红色节点的祖父节点。 提示： * 树中节点的数目在 1 到 10^4 之间。 * 每个节点的值在 1 到 100 之间。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用深度优先搜索（DFS）遍历二叉树，同时记录当前节点的父节点和祖父节点的值。如果祖父节点的值为偶数，则将当前节点的值累加到结果中。

算法步骤:
1. 定义一个递归函数 `dfs`，参数包括当前节点、父节点值和祖父节点值。
2. 在 `dfs` 函数中，如果当前节点为空，则返回。
3. 如果祖父节点的值为偶数，则将当前节点的值累加到结果中。
4. 递归调用 `dfs` 函数，分别处理当前节点的左子节点和右子节点，更新父节点和祖父节点的值。

关键点:
- 使用递归进行深度优先搜索。
- 通过传递父节点和祖父节点的值来判断当前节点是否符合条件。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是二叉树的节点数。每个节点只被访问一次。
空间复杂度: O(h)，其中 h 是二叉树的高度。递归调用栈的深度最多为树的高度。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import Optional
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution

def sum_even_grandparent(root: Optional[TreeNode]) -> int:
    """
    计算祖父节点值为偶数的节点和
    """
    def dfs(node: Optional[TreeNode], parent_val: int, grandparent_val: int) -> None:
        if not node:
            return
        if grandparent_val % 2 == 0:
            nonlocal result
            result += node.val
        dfs(node.left, node.val, parent_val)
        dfs(node.right, node.val, parent_val)

    result = 0
    dfs(root, 1, 1)  # 初始时父节点和祖父节点的值设为奇数
    return result

Solution = create_solution(sum_even_grandparent)