# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2011
标题: Maximum Value after Insertion
难度: medium
链接: https://leetcode.cn/problems/maximum-value-after-insertion/
题目类型: 贪心、字符串
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1881. 插入后的最大值 - 给你一个非常大的整数 n 和一个整数数字 x ，大整数 n 用一个字符串表示。n 中每一位数字和数字 x 都处于闭区间 [1, 9] 中，且 n 可能表示一个 负数 。 你打算通过在 n 的十进制表示的任意位置插入 x 来 最大化 n 的 数值 。但 不能 在负号的左边插入 x 。 * 例如，如果 n = 73 且 x = 6 ，那么最佳方案是将 6 插入 7 和 3 之间，使 n = 763 。 * 如果 n = -55 且 x = 2 ，那么最佳方案是将 2 插在第一个 5 之前，使 n = -255 。 返回插入操作后，用字符串表示的 n 的最大值。 示例 1： 输入：n = "99", x = 9 输出："999" 解释：不管在哪里插入 9 ，结果都是相同的。 示例 2： 输入：n = "-13", x = 2 输出："-123" 解释：向 n 中插入 x 可以得到 -213、-123 或者 -132 ，三者中最大的是 -123 。 提示： * 1 <= n.length <= 105 * 1 <= x <= 9 * n 中每一位的数字都在闭区间 [1, 9] 中。 * n 代表一个有效的整数。 * 当 n 表示负数时，将会以字符 '-' 开始。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过贪心算法找到最优插入位置

算法步骤:
1. 判断 n 是否为负数。
2. 如果 n 是正数，从左到右遍历 n，找到第一个比 x 小的数字的位置，在其前面插入 x。
3. 如果 n 是负数，从左到右遍历 n，找到第一个比 x 大的数字的位置，在其前面插入 x。

关键点:
- 通过比较数字大小来确定插入位置，确保插入后数值最大。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是字符串 n 的长度，因为我们需要遍历字符串一次。
空间复杂度: O(1)，我们只需要常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(n: str, x: int) -> str:
    """
    函数式接口 - 实现最优解法
    """
    if n[0] == '-':
        # n 是负数
        for i in range(1, len(n)):
            if int(n[i]) > x:
                return n[:i] + str(x) + n[i:]
        return n + str(x)
    else:
        # n 是正数
        for i in range(len(n)):
            if int(n[i]) < x:
                return n[:i] + str(x) + n[i:]
        return n + str(x)


Solution = create_solution(solution_function_name)