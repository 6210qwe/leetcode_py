# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 15
标题: 3Sum
难度: medium
链接: https://leetcode.cn/problems/3sum/
题目类型: 数组、双指针、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
15. 三数之和 - 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例 1： 输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 解释： nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。 nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。 nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。 不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。 注意，输出的顺序和三元组的顺序并不重要。 示例 2： 输入：nums = [0,1,1] 输出：[] 解释：唯一可能的三元组和不为 0 。 示例 3： 输入：nums = [0,0,0] 输出：[[0,0,0]] 解释：唯一可能的三元组和为 0 。 提示： * 3 <= nums.length <= 3000 * -105 <= nums[i] <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 排序 + 双指针，固定第一个数，用双指针找另外两个数

算法步骤:
1. 对数组进行排序
2. 遍历数组，固定第一个数nums[i]
3. 使用双指针left和right在剩余部分寻找另外两个数：
   - 如果nums[i] + nums[left] + nums[right] == 0，添加到结果
   - 如果和小于0，left右移（增大和）
   - 如果和大于0，right左移（减小和）
4. 跳过重复元素避免重复结果
5. 返回所有不重复的三元组

关键点:
- 排序后可以使用双指针，避免三重循环
- 需要跳过重复元素，避免重复结果
- 时间复杂度O(n²)，空间复杂度O(1)（不考虑结果数组）
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n²) - 排序O(nlogn) + 双重循环O(n²)
空间复杂度: O(1) - 只使用常数额外空间（不考虑结果数组）
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from leetcode_solutions.utils.solution import create_solution


def three_sum(nums: List[int]) -> List[List[int]]:
    """
    函数式接口 - 排序 + 双指针实现
    
    实现思路:
    先排序，然后固定第一个数，使用双指针在剩余部分寻找另外两个数。
    
    Args:
        nums: 整数数组
        
    Returns:
        所有和为0且不重复的三元组列表
        
    Example:
        >>> three_sum([-1,0,1,2,-1,-4])
        [[-1, -1, 2], [-1, 0, 1]]
        >>> three_sum([0,1,1])
        []
    """
    nums.sort()
    result = []
    n = len(nums)
    
    for i in range(n - 2):
        # 跳过重复的第一个数
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        
        # 如果最小的三个数之和都大于0，后面不可能有解
        if nums[i] + nums[i + 1] + nums[i + 2] > 0:
            break
        
        # 如果当前数和最大的两个数之和都小于0，跳过当前数
        if nums[i] + nums[n - 2] + nums[n - 1] < 0:
            continue
        
        left, right = i + 1, n - 1
        while left < right:
            current_sum = nums[i] + nums[left] + nums[right]
            if current_sum == 0:
                result.append([nums[i], nums[left], nums[right]])
                # 跳过重复的left
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                # 跳过重复的right
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
            elif current_sum < 0:
                left += 1
            else:
                right -= 1
    
    return result


# 自动生成Solution类（无需手动编写）
Solution = create_solution(three_sum)
