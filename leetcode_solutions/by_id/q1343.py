# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1343
标题: Dice Roll Simulation
难度: hard
链接: https://leetcode.cn/problems/dice-roll-simulation/
题目类型: 数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1223. 掷骰子模拟 - 有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。 不过我们在使用它时有个约束，就是使得投掷骰子时，连续 掷出数字 i 的次数不能超过 rollMax[i]（i 从 1 开始编号）。 现在，给你一个整数数组 rollMax 和一个整数 n，请你来计算掷 n 次骰子可得到的不同点数序列的数量。 假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 模 10^9 + 7 之后的结果。 示例 1： 输入：n = 2, rollMax = [1,1,2,2,2,3] 输出：34 解释：我们掷 2 次骰子，如果没有约束的话，共有 6 * 6 = 36 种可能的组合。但是根据 rollMax 数组，数字 1 和 2 最多连续出现一次，所以不会出现序列 (1,1) 和 (2,2)。因此，最终答案是 36-2 = 34。 示例 2： 输入：n = 2, rollMax = [1,1,1,1,1,1] 输出：30 示例 3： 输入：n = 3, rollMax = [1,1,1,2,2,3] 输出：181 提示： * 1 <= n <= 5000 * rollMax.length == 6 * 1 <= rollMax[i] <= 15
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。定义 dp[i][j][k] 表示前 i 次投掷中，最后一次投掷的是 j，且连续投掷了 k 次的方案数。

算法步骤:
1. 初始化 dp 数组，dp[0][j][1] = 1，表示第一次投掷时，每个面都只有一种方案。
2. 通过状态转移方程更新 dp 数组：
   - 如果当前面与上一个面相同，则 dp[i][j][k] = dp[i-1][j][k-1]。
   - 如果当前面与上一个面不同，则 dp[i][j][1] = sum(dp[i-1][x][y]) for x in range(6) and y in range(1, rollMax[x]+1) and x != j。
3. 最终结果是所有 dp[n-1][j][k] 的和。

关键点:
- 使用三维数组来存储状态，减少重复计算。
- 注意取模操作，防止结果溢出。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * 6 * 15) = O(n)
空间复杂度: O(n * 6 * 15) = O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def solution_function_name(n: int, rollMax: List[int]) -> int:
    MOD = 10**9 + 7
    dp = [[[0] * (rollMax[j] + 1) for j in range(6)] for _ in range(n)]
    
    # 初始化
    for j in range(6):
        dp[0][j][1] = 1
    
    # 动态规划
    for i in range(1, n):
        for j in range(6):
            for k in range(1, rollMax[j] + 1):
                if k > 1:
                    dp[i][j][k] = dp[i-1][j][k-1]
                else:
                    dp[i][j][k] = sum(dp[i-1][x][y] for x in range(6) for y in range(1, rollMax[x] + 1) if x != j) % MOD
    
    # 计算最终结果
    result = sum(sum(dp[n-1][j]) for j in range(6)) % MOD
    return result

Solution = create_solution(solution_function_name)