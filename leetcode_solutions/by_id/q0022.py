# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 22
标题: Generate Parentheses
难度: medium
链接: https://leetcode.cn/problems/generate-parentheses/
题目类型: 字符串、动态规划、回溯
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
22. 括号生成 - 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 示例 1： 输入：n = 3 输出：["((()))","(()())","(())()","()(())","()()()"] 示例 2： 输入：n = 1 输出：["()"] 提示： * 1 <= n <= 8
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 回溯算法，在生成过程中保证左括号数量始终大于等于右括号数量

算法步骤:
1. 使用回溯函数，参数包括当前组合、左括号数量、右括号数量
2. 如果当前组合长度为2n，添加到结果
3. 如果左括号数量小于n，可以添加左括号
4. 如果右括号数量小于左括号数量，可以添加右括号
5. 递归处理两种情况，然后回溯

关键点:
- 回溯算法可以系统地生成所有有效的括号组合
- 关键约束：右括号数量不能超过左括号数量
- 时间复杂度O(4^n/√n)，空间复杂度O(n)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(4^n/√n) - 卡特兰数的数量级
空间复杂度: O(n) - 递归栈的深度为2n，当前组合长度为2n
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from leetcode_solutions.utils.solution import create_solution


def generate_parenthesis(n: int) -> List[str]:
    """
    函数式接口 - 回溯算法实现
    
    实现思路:
    使用回溯算法生成所有有效的括号组合，保证左括号数量始终大于等于右括号数量。
    
    Args:
        n: 括号对数
        
    Returns:
        所有有效的括号组合列表
        
    Example:
        >>> generate_parenthesis(3)
        ['((()))', '(()())', '(())()', '()(())', '()()()']
        >>> generate_parenthesis(1)
        ['()']
    """
    result = []
    
    def backtrack(current: str, left: int, right: int):
        # 如果当前组合长度为2n，添加到结果
        if len(current) == 2 * n:
            result.append(current)
            return
        
        # 如果左括号数量小于n，可以添加左括号
        if left < n:
            backtrack(current + '(', left + 1, right)
        
        # 如果右括号数量小于左括号数量，可以添加右括号
        if right < left:
            backtrack(current + ')', left, right + 1)
    
    backtrack("", 0, 0)
    return result


# 自动生成Solution类（无需手动编写）
Solution = create_solution(generate_parenthesis)
