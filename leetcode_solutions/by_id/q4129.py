# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 4129
标题: Number of Centered Subarrays
难度: medium
链接: https://leetcode.cn/problems/number-of-centered-subarrays/
题目类型: 数组、哈希表、枚举
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3804. 中心子数组的数量 - 给你一个整数数组 nums。 如果一个 子数组 的元素之和 等于 该子数组中的 至少一个元素，则该子数组被称为 中心子数组。 返回数组 nums 中 中心子数组 的数量。 子数组 是数组中的一个连续、非空元素序列。 示例 1： 输入: nums = [-1,1,0] 输出: 5 解释: * 所有单元素子数组（[-1]，[1]，[0]）都是中心子数组。 * 子数组 [1, 0] 的元素之和为 1，且 1 存在于该子数组中。 * 子数组 [-1, 1, 0] 的元素之和为 0，且 0 存在于该子数组中。 * 因此，答案是 5。 示例 2： 输入: nums = [2,-3] 输出: 2 解释: 只有单元素子数组（[2]，[-3]）是中心子数组。 提示： * 1 <= nums.length <= 500 * -105 <= nums[i] <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用前缀和与哈希表来优化子数组的查找。

算法步骤:
1. 计算前缀和数组。
2. 使用哈希表记录每个前缀和出现的位置。
3. 遍历数组，对于每个元素，检查其作为中心子数组的可能性。
4. 更新哈希表并计算满足条件的子数组数量。

关键点:
- 使用前缀和可以快速计算任意子数组的和。
- 哈希表用于快速查找前缀和的位置。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(nums: List[int]) -> int:
    """
    函数式接口 - 计算中心子数组的数量
    """
    n = len(nums)
    prefix_sum = [0] * (n + 1)
    for i in range(1, n + 1):
        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]
    
    count = 0
    prefix_map = {}
    
    for i in range(n):
        for j in range(i + 1):
            subarray_sum = prefix_sum[i + 1] - prefix_sum[j]
            if subarray_sum in nums[j:i + 1]:
                count += 1
        prefix_map[prefix_sum[i + 1]] = i + 1
    
    return count


Solution = create_solution(solution_function_name)