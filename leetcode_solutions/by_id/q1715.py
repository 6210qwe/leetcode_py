# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1715
标题: Split a String Into the Max Number of Unique Substrings
难度: medium
链接: https://leetcode.cn/problems/split-a-string-into-the-max-number-of-unique-substrings/
题目类型: 哈希表、字符串、回溯
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1593. 拆分字符串使唯一子字符串的数目最大 - 给你一个字符串 s ，请你拆分该字符串，并返回拆分后唯一子字符串的最大数目。 字符串 s 拆分后可以得到若干 非空子字符串 ，这些子字符串连接后应当能够还原为原字符串。但是拆分出来的每个子字符串都必须是 唯一的 。 注意：子字符串 是字符串中的一个连续字符序列。 示例 1： 输入：s = "ababccc" 输出：5 解释：一种最大拆分方法为 ['a', 'b', 'ab', 'c', 'cc'] 。像 ['a', 'b', 'a', 'b', 'c', 'cc'] 这样拆分不满足题目要求，因为其中的 'a' 和 'b' 都出现了不止一次。 示例 2： 输入：s = "aba" 输出：2 解释：一种最大拆分方法为 ['a', 'ba'] 。 示例 3： 输入：s = "aa" 输出：1 解释：无法进一步拆分字符串。 提示： * 1 <= s.length <= 16 * s 仅包含小写英文字母
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用回溯法尝试所有可能的拆分方式，并记录最大唯一子字符串的数量。

算法步骤:
1. 初始化一个集合来存储当前已使用的子字符串。
2. 使用回溯法从字符串的第一个字符开始尝试所有可能的拆分。
3. 在每次递归调用中，检查当前子字符串是否已经存在于集合中。
4. 如果不存在，则将其添加到集合中，并继续递归处理剩余的字符串。
5. 在递归返回时，移除当前子字符串并尝试其他可能的拆分。
6. 记录并返回最大唯一子字符串的数量。

关键点:
- 使用集合来存储和检查子字符串的唯一性。
- 回溯法确保所有可能的拆分都被尝试。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(2^n)，其中 n 是字符串的长度。最坏情况下，需要尝试所有可能的拆分方式。
空间复杂度: O(n)，用于存储当前已使用的子字符串集合。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def max_unique_substrings(s: str) -> int:
    def backtrack(start: int, seen: set) -> int:
        if start == len(s):
            return 0
        
        max_count = 0
        for end in range(start + 1, len(s) + 1):
            substring = s[start:end]
            if substring not in seen:
                seen.add(substring)
                max_count = max(max_count, 1 + backtrack(end, seen))
                seen.remove(substring)
        
        return max_count
    
    return backtrack(0, set())


Solution = create_solution(max_unique_substrings)