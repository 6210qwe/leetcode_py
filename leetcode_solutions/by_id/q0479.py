# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 479
标题: Largest Palindrome Product
难度: hard
链接: https://leetcode.cn/problems/largest-palindrome-product/
题目类型: 数学、枚举
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
479. 最大回文数乘积 - 给定一个整数 n ，返回 可表示为两个 n 位整数乘积的 最大回文整数 。因为答案可能非常大，所以返回它对 1337 取余 。 示例 1： 输入：n = 2 输出：987 解释：99 x 91 = 9009, 9009 % 1337 = 987 示例 2： 输入：n = 1 输出：9 提示: * 1 <= n <= 8
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 从大到小枚举回文数，检查是否能分解为两个n位数

算法步骤:
1. 从最大的回文数开始枚举
2. 检查是否能分解为两个n位数的乘积
3. 找到第一个满足条件的回文数

关键点:
- 枚举回文数
- 检查因子分解
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(10^(2n)) - 枚举回文数
空间复杂度: O(1) - 只使用常数额外空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def largest_palindrome_product(n: int) -> int:
    """
    函数式接口 - 最大回文数乘积
    
    实现思路:
    从大到小枚举回文数，检查是否能分解为两个n位数的乘积。
    
    Args:
        n: n位数
        
    Returns:
        最大回文数乘积对1337取余
        
    Example:
        >>> largest_palindrome_product(2)
        987
    """
    if n == 1:
        return 9
    
    max_num = 10 ** n - 1
    min_num = 10 ** (n - 1)
    
    # 从最大的回文数开始枚举
    for i in range(max_num, min_num - 1, -1):
        # 构造回文数
        palindrome = int(str(i) + str(i)[::-1])
        
        # 检查是否能分解为两个n位数的乘积
        for j in range(max_num, int(palindrome ** 0.5) - 1, -1):
            if palindrome % j == 0:
                quotient = palindrome // j
                if min_num <= quotient <= max_num:
                    return palindrome % 1337
    
    return 0


# 自动生成Solution类（无需手动编写）
Solution = create_solution(largest_palindrome_product)
