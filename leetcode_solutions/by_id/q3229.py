# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3229
标题: Minimum Cost to Make Array Equalindromic
难度: medium
链接: https://leetcode.cn/problems/minimum-cost-to-make-array-equalindromic/
题目类型: 贪心、数组、数学、二分查找、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2967. 使数组成为等数数组的最小代价 - 给你一个长度为 n 下标从 0 开始的整数数组 nums 。 你可以对 nums 执行特殊操作 任意次 （也可以 0 次）。每一次特殊操作中，你需要 按顺序 执行以下步骤： * 从范围 [0, n - 1] 里选择一个下标 i 和一个 正 整数 x 。 * 将 |nums[i] - x| 添加到总代价里。 * 将 nums[i] 变为 x 。 如果一个正整数正着读和反着读都相同，那么我们称这个数是 回文数 。比方说，121 ，2552 和 65756 都是回文数，但是 24 ，46 ，235 都不是回文数。 如果一个数组中的所有元素都等于一个整数 y ，且 y 是一个小于 109 的 回文数 ，那么我们称这个数组是一个 等数数组 。 请你返回一个整数，表示执行任意次特殊操作后使 nums 成为 等数数组 的 最小 总代价。 示例 1： 输入：nums = [1,2,3,4,5] 输出：6 解释：我们可以将数组中所有元素变为回文数 3 得到等数数组，数组变成 [3,3,3,3,3] 需要执行 4 次特殊操作，代价为 |1 - 3| + |2 - 3| + |4 - 3| + |5 - 3| = 6 。 将所有元素变为其他回文数的总代价都大于 6 。 示例 2： 输入：nums = [10,12,13,14,15] 输出：11 解释：我们可以将数组中所有元素变为回文数 11 得到等数数组，数组变成 [11,11,11,11,11] 需要执行 5 次特殊操作，代价为 |10 - 11| + |12 - 11| + |13 - 11| + |14 - 11| + |15 - 11| = 11 。 将所有元素变为其他回文数的总代价都大于 11 。 示例 3 ： 输入：nums = [22,33,22,33,22] 输出：22 解释：我们可以将数组中所有元素变为回文数 22 得到等数数组，数组变为 [22,22,22,22,22] 需要执行 2 次特殊操作，代价为 |33 - 22| + |33 - 22| = 22 。 将所有元素变为其他回文数的总代价都大于 22 。 提示： * 1 <= n <= 105 * 1 <= nums[i] <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用贪心算法找到最接近中位数的回文数，并计算将其变为该回文数的总代价。

算法步骤:
1. 对数组进行排序。
2. 找到中位数。
3. 找到最接近中位数的回文数。
4. 计算将所有元素变为该回文数的总代价。

关键点:
- 中位数是最优的选择，因为它最小化了绝对差的总和。
- 通过生成回文数并比较距离来找到最接近中位数的回文数。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n) - 主要由排序操作决定。
空间复杂度: O(1) - 除了输入和输出外，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def is_palindrome(x: int) -> bool:
    return str(x) == str(x)[::-1]

def next_palindrome(x: int) -> int:
    while True:
        x += 1
        if is_palindrome(x):
            return x

def prev_palindrome(x: int) -> int:
    while True:
        x -= 1
        if is_palindrome(x):
            return x

def solution_function_name(nums: List[int]) -> int:
    """
    函数式接口 - 使数组成为等数数组的最小代价
    """
    nums.sort()
    median = nums[len(nums) // 2]
    
    # 找到最接近中位数的两个回文数
    lower_palindrome = prev_palindrome(median)
    upper_palindrome = next_palindrome(median)
    
    # 计算将所有元素变为这两个回文数的总代价
    cost_lower = sum(abs(num - lower_palindrome) for num in nums)
    cost_upper = sum(abs(num - upper_palindrome) for num in nums)
    
    return min(cost_lower, cost_upper)

Solution = create_solution(solution_function_name)