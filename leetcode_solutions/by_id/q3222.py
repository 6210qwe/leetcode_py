# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3222
标题: Number of Equal Numbers Blocks
难度: medium
链接: https://leetcode.cn/problems/number-of-equal-numbers-blocks/
题目类型: 数组、二分查找、交互
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2936. 包含相等值数字块的数量 - 备战技术面试？力扣提供海量技术面试资源，帮助你高效提升编程技能,轻松拿下世界 IT 名企 Dream Offer。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用前缀和数组来快速计算每个区间的和，并使用哈希表记录每个前缀和的出现位置。

算法步骤:
1. 计算前缀和数组。
2. 使用哈希表记录每个前缀和的出现位置。
3. 遍历哈希表，计算每个前缀和对应的区间数量。

关键点:
- 前缀和数组可以快速计算任意区间的和。
- 哈希表记录每个前缀和的出现位置，方便后续计算。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def solution_function_name(nums: List[int]) -> int:
    """
    函数式接口 - 计算包含相等值数字块的数量
    """
    n = len(nums)
    prefix_sum = [0] * (n + 1)
    for i in range(1, n + 1):
        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]
    
    prefix_sum_count = {}
    for i, ps in enumerate(prefix_sum):
        if ps not in prefix_sum_count:
            prefix_sum_count[ps] = []
        prefix_sum_count[ps].append(i)
    
    count = 0
    for indices in prefix_sum_count.values():
        m = len(indices)
        count += m * (m - 1) // 2
    
    return count

Solution = create_solution(solution_function_name)