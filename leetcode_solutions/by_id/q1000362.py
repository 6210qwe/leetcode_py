# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000362
标题: 开幕式焰火
难度: easy
链接: https://leetcode.cn/problems/sZ59z6/
题目类型: 树、深度优先搜索、广度优先搜索、哈希表、二叉树
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCP 44. 开幕式焰火 - 「力扣挑战赛」开幕式开始了，空中绽放了一颗二叉树形的巨型焰火。 给定一棵二叉树 `root` 代表焰火，节点值表示巨型焰火这一位置的颜色种类。请帮小扣计算巨型焰火有多少种不同的颜色。 **示例 1：** >输入：`root = [1,3,2,1,null,2]` > >输出：`3` > >解释：焰火中有 3 个不同的颜色，值分别为 1、2、3 **示例 2：** >输入：`root = [3,3,3]` > >输出：`1` > >解释：焰火中仅出现 1 个颜色，值为 3 **提示：** - `1 <= 节点个数 <= 1000` - `1 <= Node.val <= 1000`
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: DFS遍历二叉树，使用集合统计不同颜色

算法步骤:
1. 使用DFS遍历所有节点
2. 将节点值加入集合
3. 返回集合大小

关键点:
- DFS遍历
- 使用集合去重
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 遍历所有节点
空间复杂度: O(n) - 集合空间和递归栈
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def num_color(root: Optional[TreeNode]) -> int:
    """
    函数式接口 - 开幕式焰火
    
    实现思路:
    DFS遍历二叉树，使用集合统计不同颜色。
    
    Args:
        root: 二叉树根节点
        
    Returns:
        不同颜色的数量
        
    Example:
        >>> root = TreeNode(1)
        >>> root.left = TreeNode(3)
        >>> num_color(root)
        2
    """
    colors = set()
    
    def dfs(node: Optional[TreeNode]):
        if not node:
            return
        colors.add(node.val)
        dfs(node.left)
        dfs(node.right)
    
    dfs(root)
    return len(colors)


Solution = create_solution(num_color)
