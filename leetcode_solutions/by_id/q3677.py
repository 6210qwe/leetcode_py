# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3677
标题: Maximum Amount of Money Robot Can Earn
难度: medium
链接: https://leetcode.cn/problems/maximum-amount-of-money-robot-can-earn/
题目类型: 数组、动态规划、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3418. 机器人可以获得的最大金币数 - 给你一个 m x n 的网格。一个机器人从网格的左上角 (0, 0) 出发，目标是到达网格的右下角 (m - 1, n - 1)。在任意时刻，机器人只能向右或向下移动。 网格中的每个单元格包含一个值 coins[i][j]： * 如果 coins[i][j] >= 0，机器人可以获得该单元格的金币。 * 如果 coins[i][j] < 0，机器人会遇到一个强盗，强盗会抢走该单元格数值的 绝对值 的金币。 机器人有一项特殊能力，可以在行程中 最多感化 2个单元格的强盗，从而防止这些单元格的金币被抢走。 注意：机器人的总金币数可以是负数。 返回机器人在路径上可以获得的 最大金币数 。 示例 1： 输入： coins = [[0,1,-1],[1,-2,3],[2,-3,4]] 输出： 8 解释： 一个获得最多金币的最优路径如下： 1. 从 (0, 0) 出发，初始金币为 0（总金币 = 0）。 2. 移动到 (0, 1)，获得 1 枚金币（总金币 = 0 + 1 = 1）。 3. 移动到 (1, 1)，遇到强盗抢走 2 枚金币。机器人在此处使用一次感化能力，避免被抢（总金币 = 1）。 4. 移动到 (1, 2)，获得 3 枚金币（总金币 = 1 + 3 = 4）。 5. 移动到 (2, 2)，获得 4 枚金币（总金币 = 4 + 4 = 8）。 示例 2： 输入： coins = [[10,10,10],[10,10,10]] 输出： 40 解释： 一个获得最多金币的最优路径如下： 1. 从 (0, 0) 出发，初始金币为 10（总金币 = 10）。 2. 移动到 (0, 1)，获得 10 枚金币（总金币 = 10 + 10 = 20）。 3. 移动到 (0, 2)，再获得 10 枚金币（总金币 = 20 + 10 = 30）。 4. 移动到 (1, 2)，获得 10 枚金币（总金币 = 30 + 10 = 40）。 提示： * m == coins.length * n == coins[i].length * 1 <= m, n <= 500 * -1000 <= coins[i][j] <= 1000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用三维动态规划来记录在每个位置 (i, j) 时，剩余 k 次感化能力的最大金币数。

算法步骤:
1. 初始化一个三维 DP 表 dp[i][j][k]，表示在位置 (i, j) 且剩余 k 次感化能力时的最大金币数。
2. 填充 DP 表，考虑从左边和上边转移过来的情况，并根据当前单元格的金币数更新 DP 表。
3. 返回 dp[m-1][n-1][2] 作为结果。

关键点:
- 三维 DP 表的初始化和状态转移方程。
- 处理边界情况，确保不会越界。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m * n * 3) = O(m * n)
空间复杂度: O(m * n * 3) = O(m * n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(coins: List[List[int]]) -> int:
    """
    函数式接口 - 实现最优解法
    """
    m, n = len(coins), len(coins[0])
    dp = [[[float('-inf')] * 3 for _ in range(n)] for _ in range(m)]
    
    # 初始化起点
    dp[0][0][2] = coins[0][0]
    
    for i in range(m):
        for j in range(n):
            for k in range(3):
                if i > 0:
                    dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k] + coins[i][j])
                if j > 0:
                    dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k] + coins[i][j])
                if k > 0 and coins[i][j] < 0:
                    if i > 0:
                        dp[i][j][k-1] = max(dp[i][j][k-1], dp[i-1][j][k])
                    if j > 0:
                        dp[i][j][k-1] = max(dp[i][j][k-1], dp[i][j-1][k])
    
    return max(dp[m-1][n-1])


Solution = create_solution(solution_function_name)