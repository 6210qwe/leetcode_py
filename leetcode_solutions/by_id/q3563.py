# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3563
标题: Select Cells in Grid With Maximum Score
难度: hard
链接: https://leetcode.cn/problems/select-cells-in-grid-with-maximum-score/
题目类型: 位运算、数组、动态规划、状态压缩、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3276. 选择矩阵中单元格的最大得分 - 给你一个由正整数构成的二维矩阵 grid。 你需要从矩阵中选择 一个或多个 单元格，选中的单元格应满足以下条件： * 所选单元格中的任意两个单元格都不会处于矩阵的 同一行。 * 所选单元格的值 互不相同。 你的得分为所选单元格值的总和。 返回你能获得的 最大 得分。 示例 1： 输入： grid = [[1,2,3],[4,3,2],[1,1,1]] 输出： 8 解释： [https://assets.leetcode.com/uploads/2024/07/29/grid1drawio.png] 选择上图中用彩色标记的单元格，对应的值分别为 1、3 和 4 。 示例 2： 输入： grid = [[8,7,6],[8,3,2]] 输出： 15 解释： [https://assets.leetcode.com/uploads/2024/07/29/grid8_8drawio.png] 选择上图中用彩色标记的单元格，对应的值分别为 7 和 8 。 提示： * 1 <= grid.length, grid[i].length <= 10 * 1 <= grid[i][j] <= 100
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划和状态压缩来解决这个问题。我们使用一个二进制掩码来表示每一行的状态，并使用动态规划来记录每种状态下的最大得分。

算法步骤:
1. 初始化动态规划数组 dp，其中 dp[mask] 表示当前状态为 mask 时的最大得分。
2. 遍历每一行，对于每一行的所有可能状态，计算其得分并更新 dp 数组。
3. 最终返回 dp 数组中的最大值。

关键点:
- 使用二进制掩码来表示每一行的状态。
- 动态规划数组 dp 用于记录每种状态下的最大得分。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(2^n * m)，其中 n 是列数，m 是行数。因为每一行有 2^n 种状态，需要遍历 m 行。
空间复杂度: O(2^n)，因为我们需要存储每种状态的最大得分。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def max_sum(grid: List[List[int]]) -> int:
    """
    函数式接口 - 计算矩阵中单元格的最大得分
    """
    m, n = len(grid), len(grid[0])
    max_val = max(max(row) for row in grid)
    dp = [-float('inf')] * (1 << n)
    dp[0] = 0
    
    for row in grid:
        new_dp = [-float('inf')] * (1 << n)
        for mask in range(1 << n):
            if dp[mask] == -float('inf'):
                continue
            for j in range(n):
                if mask & (1 << j) == 0 and row[j] > 0:
                    new_mask = mask | (1 << j)
                    new_dp[new_mask] = max(new_dp[new_mask], dp[mask] + row[j])
        dp = new_dp
    
    return max(dp)

Solution = create_solution(max_sum)