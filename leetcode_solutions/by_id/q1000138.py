# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000138
标题: 古董键盘
难度: hard
链接: https://leetcode.cn/problems/Uh984O/
题目类型: 数学、动态规划、组合数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCP 25. 古董键盘 - 小扣在秋日市集购买了一个古董键盘。由于古董键盘年久失修，键盘上只有 26 个字母 **a~z** 可以按下，且每个字母最多仅能被按 `k` 次。 小扣随机按了 `n` 次按键，请返回小扣总共有可能按出多少种内容。由于数字较大，最终答案需要对 1000000007 (1e9 + 7) 取模。 **示例 1：** >输入：`k = 1, n = 1` > >输出：`26` > >解释：由于只能按一次按键，所有可能的字符串为 "a", "b", ... "z" **示例 2：** >输入：`k = 1, n = 2` > >输出：`650` > >解释：由于只能按两次按键，且每个键最多只能按一次，所有可能的字符串（按字典序排序）为 "ab", "ac", ... "zy" **提示：** - `1 <= k <= 5` - `1 <= n <= 26*k`
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划和组合数学来解决这个问题。

算法步骤:
1. 定义一个二维数组 dp[i][j] 表示使用前 i 个字母，按 j 次按键的方案数。
2. 初始化 dp[0][0] = 1，表示不使用任何字母，按 0 次按键的方案数为 1。
3. 对于每个字母 i 和每次按键 j，更新 dp[i][j] 的值。
4. 最终结果是 dp[26][n]。

关键点:
- 使用组合数学中的组合公式 C(n, k) 来计算从 n 个元素中选 k 个元素的方案数。
- 通过预处理组合数来优化计算。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(26 * n * k)
空间复杂度: O(26 * n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution

MOD = 1000000007

def solution_function_name(k: int, n: int) -> int:
    """
    函数式接口 - 计算使用 k 次按键按 n 次的方案数
    """
    # 预处理组合数
    def precompute_combinations(max_n: int) -> List[List[int]]:
        comb = [[0] * (max_n + 1) for _ in range(max_n + 1)]
        for i in range(max_n + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        return comb

    # 动态规划
    def dp(k: int, n: int) -> int:
        max_n = 26 * k
        comb = precompute_combinations(max_n)
        dp = [[0] * (n + 1) for _ in range(27)]
        dp[0][0] = 1

        for i in range(1, 27):
            for j in range(n + 1):
                for l in range(min(j, k) + 1):
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - l] * comb[j][l]) % MOD

        return dp[26][n]

    return dp(k, n)

Solution = create_solution(solution_function_name)