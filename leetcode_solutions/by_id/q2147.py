# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2147
标题: The Score of Students Solving Math Expression
难度: hard
链接: https://leetcode.cn/problems/the-score-of-students-solving-math-expression/
题目类型: 栈、记忆化搜索、数组、哈希表、数学、字符串、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2019. 解出数学表达式的学生分数 - 给你一个字符串 s ，它 只 包含数字 0-9 ，加法运算符 '+' 和乘法运算符 '*' ，这个字符串表示一个 合法 的只含有 个位数数字 的数学表达式（比方说 3+5*2）。有 n 位小学生将计算这个数学表达式，并遵循如下 运算顺序 ： 1. 按照 从左到右 的顺序计算 乘法 ，然后 2. 按照 从左到右 的顺序计算 加法 。 给你一个长度为 n 的整数数组 answers ，表示每位学生提交的答案。你的任务是给 answer 数组按照如下 规则 打分： * 如果一位学生的答案 等于 表达式的正确结果，这位学生将得到 5 分。 * 否则，如果答案由 一处或多处错误的运算顺序 计算得到，那么这位学生能得到 2 分。 * 否则，这位学生将得到 0 分。 请你返回所有学生的分数和。 示例 1： [https://assets.leetcode.com/uploads/2021/09/17/student_solving_math.png] 输入：s = "7+3*1*2", answers = [20,13,42] 输出：7 解释：如上图所示，正确答案为 13 ，因此有一位学生得分为 5 分：[20,13,42] 。 一位学生可能通过错误的运算顺序得到结果 20 ：7+3=10，10*1=10，10*2=20 。所以这位学生得分为 2 分：[20,13,42] 。 所有学生得分分别为：[2,5,0] 。所有得分之和为 2+5+0=7 。 示例 2： 输入：s = "3+5*2", answers = [13,0,10,13,13,16,16] 输出：19 解释：表达式的正确结果为 13 ，所以有 3 位学生得到 5 分：[13,0,10,13,13,16,16] 。 学生可能通过错误的运算顺序得到结果 16 ：3+5=8，8*2=16 。所以两位学生得到 2 分：[13,0,10,13,13,16,16] 。 所有学生得分分别为：[5,0,0,5,5,2,2] 。所有得分之和为 5+0+0+5+5+2+2=19 。 示例 3： 输入：s = "6+0*1", answers = [12,9,6,4,8,6] 输出：10 解释：表达式的正确结果为 6 。 如果一位学生通过错误的运算顺序计算该表达式，结果仍为 6 。 根据打分规则，运算顺序错误的学生也将得到 5 分（因为他们仍然得到了正确的结果），而不是 2 分。 所有学生得分分别为：[0,0,5,0,0,5] 。所有得分之和为 10 分。 提示： * 3 <= s.length <= 31 * s 表示一个只包含 0-9 ，'+' 和 '*' 的合法表达式。 * 表达式中所有整数运算数字都在闭区间 [0, 9] 以内。 * 1 <= 数学表达式中所有运算符数目（'+' 和 '*'） <= 15 * 测试数据保证正确表达式结果在范围 [0, 1000] 以内。 * 测试用例保证乘法中间步骤中的值永远不会超过 109。 * n == answers.length * 1 <= n <= 104 * 0 <= answers[i] <= 1000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用记忆化搜索来计算所有可能的结果，并使用集合来存储这些结果。然后根据学生的答案进行评分。

算法步骤:
1. 定义一个记忆化搜索函数 `dp`，用于计算表达式的所有可能结果。
2. 在 `dp` 函数中，递归地计算子表达式的可能结果，并根据运算符进行组合。
3. 使用集合存储所有可能的结果。
4. 计算表达式的正确结果。
5. 遍历学生的答案，根据评分规则进行评分并累加总分。

关键点:
- 使用记忆化搜索避免重复计算。
- 使用集合存储所有可能的结果，以便快速查找。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^3)，其中 n 是表达式的长度。记忆化搜索的时间复杂度为 O(n^3)。
空间复杂度: O(n^3)，记忆化搜索的空间复杂度为 O(n^3)。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution

def score_of_students(s: str, answers: List[int]) -> int:
    def dp(lo: int, hi: int) -> set:
        if (lo, hi) in memo:
            return memo[(lo, hi)]
        if lo == hi:
            return {int(s[lo])}
        
        res = set()
        for mid in range(lo + 1, hi, 2):
            left = dp(lo, mid - 1)
            right = dp(mid + 1, hi)
            for l in left:
                for r in right:
                    if s[mid] == '+':
                        res.add(l + r)
                    elif s[mid] == '*':
                        res.add(l * r)
        
        memo[(lo, hi)] = res
        return res
    
    # 计算表达式的正确结果
    correct_result = eval(s)
    
    # 使用记忆化搜索计算所有可能的结果
    memo = {}
    possible_results = dp(0, len(s) - 1)
    
    # 计算总分
    total_score = 0
    for ans in answers:
        if ans == correct_result:
            total_score += 5
        elif ans in possible_results:
            total_score += 2
    
    return total_score

Solution = create_solution(score_of_students)