# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1466
标题: Jump Game V
难度: hard
链接: https://leetcode.cn/problems/jump-game-v/
题目类型: 数组、动态规划、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1340. 跳跃游戏 V - 给你一个整数数组 arr 和一个整数 d 。每一步你可以从下标 i 跳到： * i + x ，其中 i + x < arr.length 且 0 < x <= d 。 * i - x ，其中 i - x >= 0 且 0 < x <= d 。 除此以外，你从下标 i 跳到下标 j 需要满足：arr[i] > arr[j] 且 arr[i] > arr[k] ，其中下标 k 是所有 i 到 j 之间的数字（更正式的，min(i, j) < k < max(i, j)）。 你可以选择数组的任意下标开始跳跃。请你返回你 最多 可以访问多少个下标。 请注意，任何时刻你都不能跳到数组的外面。 示例 1： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/02/02/meta-chart.jpeg] 输入：arr = [6,4,14,6,8,13,9,7,10,6,12], d = 2 输出：4 解释：你可以从下标 10 出发，然后如上图依次经过 10 --> 8 --> 6 --> 7 。 注意，如果你从下标 6 开始，你只能跳到下标 7 处。你不能跳到下标 5 处因为 13 > 9 。你也不能跳到下标 4 处，因为下标 5 在下标 4 和 6 之间且 13 > 9 。 类似的，你不能从下标 3 处跳到下标 2 或者下标 1 处。 示例 2： 输入：arr = [3,3,3,3,3], d = 3 输出：1 解释：你可以从任意下标处开始且你永远无法跳到任何其他坐标。 示例 3： 输入：arr = [7,6,5,4,3,2,1], d = 1 输出：7 解释：从下标 0 处开始，你可以按照数值从大到小，访问所有的下标。 示例 4： 输入：arr = [7,1,7,1,7,1], d = 2 输出：2 示例 5： 输入：arr = [66], d = 1 输出：1 提示： * 1 <= arr.length <= 1000 * 1 <= arr[i] <= 10^5 * 1 <= d <= arr.length
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划和记忆化搜索来解决这个问题。

算法步骤:
1. 对数组进行排序，按值从小到大处理每个元素。
2. 使用一个字典 `dp` 来存储每个下标的最大跳跃步数。
3. 对于每个下标 `i`，尝试向左和向右跳跃，更新 `dp[i]` 的值。
4. 返回 `dp` 中的最大值。

关键点:
- 使用记忆化搜索避免重复计算。
- 通过排序确保每次处理的元素都是当前最小的。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是数组长度。排序的时间复杂度是 O(n log n)，而后续的遍历和更新操作是 O(n)。
空间复杂度: O(n)，用于存储 `dp` 字典和排序后的索引。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def maxJumps(arr: List[int], d: int) -> int:
    def dfs(i: int) -> int:
        if dp[i] != -1:
            return dp[i]
        
        max_jumps = 1
        for di in [-1, 1]:
            for j in range(1, d + 1):
                ni = i + di * j
                if not (0 <= ni < n) or arr[ni] >= arr[i]:
                    break
                max_jumps = max(max_jumps, 1 + dfs(ni))
        
        dp[i] = max_jumps
        return max_jumps
    
    n = len(arr)
    dp = [-1] * n
    indices = sorted(range(n), key=lambda i: arr[i])
    
    for i in indices:
        dfs(i)
    
    return max(dp)

Solution = create_solution(maxJumps)