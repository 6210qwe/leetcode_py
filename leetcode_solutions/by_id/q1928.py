# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1928
标题: Number of Orders in the Backlog
难度: medium
链接: https://leetcode.cn/problems/number-of-orders-in-the-backlog/
题目类型: 数组、模拟、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1801. 积压订单中的订单总数 - 给你一个二维整数数组 orders ，其中每个 orders[i] = [pricei, amounti, orderTypei] 表示有 amounti 笔类型为 orderTypei 、价格为 pricei 的订单。 订单类型 orderTypei 可以分为两种： * 0 表示这是一批采购订单 buy * 1 表示这是一批销售订单 sell 注意，orders[i] 表示一批共计 amounti 笔的独立订单，这些订单的价格和类型相同。对于所有有效的 i ，由 orders[i] 表示的所有订单提交时间均早于 orders[i+1] 表示的所有订单。 存在由未执行订单组成的 积压订单 。积压订单最初是空的。提交订单时，会发生以下情况： * 如果该订单是一笔采购订单 buy ，则可以查看积压订单中价格 最低 的销售订单 sell 。如果该销售订单 sell 的价格 低于或等于 当前采购订单 buy 的价格，则匹配并执行这两笔订单，并将销售订单 sell 从积压订单中删除。否则，采购订单 buy 将会添加到积压订单中。 * 反之亦然，如果该订单是一笔销售订单 sell ，则可以查看积压订单中价格 最高 的采购订单 buy 。如果该采购订单 buy 的价格 高于或等于 当前销售订单 sell 的价格，则匹配并执行这两笔订单，并将采购订单 buy 从积压订单中删除。否则，销售订单 sell 将会添加到积压订单中。 输入所有订单后，返回积压订单中的 订单总数 。由于数字可能很大，所以需要返回对 109 + 7 取余的结果。 示例 1： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2021/03/21/ex1.png] 输入：orders = [[10,5,0],[15,2,1],[25,1,1],[30,4,0]] 输出：6 解释：输入订单后会发生下述情况： - 提交 5 笔采购订单，价格为 10 。没有销售订单，所以这 5 笔订单添加到积压订单中。 - 提交 2 笔销售订单，价格为 15 。没有采购订单的价格大于或等于 15 ，所以这 2 笔订单添加到积压订单中。 - 提交 1 笔销售订单，价格为 25 。没有采购订单的价格大于或等于 25 ，所以这 1 笔订单添加到积压订单中。 - 提交 4 笔采购订单，价格为 30 。前 2 笔采购订单与价格最低（价格为 15）的 2 笔销售订单匹配，从积压订单中删除这 2 笔销售订单。第 3 笔采购订单与价格最低的 1 笔销售订单匹配，销售订单价格为 25 ，从积压订单中删除这 1 笔销售订单。积压订单中不存在更多销售订单，所以第 4 笔采购订单需要添加到积压订单中。 最终，积压订单中有 5 笔价格为 10 的采购订单，和 1 笔价格为 30 的采购订单。所以积压订单中的订单总数为 6 。 示例 2： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2021/03/21/ex2.png] 输入：orders = [[7,1000000000,1],[15,3,0],[5,999999995,0],[5,1,1]] 输出：999999984 解释：输入订单后会发生下述情况： - 提交 109 笔销售订单，价格为 7 。没有采购订单，所以这 109 笔订单添加到积压订单中。 - 提交 3 笔采购订单，价格为 15 。这些采购订单与价格最低（价格为 7 ）的 3 笔销售订单匹配，从积压订单中删除这 3 笔销售订单。 - 提交 999999995 笔采购订单，价格为 5 。销售订单的最低价为 7 ，所以这 999999995 笔订单添加到积压订单中。 - 提交 1 笔销售订单，价格为 5 。这笔销售订单与价格最高（价格为 5 ）的 1 笔采购订单匹配，从积压订单中删除这 1 笔采购订单。 最终，积压订单中有 (1000000000-3) 笔价格为 7 的销售订单，和 (999999995-1) 笔价格为 5 的采购订单。所以积压订单中的订单总数为 1999999991 ，等于 999999984 % (109 + 7) 。 提示： * 1 <= orders.length <= 105 * orders[i].length == 3 * 1 <= pricei, amounti <= 109 * orderTypei 为 0 或 1
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想:
- 使用两个堆（优先队列）分别存储采购订单和销售订单。
- 对于每笔订单，根据其类型进行处理：
  - 采购订单：尝试与积压订单中价格最低的销售订单匹配。
  - 销售订单：尝试与积压订单中价格最高的采购订单匹配。
- 无法匹配的订单加入积压订单。
- 最后计算积压订单中的订单总数。

算法步骤:
1. 初始化两个堆：`buy_heap` 和 `sell_heap`，分别用于存储采购订单和销售订单。
2. 遍历所有订单：
   - 对于采购订单，尝试与 `sell_heap` 中价格最低的销售订单匹配。
   - 对于销售订单，尝试与 `buy_heap` 中价格最高的采购订单匹配。
   - 无法匹配的订单加入相应的堆。
3. 计算积压订单中的订单总数。

关键点:
- 使用 Python 的 `heapq` 模块来实现堆。
- 通过负数来实现最大堆。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是订单的数量。每次插入和弹出堆的操作时间复杂度为 O(log n)。
空间复杂度: O(n)，最坏情况下所有订单都进入积压订单。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def getNumberOfBacklogOrders(orders: List[List[int]]) -> int:
    MOD = 10**9 + 7
    buy_heap = []  # 最大堆，存储采购订单
    sell_heap = []  # 最小堆，存储销售订单
    
    for price, amount, order_type in orders:
        if order_type == 0:  # 采购订单
            while amount > 0 and sell_heap and sell_heap[0][0] <= price:
                sell_price, sell_amount = heapq.heappop(sell_heap)
                match_amount = min(amount, sell_amount)
                amount -= match_amount
                sell_amount -= match_amount
                if sell_amount > 0:
                    heapq.heappush(sell_heap, (sell_price, sell_amount))
            if amount > 0:
                heapq.heappush(buy_heap, (-price, amount))
        else:  # 销售订单
            while amount > 0 and buy_heap and -buy_heap[0][0] >= price:
                buy_price, buy_amount = heapq.heappop(buy_heap)
                match_amount = min(amount, buy_amount)
                amount -= match_amount
                buy_amount -= match_amount
                if buy_amount > 0:
                    heapq.heappush(buy_heap, (buy_price, buy_amount))
            if amount > 0:
                heapq.heappush(sell_heap, (price, amount))
    
    total_orders = sum(amount for _, amount in buy_heap + sell_heap) % MOD
    return total_orders

Solution = create_solution(getNumberOfBacklogOrders)