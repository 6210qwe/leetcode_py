# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1814
标题: Jump Game VI
难度: medium
链接: https://leetcode.cn/problems/jump-game-vi/
题目类型: 队列、数组、动态规划、单调队列、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1696. 跳跃游戏 VI - 给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。 一开始你在下标 0 处。每一步，你最多可以往前跳 k 步，但你不能跳出数组的边界。也就是说，你可以从下标 i 跳到 [i + 1， min(n - 1, i + k)] 包含 两个端点的任意位置。 你的目标是到达数组最后一个位置（下标为 n - 1 ），你的 得分 为经过的所有数字之和。 请你返回你能得到的 最大得分 。 示例 1： 输入：nums = [1,-1,-2,4,-7,3], k = 2 输出：7 解释：你可以选择子序列 [1,-1,4,3] （上面加粗的数字），和为 7 。 示例 2： 输入：nums = [10,-5,-2,4,0,3], k = 3 输出：17 解释：你可以选择子序列 [10,4,3] （上面加粗数字），和为 17 。 示例 3： 输入：nums = [1,-5,-20,4,-1,3,-6,-3], k = 2 输出：0 提示： * 1 <= nums.length, k <= 105 * -104 <= nums[i] <= 104
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用单调队列来维护当前窗口内的最大值，从而在 O(n) 时间复杂度内解决问题。

算法步骤:
1. 初始化一个双端队列 `deque` 来存储索引。
2. 遍历数组 `nums`，对于每个元素：
   - 移除队列中所有不在当前窗口范围内的索引。
   - 计算当前元素的最大得分，并更新 `dp` 数组。
   - 将当前索引加入队列，并移除队列中所有比当前元素小的索引。
3. 返回 `dp` 数组的最后一个元素作为结果。

关键点:
- 使用单调队列来维护当前窗口内的最大值。
- 动态规划数组 `dp` 用于存储到达每个位置的最大得分。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from collections import deque

def max_result(nums: List[int], k: int) -> int:
    n = len(nums)
    dp = [0] * n
    dp[0] = nums[0]
    deque = deque([0])

    for i in range(1, n):
        # 移除队列中所有不在当前窗口范围内的索引
        while deque and deque[0] < i - k:
            deque.popleft()

        # 计算当前元素的最大得分
        dp[i] = nums[i] + dp[deque[0]]

        # 将当前索引加入队列，并移除队列中所有比当前元素小的索引
        while deque and dp[i] >= dp[deque[-1]]:
            deque.pop()
        deque.append(i)

    return dp[-1]

Solution = create_solution(max_result)