# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000133
标题: 快速公交
难度: hard
链接: https://leetcode.cn/problems/meChtZ/
题目类型: 记忆化搜索、数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCP 20. 快速公交 - 小扣打算去秋日市集，由于游客较多，小扣的移动速度受到了人流影响： - 小扣从 `x` 号站点移动至 `x + 1` 号站点需要花费的时间为 `inc`； - 小扣从 `x` 号站点移动至 `x - 1` 号站点需要花费的时间为 `dec`。 现有 `m` 辆公交车，编号为 `0` 到 `m-1`。小扣也可以通过搭乘编号为 `i` 的公交车，从 `x` 号站点移动至 `jump[i]*x` 号站点，耗时仅为 `cost[i]`。小扣可以搭乘任意编号的公交车且搭乘公交次数不限。 假定小扣起始站点记作 `0`，秋日市集站点记作 `target`，请返回小扣抵达秋日市集最少需要花费多少时间。由于数字较大，最终答案需要对 1000000007 (1e9 + 7) 取模。 注意：小扣可在移动过程中到达编号大于 `target` 的站点。 **示例 1：** >输入：`target = 31, inc = 5, dec = 3, jump = [6], cost = [10]` > >输出：`33` > >解释： >小扣步行至 1 号站点，花费时间为 5； >小扣从 1 号站台搭乘 0 号公交至 6 * 1 = 6 站台，花费时间为 10； >小扣从 6 号站台步行至 5 号站台，花费时间为 3； >小扣从 5 号站台搭乘 0 号公交至 6 * 5 = 30 站台，花费时间为 10； >小扣从 30 号站台步行至 31 号站台，花费时间为 5； >最终小扣花费总时间为 33。 **示例 2：** >输入：`target = 612, inc = 4, dec = 5, jump = [3,6,8,11,5,10,4], cost = [4,7,6,3,7,6,4]` > >输出：`26` > >解释： >小扣步行至 1 号站点，花费时间为 4； >小扣从 1 号站台搭乘 0 号公交至 3 * 1 = 3 站台，花费时间为 4； >小扣从 3 号站台搭乘 3 号公交至 11 * 3 = 33 站台，花费时间为 3； >小扣从 33 号站台步行至 34 站台，花费时间为 4； >小扣从 34 号站台搭乘 0 号公交至 3 * 34 = 102 站台，花费时间为 4； >小扣从 102 号站台搭乘 1 号公交至 6 * 102 = 612 站台，花费时间为 7； >最终小扣花费总时间为 26。 **提示：** - `1 <= target <= 10^9` - `1 <= jump.length, cost.length <= 10` - `2 <= jump[i] <= 10^6` - `1 <= inc, dec, cost[i] <= 10^6`
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用记忆化搜索（带缓存的递归）来解决这个问题。我们需要找到从起点到目标站点的最短路径。每个站点都可以选择步行或搭乘公交车，我们通过递归计算每种选择的最小花费，并使用缓存来避免重复计算。

算法步骤:
1. 定义一个递归函数 `dfs(target)`，表示从当前站点到目标站点的最小花费。
2. 如果 `target` 已经在缓存中，直接返回缓存的结果。
3. 如果 `target` 为 0，返回 0。
4. 初始化最小花费为 `target * inc`，即全部步行的情况。
5. 对于每个公交车，计算从当前站点到目标站点的最小花费：
   - 如果 `target % jump[i] == 0`，可以选择直接搭乘公交车。
   - 否则，可以选择步行到 `target - target % jump[i]` 或 `target - target % jump[i] + jump[i]`，再搭乘公交车。
6. 更新最小花费并将其存入缓存。
7. 返回最小花费并对 1000000007 取模。

关键点:
- 使用缓存来避免重复计算。
- 考虑所有可能的步行和搭乘公交车的情况。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m * log(target))，其中 m 是公交车的数量。每次递归调用最多会减少一半的目标值。
空间复杂度: O(log(target))，递归调用栈的深度。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from functools import lru_cache

def bus_rapid_transit(target: int, inc: int, dec: int, jump: List[int], cost: List[int]) -> int:
    @lru_cache(maxsize=None)
    def dfs(t: int) -> int:
        if t == 0:
            return 0
        min_cost = t * inc
        for i in range(len(jump)):
            if t % jump[i] == 0:
                min_cost = min(min_cost, dfs(t // jump[i]) + cost[i])
            else:
                min_cost = min(min_cost, dfs(t - t % jump[i]) + cost[i] + (t % jump[i]) * inc)
                min_cost = min(min_cost, dfs((t - t % jump[i]) + jump[i]) + cost[i] + (jump[i] - t % jump[i]) * dec)
        return min_cost
    
    return dfs(target) % 1000000007

Solution = create_solution(bus_rapid_transit)