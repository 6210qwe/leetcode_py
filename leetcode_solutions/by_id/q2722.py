# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2722
标题: Prime In Diagonal
难度: easy
链接: https://leetcode.cn/problems/prime-in-diagonal/
题目类型: 数组、数学、矩阵、数论
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2614. 对角线上的质数 - 给你一个下标从 0 开始的二维整数数组 nums 。 返回位于 nums 至少一条 对角线 上的最大 质数 。如果任一对角线上均不存在质数，返回 0 。 注意： * 如果某个整数大于 1 ，且不存在除 1 和自身之外的正整数因子，则认为该整数是一个质数。 * 如果存在整数 i ，使得 nums[i][i] = val 或者 nums[i][nums.length - i - 1]= val ，则认为整数 val 位于 nums 的一条对角线上。 [https://assets.leetcode.com/uploads/2023/03/06/screenshot-2023-03-06-at-45648-pm.png] 在上图中，一条对角线是 [1,5,9] ，而另一条对角线是 [3,5,7] 。 示例 1： 输入：nums = [[1,2,3],[5,6,7],[9,10,11]] 输出：11 解释：数字 1、3、6、9 和 11 是所有 "位于至少一条对角线上" 的数字。由于 11 是最大的质数，故返回 11 。 示例 2： 输入：nums = [[1,2,3],[5,17,7],[9,11,10]] 输出：17 解释：数字 1、3、9、10 和 17 是所有满足"位于至少一条对角线上"的数字。由于 17 是最大的质数，故返回 17 。 提示： * 1 <= nums.length <= 300 * nums.length == numsi.length * 1 <= nums[i][j] <= 4*106
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 
1. 遍历两条对角线上的所有元素。
2. 检查每个元素是否为质数。
3. 找到最大质数并返回。

算法步骤:
1. 定义一个函数 `is_prime` 来检查一个数是否为质数。
2. 初始化一个变量 `max_prime` 为 0，用于存储找到的最大质数。
3. 遍历主对角线和副对角线上的所有元素。
4. 对于每个元素，使用 `is_prime` 函数检查其是否为质数。
5. 如果是质数且大于当前 `max_prime`，更新 `max_prime`。
6. 返回 `max_prime`。

关键点:
- 使用高效的质数检测方法。
- 遍历对角线时避免重复计算。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * sqrt(m))，其中 n 是矩阵的边长，m 是矩阵中的最大值。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def is_prime(num: int) -> bool:
    """检查一个数是否为质数"""
    if num < 2:
        return False
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True

def solution_function_name(nums: List[List[int]]) -> int:
    """
    函数式接口 - 返回位于 nums 至少一条对角线上的最大质数
    """
    max_prime = 0
    n = len(nums)
    
    # 遍历主对角线
    for i in range(n):
        if is_prime(nums[i][i]):
            max_prime = max(max_prime, nums[i][i])
    
    # 遍历副对角线
    for i in range(n):
        if is_prime(nums[i][n - i - 1]):
            max_prime = max(max_prime, nums[i][n - i - 1])
    
    return max_prime

Solution = create_solution(solution_function_name)