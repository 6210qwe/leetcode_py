# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1999
标题: Longer Contiguous Segments of Ones than Zeros
难度: easy
链接: https://leetcode.cn/problems/longer-contiguous-segments-of-ones-than-zeros/
题目类型: 字符串
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1869. 哪种连续子字符串更长 - 给你一个二进制字符串 s 。如果字符串中由 1 组成的 最长 连续子字符串 严格长于 由 0 组成的 最长 连续子字符串，返回 true ；否则，返回 false 。 * 例如，s = "110100010" 中，由 1 组成的最长连续子字符串的长度是 2 ，由 0 组成的最长连续子字符串的长度是 3 。 注意，如果字符串中不存在 0 ，此时认为由 0 组成的最长连续子字符串的长度是 0 。字符串中不存在 1 的情况也适用此规则。 示例 1： 输入：s = "1101" 输出：true 解释： 由 1 组成的最长连续子字符串的长度是 2："1101" 由 0 组成的最长连续子字符串的长度是 1："1101" 由 1 组成的子字符串更长，故返回 true 。 示例 2： 输入：s = "111000" 输出：false 解释： 由 1 组成的最长连续子字符串的长度是 3："111000" 由 0 组成的最长连续子字符串的长度是 3："111000" 由 1 组成的子字符串不比由 0 组成的子字符串长，故返回 false 。 示例 3： 输入：s = "110100010" 输出：false 解释： 由 1 组成的最长连续子字符串的长度是 2："110100010" 由 0 组成的最长连续子字符串的长度是 3："110100010" 由 1 组成的子字符串不比由 0 组成的子字符串长，故返回 false 。 提示： * 1 <= s.length <= 100 * s[i] 不是 '0' 就是 '1'
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过一次遍历字符串，记录当前连续的 1 和 0 的长度，并更新最大长度。

算法步骤:
1. 初始化两个变量 `max_ones` 和 `max_zeros` 分别记录 1 和 0 的最长连续子字符串的长度。
2. 初始化两个变量 `current_ones` 和 `current_zeros` 分别记录当前连续的 1 和 0 的长度。
3. 遍历字符串：
   - 如果当前字符是 '1'，则增加 `current_ones` 并重置 `current_zeros`。
   - 如果当前字符是 '0'，则增加 `current_zeros` 并重置 `current_ones`。
   - 更新 `max_ones` 和 `max_zeros`。
4. 比较 `max_ones` 和 `max_zeros`，返回 `max_ones > max_zeros`。

关键点:
- 通过一次遍历字符串来记录最长的连续 1 和 0 的长度。
- 使用四个变量来分别记录当前和最大长度。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是字符串 s 的长度。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(s: str) -> bool:
    """
    函数式接口 - 判断字符串 s 中由 1 组成的最长连续子字符串是否严格长于由 0 组成的最长连续子字符串。
    """
    max_ones = 0
    max_zeros = 0
    current_ones = 0
    current_zeros = 0

    for char in s:
        if char == '1':
            current_ones += 1
            current_zeros = 0
        else:
            current_zeros += 1
            current_ones = 0
        max_ones = max(max_ones, current_ones)
        max_zeros = max(max_zeros, current_zeros)

    return max_ones > max_zeros


Solution = create_solution(solution_function_name)