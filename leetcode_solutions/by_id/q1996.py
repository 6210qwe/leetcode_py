# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1996
标题: Number of Ways to Rearrange Sticks With K Sticks Visible
难度: hard
链接: https://leetcode.cn/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible/
题目类型: 数学、动态规划、组合数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1866. 恰有 K 根木棍可以看到的排列数目 - 有 n 根长度互不相同的木棍，长度为从 1 到 n 的整数。请你将这些木棍排成一排，并满足从左侧 可以看到 恰好 k 根木棍。从左侧 可以看到 木棍的前提是这个木棍的 左侧 不存在比它 更长的 木棍。 * 例如，如果木棍排列为 [1,3,2,5,4] ，那么从左侧可以看到的就是长度分别为 1、3 、5 的木棍。 给你 n 和 k ，返回符合题目要求的排列 数目 。由于答案可能很大，请返回对 109 + 7 取余 的结果。 示例 1： 输入：n = 3, k = 2 输出：3 解释：[1,3,2], [2,3,1] 和 [2,1,3] 是仅有的能满足恰好 2 根木棍可以看到的排列。 可以看到的木棍已经用粗体+斜体标识。 示例 2： 输入：n = 5, k = 5 输出：1 解释：[1,2,3,4,5] 是唯一一种能满足全部 5 根木棍可以看到的排列。 可以看到的木棍已经用粗体+斜体标识。 示例 3： 输入：n = 20, k = 11 输出：647427950 解释：总共有 647427950 (mod 109 + 7) 种能满足恰好有 11 根木棍可以看到的排列。 提示： * 1 <= n <= 1000 * 1 <= k <= n
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。定义 dp[i][j] 为使用 i 根木棍且能看到 j 根木棍的排列数目。

算法步骤:
1. 初始化一个二维数组 dp，其中 dp[i][j] 表示使用 i 根木棍且能看到 j 根木棍的排列数目。
2. 设置初始条件 dp[0][0] = 1，表示没有木棍时，能看到 0 根木棍的排列数目为 1。
3. 对于每一个 i 和 j，有两种情况：
   - 将第 i 根木棍放在最前面，这样能看到的木棍数目增加 1，即 dp[i][j] += dp[i-1][j-1]。
   - 将第 i 根木棍放在其他位置，这样能看到的木棍数目不变，即 dp[i][j] += dp[i-1][j] * (i-1)。
4. 返回 dp[n][k] 并对 10^9 + 7 取余的结果。

关键点:
- 动态规划的状态转移方程。
- 对结果取模以防止溢出。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * k)
空间复杂度: O(n * k)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def number_of_ways_to_rearrange_sticks(n: int, k: int) -> int:
    """
    函数式接口 - 计算恰有 K 根木棍可以看到的排列数目
    """
    MOD = 10**9 + 7
    dp = [[0] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 1

    for i in range(1, n + 1):
        for j in range(1, min(i, k) + 1):
            dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j] * (i - 1)) % MOD

    return dp[n][k]


Solution = create_solution(number_of_ways_to_rearrange_sticks)