# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1334
标题: Sum of Numbers With Units Digit K
难度: medium
链接: https://leetcode.cn/problems/sum-of-numbers-with-units-digit-k/
题目类型: 贪心、数学、动态规划、枚举
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2310. 个位数字为 K 的整数之和 - 给你两个整数 num 和 k ，考虑具有以下属性的正整数多重集： * 每个整数个位数字都是 k 。 * 所有整数之和是 num 。 返回该多重集的最小大小，如果不存在这样的多重集，返回 -1 。 注意： * 多重集与集合类似，但多重集可以包含多个同一整数，空多重集的和为 0 。 * 个位数字 是数字最右边的数位。 示例 1： 输入：num = 58, k = 9 输出：2 解释： 多重集 [9,49] 满足题目条件，和为 58 且每个整数的个位数字是 9 。 另一个满足条件的多重集是 [19,39] 。 可以证明 2 是满足题目条件的多重集的最小长度。 示例 2： 输入：num = 37, k = 2 输出：-1 解释：个位数字为 2 的整数无法相加得到 37 。 示例 3： 输入：num = 0, k = 7 输出：0 解释：空多重集的和为 0 。 提示： * 0 <= num <= 3000 * 0 <= k <= 9
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过贪心算法找到满足条件的最小多重集大小。

算法步骤:
1. 如果 num 为 0，直接返回 0。
2. 遍历从 1 到 num 的所有可能的多重集大小，检查是否存在一个大小使得所有元素的和为 num 且每个元素的个位数字为 k。
3. 如果找到满足条件的多重集大小，返回该大小；否则返回 -1。

关键点:
- 通过遍历多重集大小来找到最小的满足条件的多重集。
- 检查每个可能的多重集大小时，确保每个元素的个位数字为 k。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(num)
空间复杂度: O(1)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def min_numbers_with_units_digit_k(num: int, k: int) -> int:
    """
    函数式接口 - 找到满足条件的最小多重集大小
    """
    if num == 0:
        return 0

    for size in range(1, num + 1):
        if (k * size) % 10 == num % 10 and (k * size) <= num:
            if (num - k * size) % 10 == 0:
                return size

    return -1


Solution = create_solution(min_numbers_with_units_digit_k)