# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3460
标题: Count the Number of Inversions
难度: hard
链接: https://leetcode.cn/problems/count-the-number-of-inversions/
题目类型: 数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3193. 统计逆序对的数目 - 给你一个整数 n 和一个二维数组 requirements ，其中 requirements[i] = [endi, cnti] 表示这个要求中的末尾下标和 逆序对 的数目。 整数数组 nums 中一个下标对 (i, j) 如果满足以下条件，那么它们被称为一个 逆序对 ： * i < j 且 nums[i] > nums[j] 请你返回 [0, 1, 2, ..., n - 1] 的 排列 perm 的数目，满足对 所有 的 requirements[i] 都满足 perm[0..endi] 中恰好有 cnti 个逆序对。 由于答案可能会很大，将它对 109 + 7 取余 后返回。 示例 1： 输入：n = 3, requirements = [[2,2],[0,0]] 输出：2 解释： 两个排列为： * [2, 0, 1] * 前缀 [2, 0, 1] 的逆序对为 (0, 1) 和 (0, 2) 。 * 前缀 [2] 的逆序对数目为 0 个。 * [1, 2, 0] * 前缀 [1, 2, 0] 的逆序对为 (0, 2) 和 (1, 2) 。 * 前缀 [1] 的逆序对数目为 0 个。 示例 2： 输入：n = 3, requirements = [[2,2],[1,1],[0,0]] 输出：1 解释： 唯一满足要求的排列是 [2, 0, 1] ： * 前缀 [2, 0, 1] 的逆序对为 (0, 1) 和 (0, 2) 。 * 前缀 [2, 0] 的逆序对为 (0, 1) 。 * 前缀 [2] 的逆序对数目为 0 。 示例 3： 输入：n = 2, requirements = [[0,0],[1,0]] 输出：1 解释： 唯一满足要求的排列为 [0, 1] ： * 前缀 [0] 的逆序对数目为 0 。 * 前缀 [0, 1] 没有逆序对。 提示： * 2 <= n <= 300 * 1 <= requirements.length <= n * requirements[i] = [endi, cnti] * 0 <= endi <= n - 1 * 0 <= cnti <= 400 * 输入保证至少有一个 i 满足 endi == n - 1 。 * 输入保证所有的 endi 互不相同。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: [TODO]

算法步骤:
1. [TODO]
2. [TODO]

关键点:
- [TODO]
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O([TODO])
空间复杂度: O([TODO])
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(params):
    """
    函数式接口 - [TODO] 实现
    """
    # TODO: 实现最优解法
    pass


Solution = create_solution(solution_function_name)
