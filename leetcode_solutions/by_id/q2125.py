# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2125
标题: GCD Sort of an Array
难度: hard
链接: https://leetcode.cn/problems/gcd-sort-of-an-array/
题目类型: 并查集、数组、数学、数论、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1998. 数组的最大公因数排序 - 给你一个整数数组 nums ，你可以在 nums 上执行下述操作 任意次 ： * 如果 gcd(nums[i], nums[j]) > 1 ，交换 nums[i] 和 nums[j] 的位置。其中 gcd(nums[i], nums[j]) 是 nums[i] 和 nums[j] 的最大公因数。 如果能使用上述交换方式将 nums 按 非递减顺序 排列，返回 true ；否则，返回 false 。 示例 1： 输入：nums = [7,21,3] 输出：true 解释：可以执行下述操作完成对 [7,21,3] 的排序： - 交换 7 和 21 因为 gcd(7,21) = 7 。nums = [21,7,3] - 交换 21 和 3 因为 gcd(21,3) = 3 。nums = [3,7,21] 示例 2： 输入：nums = [5,2,6,2] 输出：false 解释：无法完成排序，因为 5 不能与其他元素交换。 示例 3： 输入：nums = [10,5,9,3,15] 输出：true 解释： 可以执行下述操作完成对 [10,5,9,3,15] 的排序： - 交换 10 和 15 因为 gcd(10,15) = 5 。nums = [15,5,9,3,10] - 交换 15 和 3 因为 gcd(15,3) = 3 。nums = [3,5,9,15,10] - 交换 10 和 15 因为 gcd(10,15) = 5 。nums = [3,5,9,10,15] 提示： * 1 <= nums.length <= 3 * 104 * 2 <= nums[i] <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用并查集来判断是否可以通过交换使数组有序。

算法步骤:
1. 找到数组中所有元素的质因数。
2. 使用并查集将具有相同质因数的元素连接起来。
3. 检查排序后的数组是否可以通过并查集中的连接关系实现。

关键点:
- 使用质因数分解和并查集来判断连通性。
- 通过并查集检查排序后的数组是否可以由原数组通过交换得到。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * sqrt(m))，其中 n 是数组长度，m 是数组中的最大值。
空间复杂度: O(m)，用于存储质因数和并查集。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import math

class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x != root_y:
            self.parent[root_x] = root_y

def gcd_sort(nums: List[int]) -> bool:
    max_num = max(nums)
    uf = UnionFind(max_num + 1)
    
    # 将具有相同质因数的元素连接起来
    for num in nums:
        for factor in range(2, int(math.sqrt(num)) + 1):
            if num % factor == 0:
                uf.union(num, factor)
                uf.union(num, num // factor)
    
    # 检查排序后的数组是否可以通过并查集中的连接关系实现
    sorted_nums = sorted(nums)
    for i in range(len(nums)):
        if uf.find(nums[i]) != uf.find(sorted_nums[i]):
            return False
    return True

Solution = create_solution(gcd_sort)