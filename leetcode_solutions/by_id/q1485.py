# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1485
标题: Minimum Cost to Make at Least One Valid Path in a Grid
难度: hard
链接: https://leetcode.cn/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/
题目类型: 广度优先搜索、图、数组、矩阵、最短路、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1368. 使网格图至少有一条有效路径的最小代价 - 给你一个 m x n 的网格图 grid 。 grid 中每个格子都有一个数字，对应着从该格子出发下一步走的方向。 grid[i][j] 中的数字可能为以下几种情况： * 1 ，下一步往右走，也就是你会从 grid[i][j] 走到 grid[i][j + 1] * 2 ，下一步往左走，也就是你会从 grid[i][j] 走到 grid[i][j - 1] * 3 ，下一步往下走，也就是你会从 grid[i][j] 走到 grid[i + 1][j] * 4 ，下一步往上走，也就是你会从 grid[i][j] 走到 grid[i - 1][j] 注意网格图中可能会有 无效数字 ，因为它们可能指向 grid 以外的区域。 一开始，你会从最左上角的格子 (0,0) 出发。我们定义一条 有效路径 为从格子 (0,0) 出发，每一步都顺着数字对应方向走，最终在最右下角的格子 (m - 1, n - 1) 结束的路径。有效路径 不需要是最短路径 。 你可以花费 cost = 1 的代价修改一个格子中的数字，但每个格子中的数字 只能修改一次 。 请你返回让网格图至少有一条有效路径的最小代价。 示例 1： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/02/29/grid1.png] 输入：grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]] 输出：3 解释：你将从点 (0, 0) 出发。 到达 (3, 3) 的路径为： (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) 花费代价 cost = 1 使方向向下 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) 花费代价 cost = 1 使方向向下 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) 花费代价 cost = 1 使方向向下 --> (3, 3) 总花费为 cost = 3. 示例 2： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/02/29/grid2.png] 输入：grid = [[1,1,3],[3,2,2],[1,1,4]] 输出：0 解释：不修改任何数字你就可以从 (0, 0) 到达 (2, 2) 。 示例 3： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/02/29/grid3.png] 输入：grid = [[1,2],[4,3]] 输出：1 示例 4： 输入：grid = [[2,2,2],[2,2,2]] 输出：3 示例 5： 输入：grid = [[4]] 输出：0 提示： * m == grid.length * n == grid[i].length * 1 <= m, n <= 100
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用 Dijkstra 算法找到从起点 (0, 0) 到终点 (m-1, n-1) 的最小代价路径。

算法步骤:
1. 初始化一个优先队列，将起点 (0, 0) 和初始代价 0 加入队列。
2. 初始化一个二维数组 `dist` 来记录从起点到每个格子的最小代价，初始值设为无穷大。
3. 从优先队列中取出当前代价最小的格子，更新其相邻格子的最小代价。
4. 如果当前格子是终点 (m-1, n-1)，则返回当前代价。
5. 如果当前格子不是终点，继续处理队列中的下一个格子，直到队列为空。

关键点:
- 使用优先队列来保证每次处理的是当前代价最小的格子。
- 更新相邻格子的代价时，如果沿着当前格子的方向走，则代价不变；否则代价加 1。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m * n * log(m * n)) - 优先队列的操作时间复杂度为 O(log(m * n))，最多处理 m * n 个格子。
空间复杂度: O(m * n) - 优先队列和 `dist` 数组的空间复杂度。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def min_cost(grid: List[List[int]]) -> int:
    m, n = len(grid), len(grid[0])
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    
    # 优先队列，存储 (代价, 行, 列)
    pq = [(0, 0, 0)]
    # 记录从起点到每个格子的最小代价
    dist = [[float('inf')] * n for _ in range(m)]
    dist[0][0] = 0
    
    while pq:
        cost, r, c = heapq.heappop(pq)
        
        if r == m - 1 and c == n - 1:
            return cost
        
        for i, (dr, dc) in enumerate(directions):
            nr, nc = r + dr, c + dc
            if 0 <= nr < m and 0 <= nc < n:
                new_cost = cost if grid[r][c] == i + 1 else cost + 1
                if new_cost < dist[nr][nc]:
                    dist[nr][nc] = new_cost
                    heapq.heappush(pq, (new_cost, nr, nc))
    
    return -1  # 应该不会到达这里

Solution = create_solution(min_cost)