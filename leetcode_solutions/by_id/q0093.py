# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 93
标题: Restore IP Addresses
难度: medium
链接: https://leetcode.cn/problems/restore-ip-addresses/
题目类型: 字符串、回溯
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
93. 复原 IP 地址 - 有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。 * 例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。 给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。 示例 1： 输入：s = "25525511135" 输出：["255.255.11.135","255.255.111.35"] 示例 2： 输入：s = "0000" 输出：["0.0.0.0"] 示例 3： 输入：s = "101023" 输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"] 提示： * 1 <= s.length <= 20 * s 仅由数字组成
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 回溯算法，将字符串分割成4段，每段都是有效的IP地址段

算法步骤:
1. 回溯函数backtrack(start, path)：
   - 如果path长度==4且start==len(s)，找到一组解
   - 否则，对于每个可能的结束位置end（start+1到start+4）：
     * 如果end > len(s)，停止
     * 提取子串segment = s[start:end]
     * 检查segment是否有效（0-255，不能有前导0）
     * 如果有效，加入path并递归
     * 回溯，移除segment
2. 调用backtrack(0, [])开始回溯

关键点:
- 有效IP段：0-255，不能有前导0（除了"0"本身）
- 需要分割成4段
- 时间复杂度O(1)（最多3^4种情况），空间复杂度O(1)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(1) - 最多3^4种分割方式
空间复杂度: O(1) - 递归栈深度最多4层
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from leetcode_solutions.utils.solution import create_solution


def restore_ip_addresses(s: str) -> List[str]:
    """
    函数式接口 - 回溯算法
    
    实现思路:
    使用回溯算法将字符串分割成4段，每段都是有效的IP地址段。
    
    Args:
        s: 只包含数字的字符串
        
    Returns:
        所有可能的有效IP地址列表
        
    Example:
        >>> restore_ip_addresses("25525511135")
        ['255.255.11.135', '255.255.111.35']
    """
    result = []
    
    def is_valid(segment: str) -> bool:
        """检查IP段是否有效"""
        if not segment or len(segment) > 3:
            return False
        if segment[0] == '0' and len(segment) > 1:
            return False
        num = int(segment)
        return 0 <= num <= 255
    
    def backtrack(start: int, path: List[str]):
        """回溯函数"""
        if len(path) == 4:
            if start == len(s):
                result.append('.'.join(path))
            return
        
        for end in range(start + 1, min(start + 4, len(s) + 1)):
            segment = s[start:end]
            if is_valid(segment):
                path.append(segment)
                backtrack(end, path)
                path.pop()
    
    backtrack(0, [])
    return result


# 自动生成Solution类（无需手动编写）
Solution = create_solution(restore_ip_addresses)
