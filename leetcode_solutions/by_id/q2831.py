# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2831
标题: Number of Beautiful Pairs
难度: easy
链接: https://leetcode.cn/problems/number-of-beautiful-pairs/
题目类型: 数组、哈希表、数学、计数、数论
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2748. 美丽下标对的数目 - 给你一个下标从 0 开始的整数数组 nums 。如果下标对 i、j 满足 0 ≤ i < j < nums.length ，如果 nums[i] 的 第一个数字 和 nums[j] 的 最后一个数字 互质 ，则认为 nums[i] 和 nums[j] 是一组 美丽下标对 。 返回 nums 中 美丽下标对 的总数目。 对于两个整数 x 和 y ，如果不存在大于 1 的整数可以整除它们，则认为 x 和 y 互质 。换而言之，如果 gcd(x, y) == 1 ，则认为 x 和 y 互质，其中 gcd(x, y) 是 x 和 y 的 最大公因数 。 示例 1： 输入：nums = [2,5,1,4] 输出：5 解释：nums 中共有 5 组美丽下标对： i = 0 和 j = 1 ：nums[0] 的第一个数字是 2 ，nums[1] 的最后一个数字是 5 。2 和 5 互质，因此 gcd(2,5) == 1 。 i = 0 和 j = 2 ：nums[0] 的第一个数字是 2 ，nums[2] 的最后一个数字是 1 。2 和 1 互质，因此 gcd(2,1) == 1 。 i = 1 和 j = 2 ：nums[1] 的第一个数字是 5 ，nums[2] 的最后一个数字是 1 。5 和 1 互质，因此 gcd(5,1) == 1 。 i = 1 和 j = 3 ：nums[1] 的第一个数字是 5 ，nums[3] 的最后一个数字是 4 。5 和 4 互质，因此 gcd(5,4) == 1 。 i = 2 和 j = 3 ：nums[2] 的第一个数字是 1 ，nums[3] 的最后一个数字是 4 。1 和 4 互质，因此 gcd(1,4) == 1 。 因此，返回 5 。 示例 2： 输入：nums = [11,21,12] 输出：2 解释：共有 2 组美丽下标对： i = 0 和 j = 1 ：nums[0] 的第一个数字是 1 ，nums[1] 的最后一个数字是 1 。gcd(1,1) == 1 。 i = 0 和 j = 2 ：nums[0] 的第一个数字是 1 ，nums[2] 的最后一个数字是 2 。gcd(1,2) == 1 。 因此，返回 2 。 提示： * 2 <= nums.length <= 100 * 1 <= nums[i] <= 9999 * nums[i] % 10 != 0
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用双重循环遍历所有可能的下标对 (i, j)，并检查 nums[i] 的第一个数字和 nums[j] 的最后一个数字是否互质。

算法步骤:
1. 定义一个辅助函数 `gcd` 来计算两个数的最大公约数。
2. 遍历所有可能的下标对 (i, j)，其中 0 ≤ i < j < len(nums)。
3. 对于每个下标对 (i, j)，获取 nums[i] 的第一个数字和 nums[j] 的最后一个数字。
4. 使用 `gcd` 函数检查这两个数字是否互质。
5. 如果互质，则计数器加一。
6. 返回计数器的值。

关键点:
- 使用字符串操作来提取数字的第一个和最后一个字符。
- 使用 `gcd` 函数来判断两个数字是否互质。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2 * log(max(num)))，其中 n 是数组长度，log(max(num)) 是计算最大公约数的时间复杂度。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import math

def count_beautiful_pairs(nums: List[int]) -> int:
    def get_first_digit(num: int) -> int:
        return int(str(num)[0])

    def get_last_digit(num: int) -> int:
        return num % 10

    count = 0
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            first_digit = get_first_digit(nums[i])
            last_digit = get_last_digit(nums[j])
            if math.gcd(first_digit, last_digit) == 1:
                count += 1
    return count

Solution = create_solution(count_beautiful_pairs)