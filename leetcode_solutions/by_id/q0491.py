# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 491
标题: Non-decreasing Subsequences
难度: medium
链接: https://leetcode.cn/problems/non-decreasing-subsequences/
题目类型: 位运算、数组、哈希表、回溯
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
491. 非递减子序列 - 给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。 数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。 示例 1： 输入：nums = [4,6,7,7] 输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]] 示例 2： 输入：nums = [4,4,3,2,1] 输出：[[4,4]] 提示： * 1 <= nums.length <= 15 * -100 <= nums[i] <= 100
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用回溯法生成所有非递减子序列，并使用集合去重

算法步骤:
1. 定义一个递归函数 `backtrack` 来生成子序列
2. 使用一个临时列表 `temp` 存储当前子序列
3. 使用一个集合 `result_set` 存储所有生成的子序列以去重
4. 在递归过程中，如果当前子序列长度大于等于2，则加入结果集
5. 对于每个元素，选择加入或不加入当前子序列，继续递归
6. 最后将结果集转换为列表返回

关键点:
- 使用集合去重，确保结果唯一
- 通过递归和回溯生成所有可能的子序列
- 优化时间和空间复杂度
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(2^n) - 每个元素都有两种选择（加入或不加入子序列）
空间复杂度: O(n * 2^n) - 结果集的大小最多为 2^n，每个子序列的长度最多为 n
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def non_decreasing_subsequences(nums: List[int]) -> List[List[int]]:
    """
    函数式接口 - 找出并返回所有非递减子序列，递增子序列中至少有两个元素

    实现思路:
    使用回溯法生成所有非递减子序列，并使用集合去重

    Args:
        nums (List[int]): 输入的整数数组
        
    Returns:
        List[List[int]]: 所有非递减子序列的列表
        
    Example:
        >>> non_decreasing_subsequences([4,6,7,7])
        [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
    """
    def backtrack(start, temp):
        if len(temp) >= 2:
            result_set.add(tuple(temp))
        for i in range(start, len(nums)):
            if not temp or nums[i] >= temp[-1]:
                temp.append(nums[i])
                backtrack(i + 1, temp)
                temp.pop()

    result_set = set()
    backtrack(0, [])
    return [list(seq) for seq in result_set]


# 自动生成Solution类（无需手动编写）
Solution = create_solution(non_decreasing_subsequences)