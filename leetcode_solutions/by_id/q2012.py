# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2012
标题: Process Tasks Using Servers
难度: medium
链接: https://leetcode.cn/problems/process-tasks-using-servers/
题目类型: 数组、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1882. 使用服务器处理任务 - 给你两个 下标从 0 开始 的整数数组 servers 和 tasks ，长度分别为 n 和 m 。servers[i] 是第 i 台服务器的 权重 ，而 tasks[j] 是处理第 j 项任务 所需要的时间（单位：秒）。 你正在运行一个仿真系统，在处理完所有任务后，该系统将会关闭。每台服务器只能同时处理一项任务。第 0 项任务在第 0 秒可以开始处理，相应地，第 j 项任务在第 j 秒可以开始处理。处理第 j 项任务时，你需要为它分配一台 权重最小 的空闲服务器。如果存在多台相同权重的空闲服务器，请选择 下标最小 的服务器。如果一台空闲服务器在第 t 秒分配到第 j 项任务，那么在 t + tasks[j] 时它将恢复空闲状态。 如果没有空闲服务器，则必须等待，直到出现一台空闲服务器，并 尽可能早 地处理剩余任务。 如果有多项任务等待分配，则按照 下标递增 的顺序完成分配。 如果同一时刻存在多台空闲服务器，可以同时将多项任务分别分配给它们。 构建长度为 m 的答案数组 ans ，其中 ans[j] 是第 j 项任务分配的服务器的下标。 返回答案数组 ans 。 示例 1： 输入：servers = [3,3,2], tasks = [1,2,3,2,1,2] 输出：[2,2,0,2,1,2] 解释：事件按时间顺序如下： - 0 秒时，第 0 项任务加入到任务队列，使用第 2 台服务器处理到 1 秒。 - 1 秒时，第 2 台服务器空闲，第 1 项任务加入到任务队列，使用第 2 台服务器处理到 3 秒。 - 2 秒时，第 2 项任务加入到任务队列，使用第 0 台服务器处理到 5 秒。 - 3 秒时，第 2 台服务器空闲，第 3 项任务加入到任务队列，使用第 2 台服务器处理到 5 秒。 - 4 秒时，第 4 项任务加入到任务队列，使用第 1 台服务器处理到 5 秒。 - 5 秒时，所有服务器都空闲，第 5 项任务加入到任务队列，使用第 2 台服务器处理到 7 秒。 示例 2： 输入：servers = [5,1,4,3,2], tasks = [2,1,2,4,5,2,1] 输出：[1,4,1,4,1,3,2] 解释：事件按时间顺序如下： - 0 秒时，第 0 项任务加入到任务队列，使用第 1 台服务器处理到 2 秒。 - 1 秒时，第 1 项任务加入到任务队列，使用第 4 台服务器处理到 2 秒。 - 2 秒时，第 1 台和第 4 台服务器空闲，第 2 项任务加入到任务队列，使用第 1 台服务器处理到 4 秒。 - 3 秒时，第 3 项任务加入到任务队列，使用第 4 台服务器处理到 7 秒。 - 4 秒时，第 1 台服务器空闲，第 4 项任务加入到任务队列，使用第 1 台服务器处理到 9 秒。 - 5 秒时，第 5 项任务加入到任务队列，使用第 3 台服务器处理到 7 秒。 - 6 秒时，第 6 项任务加入到任务队列，使用第 2 台服务器处理到 7 秒。 提示： * servers.length == n * tasks.length == m * 1 <= n, m <= 2 * 105 * 1 <= servers[i], tasks[j] <= 2 * 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用两个优先队列来管理空闲服务器和忙碌服务器。一个用于存储当前空闲的服务器，另一个用于存储当前忙碌的服务器及其释放时间。

算法步骤:
1. 初始化两个优先队列：一个用于存储空闲服务器 (idle_servers)，另一个用于存储忙碌服务器 (busy_servers)。
2. 将所有服务器按权重和下标排序后加入空闲服务器队列。
3. 遍历每个任务，对于每个任务：
   - 释放所有已经完成任务的服务器，将其从忙碌服务器队列中移除并加入空闲服务器队列。
   - 如果有空闲服务器，选择权重最小且下标最小的服务器处理当前任务，并将其加入忙碌服务器队列。
   - 如果没有空闲服务器，等待最早释放的服务器，并将其用于处理当前任务。
4. 记录每个任务分配的服务器下标。

关键点:
- 使用优先队列来高效地管理和选择服务器。
- 通过维护当前时间和服务器释放时间来确保服务器的正确调度。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O((n + m) log n)
- 初始化空闲服务器队列的时间复杂度为 O(n log n)。
- 每个任务的操作时间复杂度为 O(log n)，总共 m 个任务，因此总时间复杂度为 O(m log n)。
- 总时间复杂度为 O((n + m) log n)。

空间复杂度: O(n + m)
- 优先队列的空间复杂度为 O(n)。
- 结果数组的空间复杂度为 O(m)。
- 总空间复杂度为 O(n + m)。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def assign_tasks(servers: List[int], tasks: List[int]) -> List[int]:
    """
    分配任务到服务器
    """
    n, m = len(servers), len(tasks)
    idle_servers = [(weight, i) for i, weight in enumerate(servers)]
    heapq.heapify(idle_servers)
    busy_servers = []
    current_time = 0
    result = []

    for j in range(m):
        # 更新当前时间
        current_time = max(current_time, j)

        # 释放已经完成任务的服务器
        while busy_servers and busy_servers[0][0] <= current_time:
            _, server_index = heapq.heappop(busy_servers)
            heapq.heappush(idle_servers, (servers[server_index], server_index))

        # 如果有空闲服务器，选择权重最小且下标最小的服务器
        if idle_servers:
            weight, server_index = heapq.heappop(idle_servers)
            result.append(server_index)
            heapq.heappush(busy_servers, (current_time + tasks[j], server_index))
        else:
            # 等待最早释放的服务器
            release_time, server_index = heapq.heappop(busy_servers)
            current_time = release_time
            result.append(server_index)
            heapq.heappush(busy_servers, (current_time + tasks[j], server_index))

    return result

Solution = create_solution(assign_tasks)