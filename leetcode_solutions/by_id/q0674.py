# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 674
标题: Longest Continuous Increasing Subsequence
难度: easy
链接: https://leetcode.cn/problems/longest-continuous-increasing-subsequence/
题目类型: 数组
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
674. 最长连续递增序列 - 给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。 连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。 示例 1： 输入：nums = [1,3,5,4,7] 输出：3 解释：最长连续递增序列是 [1,3,5], 长度为3。 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 示例 2： 输入：nums = [2,2,2,2,2] 输出：1 解释：最长连续递增序列是 [2], 长度为1。 提示： * 1 <= nums.length <= 104 * -109 <= nums[i] <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 一次遍历，维护当前连续递增段的长度

算法步骤:
1. 若数组长度为 0 或 1，直接返回长度
2. 使用两个变量：
   - cur_len: 当前连续递增子序列长度
   - max_len: 遍历到目前为止的最大长度
3. 从第二个元素开始遍历：
   - 若 nums[i] > nums[i-1]，则 cur_len += 1
   - 否则重置 cur_len = 1
   - 同时更新 max_len = max(max_len, cur_len)
4. 遍历结束后返回 max_len

关键点:
- “连续递增”只比较相邻元素
- 每次断开递增时重置长度
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 只遍历一次数组
空间复杂度: O(1) - 只使用常数额外空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def find_length_of_lcis(nums: List[int]) -> int:
    """
    函数式接口 - 最长连续递增子序列
    """
    if not nums:
        return 0

    cur_len = 1
    max_len = 1

    for i in range(1, len(nums)):
        if nums[i] > nums[i - 1]:
            cur_len += 1
        else:
            cur_len = 1
        if cur_len > max_len:
            max_len = cur_len

    return max_len


Solution = create_solution(find_length_of_lcis)
