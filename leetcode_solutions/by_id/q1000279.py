# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000279
标题: 逆波兰表达式求值
难度: medium
链接: https://leetcode.cn/problems/8Zf90G/
题目类型: 栈、数组、数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCR 036. 逆波兰表达式求值 - 根据 逆波兰表示法 [https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437]，求该后缀表达式的计算结果。 有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 说明： * 整数除法只保留整数部分。 * 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例 1： 输入：tokens = ["2","1","+","3","*"] 输出：9 解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9 示例 2： 输入：tokens = ["4","13","5","/","+"] 输出：6 解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6 示例 3： 输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"] 输出：22 解释： 该算式转化为常见的中缀算术表达式为： ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 提示： * 1 <= tokens.length <= 104 * tokens[i] 要么是一个算符（"+"、"-"、"*" 或 "/"），要么是一个在范围 [-200, 200] 内的整数 逆波兰表达式： 逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。 * 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。 * 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。 逆波兰表达式主要有以下两个优点： * 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。 * 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。 注意：本题与主站 150 题相同： https://leetcode.cn/problems/evaluate-reverse-polish-notation/ [https://leetcode.cn/problems/evaluate-reverse-polish-notation/]
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用栈来处理逆波兰表达式。遍历表达式中的每个元素，如果是数字则入栈，如果是运算符则从栈中弹出两个数字进行计算，并将结果重新入栈。

算法步骤:
1. 初始化一个空栈。
2. 遍历表达式中的每个元素：
   - 如果是数字，则将其转换为整数并入栈。
   - 如果是运算符，则从栈中弹出两个数字，进行相应的运算，并将结果重新入栈。
3. 最后栈中剩下的唯一元素即为表达式的计算结果。

关键点:
- 使用栈来存储中间结果。
- 注意运算符的顺序和优先级。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是 tokens 的长度。每个元素只会被处理一次。
空间复杂度: O(n)，最坏情况下栈的大小为 n/2。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def eval_rpn(tokens: List[str]) -> int:
    """
    函数式接口 - 计算逆波兰表达式的值
    """
    stack = []

    for token in tokens:
        if token in {"+", "-", "*", "/"}:
            right_operand = stack.pop()
            left_operand = stack.pop()
            if token == "+":
                result = left_operand + right_operand
            elif token == "-":
                result = left_operand - right_operand
            elif token == "*":
                result = left_operand * right_operand
            else:  # token == "/"
                result = int(left_operand / right_operand)  # 向零取整
            stack.append(result)
        else:
            stack.append(int(token))

    return stack[0]


Solution = create_solution(eval_rpn)