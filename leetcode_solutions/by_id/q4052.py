# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 4052
标题: Equal Score Substrings
难度: easy
链接: https://leetcode.cn/problems/equal-score-substrings/
题目类型: 字符串、前缀和
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3707. 相等子字符串分数 - 给你一个由小写英文字母组成的字符串 s。 一个字符串的 得分 是其字符在字母表中的位置之和，其中 'a' = 1，'b' = 2，...，'z' = 26。 请你判断是否存在一个下标 i，使得该字符串可以被拆分成两个 非空子字符串 s[0..i] 和 s[(i + 1)..(n - 1)]，且它们的得分 相等 。 如果存在这样的拆分，则返回 true，否则返回 false。 一个 子字符串 是字符串中 非空 的连续字符序列。 示例 1: 输入: s = "adcb" 输出: true 解释: 在下标 i = 1 处拆分： * 左子字符串 = s[0..1] = "ad"，得分 = 1 + 4 = 5 * 右子字符串 = s[2..3] = "cb"，得分 = 3 + 2 = 5 两个子字符串的得分相等，因此输出为 true。 示例 2: 输入: s = "bace" 输出: false 解释: 没有拆分能产生相等的得分，因此输出为 false。 提示: * 2 <= s.length <= 100 * s 由小写英文字母组成。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用前缀和数组来快速计算任意子字符串的得分，并检查是否存在一个下标 i 使得左右子字符串的得分相等。

算法步骤:
1. 计算字符串 s 的前缀和数组 prefix_sum，其中 prefix_sum[i] 表示 s[0..i] 的得分。
2. 遍历前缀和数组，检查是否存在一个下标 i 使得 prefix_sum[i] == (prefix_sum[-1] - prefix_sum[i]) / 2。

关键点:
- 使用前缀和数组可以快速计算任意子字符串的得分。
- 通过遍历前缀和数组，可以在 O(n) 时间内找到满足条件的下标 i。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def equal_score_substrings(s: str) -> bool:
    """
    函数式接口 - 判断是否存在一个下标 i，使得字符串 s 可以被拆分成两个非空子字符串 s[0..i] 和 s[(i + 1)..(n - 1)]，且它们的得分相等。
    """
    n = len(s)
    prefix_sum = [0] * (n + 1)
    
    # 计算前缀和数组
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + (ord(s[i]) - ord('a') + 1)
    
    total_score = prefix_sum[n]
    
    # 检查是否存在一个下标 i 使得左右子字符串的得分相等
    for i in range(1, n):
        if prefix_sum[i] == total_score - prefix_sum[i]:
            return True
    
    return False


Solution = create_solution(equal_score_substrings)