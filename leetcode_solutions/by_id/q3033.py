# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3033
标题: Apply Operations to Make Two Strings Equal
难度: medium
链接: https://leetcode.cn/problems/apply-operations-to-make-two-strings-equal/
题目类型: 字符串、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2896. 执行操作使两个字符串相等 - 给你两个下标从 0 开始的二进制字符串 s1 和 s2 ，两个字符串的长度都是 n ，再给你一个正整数 x 。 你可以对字符串 s1 执行以下操作 任意次 ： * 选择两个下标 i 和 j ，将 s1[i] 和 s1[j] 都反转，操作的代价为 x 。 * 选择满足 i < n - 1 的下标 i ，反转 s1[i] 和 s1[i + 1] ，操作的代价为 1 。 请你返回使字符串 s1 和 s2 相等的 最小 操作代价之和，如果无法让二者相等，返回 -1 。 注意 ，反转字符的意思是将 0 变成 1 ，或者 1 变成 0 。 示例 1： 输入：s1 = "1100011000", s2 = "0101001010", x = 2 输出：4 解释：我们可以执行以下操作： - 选择 i = 3 执行第二个操作。结果字符串是 s1 = "1101111000" 。 - 选择 i = 4 执行第二个操作。结果字符串是 s1 = "1101001000" 。 - 选择 i = 0 和 j = 8 ，执行第一个操作。结果字符串是 s1 = "0101001010" = s2 。 总代价是 1 + 1 + 2 = 4 。这是最小代价和。 示例 2： 输入：s1 = "10110", s2 = "00011", x = 4 输出：-1 解释：无法使两个字符串相等。 提示： * n == s1.length == s2.length * 1 <= n, x <= 500 * s1 和 s2 只包含字符 '0' 和 '1' 。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们定义 dp[i][j] 为将 s1 的前 i 个字符转换为 s2 的前 i 个字符，并且最后一个不匹配的位置在 j 处的最小代价。

算法步骤:
1. 初始化 dp 数组，dp[i][j] 表示将 s1 的前 i 个字符转换为 s2 的前 i 个字符，并且最后一个不匹配的位置在 j 处的最小代价。
2. 遍历字符串 s1 和 s2，更新 dp 数组。
3. 如果 s1 和 s2 在某个位置不匹配，计算两种操作的代价并更新 dp 数组。
4. 返回 dp[n][n] 的值，如果无法使两个字符串相等，返回 -1。

关键点:
- 动态规划的状态转移方程需要考虑两种操作的代价。
- 初始化 dp 数组时，需要考虑边界情况。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2)
空间复杂度: O(n^2)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def min_operations_to_equal_strings(s1: str, s2: str, x: int) -> int:
    n = len(s1)
    if n != len(s2):
        return -1

    # 初始化 dp 数组
    dp = [[float('inf')] * (n + 1) for _ in range(n + 1)]
    dp[0][0] = 0

    # 遍历字符串 s1 和 s2
    for i in range(1, n + 1):
        for j in range(i + 1):
            if s1[i - 1] == s2[i - 1]:
                dp[i][j] = dp[i - 1][j]
            else:
                if j > 0:
                    dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + x)
                if j < i:
                    dp[i][i] = min(dp[i][i], dp[i - 1][j] + (i - j - 1))

    # 返回结果
    result = min(dp[n])
    return result if result != float('inf') else -1


Solution = create_solution(min_operations_to_equal_strings)