# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1046
标题: Max Consecutive Ones III
难度: medium
链接: https://leetcode.cn/problems/max-consecutive-ones-iii/
题目类型: 数组、二分查找、前缀和、滑动窗口
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1004. 最大连续1的个数 III - 给定一个二进制数组 nums 和一个整数 k，假设最多可以翻转 k 个 0 ，则返回执行操作后 数组中连续 1 的最大个数 。 示例 1： 输入：nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2 输出：6 解释：[1,1,1,0,0,1,1,1,1,1,1] 粗体数字从 0 翻转到 1，最长的子数组长度为 6。 示例 2： 输入：nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3 输出：10 解释：[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1] 粗体数字从 0 翻转到 1，最长的子数组长度为 10。 提示： * 1 <= nums.length <= 105 * nums[i] 不是 0 就是 1 * 0 <= k <= nums.length
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用滑动窗口来找到最长的子数组，其中包含最多 k 个 0。

算法步骤:
1. 初始化两个指针 left 和 right，表示滑动窗口的左右边界。
2. 遍历数组，右指针 right 向右移动，同时记录窗口内的 0 的数量。
3. 如果窗口内的 0 的数量超过 k，则左指针 left 向右移动，直到窗口内的 0 的数量不超过 k。
4. 记录每次窗口的长度，并更新最大长度。

关键点:
- 使用滑动窗口来维护一个包含最多 k 个 0 的子数组。
- 右指针向右扩展窗口，左指针在窗口内 0 的数量超过 k 时收缩窗口。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是数组的长度。每个元素最多被访问两次（一次由右指针，一次由左指针）。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def max_consecutive_ones(nums: List[int], k: int) -> int:
    """
    函数式接口 - 返回执行操作后数组中连续 1 的最大个数
    """
    left = 0
    zero_count = 0
    max_length = 0
    
    for right in range(len(nums)):
        if nums[right] == 0:
            zero_count += 1
        
        while zero_count > k:
            if nums[left] == 0:
                zero_count -= 1
            left += 1
        
        max_length = max(max_length, right - left + 1)
    
    return max_length


Solution = create_solution(max_consecutive_ones)