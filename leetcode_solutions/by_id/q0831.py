# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 831
标题: Largest Sum of Averages
难度: medium
链接: https://leetcode.cn/problems/largest-sum-of-averages/
题目类型: 数组、动态规划、前缀和
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
813. 最大平均值和的分组 - 给定数组 nums 和一个整数 k 。我们将给定的数组 nums 分成 最多 k 个非空子数组，且数组内部是连续的 。 分数 由每个子数组内的平均值的总和构成。 注意我们必须使用 nums 数组中的每一个数进行分组，并且分数不一定需要是整数。 返回我们所能得到的最大 分数 是多少。答案误差在 10-6 内被视为是正确的。 示例 1: 输入: nums = [9,1,2,3,9], k = 3 输出: 20.00000 解释: nums 的最优分组是[9], [1, 2, 3], [9]. 得到的分数是 9 + (1 + 2 + 3) / 3 + 9 = 20. 我们也可以把 nums 分成[9, 1], [2], [3, 9]. 这样的分组得到的分数为 5 + 2 + 6 = 13, 但不是最大值. 示例 2: 输入: nums = [1,2,3,4,5,6,7], k = 4 输出: 20.50000 提示: * 1 <= nums.length <= 100 * 1 <= nums[i] <= 104 * 1 <= k <= nums.length
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划和前缀和来解决这个问题。

算法步骤:
1. 计算前缀和数组，方便快速计算子数组的和。
2. 使用动态规划数组 dp[i][k] 表示将前 i 个元素分成 k 个子数组的最大平均值和。
3. 初始化 dp 数组，dp[i][1] 为前 i 个元素的平均值。
4. 填充 dp 数组，对于每个 dp[i][k]，遍历所有可能的分割点 j，更新 dp[i][k]。
5. 返回 dp[n][K]，即为所求的最大平均值和。

关键点:
- 使用前缀和数组快速计算子数组的和。
- 动态规划状态转移方程：dp[i][k] = max(dp[i][k], dp[j][k-1] + (prefix_sum[i] - prefix_sum[j]) / (i - j))。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2 * K)，其中 n 是数组长度，K 是最多分成的子数组个数。
空间复杂度: O(n * K)，用于存储动态规划数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def largest_sum_of_averages(nums: List[int], K: int) -> float:
    n = len(nums)
    prefix_sum = [0] * (n + 1)
    
    # 计算前缀和数组
    for i in range(1, n + 1):
        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]
    
    # 初始化 dp 数组
    dp = [[0] * (K + 1) for _ in range(n + 1)]
    
    # 初始化 dp[i][1] 为前 i 个元素的平均值
    for i in range(1, n + 1):
        dp[i][1] = prefix_sum[i] / i
    
    # 填充 dp 数组
    for k in range(2, K + 1):
        for i in range(k, n + 1):
            for j in range(k - 1, i):
                dp[i][k] = max(dp[i][k], dp[j][k - 1] + (prefix_sum[i] - prefix_sum[j]) / (i - j))
    
    return dp[n][K]


Solution = create_solution(largest_sum_of_averages)