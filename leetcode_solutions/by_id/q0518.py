# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 518
标题: Coin Change II
难度: medium
链接: https://leetcode.cn/problems/coin-change-ii/
题目类型: 数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
518. 零钱兑换 II - 给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。 请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。 假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数。 示例 1： 输入：amount = 5, coins = [1, 2, 5] 输出：4 解释：有四种方式可以凑成总金额： 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1 示例 2： 输入：amount = 3, coins = [2] 输出：0 解释：只用面额 2 的硬币不能凑成总金额 3 。 示例 3： 输入：amount = 10, coins = [10] 输出：1 提示： * 1 <= coins.length <= 300 * 1 <= coins[i] <= 5000 * coins 中的所有值 互不相同 * 0 <= amount <= 5000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们定义 dp[i] 为凑成金额 i 的组合数。对于每个硬币面额 coin，我们更新 dp 数组，使得 dp[i] += dp[i - coin]。

算法步骤:
1. 初始化一个长度为 amount + 1 的 dp 数组，dp[0] = 1，表示凑成金额 0 的唯一方法是使用 0 个硬币。
2. 遍历每个硬币面额 coin，对于每个 coin，从 coin 到 amount 更新 dp 数组。
3. 最终 dp[amount] 即为所求的组合数。

关键点:
- 动态规划的状态转移方程为 dp[i] += dp[i - coin]。
- 外层循环遍历硬币面额，内层循环遍历金额，这样可以确保每个组合只被计算一次。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * m)，其中 n 是硬币的种类数，m 是总金额。
空间复杂度: O(m)，需要一个长度为 amount + 1 的 dp 数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def change(amount: int, coins: List[int]) -> int:
    """
    函数式接口 - 计算可以凑成总金额的硬币组合数
    """
    # 初始化 dp 数组
    dp = [0] * (amount + 1)
    dp[0] = 1  # 凑成金额 0 的唯一方法是使用 0 个硬币

    # 遍历每个硬币面额
    for coin in coins:
        # 从 coin 到 amount 更新 dp 数组
        for i in range(coin, amount + 1):
            dp[i] += dp[i - coin]

    return dp[amount]


Solution = create_solution(change)