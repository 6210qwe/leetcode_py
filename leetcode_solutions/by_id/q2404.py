# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2404
标题: Number of Distinct Roll Sequences
难度: hard
链接: https://leetcode.cn/problems/number-of-distinct-roll-sequences/
题目类型: 记忆化搜索、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2318. 不同骰子序列的数目 - 给你一个整数 n 。你需要掷一个 6 面的骰子 n 次。请你在满足以下要求的前提下，求出 不同 骰子序列的数目： 1. 序列中任意 相邻 数字的 最大公约数 为 1 。 2. 序列中 相等 的值之间，至少有 2 个其他值的数字。正式地，如果第 i 次掷骰子的值 等于 第 j 次的值，那么 abs(i - j) > 2 。 请你返回不同序列的 总数目 。由于答案可能很大，请你将答案对 109 + 7 取余 后返回。 如果两个序列中至少有一个元素不同，那么它们被视为不同的序列。 示例 1： 输入：n = 4 输出：184 解释：一些可行的序列为 (1, 2, 3, 4) ，(6, 1, 2, 3) ，(1, 2, 3, 1) 等等。 一些不可行的序列为 (1, 2, 1, 3) ，(1, 2, 3, 6) 。 (1, 2, 1, 3) 是不可行的，因为第一个和第三个骰子值相等且 abs(1 - 3) = 2 （下标从 1 开始表示）。 (1, 2, 3, 6) i是不可行的，因为 3 和 6 的最大公约数是 3 。 总共有 184 个不同的可行序列，所以我们返回 184 。 示例 2： 输入：n = 2 输出：22 解释：一些可行的序列为 (1, 2) ，(2, 1) ，(3, 2) 。 一些不可行的序列为 (3, 6) ，(2, 4) ，因为最大公约数不为 1 。 总共有 22 个不同的可行序列，所以我们返回 22 。 提示： * 1 <= n <= 104
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用记忆化搜索来解决这个问题。我们定义一个递归函数 `dp(n, last, second_last)` 来表示当前长度为 n 的序列，最后一个数字是 last，倒数第二个数字是 second_last 的方案数。

算法步骤:
1. 初始化一个缓存来存储已经计算过的状态。
2. 定义递归函数 `dp(n, last, second_last)`：
   - 如果 n 为 0，返回 1，表示找到了一个有效的序列。
   - 否则，遍历所有可能的下一个数字 next_val，检查是否满足条件（gcd(last, next_val) == 1 且 next_val != second_last）。
   - 递归调用 `dp(n-1, next_val, last)` 并累加结果。
3. 返回最终的结果。

关键点:
- 使用缓存来避免重复计算。
- 通过递归和回溯来枚举所有可能的序列。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * 6^2) = O(n)
空间复杂度: O(n * 6^2) = O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution
import math
from functools import lru_cache

MOD = 10**9 + 7

@lru_cache(None)
def dp(n: int, last: int, second_last: int) -> int:
    if n == 0:
        return 1
    count = 0
    for next_val in range(1, 7):
        if math.gcd(last, next_val) == 1 and next_val != second_last:
            count += dp(n - 1, next_val, last)
            count %= MOD
    return count

def solution_function_name(n: int) -> int:
    """
    函数式接口 - 计算不同骰子序列的数目
    """
    total = 0
    for last in range(1, 7):
        for second_last in range(1, 7):
            if last != second_last:
                total += dp(n - 1, last, second_last)
                total %= MOD
    return total

Solution = create_solution(solution_function_name)