# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 439
标题: Ternary Expression Parser
难度: medium
链接: https://leetcode.cn/problems/ternary-expression-parser/
题目类型: 栈、递归、字符串
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
439. 三元表达式解析器 - 备战技术面试？力扣提供海量技术面试资源，帮助你高效提升编程技能,轻松拿下世界 IT 名企 Dream Offer。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用栈来解析三元表达式

算法步骤:
1. 初始化一个空栈
2. 从右到左遍历表达式
3. 如果遇到字符，则将其压入栈中
4. 如果遇到 '?'，则弹出栈顶的两个元素，并根据下一个字符（即 ':' 后面的字符）决定保留哪个元素
5. 将选择的元素重新压入栈中
6. 最终栈中剩下的唯一元素即为解析结果

关键点:
- 从右到左遍历以确保先处理条件表达式的子表达式
- 使用栈来存储和处理中间结果
- 注意边界条件，如空表达式等
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 其中 n 是表达式的长度，每个字符只处理一次
空间复杂度: O(n) - 栈的最大深度为表达式的长度
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def ternary_expression_parser(expression: str) -> str:
    """
    函数式接口 - 解析三元表达式
    
    实现思路:
    使用栈从右到左遍历表达式，处理每个字符并最终得到解析结果
    
    Args:
        expression (str): 三元表达式字符串
        
    Returns:
        str: 解析后的结果
        
    Example:
        >>> ternary_expression_parser("a?b:c")
        "b"
    """
    stack = []
    i = len(expression) - 1
    while i >= 0:
        ch = expression[i]
        if ch == '?':
            true_val = stack.pop()
            false_val = stack.pop()
            stack.append(true_val if expression[i - 1] == 'T' else false_val)
            i -= 2  # 跳过条件字符
        elif ch != ':':
            stack.append(ch)
        i -= 1
    return stack[0]


# 自动生成Solution类（无需手动编写）
Solution = create_solution(ternary_expression_parser)