# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 664
标题: Strange Printer
难度: hard
链接: https://leetcode.cn/problems/strange-printer/
题目类型: 字符串、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
664. 奇怪的打印机 - 有台奇怪的打印机有以下两个特殊要求： * 打印机每次只能打印由 同一个字符 组成的序列。 * 每次可以在从起始到结束的任意位置打印新字符，并且会覆盖掉原来已有的字符。 给你一个字符串 s ，你的任务是计算这个打印机打印它需要的最少打印次数。 示例 1： 输入：s = "aaabbb" 输出：2 解释：首先打印 "aaa" 然后打印 "bbb"。 示例 2： 输入：s = "aba" 输出：2 解释：首先打印 "aaa" 然后在第二个位置打印 "b" 覆盖掉原来的字符 'a'。 提示： * 1 <= s.length <= 100 * s 由小写英文字母组成
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 动态规划

算法步骤:
1. 定义 dp[i][j] 表示打印 s[i:j+1] 的最小打印次数。
2. 初始化 dp 数组，dp[i][i] = 1，因为单个字符只需要一次打印。
3. 从长度为 2 的子串开始，逐步增加子串长度，计算每个子串的最小打印次数。
4. 对于每个子串 s[i:j+1]，如果 s[i] == s[j]，则 dp[i][j] = dp[i][j-1]，否则 dp[i][j] = min(dp[i][k] + dp[k+1][j]) for i <= k < j。

关键点:
- 利用 dp 数组记录子问题的解，避免重复计算。
- 通过状态转移方程优化计算过程。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^3)，其中 n 是字符串 s 的长度。三重循环的时间复杂度。
空间复杂度: O(n^2)，用于存储 dp 数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def strange_printer(s: str) -> int:
    """
    函数式接口 - 计算打印字符串 s 所需的最少打印次数
    """
    n = len(s)
    if n == 0:
        return 0

    # 初始化 dp 数组
    dp = [[0] * n for _ in range(n)]

    # 单个字符的打印次数为 1
    for i in range(n):
        dp[i][i] = 1

    # 逐步增加子串长度
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            dp[i][j] = dp[i][j - 1] + 1
            for k in range(i, j):
                if s[k] == s[j]:
                    dp[i][j] = min(dp[i][j], dp[i][k] + (dp[k + 1][j - 1] if k < j - 1 else 0))

    return dp[0][n - 1]


Solution = create_solution(strange_printer)