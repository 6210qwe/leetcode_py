# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1061
标题: Number of Valid Subarrays
难度: hard
链接: https://leetcode.cn/problems/number-of-valid-subarrays/
题目类型: 栈、数组、单调栈
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
给定一个整数数组 nums，返回其中“有效”子数组的个数。如果一个子数组中所有元素都大于等于其左边的所有元素，则该子数组为“有效”子数组。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用单调栈来维护一个递增的子数组序列。

算法步骤:
1. 初始化一个栈和结果计数器。
2. 遍历数组中的每个元素：
   - 如果当前元素小于栈顶元素，则弹出栈顶元素，并计算以弹出元素为结尾的有效子数组数量。
   - 将当前元素及其索引压入栈中。
3. 遍历结束后，栈中剩余的元素也构成有效子数组，计算这些子数组的数量。
4. 返回结果计数器的值。

关键点:
- 使用单调栈来维护递增的子数组序列。
- 每次弹出栈顶元素时，计算以该元素为结尾的有效子数组数量。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是数组的长度。每个元素最多被压入和弹出栈一次。
空间复杂度: O(n)，最坏情况下栈中会存储所有的元素。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(nums: List[int]) -> int:
    """
    函数式接口 - 计算有效子数组的数目
    """
    stack = []
    result = 0
    
    for i, num in enumerate(nums):
        while stack and nums[stack[-1]] > num:
            j = stack.pop()
            result += i - j
        stack.append(i)
    
    while stack:
        j = stack.pop()
        result += len(nums) - j
    
    return result


Solution = create_solution(solution_function_name)