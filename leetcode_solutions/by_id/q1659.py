# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1659
标题: Get the Maximum Score
难度: hard
链接: https://leetcode.cn/problems/get-the-maximum-score/
题目类型: 贪心、数组、双指针、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1537. 最大得分 - 你有两个 有序 且数组内元素互不相同的数组 nums1 和 nums2 。 一条 合法路径 定义如下： * 选择数组 nums1 或者 nums2 开始遍历（从下标 0 处开始）。 * 从左到右遍历当前数组。 * 如果你遇到了 nums1 和 nums2 中都存在的值，那么你可以切换路径到另一个数组对应数字处继续遍历（但在合法路径中重复数字只会被统计一次）。 得分 定义为合法路径中不同数字的和。 请你返回 所有可能 合法路径 中的最大得分。由于答案可能很大，请你将它对 10^9 + 7 取余后返回。 示例 1： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/08/02/sample_1_1893.png] 输入：nums1 = [2,4,5,8,10], nums2 = [4,6,8,9] 输出：30 解释：合法路径包括： [2,4,5,8,10], [2,4,5,8,9], [2,4,6,8,9], [2,4,6,8,10],（从 nums1 开始遍历） [4,6,8,9], [4,5,8,10], [4,5,8,9], [4,6,8,10] （从 nums2 开始遍历） 最大得分为上图中的绿色路径 [2,4,6,8,10] 。 示例 2： 输入：nums1 = [1,3,5,7,9], nums2 = [3,5,100] 输出：109 解释：最大得分由路径 [1,3,5,100] 得到。 示例 3： 输入：nums1 = [1,2,3,4,5], nums2 = [6,7,8,9,10] 输出：40 解释：nums1 和 nums2 之间无相同数字。 最大得分由路径[6,7,8,9,10]得到。 提示： * 1 <= nums1.length, nums2.length <= 105 * 1 <= nums1[i], nums2[i] <= 107 * nums1 和 nums2 都是严格递增的数组。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用双指针遍历两个数组，并在遇到相同元素时进行路径切换。

算法步骤:
1. 初始化两个指针 i 和 j 分别指向 nums1 和 nums2 的起始位置。
2. 初始化两个变量 sum1 和 sum2 分别记录从 nums1 和 nums2 当前位置到下一个相同元素的和。
3. 遍历两个数组，直到其中一个数组遍历完：
   - 如果 nums1[i] < nums2[j]，则将 nums1[i] 加入 sum1 并移动 i。
   - 如果 nums1[i] > nums2[j]，则将 nums2[j] 加入 sum2 并移动 j。
   - 如果 nums1[i] == nums2[j]，则选择 sum1 和 sum2 中较大的一个加上 nums1[i]，并重置 sum1 和 sum2。
4. 处理剩余未遍历完的数组部分。
5. 返回最终结果并对 10^9 + 7 取余。

关键点:
- 使用双指针遍历两个数组，确保路径切换时的正确性。
- 在遇到相同元素时，选择较大的路径和。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n + m)，其中 n 和 m 分别是 nums1 和 nums2 的长度。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution

MOD = 10**9 + 7

def get_maximum_score(nums1: List[int], nums2: List[int]) -> int:
    """
    函数式接口 - 获取最大得分
    """
    i, j = 0, 0
    sum1, sum2 = 0, 0
    result = 0
    
    while i < len(nums1) and j < len(nums2):
        if nums1[i] < nums2[j]:
            sum1 += nums1[i]
            i += 1
        elif nums1[i] > nums2[j]:
            sum2 += nums2[j]
            j += 1
        else:
            result += max(sum1, sum2) + nums1[i]
            sum1, sum2 = 0, 0
            i += 1
            j += 1
    
    # 处理剩余的数组部分
    while i < len(nums1):
        sum1 += nums1[i]
        i += 1
    while j < len(nums2):
        sum2 += nums2[j]
        j += 1
    
    result += max(sum1, sum2)
    return result % MOD

Solution = create_solution(get_maximum_score)