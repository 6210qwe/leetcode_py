# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000230
标题: 比特位计数
难度: easy
链接: https://leetcode.cn/problems/w3tCBm/
题目类型: 位运算、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCR 003. 比特位计数 - 给定一个非负整数 n ，请计算 0 到 n 之间的每个数字的二进制表示中 1 的个数，并输出一个数组。 示例 1: 输入: n = 2 输出: [0,1,1] 解释: 0 --> 0 1 --> 1 2 --> 10 示例 2: 输入: n = 5 输出: [0,1,1,2,1,2] 解释: 0 --> 0 1 --> 1 2 --> 10 3 --> 11 4 --> 100 5 --> 101 说明 : * 0 <= n <= 105 进阶: * 给出时间复杂度为 O(n*sizeof(integer)) 的解答非常容易。但你可以在线性时间 O(n) 内用一趟扫描做到吗？ * 要求算法的空间复杂度为 O(n) 。 * 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount ）来执行此操作。 注意：本题与主站 338 题相同：https://leetcode.cn/problems/counting-bits/ [https://leetcode.cn/problems/counting-bits/]
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 动态规划利用最低位关系

算法步骤:
1. 定义数组 dp，dp[i] 表示数字 i 的二进制中 1 的个数
2. 递推关系：
   - dp[0] = 0
   - 对于 i > 0，有 dp[i] = dp[i >> 1] + (i & 1)
     因为 i 右移一位相当于去掉最低位，比特和只多出最低位是否为 1
3. 从 1 到 n 依次计算 dp[i] 并填入数组
4. 返回 dp 数组

关键点:
- 利用 i >> 1 和 i & 1 的关系可以在 O(1) 时间从 dp[i >> 1] 得到 dp[i]
- 整体只需线性遍历一次 0..n
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 线性遍历 0..n
空间复杂度: O(n) - 存储结果数组
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def count_bits(n: int) -> List[int]:
    """
    函数式接口 - 比特位计数
    """
    dp = [0] * (n + 1)
    for i in range(1, n + 1):
        dp[i] = dp[i >> 1] + (i & 1)
    return dp


Solution = create_solution(count_bits)
