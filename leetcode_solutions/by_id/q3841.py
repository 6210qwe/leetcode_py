# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3841
标题: Concatenated Divisibility
难度: hard
链接: https://leetcode.cn/problems/concatenated-divisibility/
题目类型: 位运算、数组、动态规划、状态压缩
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3533. 判断连接可整除性 - 给你一个正整数数组 nums 和一个正整数 k。 当 nums 的一个 排列 中的所有数字，按照排列顺序 连接其十进制表示 后形成的数可以 被 k 整除时，我们称该排列形成了一个 可整除连接 。 返回能够形成 可整除连接 且 字典序 最小 的排列（按整数列表的形式表示）。如果不存在这样的排列，返回一个空列表。 示例 1： 输入: nums = [3,12,45], k = 5 输出: [3,12,45] 解释: 排列 连接后的值 是否能被 5 整除 [3, 12, 45] 31245 是 [3, 45, 12] 34512 否 [12, 3, 45] 12345 是 [12, 45, 3] 12453 否 [45, 3, 12] 45312 否 [45, 12, 3] 45123 否 可以形成可整除连接且字典序最小的排列是 [3,12,45]。 示例 2： 输入: nums = [10,5], k = 10 输出: [5,10] 解释: 排列 连接后的值 是否能被 10 整除 [5, 10] 510 是 [10, 5] 105 否 可以形成可整除连接且字典序最小的排列是 [5,10]。 示例 3： 输入: nums = [1,2,3], k = 5 输出: [] 解释: 由于不存在任何可以形成有效可整除连接的排列，因此返回空列表。 提示： * 1 <= nums.length <= 13 * 1 <= nums[i] <= 105 * 1 <= k <= 100
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用深度优先搜索（DFS）和状态压缩来找到满足条件的排列，并通过剪枝优化搜索过程。

算法步骤:
1. 将每个数字转换为字符串形式，以便于后续拼接。
2. 使用DFS进行搜索，维护当前状态和当前余数。
3. 在每一步中，选择一个未使用的数字，更新当前状态和余数，并递归继续搜索。
4. 如果找到一个满足条件的排列，记录并返回结果。
5. 通过剪枝优化搜索过程，避免不必要的计算。

关键点:
- 使用状态压缩来表示当前已使用的数字集合。
- 通过余数来判断当前拼接的数是否满足条件。
- 通过剪枝优化搜索过程，提高效率。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n! * n)，其中n是nums的长度。最坏情况下需要遍历所有排列。
空间复杂度: O(n)，递归调用栈的深度最多为n。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution

def smallest_divisible_permutation(nums: List[int], k: int) -> List[int]:
    def dfs(index, path, used, remainder):
        if index == len(nums):
            if remainder == 0:
                result.append(path[:])
            return
        for i in range(len(nums)):
            if not used & (1 << i):
                new_remainder = (remainder * 10 + nums[i]) % k
                used |= 1 << i
                path.append(nums[i])
                dfs(index + 1, path, used, new_remainder)
                path.pop()
                used &= ~(1 << i)

    nums = [str(num) for num in nums]
    result = []
    dfs(0, [], 0, 0)
    return min(result, default=[])

Solution = create_solution(smallest_divisible_permutation)