# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3380
标题: Shortest Subarray With OR at Least K II
难度: medium
链接: https://leetcode.cn/problems/shortest-subarray-with-or-at-least-k-ii/
题目类型: 位运算、数组、滑动窗口
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3097. 或值至少为 K 的最短子数组 II - 给你一个 非负 整数数组 nums 和一个整数 k 。 如果一个数组中所有元素的按位或运算 OR 的值 至少 为 k ，那么我们称这个数组是 特别的 。 请你返回 nums 中 最短特别非空 子数组的长度，如果特别子数组不存在，那么返回 -1 。 示例 1： 输入：nums = [1,2,3], k = 2 输出：1 解释： 子数组 [3] 的按位 OR 值为 3 ，所以我们返回 1 。 示例 2： 输入：nums = [2,1,8], k = 10 输出：3 解释： 子数组 [2,1,8] 的按位 OR 值为 11 ，所以我们返回 3 。 示例 3： 输入：nums = [1,2], k = 0 输出：1 解释： 子数组 [1] 的按位 OR 值为 1 ，所以我们返回 1 。 提示： * 1 <= nums.length <= 2 * 105 * 0 <= nums[i] <= 109 * 0 <= k <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用滑动窗口来找到满足条件的最短子数组。

算法步骤:
1. 初始化两个指针 left 和 right，分别表示滑动窗口的左右边界。
2. 初始化一个变量 or_value 来存储当前窗口内的按位或值。
3. 移动右指针扩展窗口，更新 or_value。
4. 当 or_value >= k 时，尝试收缩左指针以找到最短子数组。
5. 记录最短子数组的长度。
6. 如果遍历完数组仍未找到满足条件的子数组，返回 -1。

关键点:
- 使用滑动窗口来动态调整子数组的大小。
- 通过按位或操作来快速计算当前窗口的 OR 值。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(1)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def shortest_subarray_with_or_at_least_k(nums: List[int], k: int) -> int:
    """
    函数式接口 - 找到或值至少为 k 的最短子数组
    """
    n = len(nums)
    left = 0
    or_value = 0
    min_length = float('inf')

    for right in range(n):
        or_value |= nums[right]
        while or_value >= k:
            min_length = min(min_length, right - left + 1)
            or_value ^= nums[left]
            left += 1

    return min_length if min_length != float('inf') else -1


Solution = create_solution(shortest_subarray_with_or_at_least_k)