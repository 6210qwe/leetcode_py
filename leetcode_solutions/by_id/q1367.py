# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1367
标题: Maximum Height by Stacking Cuboids
难度: hard
链接: https://leetcode.cn/problems/maximum-height-by-stacking-cuboids/
题目类型: 数组、动态规划、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1691. 堆叠长方体的最大高度 - 给你 n 个长方体 cuboids ，其中第 i 个长方体的长宽高表示为 cuboids[i] = [widthi, lengthi, heighti]（下标从 0 开始）。请你从 cuboids 选出一个 子集 ，并将它们堆叠起来。 如果 widthi <= widthj 且 lengthi <= lengthj 且 heighti <= heightj ，你就可以将长方体 i 堆叠在长方体 j 上。你可以通过旋转把长方体的长宽高重新排列，以将它放在另一个长方体上。 返回 堆叠长方体 cuboids 可以得到的 最大高度 。 示例 1： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/12/12/image.jpg] 输入：cuboids = [[50,45,20],[95,37,53],[45,23,12]] 输出：190 解释： 第 1 个长方体放在底部，53x37 的一面朝下，高度为 95 。 第 0 个长方体放在中间，45x20 的一面朝下，高度为 50 。 第 2 个长方体放在上面，23x12 的一面朝下，高度为 45 。 总高度是 95 + 50 + 45 = 190 。 示例 2： 输入：cuboids = [[38,25,45],[76,35,3]] 输出：76 解释： 无法将任何长方体放在另一个上面。 选择第 1 个长方体然后旋转它，使 35x3 的一面朝下，其高度为 76 。 示例 3： 输入：cuboids = [[7,11,17],[7,17,11],[11,7,17],[11,17,7],[17,7,11],[17,11,7]] 输出：102 解释： 重新排列长方体后，可以看到所有长方体的尺寸都相同。 你可以把 11x7 的一面朝下，这样它们的高度就是 17 。 堆叠长方体的最大高度为 6 * 17 = 102 。 提示： * n == cuboids.length * 1 <= n <= 100 * 1 <= widthi, lengthi, heighti <= 100
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。首先对每个长方体的尺寸进行排序，确保长方体的尺寸从小到大排列。然后使用动态规划的方法，计算每个长方体作为顶部时的最大高度。

算法步骤:
1. 对每个长方体的尺寸进行排序。
2. 对所有长方体按尺寸从小到大排序。
3. 使用动态规划计算每个长方体作为顶部时的最大高度。
4. 返回最大高度。

关键点:
- 对每个长方体的尺寸进行排序，确保可以堆叠。
- 使用动态规划来计算最大高度。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2)，其中 n 是长方体的数量。排序操作的时间复杂度是 O(n log n)，动态规划部分的时间复杂度是 O(n^2)。
空间复杂度: O(n)，用于存储动态规划的状态数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(cuboids: List[List[int]]) -> int:
    """
    函数式接口 - 计算堆叠长方体的最大高度
    """
    # 对每个长方体的尺寸进行排序
    for cuboid in cuboids:
        cuboid.sort()
    
    # 按长方体的尺寸从小到大排序
    cuboids.sort()
    
    n = len(cuboids)
    dp = [0] * n
    
    # 动态规划计算最大高度
    for i in range(n):
        dp[i] = cuboids[i][2]
        for j in range(i):
            if cuboids[j][0] <= cuboids[i][0] and cuboids[j][1] <= cuboids[i][1] and cuboids[j][2] <= cuboids[i][2]:
                dp[i] = max(dp[i], dp[j] + cuboids[i][2])
    
    return max(dp)


Solution = create_solution(solution_function_name)