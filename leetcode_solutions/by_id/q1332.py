# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1332
标题: Count Vowels Permutation
难度: hard
链接: https://leetcode.cn/problems/count-vowels-permutation/
题目类型: 动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1220. 统计元音字母序列的数目 - 给你一个整数 n，请你帮忙统计一下我们可以按下述规则形成多少个长度为 n 的字符串： * 字符串中的每个字符都应当是小写元音字母（'a', 'e', 'i', 'o', 'u'） * 每个元音 'a' 后面都只能跟着 'e' * 每个元音 'e' 后面只能跟着 'a' 或者是 'i' * 每个元音 'i' 后面 不能 再跟着另一个 'i' * 每个元音 'o' 后面只能跟着 'i' 或者是 'u' * 每个元音 'u' 后面只能跟着 'a' 由于答案可能会很大，所以请你返回 模 10^9 + 7 之后的结果。 示例 1： 输入：n = 1 输出：5 解释：所有可能的字符串分别是："a", "e", "i" , "o" 和 "u"。 示例 2： 输入：n = 2 输出：10 解释：所有可能的字符串分别是："ae", "ea", "ei", "ia", "ie", "io", "iu", "oi", "ou" 和 "ua"。 示例 3： 输入：n = 5 输出：68 提示： * 1 <= n <= 2 * 10^4
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们定义 dp[i][j] 表示长度为 i+1 的以第 j 个元音字母结尾的字符串的数量。根据题目给定的规则，我们可以得到状态转移方程。

算法步骤:
1. 初始化 dp 数组，dp[0][j] = 1，表示长度为 1 的字符串有 5 种情况。
2. 根据状态转移方程更新 dp 数组。
3. 最后将 dp[n-1] 中的所有值相加，取模 10^9 + 7。

关键点:
- 状态转移方程：
  - dp[i][0] = dp[i-1][1] + dp[i-1][2] + dp[i-1][4]  # 'a' 可以跟在 'e', 'i', 'u' 后面
  - dp[i][1] = dp[i-1][0] + dp[i-1][2]                # 'e' 可以跟在 'a', 'i' 后面
  - dp[i][2] = dp[i-1][1] + dp[i-1][3]                # 'i' 可以跟在 'e', 'o' 后面
  - dp[i][3] = dp[i-1][2]                             # 'o' 可以跟在 'i' 后面
  - dp[i][4] = dp[i-1][2] + dp[i-1][3]                # 'u' 可以跟在 'i', 'o' 后面
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(1) 通过滚动数组优化
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def count_vowels_permutation(n: int) -> int:
    """
    函数式接口 - 计算长度为 n 的符合条件的元音字母序列的数量
    """
    MOD = 10**9 + 7
    if n == 1:
        return 5
    
    # 初始化 dp 数组
    dp = [1, 1, 1, 1, 1]
    
    for _ in range(2, n + 1):
        new_dp = [
            (dp[1] + dp[2] + dp[4]) % MOD,  # 'a'
            (dp[0] + dp[2]) % MOD,           # 'e'
            (dp[1] + dp[3]) % MOD,           # 'i'
            dp[2] % MOD,                     # 'o'
            (dp[2] + dp[3]) % MOD            # 'u'
        ]
        dp = new_dp
    
    return sum(dp) % MOD


Solution = create_solution(count_vowels_permutation)