# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2250
标题: K Highest Ranked Items Within a Price Range
难度: medium
链接: https://leetcode.cn/problems/k-highest-ranked-items-within-a-price-range/
题目类型: 广度优先搜索、数组、矩阵、排序、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2146. 价格范围内最高排名的 K 样物品 - 给你一个下标从 0 开始的二维整数数组 grid ，它的大小为 m x n ，表示一个商店中物品的分布图。数组中的整数含义为： * 0 表示无法穿越的一堵墙。 * 1 表示可以自由通过的一个空格子。 * 所有其他正整数表示该格子内的一样物品的价格。你可以自由经过这些格子。 从一个格子走到上下左右相邻格子花费 1 步。 同时给你一个整数数组 pricing 和 start ，其中 pricing = [low, high] 且 start = [row, col] ，表示你开始位置为 (row, col) ，同时你只对物品价格在 闭区间 [low, high] 之内的物品感兴趣。同时给你一个整数 k 。 你想知道给定范围 内 且 排名最高 的 k 件物品的 位置 。排名按照优先级从高到低的以下规则制定： 1. 距离：定义为从 start 到一件物品的最短路径需要的步数（较近 距离的排名更高）。 2. 价格：较低 价格的物品有更高优先级，但只考虑在给定范围之内的价格。 3. 行坐标：较小 行坐标的有更高优先级。 4. 列坐标：较小 列坐标的有更高优先级。 请你返回给定价格内排名最高的 k 件物品的坐标，将它们按照排名排序后返回。如果给定价格内少于 k 件物品，那么请将它们的坐标 全部 返回。 示例 1： [https://assets.leetcode.com/uploads/2021/12/16/example1drawio.png] 输入：grid = [[1,2,0,1],[1,3,0,1],[0,2,5,1]], pricing = [2,5], start = [0,0], k = 3 输出：[[0,1],[1,1],[2,1]] 解释：起点为 (0,0) 。 价格范围为 [2,5] ，我们可以选择的物品坐标为 (0,1)，(1,1)，(2,1) 和 (2,2) 。 这些物品的排名为： - (0,1) 距离为 1 - (1,1) 距离为 2 - (2,1) 距离为 3 - (2,2) 距离为 4 所以，给定价格范围内排名最高的 3 件物品的坐标为 (0,1)，(1,1) 和 (2,1) 。 示例 2： [https://assets.leetcode.com/uploads/2021/12/16/example2drawio1.png] 输入：grid = [[1,2,0,1],[1,3,3,1],[0,2,5,1]], pricing = [2,3], start = [2,3], k = 2 输出：[[2,1],[1,2]] 解释：起点为 (2,3) 。 价格范围为 [2,3] ，我们可以选择的物品坐标为 (0,1)，(1,1)，(1,2) 和 (2,1) 。 这些物品的排名为： - (2,1) 距离为 2 ，价格为 2 - (1,2) 距离为 2 ，价格为 3 - (1,1) 距离为 3 - (0,1) 距离为 4 所以，给定价格范围内排名最高的 2 件物品的坐标为 (2,1) 和 (1,2) 。 示例 3： [https://assets.leetcode.com/uploads/2021/12/30/example3.png] 输入：grid = [[1,1,1],[0,0,1],[2,3,4]], pricing = [2,3], start = [0,0], k = 3 输出：[[2,1],[2,0]] 解释：起点为 (0,0) 。 价格范围为 [2,3] ，我们可以选择的物品坐标为 (2,0) 和 (2,1) 。 这些物品的排名为： - (2,1) 距离为 5 - (2,0) 距离为 6 所以，给定价格范围内排名最高的 2 件物品的坐标为 (2,1) 和 (2,0) 。 注意，k = 3 但给定价格范围内只有 2 件物品。 提示： * m == grid.length * n == grid[i].length * 1 <= m, n <= 105 * 1 <= m * n <= 105 * 0 <= grid[i][j] <= 105 * pricing.length == 2 * 2 <= low <= high <= 105 * start.length == 2 * 0 <= row <= m - 1 * 0 <= col <= n - 1 * grid[row][col] > 0 * 1 <= k <= m * n
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用广度优先搜索 (BFS) 从起点开始遍历网格，记录符合条件的物品，并使用堆来维护排名最高的 k 个物品。

算法步骤:
1. 初始化 BFS 队列和访问标记数组。
2. 从起点开始进行 BFS 遍历，记录每个物品的距离、价格和坐标。
3. 使用堆来维护排名最高的 k 个物品。
4. 返回堆中的 k 个物品的坐标。

关键点:
- 使用 BFS 确保找到的物品距离最近。
- 使用堆来高效地维护排名最高的 k 个物品。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m * n * log k)，其中 m 和 n 分别是网格的行数和列数，k 是需要返回的物品数量。
空间复杂度: O(m * n)，用于存储访问标记数组和 BFS 队列。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def k_highest_ranked_items(grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:
    m, n = len(grid), len(grid[0])
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    visited = [[False] * n for _ in range(m)]
    queue = [start]
    visited[start[0]][start[1]] = True
    items = []
    
    while queue:
        next_queue = []
        for r, c in queue:
            if pricing[0] <= grid[r][c] <= pricing[1]:
                heapq.heappush(items, (len(next_queue), grid[r][c], r, c))
                if len(items) > k:
                    heapq.heappop(items)
            
            for dr, dc in directions:
                nr, nc = r + dr, c + dc
                if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc] and grid[nr][nc] != 0:
                    visited[nr][nc] = True
                    next_queue.append((nr, nc))
        
        queue = next_queue
    
    return [list(item[2:]) for item in sorted(items)]

Solution = create_solution(k_highest_ranked_items)