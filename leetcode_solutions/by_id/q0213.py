# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 213
标题: House Robber II
难度: medium
链接: https://leetcode.cn/problems/house-robber-ii/
题目类型: 数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
213. 打家劫舍 II - 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。 给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。 示例 1： 输入：nums = [2,3,2] 输出：3 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例 2： 输入：nums = [1,2,3,1] 输出：4 解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 3： 输入：nums = [1,2,3] 输出：3 提示： * 1 <= nums.length <= 100 * 0 <= nums[i] <= 1000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 动态规划，由于首尾相连，分两种情况：不偷第一间或不偷最后一间

算法步骤:
1. 情况1: 不偷第一间，可以偷最后一间，计算nums[1:]的最大值
2. 情况2: 不偷最后一间，可以偷第一间，计算nums[:-1]的最大值
3. 取两种情况的最大值
4. 特殊情况：只有一间房，直接返回

关键点:
- 将环形问题转化为两个线性问题
- 时间复杂度O(n)，空间复杂度O(1)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 需要遍历数组两次
空间复杂度: O(1) - 只使用常数额外空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from leetcode_solutions.utils.solution import create_solution


def house_robber_ii(nums: List[int]) -> int:
    """
    函数式接口 - 打家劫舍II（环形）
    
    实现思路:
    动态规划，由于首尾相连，分两种情况：不偷第一间或不偷最后一间。
    
    Args:
        nums: 代表每个房屋存放金额的非负整数数组
        
    Returns:
        不触动警报装置的情况下，一夜之内能够偷窃到的最高金额
        
    Example:
        >>> house_robber_ii([2, 3, 2])
        3
    """
    if not nums:
        return 0
    if len(nums) == 1:
        return nums[0]
    
    def rob_linear(houses):
        """线性打家劫舍"""
        prev2 = 0
        prev1 = 0
        for num in houses:
            current = max(prev1, prev2 + num)
            prev2 = prev1
            prev1 = current
        return prev1
    
    # 情况1: 不偷第一间
    case1 = rob_linear(nums[1:])
    # 情况2: 不偷最后一间
    case2 = rob_linear(nums[:-1])
    
    return max(case1, case2)


# 自动生成Solution类（无需手动编写）
Solution = create_solution(house_robber_ii)
