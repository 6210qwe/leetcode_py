# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2096
标题: Find the Longest Valid Obstacle Course at Each Position
难度: hard
链接: https://leetcode.cn/problems/find-the-longest-valid-obstacle-course-at-each-position/
题目类型: 树状数组、数组、二分查找
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1964. 找出到每个位置为止最长的有效障碍赛跑路线 - 你打算构建一些障碍赛跑路线。给你一个 下标从 0 开始 的整数数组 obstacles ，数组长度为 n ，其中 obstacles[i] 表示第 i 个障碍的高度。 对于每个介于 0 和 n - 1 之间（包含 0 和 n - 1）的下标 i ，在满足下述条件的前提下，请你找出 obstacles 能构成的最长障碍路线的长度： * 你可以选择下标介于 0 到 i 之间（包含 0 和 i）的任意个障碍。 * 在这条路线中，必须包含第 i 个障碍。 * 你必须按障碍在 obstacles 中的 出现顺序 布置这些障碍。 * 除第一个障碍外，路线中每个障碍的高度都必须和前一个障碍 相同 或者 更高 。 返回长度为 n 的答案数组 ans ，其中 ans[i] 是上面所述的下标 i 对应的最长障碍赛跑路线的长度。 示例 1： 输入：obstacles = [1,2,3,2] 输出：[1,2,3,3] 解释：每个位置的最长有效障碍路线是： - i = 0: [1], [1] 长度为 1 - i = 1: [1,2], [1,2] 长度为 2 - i = 2: [1,2,3], [1,2,3] 长度为 3 - i = 3: [1,2,3,2], [1,2,2] 长度为 3 示例 2： 输入：obstacles = [2,2,1] 输出：[1,2,1] 解释：每个位置的最长有效障碍路线是： - i = 0: [2], [2] 长度为 1 - i = 1: [2,2], [2,2] 长度为 2 - i = 2: [2,2,1], [1] 长度为 1 示例 3： 输入：obstacles = [3,1,5,6,4,2] 输出：[1,1,2,3,2,2] 解释：每个位置的最长有效障碍路线是： - i = 0: [3], [3] 长度为 1 - i = 1: [3,1], [1] 长度为 1 - i = 2: [3,1,5], [3,5] 长度为 2, [1,5] 也是有效的障碍赛跑路线 - i = 3: [3,1,5,6], [3,5,6] 长度为 3, [1,5,6] 也是有效的障碍赛跑路线 - i = 4: [3,1,5,6,4], [3,4] 长度为 2, [1,4] 也是有效的障碍赛跑路线 - i = 5: [3,1,5,6,4,2], [1,2] 长度为 2 提示： * n == obstacles.length * 1 <= n <= 105 * 1 <= obstacles[i] <= 107
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划和二分查找来解决这个问题。

算法步骤:
1. 初始化一个空列表 `dp` 来存储当前的最长递增子序列。
2. 遍历 `obstacles` 数组，对于每个障碍高度 `h`：
   - 使用二分查找找到 `dp` 中第一个大于等于 `h` 的位置 `idx`。
   - 如果 `idx` 等于 `dp` 的长度，说明 `h` 可以延长当前的最长递增子序列，将其添加到 `dp` 中。
   - 否则，更新 `dp[idx]` 为 `h`。
   - 将 `idx + 1` 添加到结果数组 `ans` 中。
3. 返回结果数组 `ans`。

关键点:
- 使用二分查找来优化查找过程，使得时间复杂度降到 O(n log n)。
- `dp` 数组用于存储当前的最长递增子序列，从而避免重复计算。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是 obstacles 的长度。遍历 obstacles 需要 O(n) 时间，每次二分查找需要 O(log n) 时间。
空间复杂度: O(n)，`dp` 数组的空间复杂度为 O(n)。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import bisect


def solution_function_name(obstacles: List[int]) -> List[int]:
    """
    函数式接口 - 找出到每个位置为止最长的有效障碍赛跑路线
    """
    dp = []
    ans = []

    for h in obstacles:
        idx = bisect.bisect_right(dp, h)
        if idx == len(dp):
            dp.append(h)
        else:
            dp[idx] = h
        ans.append(idx + 1)

    return ans


Solution = create_solution(solution_function_name)