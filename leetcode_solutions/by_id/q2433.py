# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2433
标题: Best Poker Hand
难度: easy
链接: https://leetcode.cn/problems/best-poker-hand/
题目类型: 数组、哈希表、计数
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2347. 最好的扑克手牌 - 给你一个整数数组 ranks 和一个字符数组 suit 。你有 5 张扑克牌，第 i 张牌大小为 ranks[i] ，花色为 suits[i] 。 下述是从好到坏你可能持有的 手牌类型 ： 1. "Flush"：同花，五张相同花色的扑克牌。 2. "Three of a Kind"：三条，有 3 张大小相同的扑克牌。 3. "Pair"：对子，两张大小一样的扑克牌。 4. "High Card"：高牌，五张大小互不相同的扑克牌。 请你返回一个字符串，表示给定的 5 张牌中，你能组成的 最好手牌类型 。 注意：返回的字符串 大小写 需与题目描述相同。 示例 1： 输入：ranks = [13,2,3,1,9], suits = ["a","a","a","a","a"] 输出："Flush" 解释：5 张扑克牌的花色相同，所以返回 "Flush" 。 示例 2： 输入：ranks = [4,4,2,4,4], suits = ["d","a","a","b","c"] 输出："Three of a Kind" 解释：第一、二和四张牌组成三张相同大小的扑克牌，所以得到 "Three of a Kind" 。 注意我们也可以得到 "Pair" ，但是 "Three of a Kind" 是更好的手牌类型。 有其他的 3 张牌也可以组成 "Three of a Kind" 手牌类型。 示例 3： 输入：ranks = [10,10,2,12,9], suits = ["a","b","c","a","d"] 输出："Pair" 解释：第一和第二张牌大小相同，所以得到 "Pair" 。 我们无法得到 "Flush" 或者 "Three of a Kind" 。 提示： * ranks.length == suits.length == 5 * 1 <= ranks[i] <= 13 * 'a' <= suits[i] <= 'd' * 任意两张扑克牌不会同时有相同的大小和花色。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过检查花色是否一致来判断是否为同花，然后通过计数牌面大小来判断是否有三条或对子。

算法步骤:
1. 检查所有花色是否相同，如果相同则返回 "Flush"。
2. 使用哈希表统计每个牌面大小出现的次数。
3. 根据牌面大小的统计结果，判断是否存在三条或对子，返回相应的手牌类型。
4. 如果没有找到上述手牌类型，则返回 "High Card"。

关键点:
- 使用集合来快速检查花色是否一致。
- 使用字典来统计牌面大小的出现次数。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(1) - 因为输入大小固定为 5，所以时间复杂度是常数级的。
空间复杂度: O(1) - 使用的额外空间也是常数级的。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def best_poker_hand(ranks: List[int], suits: List[str]) -> str:
    """
    返回给定的 5 张牌中，能组成的最好手牌类型。
    """
    # 检查是否为同花
    if len(set(suits)) == 1:
        return "Flush"
    
    # 统计每个牌面大小出现的次数
    rank_count = {}
    for rank in ranks:
        if rank in rank_count:
            rank_count[rank] += 1
        else:
            rank_count[rank] = 1
    
    # 检查是否有三条
    for count in rank_count.values():
        if count >= 3:
            return "Three of a Kind"
    
    # 检查是否有对子
    for count in rank_count.values():
        if count == 2:
            return "Pair"
    
    # 如果没有找到上述手牌类型，则返回 "High Card"
    return "High Card"


Solution = create_solution(best_poker_hand)