# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1800
标题: Concatenation of Consecutive Binary Numbers
难度: medium
链接: https://leetcode.cn/problems/concatenation-of-consecutive-binary-numbers/
题目类型: 位运算、数学、模拟
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1680. 连接连续二进制数字 - 给你一个整数 n ，请你将 1 到 n 的二进制表示连接起来，并返回连接结果对应的 十进制 数字对 109 + 7 取余的结果。 示例 1： 输入：n = 1 输出：1 解释：二进制的 "1" 对应着十进制的 1 。 示例 2： 输入：n = 3 输出：27 解释：二进制下，1，2 和 3 分别对应 "1" ，"10" 和 "11" 。 将它们依次连接，我们得到 "11011" ，对应着十进制的 27 。 示例 3： 输入：n = 12 输出：505379714 解释：连接结果为 "1101110010111011110001001101010111100" 。 对应的十进制数字为 118505380540 。 对 109 + 7 取余后，结果为 505379714 。 提示： * 1 <= n <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 模拟连接过程，每次左移并加上新数字

算法步骤:
1. 遍历1到n
2. 对于每个数字i，计算其二进制长度
3. 将结果左移相应位数，然后加上i
4. 取模防止溢出

关键点:
- 位运算
- 模运算
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n*log n) - n为数字，log n为平均二进制长度
空间复杂度: O(1) - 只使用常数额外空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def concatenated_binary(n: int) -> int:
    """
    函数式接口 - 连接连续二进制数字
    
    实现思路:
    模拟连接过程，每次左移并加上新数字。
    
    Args:
        n: 整数
        
    Returns:
        连接结果对10^9+7取余
        
    Example:
        >>> concatenated_binary(3)
        27
    """
    MOD = 10**9 + 7
    result = 0
    
    for i in range(1, n + 1):
        # 计算i的二进制长度
        length = i.bit_length()
        # 左移并加上i
        result = ((result << length) + i) % MOD
    
    return result


Solution = create_solution(concatenated_binary)
