# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1140
标题: Distant Barcodes
难度: medium
链接: https://leetcode.cn/problems/distant-barcodes/
题目类型: 贪心、数组、哈希表、计数、排序、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1054. 距离相等的条形码 - 在一个仓库里，有一排条形码，其中第 i 个条形码为 barcodes[i]。 请你重新排列这些条形码，使其中任意两个相邻的条形码不能相等。 你可以返回任何满足该要求的答案，此题保证存在答案。 示例 1： 输入：barcodes = [1,1,1,2,2,2] 输出：[2,1,2,1,2,1] 示例 2： 输入：barcodes = [1,1,1,1,2,2,3,3] 输出：[1,3,1,3,2,1,2,1] 提示： * 1 <= barcodes.length <= 10000 * 1 <= barcodes[i] <= 10000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用最大堆来确保频率最高的条形码尽可能分散。

算法步骤:
1. 统计每个条形码的频率。
2. 使用最大堆存储条形码及其频率。
3. 每次从堆中取出频率最高的两个条形码，将它们依次放入结果数组中，并更新其频率。
4. 如果某个条形码的频率仍未为0，则将其重新放回堆中。
5. 重复上述过程直到堆为空。

关键点:
- 使用最大堆来确保频率最高的条形码尽可能分散。
- 每次处理两个条形码以确保相邻条形码不相同。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log k)，其中 n 是条形码的数量，k 是不同条形码的数量。
空间复杂度: O(n)，用于存储条形码的频率和结果数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def rearrange_barcodes(barcodes: List[int]) -> List[int]:
    """
    函数式接口 - 重新排列条形码，使任意两个相邻的条形码不相等。
    """
    # 统计每个条形码的频率
    frequency = {}
    for barcode in barcodes:
        if barcode in frequency:
            frequency[barcode] += 1
        else:
            frequency[barcode] = 1
    
    # 使用最大堆存储条形码及其频率
    max_heap = []
    for barcode, freq in frequency.items():
        heapq.heappush(max_heap, (-freq, barcode))
    
    result = []
    while len(max_heap) > 1:
        # 取出频率最高的两个条形码
        freq1, barcode1 = heapq.heappop(max_heap)
        freq2, barcode2 = heapq.heappop(max_heap)
        
        # 将它们依次放入结果数组中
        result.append(barcode1)
        result.append(barcode2)
        
        # 更新频率
        if freq1 + 1 < 0:
            heapq.heappush(max_heap, (freq1 + 1, barcode1))
        if freq2 + 1 < 0:
            heapq.heappush(max_heap, (freq2 + 1, barcode2))
    
    # 如果堆中还有剩余的条形码
    if max_heap:
        freq, barcode = heapq.heappop(max_heap)
        result.append(barcode)
    
    return result

Solution = create_solution(rearrange_barcodes)