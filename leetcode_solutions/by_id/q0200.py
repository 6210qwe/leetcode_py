# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 200
标题: Number of Islands
难度: medium
链接: https://leetcode.cn/problems/number-of-islands/
题目类型: 深度优先搜索、广度优先搜索、并查集、数组、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
200. 岛屿数量 - 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 示例 1： 输入：grid = [ ['1','1','1','1','0'], ['1','1','0','1','0'], ['1','1','0','0','0'], ['0','0','0','0','0'] ] 输出：1 示例 2： 输入：grid = [ ['1','1','0','0','0'], ['1','1','0','0','0'], ['0','0','1','0','0'], ['0','0','0','1','1'] ] 输出：3 提示： * m == grid.length * n == grid[i].length * 1 <= m, n <= 300 * grid[i][j] 的值为 '0' 或 '1'
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用DFS或BFS遍历所有连通的陆地，标记为已访问

算法步骤:
1. 遍历网格的每个位置
2. 如果遇到'1'（陆地），进行DFS/BFS标记所有连通的陆地
3. 每遇到一个新的岛屿，计数器加1
4. 将访问过的陆地标记为'0'避免重复计算

关键点:
- 使用DFS或BFS遍历连通区域
- 时间复杂度O(mn)，空间复杂度O(mn)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(mn) - m和n分别是网格的行数和列数
空间复杂度: O(mn) - 递归栈深度
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from leetcode_solutions.utils.solution import create_solution


def number_of_islands(grid: List[List[str]]) -> int:
    """
    函数式接口 - 计算岛屿数量
    
    实现思路:
    使用DFS遍历所有连通的陆地，标记为已访问。
    
    Args:
        grid: 二维网格，'1'表示陆地，'0'表示水
        
    Returns:
        岛屿的数量
        
    Example:
        >>> grid = [['1','1','1','1','0'], ['1','1','0','1','0'], ['1','1','0','0','0'], ['0','0','0','0','0']]
        >>> number_of_islands(grid)
        1
    """
    if not grid or not grid[0]:
        return 0
    
    m, n = len(grid), len(grid[0])
    count = 0
    
    def dfs(i: int, j: int):
        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != '1':
            return
        
        grid[i][j] = '0'  # 标记为已访问
        
        # 遍历四个方向
        dfs(i + 1, j)
        dfs(i - 1, j)
        dfs(i, j + 1)
        dfs(i, j - 1)
    
    for i in range(m):
        for j in range(n):
            if grid[i][j] == '1':
                count += 1
                dfs(i, j)
    
    return count


# 自动生成Solution类（无需手动编写）
Solution = create_solution(number_of_islands)
