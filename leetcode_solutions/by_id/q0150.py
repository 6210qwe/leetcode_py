# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 150
标题: Evaluate Reverse Polish Notation
难度: medium
链接: https://leetcode.cn/problems/evaluate-reverse-polish-notation/
题目类型: 栈、数组、数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
150. 逆波兰表达式求值 - 给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 [https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437] 表示的算术表达式。 请你计算该表达式。返回一个表示表达式值的整数。 注意： * 有效的算符为 '+'、'-'、'*' 和 '/' 。 * 每个操作数（运算对象）都可以是一个整数或者另一个表达式。 * 两个整数之间的除法总是 向零截断 。 * 表达式中不含除零运算。 * 输入是一个根据逆波兰表示法表示的算术表达式。 * 答案及所有中间计算结果可以用 32 位 整数表示。 示例 1： 输入：tokens = ["2","1","+","3","*"] 输出：9 解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9 示例 2： 输入：tokens = ["4","13","5","/","+"] 输出：6 解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6 示例 3： 输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"] 输出：22 解释：该算式转化为常见的中缀算术表达式为： ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 提示： * 1 <= tokens.length <= 104 * tokens[i] 是一个算符（"+"、"-"、"*" 或 "/"），或是在范围 [-200, 200] 内的一个整数 逆波兰表达式： 逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。 * 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。 * 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。 逆波兰表达式主要有以下两个优点： * 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。 * 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用栈，遇到数字入栈，遇到运算符弹出两个数计算

算法步骤:
1. 遍历tokens数组
2. 如果是数字，入栈
3. 如果是运算符，弹出栈顶两个数，计算结果后入栈
4. 最后栈中剩余的数就是结果

关键点:
- 注意除法向零截断
- 时间复杂度O(n)，空间复杂度O(n)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 需要遍历tokens数组一次
空间复杂度: O(n) - 栈最多存储n/2个数字
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from leetcode_solutions.utils.solution import create_solution


def evaluate_reverse_polish_notation(tokens: List[str]) -> int:
    """
    函数式接口 - 计算逆波兰表达式
    
    实现思路:
    使用栈，遇到数字入栈，遇到运算符弹出两个数计算结果后入栈。
    
    Args:
        tokens: 逆波兰表达式数组
        
    Returns:
        表达式的计算结果
        
    Example:
        >>> evaluate_reverse_polish_notation(["2", "1", "+", "3", "*"])
        9
    """
    stack = []
    
    for token in tokens:
        if token in ['+', '-', '*', '/']:
            b = stack.pop()
            a = stack.pop()
            
            if token == '+':
                stack.append(a + b)
            elif token == '-':
                stack.append(a - b)
            elif token == '*':
                stack.append(a * b)
            else:  # token == '/'
                # 向零截断
                stack.append(int(a / b))
        else:
            stack.append(int(token))
    
    return stack[0]


# 自动生成Solution类（无需手动编写）
Solution = create_solution(evaluate_reverse_polish_notation)
