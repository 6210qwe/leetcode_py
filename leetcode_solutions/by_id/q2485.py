# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2485
标题: Finding the Number of Visible Mountains
难度: medium
链接: https://leetcode.cn/problems/finding-the-number-of-visible-mountains/
题目类型: 栈、数组、排序、单调栈
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2345. 寻找可见山的数量 - 备战技术面试？力扣提供海量技术面试资源，帮助你高效提升编程技能,轻松拿下世界 IT 名企 Dream Offer。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用单调栈来处理山脉的可见性问题。首先对山脉进行排序，然后使用单调栈来判断每个山脉是否可见。

算法步骤:
1. 将山脉按照 x 坐标升序排序，如果 x 坐标相同，则按 y 坐标降序排序。
2. 初始化一个空的单调栈。
3. 遍历排序后的山脉列表，对于每个山脉：
   - 如果栈为空，或者当前山脉的 x 坐标大于栈顶山脉的 x 坐标且 y 坐标大于栈顶山脉的 y 坐标，则将当前山脉入栈。
   - 否则，跳过当前山脉。
4. 最后栈中的元素即为可见的山脉数量。

关键点:
- 排序是关键，确保 x 坐标相同的山脉中较高的在前。
- 使用单调栈来维护可见的山脉。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是山脉的数量。排序操作的时间复杂度为 O(n log n)，遍历和栈操作的时间复杂度为 O(n)。
空间复杂度: O(n)，最坏情况下栈中可能包含所有的山脉。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def count_visible_mountains(peaks: List[List[int]]) -> int:
    """
    函数式接口 - 计算可见的山脉数量
    """
    # 按 x 坐标升序排序，如果 x 坐标相同，则按 y 坐标降序排序
    peaks.sort(key=lambda p: (p[0], -p[1]))
    
    # 初始化单调栈
    stack = []
    
    for peak in peaks:
        # 如果栈为空，或者当前山脉的 x 坐标大于栈顶山脉的 x 坐标且 y 坐标大于栈顶山脉的 y 坐标
        if not stack or (peak[0] > stack[-1][0] and peak[1] > stack[-1][1]):
            stack.append(peak)
    
    return len(stack)

Solution = count_visible_mountains