# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3178
标题: Minimum Increment Operations to Make Array Beautiful
难度: medium
链接: https://leetcode.cn/problems/minimum-increment-operations-to-make-array-beautiful/
题目类型: 数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2919. 使数组变美的最小增量运算数 - 给你一个下标从 0 开始、长度为 n 的整数数组 nums ，和一个整数 k 。 你可以执行下述 递增 运算 任意 次（可以是 0 次）： * 从范围 [0, n - 1] 中选择一个下标 i ，并将 nums[i] 的值加 1 。 如果数组中任何长度 大于或等于 3 的子数组，其 最大 元素都大于或等于 k ，则认为数组是一个 美丽数组 。 以整数形式返回使数组变为 美丽数组 需要执行的 最小 递增运算数。 子数组是数组中的一个连续 非空 元素序列。 示例 1： 输入：nums = [2,3,0,0,2], k = 4 输出：3 解释：可以执行下述递增运算，使 nums 变为美丽数组： 选择下标 i = 1 ，并且将 nums[1] 的值加 1 -> [2,4,0,0,2] 。 选择下标 i = 4 ，并且将 nums[4] 的值加 1 -> [2,4,0,0,3] 。 选择下标 i = 4 ，并且将 nums[4] 的值加 1 -> [2,4,0,0,4] 。 长度大于或等于 3 的子数组为 [2,4,0], [4,0,0], [0,0,4], [2,4,0,0], [4,0,0,4], [2,4,0,0,4] 。 在所有子数组中，最大元素都等于 k = 4 ，所以 nums 现在是美丽数组。 可以证明无法用少于 3 次递增运算使 nums 变为美丽数组。 因此，答案为 3 。 示例 2： 输入：nums = [0,1,3,3], k = 5 输出：2 解释：可以执行下述递增运算，使 nums 变为美丽数组： 选择下标 i = 2 ，并且将 nums[2] 的值加 1 -> [0,1,4,3] 。 选择下标 i = 2 ，并且将 nums[2] 的值加 1 -> [0,1,5,3] 。 长度大于或等于 3 的子数组为 [0,1,5]、[1,5,3]、[0,1,5,3] 。 在所有子数组中，最大元素都等于 k = 5 ，所以 nums 现在是美丽数组。 可以证明无法用少于 2 次递增运算使 nums 变为美丽数组。 因此，答案为 2 。 示例 3： 输入：nums = [1,1,2], k = 1 输出：0 解释：在这个示例中，只有一个长度大于或等于 3 的子数组 [1,1,2] 。 其最大元素 2 已经大于 k = 1 ，所以无需执行任何增量运算。 因此，答案为 0 。 提示： * 3 <= n == nums.length <= 105 * 0 <= nums[i] <= 109 * 0 <= k <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们定义 dp[i] 为使得 nums[0:i+1] 变成美丽数组所需的最小增量次数。状态转移方程为：
dp[i] = min(dp[i-1] + max(0, k - nums[i]), dp[i-2] + max(0, k - nums[i-1]), dp[i-3] + max(0, k - nums[i-2]))

算法步骤:
1. 初始化 dp 数组，dp[0] 和 dp[1] 分别为 max(0, k - nums[0]) 和 max(0, k - nums[1])。
2. 从 i = 2 开始，使用状态转移方程计算 dp[i]。
3. 返回 dp[n-1] 作为结果。

关键点:
- 使用动态规划来避免重复计算。
- 状态转移方程考虑了前三个位置的最小增量次数。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是 nums 的长度。我们需要遍历整个数组一次。
空间复杂度: O(n)，用于存储 dp 数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def min_increment_operations(nums: List[int], k: int) -> int:
    """
    函数式接口 - 计算使数组变美的最小增量运算数
    """
    n = len(nums)
    if n < 3:
        return 0

    # 初始化 dp 数组
    dp = [0] * n
    dp[0] = max(0, k - nums[0])
    dp[1] = max(0, k - nums[1])

    for i in range(2, n):
        dp[i] = min(
            dp[i-1] + max(0, k - nums[i]),
            dp[i-2] + max(0, k - nums[i-1]),
            dp[i-3] + max(0, k - nums[i-2])
        )

    return dp[n-1]


Solution = create_solution(min_increment_operations)