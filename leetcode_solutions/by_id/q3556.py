# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3556
标题: Final Array State After K Multiplication Operations II
难度: hard
链接: https://leetcode.cn/problems/final-array-state-after-k-multiplication-operations-ii/
题目类型: 数组、模拟、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3266. K 次乘运算后的最终数组 II - 给你一个整数数组 nums ，一个整数 k 和一个整数 multiplier 。 你需要对 nums 执行 k 次操作，每次操作中： * 找到 nums 中的 最小 值 x ，如果存在多个最小值，选择最 前面 的一个。 * 将 x 替换为 x * multiplier 。 k 次操作以后，你需要将 nums 中每一个数值对 109 + 7 取余。 请你返回执行完 k 次乘运算以及取余运算之后，最终的 nums 数组。 示例 1： 输入：nums = [2,1,3,5,6], k = 5, multiplier = 2 输出：[8,4,6,5,6] 解释： 操作 结果 1 次操作后 [2, 2, 3, 5, 6] 2 次操作后 [4, 2, 3, 5, 6] 3 次操作后 [4, 4, 3, 5, 6] 4 次操作后 [4, 4, 6, 5, 6] 5 次操作后 [8, 4, 6, 5, 6] 取余操作后 [8, 4, 6, 5, 6] 示例 2： 输入：nums = [100000,2000], k = 2, multiplier = 1000000 输出：[999999307,999999993] 解释： 操作 结果 1 次操作后 [100000, 2000000000] 2 次操作后 [100000000000, 2000000000] 取余操作后 [999999307, 999999993] 提示： * 1 <= nums.length <= 104 * 1 <= nums[i] <= 109 * 1 <= k <= 109 * 1 <= multiplier <= 106
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用最小堆来维护当前数组中的最小值，并在每次操作中更新该值。

算法步骤:
1. 初始化一个最小堆，并将数组中的每个元素及其索引存入堆中。
2. 进行 k 次操作：
   - 从堆中取出最小值及其索引。
   - 计算新的值并更新数组中的对应位置。
   - 将更新后的值及其索引重新插入堆中。
3. 对数组中的每个元素进行取余操作。
4. 返回最终的数组。

关键点:
- 使用最小堆来高效地找到和更新最小值。
- 在每次操作后，需要将更新后的值重新插入堆中。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(k log n)，其中 n 是数组的长度，k 是操作次数。每次操作中，堆的插入和删除操作的时间复杂度为 O(log n)。
空间复杂度: O(n)，用于存储堆中的元素及其索引。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def final_array_state(nums: List[int], k: int, multiplier: int) -> List[int]:
    """
    函数式接口 - 返回执行完 k 次乘运算以及取余运算之后，最终的 nums 数组。
    """
    mod = 10**9 + 7
    # 初始化最小堆
    min_heap = [(num, i) for i, num in enumerate(nums)]
    heapq.heapify(min_heap)
    
    for _ in range(k):
        # 取出最小值及其索引
        val, idx = heapq.heappop(min_heap)
        # 更新值
        new_val = (val * multiplier) % mod
        # 更新数组
        nums[idx] = new_val
        # 将更新后的值及其索引重新插入堆中
        heapq.heappush(min_heap, (new_val, idx))
    
    # 对数组中的每个元素进行取余操作
    return [num % mod for num in nums]

Solution = create_solution(final_array_state)