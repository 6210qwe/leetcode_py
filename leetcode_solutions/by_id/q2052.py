# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2052
标题: Depth of BST Given Insertion Order
难度: medium
链接: https://leetcode.cn/problems/depth-of-bst-given-insertion-order/
题目类型: 树、二叉搜索树、数组、二叉树、有序集合
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1902. 给定二叉搜索树的插入顺序求深度 - 备战技术面试？力扣提供海量技术面试资源，帮助你高效提升编程技能,轻松拿下世界 IT 名企 Dream Offer。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用单调栈来维护当前节点的深度，并在插入过程中更新最大深度。

算法步骤:
1. 初始化一个空栈和一个变量 `max_depth` 来记录最大深度。
2. 遍历插入顺序数组，对于每个元素：
   - 如果栈不为空且当前元素大于栈顶元素，则弹出栈顶元素并更新当前深度。
   - 将当前元素及其深度压入栈中。
   - 更新 `max_depth` 为当前深度和 `max_depth` 的较大值。
3. 返回 `max_depth`。

关键点:
- 使用单调栈来维护当前节点的深度。
- 在插入过程中动态更新最大深度。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是插入顺序数组的长度。每个元素最多被压入和弹出栈一次。
空间复杂度: O(n)，最坏情况下栈的大小为 n。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def max_depth_bst(order: List[int]) -> int:
    """
    函数式接口 - 计算给定插入顺序的二叉搜索树的最大深度
    """
    stack = []
    max_depth = 0
    current_depth = 0
    
    for num in order:
        while stack and num > stack[-1]:
            stack.pop()
            current_depth -= 1
        current_depth += 1
        max_depth = max(max_depth, current_depth)
        stack.append(num)
    
    return max_depth

Solution = create_solution(max_depth_bst)