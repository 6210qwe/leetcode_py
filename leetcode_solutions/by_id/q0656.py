# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 656
标题: Coin Path
难度: hard
链接: https://leetcode.cn/problems/coin-path/
题目类型: 数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
656. 成本最小路径 - 备战技术面试？力扣提供海量技术面试资源，帮助你高效提升编程技能,轻松拿下世界 IT 名企 Dream Offer。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们定义 dp[i] 为到达第 i 个位置的最小成本。通过从后向前遍历数组，我们可以计算出每个位置的最小成本。

算法步骤:
1. 初始化一个 dp 数组，长度为 n+1，其中 dp[i] 表示到达第 i 个位置的最小成本。
2. 从后向前遍历数组，对于每个位置 i，尝试从 i+1 到 i+k 的所有位置，找到最小的成本。
3. 如果无法到达任何位置，则返回 -1。
4. 返回 dp[0] 作为结果。

关键点:
- 从后向前遍历可以避免重复计算。
- 使用一个辅助数组 pre 来记录前一个位置，以便构造最终路径。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * k)，其中 n 是数组的长度，k 是跳跃的最大步数。
空间复杂度: O(n)，需要两个长度为 n 的数组来存储 dp 和 pre。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional

def min_cost_path(costs: List[int], k: int) -> List[int]:
    n = len(costs)
    if n == 0:
        return []
    
    # 初始化 dp 和 pre 数组
    dp = [float('inf')] * (n + 1)
    pre = [-1] * (n + 1)
    dp[n] = 0
    
    # 从后向前遍历
    for i in range(n - 1, -1, -1):
        for j in range(1, k + 1):
            if i + j <= n and dp[i + j] < float('inf'):
                if costs[i] + dp[i + j] < dp[i]:
                    dp[i] = costs[i] + dp[i + j]
                    pre[i] = i + j
    
    # 构造路径
    if dp[0] == float('inf'):
        return [-1]
    
    path = []
    i = 0
    while i != -1:
        path.append(i)
        i = pre[i]
    
    return path

Solution = create_solution(min_cost_path)