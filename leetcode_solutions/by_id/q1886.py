# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1886
标题: Minimum Limit of Balls in a Bag
难度: medium
链接: https://leetcode.cn/problems/minimum-limit-of-balls-in-a-bag/
题目类型: 数组、二分查找
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1760. 袋子里最少数目的球 - 给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数 maxOperations 。 你可以进行如下操作至多 maxOperations 次： * 选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 正整数 个球。 * 比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。 你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。 请你返回进行上述操作后的最小开销。 示例 1： 输入：nums = [9], maxOperations = 2 输出：3 解释： - 将装有 9 个球的袋子分成装有 6 个和 3 个球的袋子。[9] -> [6,3] 。 - 将装有 6 个球的袋子分成装有 3 个和 3 个球的袋子。[6,3] -> [3,3,3] 。 装有最多球的袋子里装有 3 个球，所以开销为 3 并返回 3 。 示例 2： 输入：nums = [2,4,8,2], maxOperations = 4 输出：2 解释： - 将装有 8 个球的袋子分成装有 4 个和 4 个球的袋子。[2,4,8,2] -> [2,4,4,4,2] 。 - 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,4,4,4,2] -> [2,2,2,4,4,2] 。 - 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,4,4,2] -> [2,2,2,2,2,4,2] 。 - 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,2,2,4,2] -> [2,2,2,2,2,2,2,2] 。 装有最多球的袋子里装有 2 个球，所以开销为 2 并返回 2 。 示例 3： 输入：nums = [7,17], maxOperations = 2 输出：7 提示： * 1 <= nums.length <= 105 * 1 <= maxOperations, nums[i] <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用二分查找来确定最小的最大球数。

算法步骤:
1. 初始化二分查找的左右边界，left 为 1，right 为 nums 中的最大值。
2. 在每次迭代中，计算中间值 mid。
3. 计算将所有袋子中的球数减少到不超过 mid 所需的操作次数。
4. 如果操作次数小于等于 maxOperations，则说明可以将最大球数减少到 mid 或更小，更新 right 为 mid - 1。
5. 否则，更新 left 为 mid + 1。
6. 最终返回 left 作为结果。

关键点:
- 使用二分查找来缩小可能的最大球数范围。
- 计算所需的操作次数时，使用 (num - 1) // mid 来计算将 num 减少到不超过 mid 所需的操作次数。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log(max(nums)))，其中 n 是 nums 的长度，log(max(nums)) 是二分查找的时间复杂度。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def minimumSize(nums: List[int], maxOperations: int) -> int:
    """
    返回进行上述操作后的最小开销。
    """
    def count_operations_to_limit_max(num: int, limit: int) -> int:
        return (num - 1) // limit

    left, right = 1, max(nums)
    
    while left < right:
        mid = (left + right) // 2
        operations_needed = sum(count_operations_to_limit_max(num, mid) for num in nums)
        
        if operations_needed <= maxOperations:
            right = mid
        else:
            left = mid + 1
    
    return left

Solution = create_solution(minimumSize)