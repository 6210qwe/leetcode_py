# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 14
标题: Longest Common Prefix
难度: easy
链接: https://leetcode.cn/problems/longest-common-prefix/
题目类型: 字典树、数组、字符串
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
14. 最长公共前缀 - 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 ""。 示例 1： 输入：strs = ["flower","flow","flight"] 输出："fl" 示例 2： 输入：strs = ["dog","racecar","car"] 输出："" 解释：输入不存在公共前缀。 提示： * 1 <= strs.length <= 200 * 0 <= strs[i].length <= 200 * strs[i] 如果非空，则仅由小写英文字母组成
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 纵向扫描，比较所有字符串的相同位置字符

算法步骤:
1. 如果字符串数组为空，返回空字符串
2. 找到最短字符串的长度作为最大可能前缀长度
3. 从第一个字符开始，逐字符比较所有字符串：
   - 如果所有字符串在位置i的字符都相同，继续
   - 否则，返回strs[0][:i]
4. 如果所有字符都相同，返回最短字符串

关键点:
- 纵向扫描比横向扫描（逐个字符串比较）更高效
- 时间复杂度O(mn)，m为字符串数量，n为最短字符串长度
- 空间复杂度O(1)，只使用常数额外空间
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(mn) - m为字符串数量，n为最短字符串长度
空间复杂度: O(1) - 只使用常数额外空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from leetcode_solutions.utils.solution import create_solution


def longest_common_prefix(strs: List[str]) -> str:
    """
    函数式接口 - 纵向扫描实现
    
    实现思路:
    纵向扫描所有字符串，比较相同位置的字符，找到最长公共前缀。
    
    Args:
        strs: 字符串数组
        
    Returns:
        最长公共前缀
        
    Example:
        >>> longest_common_prefix(["flower","flow","flight"])
        'fl'
        >>> longest_common_prefix(["dog","racecar","car"])
        ''
    """
    if not strs:
        return ""
    
    # 找到最短字符串的长度
    min_len = min(len(s) for s in strs)
    
    # 纵向扫描
    for i in range(min_len):
        char = strs[0][i]
        # 检查所有字符串在位置i的字符是否相同
        if not all(s[i] == char for s in strs):
            return strs[0][:i]
    
    # 所有字符都相同，返回最短字符串
    return strs[0][:min_len]


# 自动生成Solution类（无需手动编写）
Solution = create_solution(longest_common_prefix)
