# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 922
标题: Possible Bipartition
难度: medium
链接: https://leetcode.cn/problems/possible-bipartition/
题目类型: 深度优先搜索、广度优先搜索、并查集、图
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
886. 可能的二分法 - 给定一组 n 人（编号为 1, 2, ..., n）， 我们想把每个人分进任意大小的两组。每个人都可能不喜欢其他人，那么他们不应该属于同一组。 给定整数 n 和数组 dislikes ，其中 dislikes[i] = [ai, bi] ，表示不允许将编号为 ai 和 bi的人归入同一组。当可以用这种方法将所有人分进两组时，返回 true；否则返回 false。 示例 1： 输入：n = 4, dislikes = [[1,2],[1,3],[2,4]] 输出：true 解释：group1 [1,4], group2 [2,3] 示例 2： 输入：n = 3, dislikes = [[1,2],[1,3],[2,3]] 输出：false 示例 3： 输入：n = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]] 输出：false 提示： * 1 <= n <= 2000 * 0 <= dislikes.length <= 104 * dislikes[i].length == 2 * 1 <= dislikes[i][j] <= n * ai < bi * dislikes 中每一组都 不同
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用深度优先搜索 (DFS) 或广度优先搜索 (BFS) 对图进行二分染色，判断是否可以将图分成两个集合。

算法步骤:
1. 构建图的邻接表表示。
2. 初始化颜色数组，用于记录每个节点的颜色（未访问、红色、蓝色）。
3. 遍历每个节点，如果该节点未被访问过，则从该节点开始进行 DFS 或 BFS，尝试对其进行染色。
4. 在染色过程中，如果发现相邻节点已经染了相同的颜色，则说明无法进行二分染色，返回 False。
5. 如果所有节点都能成功染色，则返回 True。

关键点:
- 使用邻接表表示图，方便进行遍历。
- 使用颜色数组记录每个节点的状态，避免重复访问和冲突。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(V + E)，其中 V 是节点数，E 是边数。我们需要遍历所有节点和边。
空间复杂度: O(V + E)，存储图的邻接表和颜色数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def possible_bipartition(n: int, dislikes: List[List[int]]) -> bool:
    """
    判断是否可以将给定的 n 个人分成两组，使得每对不喜欢的人不在同一组。
    """
    # 构建图的邻接表
    graph = [[] for _ in range(n + 1)]
    for u, v in dislikes:
        graph[u].append(v)
        graph[v].append(u)

    # 定义颜色数组
    colors = [0] * (n + 1)  # 0: 未访问, 1: 红色, -1: 蓝色

    def dfs(node: int, color: int) -> bool:
        if colors[node] != 0:
            return colors[node] == color
        colors[node] = color
        for neighbor in graph[node]:
            if not dfs(neighbor, -color):
                return False
        return True

    for i in range(1, n + 1):
        if colors[i] == 0 and not dfs(i, 1):
            return False

    return True

Solution = create_solution(possible_bipartition)