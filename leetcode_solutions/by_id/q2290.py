# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2290
标题: Removing Minimum Number of Magic Beans
难度: medium
链接: https://leetcode.cn/problems/removing-minimum-number-of-magic-beans/
题目类型: 贪心、数组、枚举、前缀和、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2171. 拿出最少数目的魔法豆 - 给定一个 正整数 数组 beans ，其中每个整数表示一个袋子里装的魔法豆的数目。 请你从每个袋子中 拿出 一些豆子（也可以 不拿出），使得剩下的 非空 袋子中（即 至少还有一颗 魔法豆的袋子）魔法豆的数目 相等。一旦把魔法豆从袋子中取出，你不能再将它放到任何袋子中。 请返回你需要拿出魔法豆的 最少数目。 示例 1： 输入：beans = [4,1,6,5] 输出：4 解释： - 我们从有 1 个魔法豆的袋子中拿出 1 颗魔法豆。 剩下袋子中魔法豆的数目为：[4,0,6,5] - 然后我们从有 6 个魔法豆的袋子中拿出 2 个魔法豆。 剩下袋子中魔法豆的数目为：[4,0,4,5] - 然后我们从有 5 个魔法豆的袋子中拿出 1 个魔法豆。 剩下袋子中魔法豆的数目为：[4,0,4,4] 总共拿出了 1 + 2 + 1 = 4 个魔法豆，剩下非空袋子中魔法豆的数目相等。 没有比取出 4 个魔法豆更少的方案。 示例 2： 输入：beans = [2,10,3,2] 输出：7 解释： - 我们从有 2 个魔法豆的其中一个袋子中拿出 2 个魔法豆。 剩下袋子中魔法豆的数目为：[0,10,3,2] - 然后我们从另一个有 2 个魔法豆的袋子中拿出 2 个魔法豆。 剩下袋子中魔法豆的数目为：[0,10,3,0] - 然后我们从有 3 个魔法豆的袋子中拿出 3 个魔法豆。 剩下袋子中魔法豆的数目为：[0,10,0,0] 总共拿出了 2 + 2 + 3 = 7 个魔法豆，剩下非空袋子中魔法豆的数目相等。 没有比取出 7 个魔法豆更少的方案。 提示： * 1 <= beans.length <= 105 * 1 <= beans[i] <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过排序和前缀和计算最小需要移除的魔法豆数量。

算法步骤:
1. 对数组进行排序。
2. 计算前缀和数组。
3. 遍历每个可能的剩余魔法豆数量，计算需要移除的魔法豆数量，并更新最小值。

关键点:
- 排序后，我们可以利用前缀和快速计算每个位置的总和。
- 通过遍历每个可能的剩余魔法豆数量，可以找到最小的移除数量。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def minimum_beans(beans: List[int]) -> int:
    """
    函数式接口 - 计算需要移除的最少魔法豆数量
    """
    n = len(beans)
    beans.sort()
    prefix_sum = [0] * (n + 1)
    
    # 计算前缀和
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + beans[i]
    
    min_remove = float('inf')
    
    # 遍历每个可能的剩余魔法豆数量
    for i in range(n):
        current_beans = beans[i]
        remove_count = (prefix_sum[i] - current_beans * i) + (prefix_sum[n] - prefix_sum[i + 1] - current_beans * (n - i - 1))
        min_remove = min(min_remove, remove_count)
    
    return min_remove


Solution = create_solution(minimum_beans)