# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1402
标题: Count Square Submatrices with All Ones
难度: medium
链接: https://leetcode.cn/problems/count-square-submatrices-with-all-ones/
题目类型: 数组、动态规划、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1277. 统计全为 1 的正方形子矩阵 - 给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的 正方形 子矩阵的个数。 示例 1： 输入：matrix = [ [0,1,1,1], [1,1,1,1], [0,1,1,1] ] 输出：15 解释： 边长为 1 的正方形有 10 个。 边长为 2 的正方形有 4 个。 边长为 3 的正方形有 1 个。 正方形的总数 = 10 + 4 + 1 = 15. 示例 2： 输入：matrix = [ [1,0,1], [1,1,0], [1,1,0] ] 输出：7 解释： 边长为 1 的正方形有 6 个。 边长为 2 的正方形有 1 个。 正方形的总数 = 6 + 1 = 7. 提示： * 1 <= arr.length <= 300 * 1 <= arr[0].length <= 300 * 0 <= arr[i][j] <= 1
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来计算每个位置作为右下角的最大正方形边长，并累加这些边长。

算法步骤:
1. 初始化一个与输入矩阵大小相同的 DP 矩阵，用于存储以 (i, j) 为右下角的最大正方形边长。
2. 遍历输入矩阵，对于每个位置 (i, j)，如果 matrix[i][j] 为 1，则更新 dp[i][j] 为 min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1。
3. 累加所有 dp[i][j] 的值，即为所有正方形子矩阵的数量。

关键点:
- 动态规划的状态转移方程：dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
- 边界处理：当 i 或 j 为 0 时，dp[i][j] 只能为 1（因为无法形成更大的正方形）。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m * n)，其中 m 和 n 分别是矩阵的行数和列数。
空间复杂度: O(m * n)，使用了与输入矩阵相同大小的 DP 矩阵。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def count_squares(matrix: List[List[int]]) -> int:
    if not matrix or not matrix[0]:
        return 0
    
    m, n = len(matrix), len(matrix[0])
    dp = [[0] * n for _ in range(m)]
    count = 0
    
    for i in range(m):
        for j in range(n):
            if matrix[i][j] == 1:
                if i == 0 or j == 0:
                    dp[i][j] = 1
                else:
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
                count += dp[i][j]
    
    return count

Solution = create_solution(count_squares)