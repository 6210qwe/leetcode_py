# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3019
标题: Furthest Point From Origin
难度: easy
链接: https://leetcode.cn/problems/furthest-point-from-origin/
题目类型: 字符串、计数
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2833. 距离原点最远的点 - 给你一个长度为 n 的字符串 moves ，该字符串仅由字符 'L'、'R' 和 '_' 组成。字符串表示你在一条原点为 0 的数轴上的若干次移动。 你的初始位置就在原点（0），第 i 次移动过程中，你可以根据对应字符选择移动方向： * 如果 moves[i] = 'L' 或 moves[i] = '_' ，可以选择向左移动一个单位距离 * 如果 moves[i] = 'R' 或 moves[i] = '_' ，可以选择向右移动一个单位距离 移动 n 次之后，请你找出可以到达的距离原点 最远 的点，并返回 从原点到这一点的距离 。 示例 1： 输入：moves = "L_RL__R" 输出：3 解释：可以到达的距离原点 0 最远的点是 -3 ，移动的序列为 "LLRLLLR" 。 示例 2： 输入：moves = "_R__LL_" 输出：5 解释：可以到达的距离原点 0 最远的点是 -5 ，移动的序列为 "LRLLLLL" 。 示例 3： 输入：moves = "_______" 输出：7 解释：可以到达的距离原点 0 最远的点是 7 ，移动的序列为 "RRRRRRR" 。 提示： * 1 <= moves.length == n <= 50 * moves 仅由字符 'L'、'R' 和 '_' 组成
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 计算 'L' 和 'R' 的数量差值，并将所有的 '_' 用于增加这个差值。

算法步骤:
1. 初始化计数器 count_l, count_r, count_blank 分别记录 'L', 'R', '_' 的数量。
2. 遍历字符串 moves，统计每个字符的数量。
3. 计算最终的最大距离：max_distance = abs(count_l - count_r) + count_blank。

关键点:
- 将所有的 '_' 用于增加 'L' 和 'R' 的数量差值，以达到最大距离。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是字符串 moves 的长度。我们需要遍历整个字符串一次。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def furthest_distance_from_origin(moves: str) -> int:
    """
    函数式接口 - 计算距离原点最远的点
    """
    count_l = 0
    count_r = 0
    count_blank = 0
    
    for move in moves:
        if move == 'L':
            count_l += 1
        elif move == 'R':
            count_r += 1
        elif move == '_':
            count_blank += 1
    
    max_distance = abs(count_l - count_r) + count_blank
    return max_distance


Solution = create_solution(furthest_distance_from_origin)