# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2823
标题: The Knight’s Tour
难度: medium
链接: https://leetcode.cn/problems/the-knights-tour/
题目类型: 数组、回溯、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
在一个 n x n 的棋盘上，骑士从一个给定的起始位置 (row, col) 开始移动。骑士的移动规则与国际象棋中的骑士相同，即每次可以向八个方向之一移动两格再转90度移动一格。骑士的目标是遍历整个棋盘，每个格子恰好访问一次。返回所有可能的路径。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用回溯法来解决这个问题。从起始位置开始，尝试每一个可能的移动，如果移动到的位置是有效的（即在棋盘内且未被访问过），则继续递归。如果找到一条完整的路径，则记录该路径。如果没有找到，则回溯到上一步，尝试其他可能的移动。

算法步骤:
1. 初始化一个 n x n 的棋盘，用一个二维数组表示，初始值为 -1 表示未访问。
2. 定义骑士的八个可能移动方向。
3. 从起始位置开始，使用递归和回溯的方法尝试每一种可能的移动。
4. 如果找到一条完整的路径，则记录该路径。
5. 如果没有找到，则回溯到上一步，尝试其他可能的移动。

关键点:
- 使用回溯法来穷举所有可能的路径。
- 通过一个二维数组来记录棋盘的状态，避免重复访问。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(8^n)，其中 n 是棋盘的边长。最坏情况下，每个位置都有 8 种可能的移动。
空间复杂度: O(n^2)，用于存储棋盘的状态。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional

def solution_function_name(n: int, row: int, col: int) -> List[List[int]]:
    """
    函数式接口 - 返回所有可能的骑士路径
    """
    # 定义骑士的八个可能移动方向
    directions = [
        (2, 1), (2, -1), (-2, 1), (-2, -1),
        (1, 2), (1, -2), (-1, 2), (-1, -2)
    ]
    
    def is_valid(x: int, y: int) -> bool:
        """检查位置 (x, y) 是否在棋盘内且未被访问过"""
        return 0 <= x < n and 0 <= y < n and board[x][y] == -1
    
    def backtrack(x: int, y: int, move: int):
        """回溯法尝试每一种可能的移动"""
        if move == n * n:
            paths.append(path[:])
            return
        
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if is_valid(nx, ny):
                board[nx][ny] = move
                path.append([nx, ny])
                backtrack(nx, ny, move + 1)
                path.pop()
                board[nx][ny] = -1
    
    # 初始化棋盘
    board = [[-1] * n for _ in range(n)]
    board[row][col] = 0
    paths = []
    path = [[row, col]]
    
    # 从起始位置开始回溯
    backtrack(row, col, 1)
    
    return paths

Solution = create_solution(solution_function_name)