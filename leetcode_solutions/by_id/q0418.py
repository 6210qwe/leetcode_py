# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 418
标题: Sentence Screen Fitting
难度: medium
链接: https://leetcode.cn/problems/sentence-screen-fitting/
题目类型: 数组、字符串、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
418. 屏幕可显示句子的数量 - 备战技术面试？力扣提供海量技术面试资源，帮助你高效提升编程技能,轻松拿下世界 IT 名企 Dream Offer。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用贪心算法来计算屏幕上可以显示的句子数量

算法步骤:
1. 计算整个句子的长度（包括空格）
2. 遍历每一行，尽可能多地填充句子
3. 如果当前行不能完全填充一个完整的句子，则从下一个单词开始填充下一行

关键点:
- 注意边界条件，如行数和列数为0的情况
- 优化时间和空间复杂度，避免不必要的重复计算
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * m) - 其中n是句子的长度，m是屏幕的行数
空间复杂度: O(1) - 只使用了常数级的额外空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def sentence_screen_fitting(sentence: List[str], rows: int, cols: int) -> int:
    """
    函数式接口 - 计算屏幕上可以显示的句子数量
    
    实现思路:
    使用贪心算法，逐行填充句子，直到填满所有行。每行尽可能多地填充句子，如果当前行不能完全填充一个完整的句子，则从下一个单词开始填充下一行。

    Args:
        sentence (List[str]): 句子列表
        rows (int): 屏幕的行数
        cols (int): 屏幕的列数
        
    Returns:
        int: 屏幕上可以显示的句子数量
        
    Example:
        >>> sentence_screen_fitting(["hello", "world"], 2, 8)
        1
    """
    if not sentence or rows == 0 or cols == 0:
        return 0

    # 将句子拼接成一个长字符串，并在每个单词之间加上空格
    s = ' '.join(sentence) + ' '
    n = len(s)

    # 初始化指针和计数器
    index = 0
    count = 0

    for _ in range(rows):
        # 每一行尽可能多地填充句子
        index += cols
        # 如果当前字符是空格，则可以直接跳过
        while index > 0 and s[index % n] != ' ':
            index -= 1
        # 如果当前字符不是空格，则需要回退到上一个空格
        if s[index % n] == ' ':
            index += 1
        # 计算当前行可以显示的句子数量
        count += index // n

    return count


# 自动生成Solution类（无需手动编写）
Solution = create_solution(sentence_screen_fitting)