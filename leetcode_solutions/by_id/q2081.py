# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2081
标题: Minimum Total Space Wasted With K Resizing Operations
难度: medium
链接: https://leetcode.cn/problems/minimum-total-space-wasted-with-k-resizing-operations/
题目类型: 数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1959. K 次调整数组大小浪费的最小总空间 - 你正在设计一个动态数组。给你一个下标从 0 开始的整数数组 nums ，其中 nums[i] 是 i 时刻数组中的元素数目。除此以外，你还有一个整数 k ，表示你可以 调整 数组大小的 最多 次数（每次都可以调整成 任意 大小）。 t 时刻数组的大小 sizet 必须大于等于 nums[t] ，因为数组需要有足够的空间容纳所有元素。t 时刻 浪费的空间 为 sizet - nums[t] ，总 浪费空间为满足 0 <= t < nums.length 的每一个时刻 t 浪费的空间 之和 。 在调整数组大小不超过 k 次的前提下，请你返回 最小总浪费空间 。 注意：数组最开始时可以为 任意大小 ，且 不计入 调整大小的操作次数。 示例 1： 输入：nums = [10,20], k = 0 输出：10 解释：size = [20,20]. 我们可以让数组初始大小为 20 。 总浪费空间为 (20 - 10) + (20 - 20) = 10 。 示例 2： 输入：nums = [10,20,30], k = 1 输出：10 解释：size = [20,20,30]. 我们可以让数组初始大小为 20 ，然后时刻 2 调整大小为 30 。 总浪费空间为 (20 - 10) + (20 - 20) + (30 - 30) = 10 。 示例 3： 输入：nums = [10,20,15,30,20], k = 2 输出：15 解释：size = [10,20,20,30,30]. 我们可以让数组初始大小为 10 ，时刻 1 调整大小为 20 ，时刻 3 调整大小为 30 。 总浪费空间为 (10 - 10) + (20 - 20) + (20 - 15) + (30 - 30) + (30 - 20) = 15 。 提示： * 1 <= nums.length <= 200 * 1 <= nums[i] <= 106 * 0 <= k <= nums.length - 1
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们定义 dp[i][j] 为在前 i 个元素中进行 j 次调整操作的最小浪费空间。通过预处理每个子数组的最大值和总和，我们可以快速计算出每个子数组的浪费空间。

算法步骤:
1. 预处理每个子数组的最大值和总和。
2. 初始化 dp 表，dp[i][0] 为前 i 个元素不进行任何调整的最小浪费空间。
3. 填充 dp 表，对于每个可能的调整次数 j，计算 dp[i][j] 的值。
4. 返回 dp[n][k]，即在 n 个元素中进行 k 次调整操作的最小浪费空间。

关键点:
- 通过预处理减少重复计算。
- 动态规划的状态转移方程为 dp[i][j] = min(dp[i][j], dp[p][j-1] + waste(p+1, i))，其中 waste(p+1, i) 表示从 p+1 到 i 的子数组的浪费空间。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2 * k)，其中 n 是 nums 的长度，k 是调整次数。
空间复杂度: O(n * k)，用于存储 dp 表。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def min_space_wasted_k_resizing(nums: List[int], k: int) -> int:
    n = len(nums)
    if n == 0:
        return 0

    # 预处理每个子数组的最大值和总和
    max_values = [[0] * n for _ in range(n)]
    sums = [0] * n
    for i in range(n):
        max_val = 0
        total = 0
        for j in range(i, n):
            max_val = max(max_val, nums[j])
            total += nums[j]
            max_values[i][j] = max_val
            if i > 0:
                sums[j] += sums[j - 1]
            else:
                sums[j] = total

    # 初始化 dp 表
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0

    for i in range(1, n + 1):
        for j in range(k + 1):
            if j > 0:
                for p in range(i):
                    waste = max_values[p][i - 1] * (i - p) - (sums[i - 1] - (p > 0 and sums[p - 1]))
                    dp[i][j] = min(dp[i][j], dp[p][j - 1] + waste)
            else:
                waste = max_values[0][i - 1] * i - sums[i - 1]
                dp[i][j] = min(dp[i][j], waste)

    return dp[n][k]

Solution = create_solution(min_space_wasted_k_resizing)