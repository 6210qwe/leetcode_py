# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000085
标题: 游乐园的游览计划
难度: hard
链接: https://leetcode.cn/problems/you-le-yuan-de-you-lan-ji-hua/
题目类型: 图、几何、数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCP 16. 游乐园的游览计划 - 又到了一年一度的春游时间，小吴计划去游乐场游玩 1 天，游乐场总共有 N 个游乐项目，编号从 0 到 N-1。小吴给每个游乐项目定义了一个非负整数值 value[i] 表示自己的喜爱值。两个游乐项目之间会有双向路径相连，整个游乐场总共有 M 条双向路径，保存在二维数组 edges中。 小吴计划选择一个游乐项目 A 作为这一天游玩的重点项目。上午小吴准备游玩重点项目 A 以及与项目 A 相邻的两个项目 B、C （项目A、B与C要求是不同的项目，且项目B与项目C要求相邻），并返回 A ，即存在一条 A-B-C-A 的路径。 下午，小吴决定再游玩重点项目 A以及与A相邻的两个项目 B'、C'，（项目A、B'与C'要求是不同的项目，且项目B'与项目C'要求相邻），并返回 A ，即存在一条 A-B'-C'-A 的路径。下午游玩项目 B'、C' 可与上午游玩项目B、C存在重复项目。 小吴希望提前安排好游玩路径，使得喜爱值之和最大。请你返回满足游玩路径选取条件的最大喜爱值之和，如果没有这样的路径，返回 0。 注意：一天中重复游玩同一个项目并不能重复增加喜爱值了。例如：上下午游玩路径分别是 A-B-C-A与A-C-D-A 那么只能获得 value[A] + value[B] + value[C] + value[D] 的总和。 示例 1： > 输入：edges = [[0,1],[1,2],[0,2]], value = [1,2,3] > > 输出：6 > > 解释：喜爱值之和最高的方案之一是 0->1->2->0 与 0->2->1->0 。重复游玩同一点不重复计入喜爱值，返回1+2+3=6 示例 2： > 输入：edges = [[0,2],[2,1]], value = [1,2,5] > > 输出：0 > > 解释：无满足要求的游玩路径，返回 0 示例 3： > 输入：edges = [[0,1],[0,2],[0,3],[0,4],[0,5],[1,3],[2,4],[2,5],[3,4],[3,5],[4,5]], value = [7,8,6,8,9,7] > > 输出：39 > > 解释：喜爱值之和最高的方案之一是 3->0->1->3 与 3->4->5->3 。喜爱值最高为 7+8+8+9+7=39 限制： * 3 <= value.length <= 10000 * 1 <= edges.length <= 10000 * 0 <= edges[i][0],edges[i][1] < value.length * 0 <= value[i] <= 10000 * edges中没有重复的边 * edges[i][0] != edges[i][1]
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用图的邻接表表示法，通过遍历每个节点及其相邻节点来找到满足条件的最大喜爱值。

算法步骤:
1. 构建图的邻接表。
2. 遍历每个节点，计算其相邻节点对的最大喜爱值。
3. 对于每个节点，找到两个不相交的相邻节点对，计算总喜爱值。
4. 返回最大总喜爱值。

关键点:
- 使用邻接表存储图结构，便于快速查找相邻节点。
- 通过遍历每个节点及其相邻节点对，确保找到所有可能的路径组合。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n + m)，其中 n 是节点数，m 是边数。构建邻接表的时间复杂度为 O(m)，遍历每个节点及其相邻节点对的时间复杂度为 O(n + m)。
空间复杂度: O(n + m)，用于存储邻接表。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def max_happiness(edges: List[List[int]], value: List[int]) -> int:
    # 构建邻接表
    graph = [[] for _ in range(len(value))]
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)
    
    max_happiness = 0
    
    # 遍历每个节点
    for a in range(len(value)):
        if len(graph[a]) < 2:
            continue
        
        # 找到节点 a 的相邻节点对 (b, c)
        for i in range(len(graph[a])):
            b = graph[a][i]
            for j in range(i + 1, len(graph[a])):
                c = graph[a][j]
                if c in graph[b]:
                    morning_happiness = value[a] + value[b] + value[c]
                    
                    # 找到另一个相邻节点对 (b', c')
                    for k in range(len(graph[a])):
                        b_prime = graph[a][k]
                        if b_prime == b or b_prime == c:
                            continue
                        for l in range(k + 1, len(graph[a])):
                            c_prime = graph[a][l]
                            if c_prime == b or c_prime == c or c_prime not in graph[b_prime]:
                                continue
                            afternoon_happiness = value[a] + value[b_prime] + value[c_prime]
                            total_happiness = morning_happiness + afternoon_happiness - value[a]
                            max_happiness = max(max_happiness, total_happiness)
    
    return max_happiness

Solution = create_solution(max_happiness)