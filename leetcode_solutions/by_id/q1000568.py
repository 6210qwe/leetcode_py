# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000568
标题: 生物进化录
难度: hard
链接: https://leetcode.cn/problems/qoQAMX/
题目类型: 其他
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCP 80. 生物进化录 - 在永恒之森中，存在着一本生物进化录，以 **一个树形结构** 记载了所有生物的演化过程。经过观察并整理了各节点间的关系，`parents[i]` 表示编号 `i` 节点的父节点编号(根节点的父节点为 `-1`)。 为了探索和记录其中的演化规律，队伍中的炼金术师提出了一种方法，可以以字符串的形式将其复刻下来，规则如下： - 初始只有一个根节点，表示演化的起点，依次记录 `01` 字符串中的字符， - 如果记录 `0`，则在当前节点下添加一个子节点，并将指针指向新添加的子节点； - 如果记录 `1`，则将指针回退到当前节点的父节点处。 现在需要应用上述的记录方法，复刻下它的演化过程。请返回能够复刻演化过程的字符串中， **字典序最小** 的 `01` 字符串。 **注意：** - 节点指针最终可以停在任何节点上，不一定要回到根节点。 **示例 1：** > 输入：`parents = [-1,0,0,2]` > > 输出：`"00110"` > >解释：树结构如下图所示，共存在 2 种记录方案： >第 1 种方案为：0(记录编号 1 的节点) -> 1(回退至节点 0) -> 0(记录编号 2 的节点) -> 0((记录编号 3 的节点)) >第 2 种方案为：0(记录编号 2 的节点) -> 0(记录编号 3 的节点) -> 1(回退至节点 2) -> 1(回退至节点 0) -> 0(记录编号 1 的节点) >返回字典序更小的 `"00110"` ![image.png](https://pic.leetcode.cn/1682319485-cRVudI-image.png){:width=120px}![进化 (3).gif](https://pic.leetcode.cn/1682412701-waHdnm-%E8%BF%9B%E5%8C%96%20\(3\).gif){:width=320px} **示例 2：** > 输入：`parents = [-1,0,0,1,2,2]` > > 输出：`"00101100"` **提示：** - `1 <= parents.length <= 10^4` - `-1 <= parents[i] < i` (即父节点编号小于子节点)
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用深度优先搜索（DFS）来构建字典序最小的01字符串。

算法步骤:
1. 构建树结构，使用邻接表表示。
2. 定义一个递归函数进行DFS，从根节点开始。
3. 在DFS过程中，优先处理子节点较少的子树，以确保字典序最小。
4. 每次进入子节点时记录'0'，退出子节点时记录'1'。

关键点:
- 使用堆来存储子节点，以确保每次先处理子节点较少的子树。
- 通过递归调用DFS来构建字符串。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中n是节点数。每个节点最多被处理一次，且每次处理的时间复杂度为O(log n)（堆操作）。
空间复杂度: O(n)，用于存储树结构和递归调用栈。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution
import heapq

def solution_function_name(parents: List[int]) -> str:
    """
    函数式接口 - 返回字典序最小的01字符串
    """
    def build_tree(parents: List[int]) -> dict:
        tree = {}
        for i in range(len(parents)):
            if i not in tree:
                tree[i] = []
            if parents[i] != -1:
                if parents[i] not in tree:
                    tree[parents[i]] = []
                tree[parents[i]].append(i)
        return tree

    def dfs(node: int) -> str:
        result = ""
        if node in tree:
            children = tree[node]
            # 使用堆来确保优先处理子节点较少的子树
            heapq.heapify(children)
            while children:
                child = heapq.heappop(children)
                result += "0" + dfs(child) + "1"
        return result

    tree = build_tree(parents)
    root = parents.index(-1)
    return "0" + dfs(root)

Solution = create_solution(solution_function_name)