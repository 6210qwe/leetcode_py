# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1344
标题: Maximum Equal Frequency
难度: hard
链接: https://leetcode.cn/problems/maximum-equal-frequency/
题目类型: 数组、哈希表
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1224. 最大相等频率 - 给你一个正整数数组 nums，请你帮忙从该数组中找出能满足下面要求的 最长 前缀，并返回该前缀的长度： * 从前缀中 恰好删除一个 元素后，剩下每个数字的出现次数都相同。 如果删除这个元素后没有剩余元素存在，仍可认为每个数字都具有相同的出现次数（也就是 0 次）。 示例 1： 输入：nums = [2,2,1,1,5,3,3,5] 输出：7 解释：对于长度为 7 的子数组 [2,2,1,1,5,3,3]，如果我们从中删去 nums[4] = 5，就可以得到 [2,2,1,1,3,3]，里面每个数字都出现了两次。 示例 2： 输入：nums = [1,1,1,2,2,2,3,3,3,4,4,4,5] 输出：13 提示： * 2 <= nums.length <= 105 * 1 <= nums[i] <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用两个计数器来记录每个数字的出现次数和每个出现次数的频率。通过遍历数组并更新这些计数器，可以判断当前前缀是否满足条件。

算法步骤:
1. 初始化两个计数器：`count` 用于记录每个数字的出现次数，`freq` 用于记录每个出现次数的频率。
2. 遍历数组 `nums`，更新 `count` 和 `freq`。
3. 在每次更新后，检查当前前缀是否满足条件：
   - 如果所有数字的出现次数相同，或者只有一个数字的出现次数比其他数字多 1，并且这个多 1 的数字只出现一次，那么当前前缀满足条件。
4. 记录满足条件的最大前缀长度。

关键点:
- 使用两个计数器来高效地维护和检查前缀的频率。
- 通过遍历数组并更新计数器，可以在 O(n) 时间内完成检查。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是数组 `nums` 的长度。我们只需要遍历数组一次。
空间复杂度: O(n)，最坏情况下需要存储每个数字的出现次数和每个出现次数的频率。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def maxEqualFreq(nums: List[int]) -> int:
    count = {}
    freq = {}
    max_freq = 0
    res = 0
    
    for i, num in enumerate(nums):
        # 更新 count 和 freq
        if num in count:
            old_count = count[num]
            freq[old_count] -= 1
            if freq[old_count] == 0:
                del freq[old_count]
        new_count = count.get(num, 0) + 1
        count[num] = new_count
        freq[new_count] = freq.get(new_count, 0) + 1
        max_freq = max(max_freq, new_count)
        
        # 检查当前前缀是否满足条件
        if (max_freq * freq[max_freq] == i or
            (max_freq - 1) * (freq[max_freq - 1] + 1) == i + 1 and freq[max_freq] == 1 or
            max_freq == 1):
            res = i + 1
    
    return res

Solution = maxEqualFreq