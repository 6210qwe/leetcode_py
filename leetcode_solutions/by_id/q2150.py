# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2150
标题: Kth Smallest Product of Two Sorted Arrays
难度: hard
链接: https://leetcode.cn/problems/kth-smallest-product-of-two-sorted-arrays/
题目类型: 数组、二分查找
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2040. 两个有序数组的第 K 小乘积 - 给你两个 从小到大排好序 且下标从 0 开始的整数数组 nums1 和 nums2 以及一个整数 k ，请你返回第 k （从 1 开始编号）小的 nums1[i] * nums2[j] 的乘积，其中 0 <= i < nums1.length 且 0 <= j < nums2.length 。 示例 1： 输入：nums1 = [2,5], nums2 = [3,4], k = 2 输出：8 解释：第 2 小的乘积计算如下： - nums1[0] * nums2[0] = 2 * 3 = 6 - nums1[0] * nums2[1] = 2 * 4 = 8 第 2 小的乘积为 8 。 示例 2： 输入：nums1 = [-4,-2,0,3], nums2 = [2,4], k = 6 输出：0 解释：第 6 小的乘积计算如下： - nums1[0] * nums2[1] = (-4) * 4 = -16 - nums1[0] * nums2[0] = (-4) * 2 = -8 - nums1[1] * nums2[1] = (-2) * 4 = -8 - nums1[1] * nums2[0] = (-2) * 2 = -4 - nums1[2] * nums2[0] = 0 * 2 = 0 - nums1[2] * nums2[1] = 0 * 4 = 0 第 6 小的乘积为 0 。 示例 3： 输入：nums1 = [-2,-1,0,1,2], nums2 = [-3,-1,2,4,5], k = 3 输出：-6 解释：第 3 小的乘积计算如下： - nums1[0] * nums2[4] = (-2) * 5 = -10 - nums1[0] * nums2[3] = (-2) * 4 = -8 - nums1[4] * nums2[0] = 2 * (-3) = -6 第 3 小的乘积为 -6 。 提示： * 1 <= nums1.length, nums2.length <= 5 * 104 * -105 <= nums1[i], nums2[j] <= 105 * 1 <= k <= nums1.length * nums2.length * nums1 和 nums2 都是从小到大排好序的。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用二分查找来找到第 k 小的乘积。通过二分查找确定一个值 mid，并计算小于等于 mid 的乘积对的数量，从而逐步缩小范围。

算法步骤:
1. 初始化二分查找的左右边界 left 和 right。
2. 在每次迭代中，计算中间值 mid，并计算小于等于 mid 的乘积对的数量。
3. 根据乘积对的数量调整 left 和 right 的值，直到找到第 k 小的乘积。

关键点:
- 使用二分查找来减少搜索范围。
- 计算小于等于 mid 的乘积对的数量时，需要考虑正负数的情况。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O((m + n) * log(max_val))，其中 m 和 n 分别是 nums1 和 nums2 的长度，max_val 是乘积的最大可能值。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def count_less_equal(nums1: List[int], nums2: List[int], target: int) -> int:
    """计算乘积小于等于 target 的数量"""
    count = 0
    j1, j2 = len(nums2) - 1, len(nums2) - 1
    for num in nums1:
        if num > 0:
            while j1 >= 0 and num * nums2[j1] > target:
                j1 -= 1
            count += j1 + 1
        elif num == 0:
            if target >= 0:
                count += len(nums2)
        else:
            while j2 >= 0 and num * nums2[j2] > target:
                j2 -= 1
            count += j2 + 1
    return count

def kth_smallest_product(nums1: List[int], nums2: List[int], k: int) -> int:
    """找到第 k 小的乘积"""
    left, right = -10**10, 10**10
    while left < right:
        mid = (left + right) // 2
        if count_less_equal(nums1, nums2, mid) < k:
            left = mid + 1
        else:
            right = mid
    return left

Solution = create_solution(kth_smallest_product)