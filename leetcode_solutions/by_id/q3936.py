# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3936
标题: Split Array by Prime Indices
难度: medium
链接: https://leetcode.cn/problems/split-array-by-prime-indices/
题目类型: 数组、数学、数论
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3618. 根据质数下标分割数组 - 给你一个整数数组 nums。 根据以下规则将 nums 分割成两个数组 A 和 B： * nums 中位于 质数 下标的元素必须放入数组 A。 * 所有其他元素必须放入数组 B。 返回两个数组和的 绝对 差值：|sum(A) - sum(B)|。 质数 是一个大于 1 的自然数，它只有两个因子，1和它本身。 注意：空数组的和为 0。 示例 1: 输入: nums = [2,3,4] 输出: 1 解释: * 数组中唯一的质数下标是 2，所以 nums[2] = 4 被放入数组 A。 * 其余元素 nums[0] = 2 和 nums[1] = 3 被放入数组 B。 * sum(A) = 4，sum(B) = 2 + 3 = 5。 * 绝对差值是 |4 - 5| = 1。 示例 2: 输入: nums = [-1,5,7,0] 输出: 3 解释: * 数组中的质数下标是 2 和 3，所以 nums[2] = 7 和 nums[3] = 0 被放入数组 A。 * 其余元素 nums[0] = -1 和 nums[1] = 5 被放入数组 B。 * sum(A) = 7 + 0 = 7，sum(B) = -1 + 5 = 4。 * 绝对差值是 |7 - 4| = 3。 提示: * 1 <= nums.length <= 105 * -109 <= nums[i] <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用埃拉托斯特尼筛法预先计算出一定范围内的所有质数，并根据这些质数来分割数组。

算法步骤:
1. 使用埃拉托斯特尼筛法生成一个布尔数组，标记出所有小于等于 n 的质数。
2. 遍历输入数组 nums，根据下标是否为质数将其元素分别累加到 A 和 B 中。
3. 计算 A 和 B 的和的绝对差值并返回。

关键点:
- 使用埃拉托斯特尼筛法预处理质数，提高效率。
- 遍历数组时直接根据下标判断是否为质数，避免重复计算。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log log n + m)，其中 n 是预处理质数的上限（可以取 sqrt(10^5)），m 是输入数组的长度。
空间复杂度: O(n)，用于存储质数标记数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution

def is_prime(n: int) -> bool:
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def solution_function_name(nums: List[int]) -> int:
    """
    函数式接口 - 根据质数下标分割数组并返回两个数组和的绝对差值
    """
    n = len(nums)
    prime_indices = [is_prime(i) for i in range(n)]
    
    sum_A = sum(nums[i] for i in range(n) if prime_indices[i])
    sum_B = sum(nums[i] for i in range(n) if not prime_indices[i])
    
    return abs(sum_A - sum_B)

Solution = create_solution(solution_function_name)