# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2123
标题: The Number of Weak Characters in the Game
难度: medium
链接: https://leetcode.cn/problems/the-number-of-weak-characters-in-the-game/
题目类型: 栈、贪心、数组、排序、单调栈
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1996. 游戏中弱角色的数量 - 你正在参加一个多角色游戏，每个角色都有两个主要属性：攻击 和 防御 。给你一个二维整数数组 properties ，其中 properties[i] = [attacki, defensei] 表示游戏中第 i 个角色的属性。 如果存在一个其他角色的攻击和防御等级 都严格高于 该角色的攻击和防御等级，则认为该角色为 弱角色 。更正式地，如果认为角色 i 弱于 存在的另一个角色 j ，那么 attackj > attacki 且 defensej > defensei 。 返回 弱角色 的数量。 示例 1： 输入：properties = [[5,5],[6,3],[3,6]] 输出：0 解释：不存在攻击和防御都严格高于其他角色的角色。 示例 2： 输入：properties = [[2,2],[3,3]] 输出：1 解释：第一个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。 示例 3： 输入：properties = [[1,5],[10,4],[4,3]] 输出：1 解释：第三个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。 提示： * 2 <= properties.length <= 105 * properties[i].length == 2 * 1 <= attacki, defensei <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用排序和单调栈来找到所有弱角色。

算法步骤:
1. 按照攻击力降序排序，如果攻击力相同，则按防御力升序排序。
2. 从左到右遍历排序后的数组，维护一个单调递减的栈，存储当前遇到的最大防御力。
3. 对于每个角色，如果其防御力小于栈顶元素，则该角色为弱角色。

关键点:
- 排序时，确保攻击力相同的角色按防御力升序排列，这样可以避免重复计算。
- 使用单调栈来维护当前的最大防御力。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是 properties 的长度。排序操作的时间复杂度为 O(n log n)，遍历操作为 O(n)。
空间复杂度: O(1)，除了输入和输出外，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def number_of_weak_characters(properties: List[List[int]]) -> int:
    """
    函数式接口 - 计算弱角色的数量
    """
    # 按攻击力降序排序，如果攻击力相同，则按防御力升序排序
    properties.sort(key=lambda x: (-x[0], x[1]))
    
    max_defense = 0
    weak_count = 0
    
    for _, defense in properties:
        if defense < max_defense:
            weak_count += 1
        else:
            max_defense = defense
    
    return weak_count


Solution = create_solution(number_of_weak_characters)