# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000288
标题: 目标和
难度: medium
链接: https://leetcode.cn/problems/YaVDxD/
题目类型: 数组、动态规划、回溯
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCR 102. 目标和 - 给定一个正整数数组 nums 和一个整数 target 。 向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ： * 例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。 示例 1： 输入：nums = [1,1,1,1,1], target = 3 输出：5 解释：一共有 5 种方法让最终目标和为 3 。 -1 + 1 + 1 + 1 + 1 = 3 +1 - 1 + 1 + 1 + 1 = 3 +1 + 1 - 1 + 1 + 1 = 3 +1 + 1 + 1 - 1 + 1 = 3 +1 + 1 + 1 + 1 - 1 = 3 示例 2： 输入：nums = [1], target = 1 输出：1 提示： * 1 <= nums.length <= 20 * 0 <= nums[i] <= 1000 * 0 <= sum(nums[i]) <= 1000 * -1000 <= target <= 1000 注意：本题与主站 494 题相同： https://leetcode.cn/problems/target-sum/ [https://leetcode.cn/problems/target-sum/]
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。将问题转化为一个子集和问题。

算法步骤:
1. 计算数组的总和 `total_sum`。
2. 如果 `(total_sum + target) % 2 != 0` 或 `total_sum < abs(target)`，则返回 0，因为无法找到满足条件的子集。
3. 将问题转化为求解子集和问题，新的目标和为 `(total_sum + target) // 2`。
4. 使用动态规划数组 `dp`，其中 `dp[j]` 表示可以组成和为 `j` 的子集数量。
5. 初始化 `dp[0] = 1`，表示和为 0 的子集有一个（空集）。
6. 遍历数组 `nums`，对于每个元素 `num`，从后向前更新 `dp` 数组。
7. 最终返回 `dp[(total_sum + target) // 2]`。

关键点:
- 将问题转化为子集和问题，使用动态规划求解。
- 动态规划数组 `dp` 的初始化和更新顺序。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * S)，其中 n 是数组长度，S 是目标和的一半。
空间复杂度: O(S)，其中 S 是目标和的一半。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def findTargetSumWays(nums: List[int], target: int) -> int:
    total_sum = sum(nums)
    if (total_sum + target) % 2 != 0 or total_sum < abs(target):
        return 0
    
    new_target = (total_sum + target) // 2
    dp = [0] * (new_target + 1)
    dp[0] = 1
    
    for num in nums:
        for j in range(new_target, num - 1, -1):
            dp[j] += dp[j - num]
    
    return dp[new_target]

Solution = create_solution(findTargetSumWays)