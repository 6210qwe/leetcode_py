# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 4150
标题: Sort Integers by Binary Reflection
难度: easy
链接: https://leetcode.cn/problems/sort-integers-by-binary-reflection/
题目类型: 数组、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3769. 二进制反射排序 - 给你一个整数数组 nums。 二进制反射 是对一个 正整数 的二进制表示按顺序反转（忽略前导零）后，将反转得到的二进制数转为十进制的结果。 请按每个元素的二进制反射值的 升序 对数组进行排序。如果两个不同的数字具有相同的二进制反射值，则 较小 的原始数字应排在前面。 返回排序后的数组。 示例 1： 输入： nums = [4,5,4] 输出： [4,4,5] 解释： 二进制反射值为： * 4 -> (二进制) 100 -> (反转) 001 -> 1 * 5 -> (二进制) 101 -> (反转) 101 -> 5 * 4 -> (二进制) 100 -> (反转) 001 -> 1 根据反射值排序为 [4, 4, 5]。 示例 2： 输入： nums = [3,6,5,8] 输出： [8,3,6,5] 解释： 二进制反射值为： * 3 -> (二进制) 11 -> (反转) 11 -> 3 * 6 -> (二进制) 110 -> (反转) 011 -> 3 * 5 -> (二进制) 101 -> (反转) 101 -> 5 * 8 -> (二进制) 1000 -> (反转) 0001 -> 1 根据反射值排序为 [8, 3, 6, 5]。 注意，3 和 6 的反射值相同，因此需要按原始值的升序排列。 提示： * 1 <= nums.length <= 100 * 1 <= nums[i] <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 计算每个数字的二进制反射值，并根据反射值和原始值进行排序。

算法步骤:
1. 定义一个辅助函数 `binary_reflection` 来计算一个数字的二进制反射值。
2. 使用 `sorted` 函数对数组进行排序，排序的关键是先按反射值排序，如果反射值相同则按原始值排序。

关键点:
- 使用 `bin` 函数获取二进制表示，并去掉前导 '0b'。
- 反转二进制字符串并转换回十进制。
- 使用 `sorted` 函数进行多关键字排序。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是数组的长度。排序操作的时间复杂度是 O(n log n)。
空间复杂度: O(n)，用于存储排序后的数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution

def binary_reflection(num: int) -> int:
    """计算一个数字的二进制反射值"""
    binary_str = bin(num)[2:]  # 获取二进制表示并去掉前导 '0b'
    reversed_binary_str = binary_str[::-1]  # 反转二进制字符串
    return int(reversed_binary_str, 2)  # 转换回十进制

def sort_by_binary_reflection(nums: List[int]) -> List[int]:
    """
    按每个元素的二进制反射值的升序对数组进行排序。如果两个不同的数字具有相同的二进制反射值，则较小的原始数字应排在前面。
    """
    return sorted(nums, key=lambda x: (binary_reflection(x), x))

Solution = create_solution(sort_by_binary_reflection)