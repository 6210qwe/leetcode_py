# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 754
标题: Cracking the Safe
难度: hard
链接: https://leetcode.cn/problems/cracking-the-safe/
题目类型: 深度优先搜索、图、欧拉回路
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
753. 破解保险箱 - 有一个需要密码才能打开的保险箱。密码是 n 位数, 密码的每一位都是范围 [0, k - 1] 中的一个数字。 保险箱有一种特殊的密码校验方法，你可以随意输入密码序列，保险箱会自动记住 最后 n 位输入 ，如果匹配，则能够打开保险箱。 * 例如，正确的密码是 "345" ，并且你输入的是 "012345" ： * 输入 0 之后，最后 3 位输入是 "0" ，不正确。 * 输入 1 之后，最后 3 位输入是 "01" ，不正确。 * 输入 2 之后，最后 3 位输入是 "012" ，不正确。 * 输入 3 之后，最后 3 位输入是 "123" ，不正确。 * 输入 4 之后，最后 3 位输入是 "234" ，不正确。 * 输入 5 之后，最后 3 位输入是 "345" ，正确，打开保险箱。 在只知道密码位数 n 和范围边界 k 的前提下，请你找出并返回确保在输入的 某个时刻 能够打开保险箱的任一 最短 密码序列 。 示例 1： 输入：n = 1, k = 2 输出："10" 解释：密码只有 1 位，所以输入每一位就可以。"01" 也能够确保打开保险箱。 示例 2： 输入：n = 2, k = 2 输出："01100" 解释：对于每种可能的密码： - "00" 从第 4 位开始输入。 - "01" 从第 1 位开始输入。 - "10" 从第 3 位开始输入。 - "11" 从第 2 位开始输入。 因此 "01100" 可以确保打开保险箱。"01100"、"10011" 和 "11001" 也可以确保打开保险箱。 提示： * 1 <= n <= 4 * 1 <= k <= 10 * 1 <= kn <= 4096
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用 Hierholzer 算法找到欧拉路径，生成最短的密码序列。

算法步骤:
1. 初始化一个集合 `visited` 来记录已经访问过的边。
2. 定义一个递归函数 `dfs`，用于深度优先搜索构建欧拉路径。
3. 从初始节点开始进行深度优先搜索，直到所有边都被访问过。
4. 将结果反转并去掉前缀部分，得到最终的最短密码序列。

关键点:
- 使用 Hierholzer 算法可以有效地找到欧拉路径。
- 通过递归的方式构建路径，确保所有边都被访问。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(k^n)，其中 k 是密码每一位的可能取值，n 是密码的长度。
空间复杂度: O(k^n)，存储已访问的边和递归调用栈。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def crack_safe(n: int, k: int) -> str:
    """
    函数式接口 - 使用 Hierholzer 算法找到欧拉路径，生成最短的密码序列。
    """
    # 初始化变量
    visited = set()
    result = []

    def dfs(node: str):
        for x in range(k):
            edge = node + str(x)
            if edge not in visited:
                visited.add(edge)
                dfs(edge[1:])
                result.append(str(x))

    # 从初始节点开始进行深度优先搜索
    start_node = "0" * (n - 1)
    dfs(start_node)

    # 将结果反转并去掉前缀部分
    return start_node + "".join(reversed(result))


Solution = create_solution(crack_safe)