# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2979
标题: Maximize the Profit as the Salesman
难度: medium
链接: https://leetcode.cn/problems/maximize-the-profit-as-the-salesman/
题目类型: 数组、哈希表、二分查找、动态规划、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2830. 销售利润最大化 - 给你一个整数 n 表示数轴上的房屋数量，编号从 0 到 n - 1 。 另给你一个二维整数数组 offers ，其中 offers[i] = [starti, endi, goldi] 表示第 i 个买家想要以 goldi 枚金币的价格购买从 starti 到 endi 的所有房屋。 作为一名销售，你需要有策略地选择并销售房屋使自己的收入最大化。 返回你可以赚取的金币的最大数目。 注意 同一所房屋不能卖给不同的买家，并且允许保留一些房屋不进行出售。 示例 1： 输入：n = 5, offers = [[0,0,1],[0,2,2],[1,3,2]] 输出：3 解释： 有 5 所房屋，编号从 0 到 4 ，共有 3 个购买要约。 将位于 [0,0] 范围内的房屋以 1 金币的价格出售给第 1 位买家，并将位于 [1,3] 范围内的房屋以 2 金币的价格出售给第 3 位买家。 可以证明我们最多只能获得 3 枚金币。 示例 2： 输入：n = 5, offers = [[0,0,1],[0,2,10],[1,3,2]] 输出：10 解释：有 5 所房屋，编号从 0 到 4 ，共有 3 个购买要约。 将位于 [0,2] 范围内的房屋以 10 金币的价格出售给第 2 位买家。 可以证明我们最多只能获得 10 枚金币。 提示： * 1 <= n <= 105 * 1 <= offers.length <= 105 * offers[i].length == 3 * 0 <= starti <= endi <= n - 1 * 1 <= goldi <= 103
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们可以将每个 offer 按照结束时间进行排序，然后使用一个 dp 数组来记录到当前房屋为止的最大收益。

算法步骤:
1. 将 offers 按照结束时间进行排序。
2. 初始化一个 dp 数组，dp[i] 表示到第 i 个房屋为止的最大收益。
3. 遍历每个 offer，对于每个 offer，找到它开始之前的最大收益，加上当前 offer 的收益，更新 dp 数组。
4. 最后返回 dp 数组的最后一个元素，即为最大收益。

关键点:
- 使用二分查找来快速找到当前 offer 开始之前的最大收益。
- 动态规划的状态转移方程为 dp[i] = max(dp[i], dp[start] + gold)。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是 offers 的长度。排序操作的时间复杂度为 O(n log n)，遍历和二分查找的时间复杂度为 O(n log n)。
空间复杂度: O(n)，需要一个 dp 数组来记录到每个房屋为止的最大收益。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import bisect

def maximize_the_profit(n: int, offers: List[List[int]]) -> int:
    # 按结束时间排序
    offers.sort(key=lambda x: x[1])
    
    # 初始化 dp 数组
    dp = [0] * (n + 1)
    
    for start, end, gold in offers:
        # 使用二分查找找到 start 之前的最大收益
        prev_max = dp[bisect.bisect_right(offers, [start, start, 0], key=lambda x: x[1]) - 1]
        # 更新 dp[end + 1]
        dp[end + 1] = max(dp[end + 1], prev_max + gold)
    
    # 返回最大收益
    return max(dp)

Solution = create_solution(maximize_the_profit)