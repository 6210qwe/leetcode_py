# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 7
标题: Reverse Integer
难度: medium
链接: https://leetcode.cn/problems/reverse-integer/
题目类型: 数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
7. 整数反转 - 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）。 示例 1： 输入：x = 123 输出：321 示例 2： 输入：x = -123 输出：-321 示例 3： 输入：x = 120 输出：21 示例 4： 输入：x = 0 输出：0 提示： * -231 <= x <= 231 - 1
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 逐位反转整数，在反转过程中检查溢出

算法步骤:
1. 判断整数是否为负数，记录符号
2. 将整数转为正数处理（避免负数取模的复杂性）
3. 逐位反转：result = result * 10 + x % 10
4. 在每次乘法前检查是否溢出：
   - 如果result > INT_MAX // 10，则溢出
   - 如果result == INT_MAX // 10 且 x % 10 > 7，则溢出
5. 返回带符号的结果

关键点:
- 需要在反转过程中检查溢出，而不是反转后检查
- 32位整数范围：[-2^31, 2^31-1]，即[-2147483648, 2147483647]
- 使用数学方法反转，避免字符串转换
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(log|x|) - 需要处理的位数，约为log10|x|
空间复杂度: O(1) - 只使用常数额外空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from leetcode_solutions.utils.solution import create_solution


def reverse(x: int) -> int:
    """
    函数式接口 - 数学方法实现
    
    实现思路:
    逐位反转整数，在反转过程中检查是否溢出32位整数范围。
    
    Args:
        x: 输入的32位有符号整数
        
    Returns:
        反转后的整数，如果溢出则返回0
        
    Example:
        >>> reverse(123)
        321
        >>> reverse(-123)
        -321
        >>> reverse(120)
        21
    """
    INT_MAX = 2**31 - 1
    INT_MIN = -2**31
    
    result = 0
    sign = 1 if x >= 0 else -1
    x = abs(x)
    
    while x > 0:
        digit = x % 10
        # 检查溢出：在乘法前检查
        if result > INT_MAX // 10 or (result == INT_MAX // 10 and digit > 7):
            return 0
        result = result * 10 + digit
        x //= 10
    
    return sign * result


# 自动生成Solution类（无需手动编写）
Solution = create_solution(reverse)
