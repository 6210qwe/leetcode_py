# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2366
标题: Maximum Bags With Full Capacity of Rocks
难度: medium
链接: https://leetcode.cn/problems/maximum-bags-with-full-capacity-of-rocks/
题目类型: 贪心、数组、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2279. 装满石头的背包的最大数量 - 现有编号从 0 到 n - 1 的 n 个背包。给你两个下标从 0 开始的整数数组 capacity 和 rocks 。第 i 个背包最大可以装 capacity[i] 块石头，当前已经装了 rocks[i] 块石头。另给你一个整数 additionalRocks ，表示你可以放置的额外石头数量，石头可以往 任意 背包中放置。 请你将额外的石头放入一些背包中，并返回放置后装满石头的背包的 最大 数量。 示例 1： 输入：capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2 输出：3 解释： 1 块石头放入背包 0 ，1 块石头放入背包 1 。 每个背包中的石头总数是 [2,3,4,4] 。 背包 0 、背包 1 和 背包 2 都装满石头。 总计 3 个背包装满石头，所以返回 3 。 可以证明不存在超过 3 个背包装满石头的情况。 注意，可能存在其他放置石头的方案同样能够得到 3 这个结果。 示例 2： 输入：capacity = [10,2,2], rocks = [2,2,0], additionalRocks = 100 输出：3 解释： 8 块石头放入背包 0 ，2 块石头放入背包 2 。 每个背包中的石头总数是 [10,2,2] 。 背包 0 、背包 1 和背包 2 都装满石头。 总计 3 个背包装满石头，所以返回 3 。 可以证明不存在超过 3 个背包装满石头的情况。 注意，不必用完所有的额外石头。 提示： * n == capacity.length == rocks.length * 1 <= n <= 5 * 104 * 1 <= capacity[i] <= 109 * 0 <= rocks[i] <= capacity[i] * 1 <= additionalRocks <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用贪心算法，优先填充需要最少石头就能装满的背包。

算法步骤:
1. 计算每个背包还需要多少石头才能装满。
2. 将这些差值从小到大排序。
3. 依次填充背包，直到用完所有额外的石头或所有背包都装满。

关键点:
- 通过排序来确保优先填充需要最少石头的背包。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是背包的数量。排序操作的时间复杂度为 O(n log n)。
空间复杂度: O(n)，存储每个背包还需要的石头数量。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def maximum_bags(capacity: List[int], rocks: List[int], additional_rocks: int) -> int:
    """
    函数式接口 - 返回放置后装满石头的背包的最大数量
    """
    # 计算每个背包还需要多少石头才能装满
    remaining_rocks = [c - r for c, r in zip(capacity, rocks)]
    
    # 将这些差值从小到大排序
    remaining_rocks.sort()
    
    # 依次填充背包，直到用完所有额外的石头或所有背包都装满
    full_bags = 0
    for needed_rocks in remaining_rocks:
        if additional_rocks >= needed_rocks:
            full_bags += 1
            additional_rocks -= needed_rocks
        else:
            break
    
    return full_bags

Solution = create_solution(maximum_bags)