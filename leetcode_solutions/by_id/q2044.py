# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2044
标题: Number of Wonderful Substrings
难度: medium
链接: https://leetcode.cn/problems/number-of-wonderful-substrings/
题目类型: 位运算、哈希表、字符串、前缀和
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1915. 最美子字符串的数目 - 如果某个字符串中 至多一个 字母出现 奇数 次，则称其为 最美 字符串。 * 例如，"ccjjc" 和 "abab" 都是最美字符串，但 "ab" 不是。 给你一个字符串 word ，该字符串由前十个小写英文字母组成（'a' 到 'j'）。请你返回 word 中 最美非空子字符串 的数目。如果同样的子字符串在 word 中出现多次，那么应当对 每次出现 分别计数。 子字符串 是字符串中的一个连续字符序列。 示例 1： 输入：word = "aba" 输出：4 解释：4 个最美子字符串如下所示： - "aba" -> "a" - "aba" -> "b" - "aba" -> "a" - "aba" -> "aba" 示例 2： 输入：word = "aabb" 输出：9 解释：9 个最美子字符串如下所示： - "aabb" -> "a" - "aabb" -> "aa" - "aabb" -> "aab" - "aabb" -> "aabb" - "aabb" -> "a" - "aabb" -> "abb" - "aabb" -> "b" - "aabb" -> "bb" - "aabb" -> "b" 示例 3： 输入：word = "he" 输出：2 解释：2 个最美子字符串如下所示： - "he" -> "h" - "he" -> "e" 提示： * 1 <= word.length <= 105 * word 由从 'a' 到 'j' 的小写英文字母组成
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用前缀异或和与哈希表来记录每个前缀状态的出现次数，从而高效地计算出所有最美子字符串的数量。

算法步骤:
1. 初始化一个哈希表 `prefix_count`，用于记录每个前缀状态的出现次数。初始时将 `0` 状态的出现次数设为 1。
2. 遍历字符串 `word`，使用一个变量 `state` 来表示当前前缀的奇偶状态。
3. 对于每个字符，更新 `state`，并计算当前状态和所有可能的单个字母翻转后的状态在哈希表中的出现次数。
4. 更新结果 `res`，将当前状态和所有可能的单个字母翻转后的状态的出现次数累加到 `res` 中。
5. 更新哈希表 `prefix_count`，增加当前状态的出现次数。

关键点:
- 使用位运算来表示前缀的奇偶状态。
- 使用哈希表来记录每个前缀状态的出现次数，从而高效地计算出所有最美子字符串的数量。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是字符串 `word` 的长度。我们只需要遍历字符串一次。
空间复杂度: O(1)，哈希表的大小最多为 2^10 = 1024，因此可以视为常数空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def count_wonderful_substrings(word: str) -> int:
    """
    计算最美子字符串的数量
    """
    prefix_count = [0] * 1024
    prefix_count[0] = 1
    state = 0
    res = 0
    
    for char in word:
        # 更新当前前缀的奇偶状态
        state ^= 1 << (ord(char) - ord('a'))
        
        # 计算当前状态的出现次数
        res += prefix_count[state]
        
        # 计算所有可能的单个字母翻转后的状态的出现次数
        for i in range(10):
            res += prefix_count[state ^ (1 << i)]
        
        # 更新哈希表
        prefix_count[state] += 1
    
    return res


Solution = create_solution(count_wonderful_substrings)