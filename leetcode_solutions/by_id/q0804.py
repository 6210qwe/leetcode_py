# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 804
标题: Rotated Digits
难度: medium
链接: https://leetcode.cn/problems/rotated-digits/
题目类型: 数学、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
788. 旋转数字 - 我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。 如果一个数的每位数字被旋转以后仍然还是一个数字， 则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方（在这种情况下，它们以不同的方向旋转，换句话说，2 和 5 互为镜像）；6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。 现在我们有一个正整数 N, 计算从 1 到 N 中有多少个数 X 是好数？ 示例： 输入: 10 输出: 4 解释: 在[1, 10]中有四个好数： 2, 5, 6, 9。 注意 1 和 10 不是好数, 因为他们在旋转之后不变。 提示： * N 的取值范围是 [1, 10000]。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来计算从 1 到 N 中有多少个数 X 是好数。

算法步骤:
1. 定义状态 dp[i][j] 表示长度为 i 的数字中，是否包含 2, 5, 6, 9 中的一个，并且是否包含 3, 4, 7 中的一个。
2. 初始化 dp 数组，dp[0][0] = 1 表示空字符串是有效的。
3. 遍历每一位数字，更新 dp 数组。
4. 最终结果为 dp[len(N)][0]。

关键点:
- 通过动态规划避免重复计算。
- 使用位运算优化状态表示。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(d * 2^d)，其中 d 是 N 的位数。
空间复杂度: O(d * 2^d)，用于存储 dp 数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(n: int) -> int:
    """
    函数式接口 - 计算从 1 到 N 中有多少个数 X 是好数
    """
    # 将 N 转换为字符串
    n_str = str(n)
    d = len(n_str)
    
    # 定义 dp 数组
    dp = [[0 for _ in range(2)] for _ in range(d + 1)]
    dp[0][0] = 1
    
    # 有效数字集合
    valid_digits = {'0', '1', '8'}
    good_digits = {'2', '5', '6', '9'}
    invalid_digits = {'3', '4', '7'}
    
    for i in range(1, d + 1):
        for j in range(10):
            if str(j) in invalid_digits:
                continue
            is_good = 1 if str(j) in good_digits else 0
            for k in range(2):
                if j < int(n_str[i - 1]):
                    dp[i][k | is_good] += dp[i - 1][k]
                elif j == int(n_str[i - 1]):
                    dp[i][k | is_good] += dp[i - 1][k]
    
    return dp[d][1]


Solution = create_solution(solution_function_name)