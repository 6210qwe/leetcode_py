# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3446
标题: Find the Number of Good Pairs I
难度: easy
链接: https://leetcode.cn/problems/find-the-number-of-good-pairs-i/
题目类型: 数组、哈希表
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3162. 优质数对的总数 I - 给你两个整数数组 nums1 和 nums2，长度分别为 n 和 m。同时给你一个正整数 k。 如果 nums1[i] 可以除尽 nums2[j] * k，则称数对 (i, j) 为 优质数对（0 <= i <= n - 1, 0 <= j <= m - 1）。 返回 优质数对 的总数。 示例 1： 输入：nums1 = [1,3,4], nums2 = [1,3,4], k = 1 输出：5 解释： 5个优质数对分别是 (0, 0), (1, 0), (1, 1), (2, 0), 和 (2, 2)。 示例 2： 输入：nums1 = [1,2,4,12], nums2 = [2,4], k = 3 输出：2 解释： 2个优质数对分别是 (3, 0) 和 (3, 1)。 提示： * 1 <= n, m <= 50 * 1 <= nums1[i], nums2[j] <= 50 * 1 <= k <= 50
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用双重循环遍历 nums1 和 nums2，检查每个数对是否满足条件。

算法步骤:
1. 初始化计数器 count 为 0。
2. 使用双重循环遍历 nums1 和 nums2。
3. 对于每一对 (i, j)，检查 nums1[i] 是否可以整除 nums2[j] * k。
4. 如果满足条件，增加计数器 count。
5. 返回计数器 count。

关键点:
- 直接使用双重循环进行检查，时间复杂度为 O(n * m)。
- 空间复杂度为 O(1)，因为只使用了常数级的额外空间。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * m)
空间复杂度: O(1)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(nums1: List[int], nums2: List[int], k: int) -> int:
    """
    函数式接口 - 计算优质数对的总数
    """
    count = 0
    for num1 in nums1:
        for num2 in nums2:
            if num1 % (num2 * k) == 0:
                count += 1
    return count


Solution = create_solution(solution_function_name)