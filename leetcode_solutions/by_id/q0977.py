# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 977
标题: Distinct Subsequences II
难度: hard
链接: https://leetcode.cn/problems/distinct-subsequences-ii/
题目类型: 字符串、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
940. 不同的子序列 II - 给定一个字符串 s，计算 s 的 不同非空子序列 的个数。因为结果可能很大，所以返回答案需要对 10^9 + 7 取余 。 字符串的 子序列 是经由原字符串删除一些（也可能不删除）字符但不改变剩余字符相对位置的一个新字符串。 * 例如，"ace" 是 "abcde" 的一个子序列，但 "aec" 不是。 示例 1： 输入：s = "abc" 输出：7 解释：7 个不同的子序列分别是 "a", "b", "c", "ab", "ac", "bc", 以及 "abc"。 示例 2： 输入：s = "aba" 输出：6 解释：6 个不同的子序列分别是 "a", "b", "ab", "ba", "aa" 以及 "aba"。 示例 3： 输入：s = "aaa" 输出：3 解释：3 个不同的子序列分别是 "a", "aa" 以及 "aaa"。 提示： * 1 <= s.length <= 2000 * s 仅由小写英文字母组成
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来计算不同子序列的数量。我们维护一个数组 `dp`，其中 `dp[i]` 表示以第 `i` 个字符结尾的不同子序列的数量。对于每个字符，我们可以选择将其添加到之前的所有子序列中，或者单独作为一个新的子序列。

算法步骤:
1. 初始化一个长度为 26 的数组 `last`，用于记录每个字符上次出现的位置。
2. 初始化一个长度为 `n+1` 的数组 `dp`，其中 `dp[0] = 0`，表示空字符串的子序列数量为 0。
3. 遍历字符串 `s`，对于每个字符 `c`：
   - 更新 `dp[i+1]` 为 `dp[i] * 2 % MOD`，表示将当前字符添加到之前的所有子序列中。
   - 如果字符 `c` 之前已经出现过，则减去从上次出现位置到当前位置之间的子序列数量，避免重复计算。
   - 更新 `last[c]` 为当前索引 `i`。
4. 返回 `dp[n] - 1`，减去空字符串的情况。

关键点:
- 使用 `last` 数组记录每个字符上次出现的位置，避免重复计算。
- 动态规划的状态转移方程为 `dp[i+1] = (dp[i] * 2 - dp[last[c]]) % MOD`。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是字符串 s 的长度。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution

MOD = 10**9 + 7

def distinct_subsequences(s: str) -> int:
    n = len(s)
    last = [-1] * 26
    dp = [0] * (n + 1)
    dp[0] = 0

    for i in range(n):
        c = ord(s[i]) - ord('a')
        dp[i + 1] = (dp[i] * 2) % MOD
        if last[c] >= 0:
            dp[i + 1] -= dp[last[c]]
        dp[i + 1] %= MOD
        last[c] = i

    return (dp[n] - 1) % MOD

Solution = create_solution(distinct_subsequences)