# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3164
标题: Last Visited Integers
难度: easy
链接: https://leetcode.cn/problems/last-visited-integers/
题目类型: 数组、模拟
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2899. 上一个遍历的整数 - 给你一个整数数组 nums ，其中 nums[i] 要么是一个正整数，要么是 -1 。我们需要为每个 -1 找到相应的正整数，我们称之为最后访问的整数。 为了达到这个目标，定义两个空数组：seen 和 ans。 从数组 nums 的头部开始遍历。 * 如果遇到正整数，把它添加到 seen 的 头部。 * 如果遇到 -1，则设 k 是到目前为止看到的 连续 -1 的数目(包括当前 -1)， * 如果 k 小于等于 seen 的长度，把 seen 的第 k 个元素添加到 ans。 * 如果 k 严格大于 seen 的长度，把 -1 添加到 ans。 请你返回数组 ans。 示例 1： 输入：nums = [1,2,-1,-1,-1] 输出：[2,1,-1] 解释： 开始时 seen = [] 且 ans = []。 1.处理 nums[0]：nums 中的第一个元素是 1。我们将其放在 seen 的前面。现在，seen == [1]。 2.处理 nums[1]：下一个元素是 2。我们将其放在 seen 的前面。现在，seen == [2, 1]。 3.处理 nums[2]：下一个元素是 -1。这是 -1 的第一次出现，所以 k == 1。我们找到 seen 中的第一个元素，把 2 添加到 ans。现在，ans == [2]。 4.处理 nums[3]：又一个 -1。这是 -1 的第二次出现，所以 k == 2。seen 中的第二个元素是 1，所以我们把 1 添加到 ans。现在，ans == [2, 1]。 5.处理 nums[4]：又一个 -1。第三次出现，让 k = 3。然而，seen 中只有两个元素（[2, 1]）。因为 k 比 seen 中的元素数量更大，我们把 -1 添加到 ans。最终，ans == [2, 1, -1]。 示例 2： 输入：nums = [1,-1,2,-1,-1] 输出：[1,2,1] 解释： 开始时 seen = [] 且 ans = []。 1.处理 nums[0]：nums 中的第一个元素是 1。我们将其放在 seen 的前面。现在，seen == [1]。 2.处理 nums[1]：下一个元素是 -1。这是 -1 的第一次出现，所以 k == 1。我们找到 seen 中的第一个元素，即 1。把 1 添加到 ans。现在，ans == [1]。 3.处理 nums[2]：下一个元素是 2。我们将其放在 seen 的前面。现在，seen == [2, 1]。 4.处理 nums[3]：下一个元素是 -1。这个 -1 与 第一个 -1 不连续，因为中间有个 2。因此，k 重置为 1。seen 中的第一个元素是 2，所以我们把 2 添加到 ans。现在，ans == [1, 2]。 5.处理 nums[4]：又一个 -1。它与前一个 -1 相邻，所以 k == 2。seen 中的第 2 个元素是 1。把 1 添加到 ans。最终，ans == [1, 2, 1]。 提示： * 1 <= nums.length <= 100 * nums[i] == -1 或 1 <= nums[i] <= 100
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用一个列表 seen 来存储遇到的正整数，并使用一个变量 k 来记录连续 -1 的数量。遍历 nums 数组，根据遇到的值更新 seen 和 k，并将结果添加到 ans 列表中。

算法步骤:
1. 初始化 seen 和 ans 列表，以及 k 变量。
2. 遍历 nums 数组：
   - 如果遇到正整数，将其添加到 seen 列表的开头。
   - 如果遇到 -1，增加 k 的值，并根据 k 的值从 seen 列表中获取相应的元素或 -1，将其添加到 ans 列表中。
3. 返回 ans 列表。

关键点:
- 使用列表的 insert 方法将正整数添加到 seen 列表的开头。
- 使用 k 记录连续 -1 的数量，并根据 k 从 seen 列表中获取相应的元素。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是 nums 的长度。我们只需要遍历一次 nums 数组。
空间复杂度: O(n)，在最坏情况下，seen 列表可能包含所有的正整数。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def last_visited_integers(nums: List[int]) -> List[int]:
    """
    函数式接口 - 实现
    """
    seen = []
    ans = []
    k = 0

    for num in nums:
        if num != -1:
            seen.insert(0, num)
            k = 0
        else:
            k += 1
            if k <= len(seen):
                ans.append(seen[k - 1])
            else:
                ans.append(-1)

    return ans


Solution = create_solution(last_visited_integers)