# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 456
标题: 132 Pattern
难度: medium
链接: https://leetcode.cn/problems/132-pattern/
题目类型: 栈、数组、二分查找、有序集合、单调栈
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
456. 132 模式 - 给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i < j < k 和 nums[i] < nums[k] < nums[j] 。 如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。 示例 1： 输入：nums = [1,2,3,4] 输出：false 解释：序列中不存在 132 模式的子序列。 示例 2： 输入：nums = [3,1,4,2] 输出：true 解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。 示例 3： 输入：nums = [-1,3,2,0] 输出：true 解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。 提示： * n == nums.length * 1 <= n <= 2 * 105 * -109 <= nums[i] <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 单调栈，从右往左遍历，维护递减栈

算法步骤:
1. 从右往左遍历，维护一个单调递减栈
2. 记录被弹出元素的最大值作为nums[k]的候选
3. 如果当前元素小于候选值，说明找到了132模式

关键点:
- 从右往左遍历，找中间值
- 使用单调栈维护可能的nums[j]
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 遍历数组一次
空间复杂度: O(n) - 栈空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def pattern_132(nums: List[int]) -> bool:
    """
    函数式接口 - 132 模式
    
    实现思路:
    从右往左遍历，使用单调栈找中间值，维护被弹出元素的最大值。
    
    Args:
        nums: 整数数组
        
    Returns:
        是否存在132模式
        
    Example:
        >>> pattern_132([3,1,4,2])
        True
    """
    n = len(nums)
    if n < 3:
        return False
    
    # 从右往左遍历，维护单调递减栈
    stack = []
    # 记录被弹出元素的最大值，作为nums[k]的候选
    max_k = float('-inf')
    
    for i in range(n - 1, -1, -1):
        # 如果当前元素小于max_k，说明找到了132模式
        if nums[i] < max_k:
            return True
        
        # 维护单调递减栈
        while stack and stack[-1] < nums[i]:
            max_k = max(max_k, stack.pop())
        
        stack.append(nums[i])
    
    return False


# 自动生成Solution类（无需手动编写）
Solution = create_solution(pattern_132)
