# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000131
标题: 数字游戏
难度: hard
链接: https://leetcode.cn/problems/5TxKeK/
题目类型: 数组、数学、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCP 24. 数字游戏 - 小扣在秋日市集入口处发现了一个数字游戏。主办方共有 `N` 个计数器，计数器编号为 `0 ~ N-1`。每个计数器上分别显示了一个数字，小扣按计数器编号升序将所显示的数字记于数组 `nums`。每个计数器上有两个按钮，分别可以实现将显示数字加一或减一。小扣每一次操作可以选择一个计数器，按下加一或减一按钮。 主办方请小扣回答出一个长度为 `N` 的数组，第 `i` 个元素(0 <= i < N)表示将 `0~i` 号计数器 **初始** 所示数字操作成满足所有条件 `nums[a]+1 == nums[a+1],(0 <= a < i)` 的最小操作数。回答正确方可进入秋日市集。 由于答案可能很大，请将每个最小操作数对 `1,000,000,007` 取余。 **示例 1：** >输入：`nums = [3,4,5,1,6,7]` > >输出：`[0,0,0,5,6,7]` > >解释： >i = 0，[3] 无需操作 >i = 1，[3,4] 无需操作； >i = 2，[3,4,5] 无需操作； >i = 3，将 [3,4,5,1] 操作成 [3,4,5,6], 最少 5 次操作； >i = 4，将 [3,4,5,1,6] 操作成 [3,4,5,6,7], 最少 6 次操作； >i = 5，将 [3,4,5,1,6,7] 操作成 [3,4,5,6,7,8]，最少 7 次操作； >返回 [0,0,0,5,6,7]。 **示例 2：** >输入：`nums = [1,2,3,4,5]` > >输出：`[0,0,0,0,0]` > >解释：对于任意计数器编号 i 都无需操作。 **示例 3：** >输入：`nums = [1,1,1,2,3,4]` > >输出：`[0,1,2,3,3,3]` > >解释： >i = 0，无需操作； >i = 1，将 [1,1] 操作成 [1,2] 或 [0,1] 最少 1 次操作； >i = 2，将 [1,1,1] 操作成 [1,2,3] 或 [0,1,2]，最少 2 次操作； >i = 3，将 [1,1,1,2] 操作成 [1,2,3,4] 或 [0,1,2,3]，最少 3 次操作； >i = 4，将 [1,1,1,2,3] 操作成 [-1,0,1,2,3]，最少 3 次操作； >i = 5，将 [1,1,1,2,3,4] 操作成 [-1,0,1,2,3,4]，最少 3 次操作； >返回 [0,1,2,3,3,3]。 **提示：** - `1 <= nums.length <= 10^5` - `1 <= nums[i] <= 10^3`
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用两个堆（优先队列）来维护当前窗口内的最大值和最小值，从而计算最小操作数。

算法步骤:
1. 初始化两个堆（优先队列），一个用于存储当前窗口内的最大值，另一个用于存储当前窗口内的最小值。
2. 遍历数组，对于每个位置 i，计算当前窗口内的最小操作数。
3. 更新结果数组，并将当前元素加入两个堆中。
4. 返回结果数组。

关键点:
- 使用两个堆来维护当前窗口内的最大值和最小值，从而高效地计算最小操作数。
- 通过维护窗口内的差值和，可以快速计算最小操作数。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是数组的长度。每次插入和删除堆的操作时间复杂度为 O(log n)。
空间复杂度: O(n)，需要额外的空间来存储两个堆。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def solution_function_name(nums: List[int]) -> List[int]:
    """
    函数式接口 - 计算将 0~i 号计数器所示数字操作成满足所有条件 nums[a]+1 == nums[a+1],(0 <= a < i) 的最小操作数
    """
    MOD = 1000000007
    n = len(nums)
    result = [0] * n
    max_heap = []
    min_heap = []
    max_sum = 0
    min_sum = 0
    diff_sum = 0
    
    for i in range(n):
        # 调整 nums[i] 使其与前一个元素相差 1
        adjusted_num = nums[i] - i
        diff_sum += adjusted_num
        
        # 维护最大堆
        heapq.heappush(max_heap, -adjusted_num)
        max_sum += adjusted_num
        if len(max_heap) > (i + 1) // 2:
            max_sum -= -heapq.heappop(max_heap)
        
        # 维护最小堆
        heapq.heappush(min_heap, adjusted_num)
        min_sum += adjusted_num
        if len(min_heap) > (i + 1) // 2:
            min_sum -= heapq.heappop(min_heap)
        
        # 计算最小操作数
        if (i + 1) % 2 == 0:
            median = (-max_heap[0] + min_heap[0]) // 2
        else:
            median = -max_heap[0]
        
        result[i] = (diff_sum - (i + 1) * median) % MOD
    
    return result

Solution = create_solution(solution_function_name)