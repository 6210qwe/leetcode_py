# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000483
标题: 美观的花束
难度: medium
链接: https://leetcode.cn/problems/1GxJYY/
题目类型: 数组、滑动窗口
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCP 68. 美观的花束 - 力扣嘉年华的花店中从左至右摆放了一排鲜花，记录于整型一维矩阵 `flowers` 中每个数字表示该位置所种鲜花的品种编号。你可以选择一段区间的鲜花做成插花，且不能丢弃。 在你选择的插花中，如果每一品种的鲜花数量都不超过 `cnt` 朵，那么我们认为这束插花是 「美观的」。 > - 例如：`[5,5,5,6,6]` 中品种为 `5` 的花有 `3` 朵， 品种为 `6` 的花有 `2` 朵，**每一品种** 的数量均不超过 `3` 请返回在这一排鲜花中，共有多少种可选择的区间，使得插花是「美观的」。 **注意：** - 结果无需取模，用例保证输出为 int32 范围内的整数。 **示例 1：** >输入：`flowers = [1,2,3,2], cnt = 1` > >输出：`8` > >解释：相同的鲜花不超过 `1` 朵，共有 `8` 种花束是美观的； >长度为 `1` 的区间 `[1]、[2]、[3]、[2]` 均满足条件，共 `4` 种可选择区间 >长度为 `2` 的区间 `[1,2]、[2,3]、[3,2]` 均满足条件，共 `3` 种可选择区间 >长度为 `3` 的区间 `[1,2,3]` 满足条件，共 `1` 种可选择区间。 >区间 `[2,3,2],[1,2,3,2]` 都包含了 `2` 朵鲜花 `2` ，不满足条件。 >返回总数 `4+3+1 = 8` **示例 2：** >输入：`flowers = [5,3,3,3], cnt = 2` > >输出：`8` **提示：** - `1 <= flowers.length <= 10^5` - `1 <= flowers[i] <= 10^5` - `1 <= cnt <= 10^5`
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用滑动窗口来统计每个品种的鲜花数量，并确保每个品种的数量不超过 `cnt`。

算法步骤:
1. 初始化两个指针 `left` 和 `right`，分别表示滑动窗口的左右边界。
2. 使用一个字典 `count` 来记录当前窗口内每个品种的鲜花数量。
3. 移动右指针 `right`，扩展窗口，同时更新 `count` 字典。
4. 如果某个品种的鲜花数量超过 `cnt`，则移动左指针 `left`，缩小窗口，直到所有品种的鲜花数量都不超过 `cnt`。
5. 计算当前窗口的合法子区间数量，并累加到结果中。

关键点:
- 使用滑动窗口来维护当前区间的合法性。
- 通过字典来高效地统计每个品种的鲜花数量。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是 `flowers` 的长度。每个元素最多被访问两次（一次通过右指针，一次通过左指针）。
空间复杂度: O(k)，其中 k 是不同品种的鲜花数量。字典 `count` 最多存储 k 个键值对。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(flowers: List[int], cnt: int) -> int:
    """
    函数式接口 - 实现最优解法
    """
    left = 0
    count = {}
    result = 0
    
    for right in range(len(flowers)):
        if flowers[right] in count:
            count[flowers[right]] += 1
        else:
            count[flowers[right]] = 1
        
        while count[flowers[right]] > cnt:
            count[flowers[left]] -= 1
            left += 1
        
        result += right - left + 1
    
    return result


Solution = create_solution(solution_function_name)