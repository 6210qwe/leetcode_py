# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2662
标题: Check Knight Tour Configuration
难度: medium
链接: https://leetcode.cn/problems/check-knight-tour-configuration/
题目类型: 深度优先搜索、广度优先搜索、数组、矩阵、模拟
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2596. 检查骑士巡视方案 - 骑士在一张 n x n 的棋盘上巡视。在 有效 的巡视方案中，骑士会从棋盘的 左上角 出发，并且访问棋盘上的每个格子 恰好一次 。 给你一个 n x n 的整数矩阵 grid ，由范围 [0, n * n - 1] 内的不同整数组成，其中 grid[row][col] 表示单元格 (row, col) 是骑士访问的第 grid[row][col] 个单元格。骑士的行动是从下标 0 开始的。 如果 grid 表示了骑士的有效巡视方案，返回 true；否则返回 false。 注意，骑士行动时可以垂直移动两个格子且水平移动一个格子，或水平移动两个格子且垂直移动一个格子。下图展示了骑士从某个格子出发可能的八种行动路线。 [https://pic.leetcode.cn/1694590028-CTMBQL-image.png] 示例 1： [https://pic.leetcode.cn/1694590044-AmhkRb-image.png] 输入：grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]] 输出：true 解释：grid 如上图所示，可以证明这是一个有效的巡视方案。 示例 2： [https://pic.leetcode.cn/1694590057-FIMBAG-image.png] 输入：grid = [[0,3,6],[5,8,1],[2,7,4]] 输出：false 解释：grid 如上图所示，考虑到骑士第 7 次行动后的位置，第 8 次行动是无效的。 提示： * n == grid.length == grid[i].length * 3 <= n <= 7 * 0 <= grid[row][col] < n * n * grid 中的所有整数 互不相同
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 检查骑士的每一步是否符合骑士的移动规则，并且确保所有格子都被访问。

算法步骤:
1. 构建一个字典来存储每个数字对应的坐标。
2. 遍历字典，检查每一步是否符合骑士的移动规则。
3. 如果所有步都符合规则并且所有格子都被访问，则返回 True，否则返回 False。

关键点:
- 使用字典存储每个数字的坐标，方便快速查找。
- 检查每一步是否符合骑士的移动规则。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2)
空间复杂度: O(n^2)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def check_knight_tour(grid: List[List[int]]) -> bool:
    """
    检查给定的网格是否表示有效的骑士巡视方案。
    """
    n = len(grid)
    if n == 0:
        return False
    
    # 构建一个字典来存储每个数字对应的坐标
    pos = {}
    for i in range(n):
        for j in range(n):
            pos[grid[i][j]] = (i, j)
    
    # 定义骑士的移动方向
    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]
    
    # 检查每一步是否符合骑士的移动规则
    for step in range(1, n * n):
        r1, c1 = pos[step - 1]
        r2, c2 = pos[step]
        if not any((r1 + dr, c1 + dc) == (r2, c2) for dr, dc in moves):
            return False
    
    return True


Solution = create_solution(check_knight_tour)