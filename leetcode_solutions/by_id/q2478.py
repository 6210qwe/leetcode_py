# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2478
标题: Longest Nice Subarray
难度: medium
链接: https://leetcode.cn/problems/longest-nice-subarray/
题目类型: 位运算、数组、滑动窗口
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2401. 最长优雅子数组 - 给你一个由 正 整数组成的数组 nums 。 如果 nums 的子数组中位于 不同 位置的每对元素按位 与（AND）运算的结果等于 0 ，则称该子数组为 优雅 子数组。 返回 最长 的优雅子数组的长度。 子数组 是数组中的一个 连续 部分。 注意：长度为 1 的子数组始终视作优雅子数组。 示例 1： 输入：nums = [1,3,8,48,10] 输出：3 解释：最长的优雅子数组是 [3,8,48] 。子数组满足题目条件： - 3 AND 8 = 0 - 3 AND 48 = 0 - 8 AND 48 = 0 可以证明不存在更长的优雅子数组，所以返回 3 。 示例 2： 输入：nums = [3,1,5,11,13] 输出：1 解释：最长的优雅子数组长度为 1 ，任何长度为 1 的子数组都满足题目条件。 提示： * 1 <= nums.length <= 105 * 1 <= nums[i] <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用滑动窗口来找到最长的优雅子数组。

算法步骤:
1. 初始化两个指针 left 和 right，分别表示滑动窗口的左右边界。
2. 使用一个变量 current_and 来记录当前窗口内所有元素的按位与结果。
3. 移动右指针扩展窗口，更新 current_and。
4. 如果 current_and 不为 0，说明当前窗口内的元素不满足优雅子数组的条件，移动左指针缩小窗口，直到 current_and 为 0。
5. 在每次移动右指针时，更新最长优雅子数组的长度。

关键点:
- 使用按位与操作来判断窗口内的元素是否满足条件。
- 滑动窗口的动态调整确保了时间复杂度的最优。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是数组的长度。每个元素最多被访问两次（一次通过右指针，一次通过左指针）。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def longest_nice_subarray(nums: List[int]) -> int:
    """
    函数式接口 - 返回最长的优雅子数组的长度
    """
    left = 0
    current_and = 0
    max_length = 0
    
    for right in range(len(nums)):
        while (current_and & nums[right]) != 0:
            current_and ^= nums[left]
            left += 1
        current_and |= nums[right]
        max_length = max(max_length, right - left + 1)
    
    return max_length


Solution = create_solution(longest_nice_subarray)