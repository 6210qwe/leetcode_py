# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2272
标题: Maximum Good People Based on Statements
难度: hard
链接: https://leetcode.cn/problems/maximum-good-people-based-on-statements/
题目类型: 位运算、数组、回溯、枚举
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2151. 基于陈述统计最多好人数 - 游戏中存在两种角色： * 好人：该角色只说真话。 * 坏人：该角色可能说真话，也可能说假话。 给你一个下标从 0 开始的二维整数数组 statements ，大小为 n x n ，表示 n 个玩家对彼此角色的陈述。具体来说，statements[i][j] 可以是下述值之一： * 0 表示 i 的陈述认为 j 是 坏人 。 * 1 表示 i 的陈述认为 j 是 好人 。 * 2 表示 i 没有对 j 作出陈述。 另外，玩家不会对自己进行陈述。形式上，对所有 0 <= i < n ，都有 statements[i][i] = 2 。 根据这 n 个玩家的陈述，返回可以认为是 好人 的 最大 数目。 示例 1： [https://assets.leetcode.com/uploads/2022/01/15/logic1.jpg] 输入：statements = [[2,1,2],[1,2,2],[2,0,2]] 输出：2 解释：每个人都做一条陈述。 - 0 认为 1 是好人。 - 1 认为 0 是好人。 - 2 认为 1 是坏人。 以 2 为突破点。 - 假设 2 是一个好人： - 基于 2 的陈述，1 是坏人。 - 那么可以确认 1 是坏人，2 是好人。 - 基于 1 的陈述，由于 1 是坏人，那么他在陈述时可能： - 说真话。在这种情况下会出现矛盾，所以假设无效。 - 说假话。在这种情况下，0 也是坏人并且在陈述时说假话。 - 在认为 2 是好人的情况下，这组玩家中只有一个好人。 - 假设 2 是一个坏人： - 基于 2 的陈述，由于 2 是坏人，那么他在陈述时可能： - 说真话。在这种情况下，0 和 1 都是坏人。 - 在认为 2 是坏人但说真话的情况下，这组玩家中没有一个好人。 - 说假话。在这种情况下，1 是好人。 - 由于 1 是好人，0 也是好人。 - 在认为 2 是坏人且说假话的情况下，这组玩家中有两个好人。 在最佳情况下，至多有两个好人，所以返回 2 。 注意，能得到此结论的方法不止一种。 示例 2： [https://assets.leetcode.com/uploads/2022/01/15/logic2.jpg] 输入：statements = [[2,0],[0,2]] 输出：1 解释：每个人都做一条陈述。 - 0 认为 1 是坏人。 - 1 认为 0 是坏人。 以 0 为突破点。 - 假设 0 是一个好人： - 基于与 0 的陈述，1 是坏人并说假话。 - 在认为 0 是好人的情况下，这组玩家中只有一个好人。 - 假设 0 是一个坏人： - 基于 0 的陈述，由于 0 是坏人，那么他在陈述时可能： - 说真话。在这种情况下，0 和 1 都是坏人。 - 在认为 0 是坏人但说真话的情况下，这组玩家中没有一个好人。 - 说假话。在这种情况下，1 是好人。 - 在认为 0 是坏人且说假话的情况下，这组玩家中只有一个好人。 在最佳情况下，至多有一个好人，所以返回 1 。 注意，能得到此结论的方法不止一种。 提示： * n == statements.length == statements[i].length * 2 <= n <= 15 * statements[i][j] 的值为 0、1 或 2 * statements[i][i] == 2
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用位掩码和回溯法来枚举所有可能的好人组合，并验证每个组合是否满足所有好人的陈述。

算法步骤:
1. 使用位掩码来表示每个人是否是好人。
2. 枚举所有可能的好人组合（从 0 到 2^n - 1）。
3. 对于每个组合，检查其是否满足所有好人的陈述。
4. 如果满足，则更新最大好人数。

关键点:
- 使用位掩码来高效地表示和操作好人组合。
- 回溯法用于枚举所有可能的组合。
- 验证每个组合是否满足所有好人的陈述。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(2^n * n^2)
- 枚举所有可能的好人组合需要 O(2^n) 的时间。
- 对于每个组合，验证其是否满足所有好人的陈述需要 O(n^2) 的时间。

空间复杂度: O(1)
- 除了输入和输出外，只需要常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(statements: List[List[int]]) -> int:
    """
    函数式接口 - 返回可以认为是好人的最大数目
    """
    n = len(statements)
    max_good_people = 0

    def is_valid(mask: int) -> bool:
        for i in range(n):
            if mask & (1 << i):
                for j in range(n):
                    if statements[i][j] == 0 and mask & (1 << j):
                        return False
                    if statements[i][j] == 1 and not (mask & (1 << j)):
                        return False
        return True

    for mask in range(1 << n):
        if is_valid(mask):
            max_good_people = max(max_good_people, bin(mask).count('1'))

    return max_good_people


Solution = create_solution(solution_function_name)