# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3712
标题: Minimum Cost to Make Arrays Identical
难度: medium
链接: https://leetcode.cn/problems/minimum-cost-to-make-arrays-identical/
题目类型: 贪心、数组、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3424. 将数组变相同的最小代价 - 给你两个长度都为 n 的整数数组 arr 和 brr 以及一个整数 k 。你可以对 arr 执行以下操作任意次： * 将 arr 分割成若干个 连续的 子数组，并将这些子数组按任意顺序重新排列。这个操作的代价为 k 。 * 选择 arr 中的任意一个元素，将它增加或者减少一个正整数 x 。这个操作的代价为 x 。 请你返回将 arr 变为 brr 的 最小 总代价。 子数组 是一个数组中一段连续 非空 的元素序列。 示例 1： 输入：arr = [-7,9,5], brr = [7,-2,-5], k = 2 输出：13 解释： * 将 arr 分割成两个连续子数组：[-7] 和 [9, 5] 然后将它们重新排列成 [9, 5, -7] ，代价为 2 。 * 将 arr[0] 减小 2 ，数组变为 [7, 5, -7] ，操作代价为 2 。 * 将 arr[1] 减小 7 ，数组变为 [7, -2, -7] ，操作代价为 7 。 * 将 arr[2] 增加 2 ，数组变为 [7, -2, -5] ，操作代价为 2 。 将两个数组变相等的总代价为 2 + 2 + 7 + 2 = 13 。 示例 2： 输入：arr = [2,1], brr = [2,1], k = 0 输出：0 解释： 由于数组已经相等，不需要进行任何操作，所以总代价为 0 。 提示： * 1 <= arr.length == brr.length <= 105 * 0 <= k <= 2 * 1010 * -105 <= arr[i] <= 105 * -105 <= brr[i] <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过排序和贪心算法来最小化调整数组的代价。

算法步骤:
1. 对 arr 和 brr 进行排序。
2. 初始化总代价 total_cost 为 0。
3. 遍历排序后的数组，计算每个位置上需要调整的值的绝对差值，并累加到 total_cost。
4. 如果 total_cost 大于 k，则使用 k 作为分割和重排的代价，否则直接使用 total_cost。

关键点:
- 通过排序和贪心算法确保每次调整的代价最小。
- 通过比较 total_cost 和 k 来决定是否使用分割和重排操作。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是数组的长度。排序操作的时间复杂度是 O(n log n)。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def minimum_cost_to_make_arrays_identical(arr: List[int], brr: List[int], k: int) -> int:
    """
    函数式接口 - 返回将 arr 变为 brr 的最小总代价
    """
    # 对 arr 和 brr 进行排序
    arr.sort()
    brr.sort()

    # 初始化总代价
    total_cost = 0

    # 计算每个位置上需要调整的值的绝对差值
    for a, b in zip(arr, brr):
        total_cost += abs(a - b)

    # 如果总代价大于 k，则使用 k 作为分割和重排的代价
    if total_cost > k:
        return k
    else:
        return total_cost


Solution = create_solution(minimum_cost_to_make_arrays_identical)