# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 132
标题: Palindrome Partitioning II
难度: hard
链接: https://leetcode.cn/problems/palindrome-partitioning-ii/
题目类型: 字符串、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
132. 分割回文串 II - 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文串。 返回符合要求的 最少分割次数 。 示例 1： 输入：s = "aab" 输出：1 解释：只需一次分割就可将 s 分割成 ["aa","b"] 这样两个回文子串。 示例 2： 输入：s = "a" 输出：0 示例 3： 输入：s = "ab" 输出：1 提示： * 1 <= s.length <= 2000 * s 仅由小写英文字母组成
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 动态规划，dp[i]表示前i个字符的最少分割次数

算法步骤:
1. 使用DP预处理，判断所有子串是否为回文串
2. dp[i] = min(dp[j] + 1)，其中s[j:i]是回文串
3. 返回dp[n]

关键点:
- 动态规划，预处理回文串
- 时间复杂度O(n^2)，空间复杂度O(n^2)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2) - 需要预处理回文串和DP
空间复杂度: O(n^2) - DP数组空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from leetcode_solutions.utils.solution import create_solution


def palindrome_partitioning_ii(s: str) -> int:
    """
    函数式接口 - 分割回文串II
    
    实现思路:
    动态规划，dp[i]表示前i个字符的最少分割次数。
    
    Args:
        s: 字符串
        
    Returns:
        符合要求的最少分割次数
        
    Example:
        >>> palindrome_partitioning_ii("aab")
        1
    """
    n = len(s)
    # DP预处理，判断子串是否为回文串
    is_palindrome = [[False] * n for _ in range(n)]
    for i in range(n):
        is_palindrome[i][i] = True
    for i in range(n - 1):
        if s[i] == s[i + 1]:
            is_palindrome[i][i + 1] = True
    for length in range(3, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            if s[i] == s[j] and is_palindrome[i + 1][j - 1]:
                is_palindrome[i][j] = True
    
    # dp[i]表示前i个字符的最少分割次数
    dp = [float('inf')] * (n + 1)
    dp[0] = -1
    
    for i in range(1, n + 1):
        for j in range(i):
            if is_palindrome[j][i - 1]:
                dp[i] = min(dp[i], dp[j] + 1)
    
    return dp[n]


# 自动生成Solution类（无需手动编写）
Solution = create_solution(palindrome_partitioning_ii)
