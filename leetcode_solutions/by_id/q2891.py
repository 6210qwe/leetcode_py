# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2891
标题: Maximum Beauty of an Array After Applying Operation
难度: medium
链接: https://leetcode.cn/problems/maximum-beauty-of-an-array-after-applying-operation/
题目类型: 数组、二分查找、排序、滑动窗口
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2779. 数组的最大美丽值 - 给你一个下标从 0 开始的整数数组 nums 和一个 非负 整数 k 。 在一步操作中，你可以执行下述指令： * 在范围 [0, nums.length - 1] 中选择一个 此前没有选过 的下标 i 。 * 将 nums[i] 替换为范围 [nums[i] - k, nums[i] + k] 内的任一整数。 数组的 美丽值 定义为数组中由相等元素组成的最长子序列的长度。 对数组 nums 执行上述操作任意次后，返回数组可能取得的 最大 美丽值。 注意：你 只 能对每个下标执行 一次 此操作。 数组的 子序列 定义是：经由原数组删除一些元素（也可能不删除）得到的一个新数组，且在此过程中剩余元素的顺序不发生改变。 示例 1： 输入：nums = [4,6,1,2], k = 2 输出：3 解释：在这个示例中，我们执行下述操作： - 选择下标 1 ，将其替换为 4（从范围 [4,8] 中选出），此时 nums = [4,4,1,2] 。 - 选择下标 3 ，将其替换为 4（从范围 [0,4] 中选出），此时 nums = [4,4,1,4] 。 执行上述操作后，数组的美丽值是 3（子序列由下标 0 、1 、3 对应的元素组成）。 可以证明 3 是我们可以得到的由相等元素组成的最长子序列长度。 示例 2： 输入：nums = [1,1,1,1], k = 10 输出：4 解释：在这个示例中，我们无需执行任何操作。 数组 nums 的美丽值是 4（整个数组）。 提示： * 1 <= nums.length <= 105 * 0 <= nums[i], k <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用滑动窗口来找到数组中可以转换为相同值的最长子数组。

算法步骤:
1. 对数组进行排序。
2. 使用滑动窗口来找到可以转换为相同值的最长子数组。
3. 计算窗口内的最大长度。

关键点:
- 通过排序和滑动窗口来简化问题。
- 滑动窗口的左右边界控制在差值不超过 2k 的范围内。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是数组的长度，因为排序的时间复杂度是 O(n log n)。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def max_beauty_after_operations(nums: List[int], k: int) -> int:
    """
    函数式接口 - 返回数组可能取得的最大美丽值
    """
    # 对数组进行排序
    nums.sort()
    
    # 初始化滑动窗口的左右边界
    left, right = 0, 0
    max_length = 0
    
    while right < len(nums):
        # 如果当前窗口的差值超过 2k，则移动左边界
        while nums[right] - nums[left] > 2 * k:
            left += 1
        
        # 更新最大长度
        max_length = max(max_length, right - left + 1)
        
        # 移动右边界
        right += 1
    
    return max_length


Solution = create_solution(max_beauty_after_operations)