# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 733
标题: Flood Fill
难度: easy
链接: https://leetcode.cn/problems/flood-fill/
题目类型: 深度优先搜索、广度优先搜索、数组、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
733. 图像渲染 - 有一幅以 m x n 的二维整数数组表示的图画 image ，其中 image[i][j] 表示该图画的像素值大小。你也被给予三个整数 sr , sc 和 color 。你应该从像素 image[sr][sc] 开始对图像进行上色 填充 。 为了完成 上色工作： 1. 从初始像素开始，将其颜色改为 color。 2. 对初始坐标的 上下左右四个方向上 相邻且与初始像素的原始颜色同色的像素点执行相同操作。 3. 通过检查与初始像素的原始颜色相同的相邻像素并修改其颜色来继续 重复 此过程。 4. 当 没有 其它原始颜色的相邻像素时 停止 操作。 最后返回经过上色渲染 修改 后的图像 。 示例 1: [https://assets.leetcode.com/uploads/2021/06/01/flood1-grid.jpg] 输入：image = [[1,1,1],[1,1,0],[1,0,1]]，sr = 1, sc = 1, color = 2 输出：[[2,2,2],[2,2,0],[2,0,1]] 解释：在图像的正中间，坐标 (sr,sc)=(1,1) （即红色像素）,在路径上所有符合条件的像素点的颜色都被更改成相同的新颜色（即蓝色像素）。 注意，右下角的像素 没有 更改为2，因为它不是在上下左右四个方向上与初始点相连的像素点。 示例 2: 输入：image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0 输出：[[0,0,0],[0,0,0]] 解释：初始像素已经用 0 着色，这与目标颜色相同。因此，不会对图像进行任何更改。 提示: * m == image.length * n == image[i].length * 1 <= m, n <= 50 * 0 <= image[i][j], color < 216 * 0 <= sr < m * 0 <= sc < n
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用深度优先搜索 (DFS) 来填充图像。

算法步骤:
1. 获取初始像素的颜色。
2. 如果初始像素的颜色与目标颜色相同，则直接返回图像。
3. 使用 DFS 递归地将初始像素及其相邻像素的颜色更改为目标颜色。

关键点:
- 使用递归来实现深度优先搜索。
- 递归过程中，检查边界条件和颜色是否匹配。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m * n)，其中 m 和 n 分别是图像的行数和列数。每个像素最多访问一次。
空间复杂度: O(m * n)，最坏情况下递归栈的深度为 m * n。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def floodFill(image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
    """
    函数式接口 - 使用深度优先搜索 (DFS) 来填充图像。
    """
    original_color = image[sr][sc]
    
    if original_color == newColor:
        return image
    
    def dfs(r: int, c: int):
        if r < 0 or r >= len(image) or c < 0 or c >= len(image[0]) or image[r][c] != original_color:
            return
        image[r][c] = newColor
        dfs(r + 1, c)
        dfs(r - 1, c)
        dfs(r, c + 1)
        dfs(r, c - 1)
    
    dfs(sr, sc)
    return image


Solution = create_solution(floodFill)