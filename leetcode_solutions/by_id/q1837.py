# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1837
标题: Daily Leads and Partners
难度: easy
链接: https://leetcode.cn/problems/daily-leads-and-partners/
题目类型: 数据库
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1693. 每天的领导和合伙人 - 表：DailySales +-------------+---------+ | Column Name | Type | +-------------+---------+ | date_id | date | | make_name | varchar | | lead_id | int | | partner_id | int | +-------------+---------+ 该表没有主键(具有唯一值的列)。它可能包含重复项。 该表包含日期、产品的名称，以及售给的领导和合伙人的编号。 名称只包含小写英文字母。 对于每一个 date_id 和 make_name，找出 不同 的 lead_id 以及 不同 的 partner_id 的数量。 按 任意顺序 返回结果表。 返回结果格式如下示例所示。 示例 1: 输入： DailySales 表： +-----------+-----------+---------+------------+ | date_id | make_name | lead_id | partner_id | +-----------+-----------+---------+------------+ | 2020-12-8 | toyota | 0 | 1 | | 2020-12-8 | toyota | 1 | 0 | | 2020-12-8 | toyota | 1 | 2 | | 2020-12-7 | toyota | 0 | 2 | | 2020-12-7 | toyota | 0 | 1 | | 2020-12-8 | honda | 1 | 2 | | 2020-12-8 | honda | 2 | 1 | | 2020-12-7 | honda | 0 | 1 | | 2020-12-7 | honda | 1 | 2 | | 2020-12-7 | honda | 2 | 1 | +-----------+-----------+---------+------------+ 输出： +-----------+-----------+--------------+-----------------+ | date_id | make_name | unique_leads | unique_partners | +-----------+-----------+--------------+-----------------+ | 2020-12-8 | toyota | 2 | 3 | | 2020-12-7 | toyota | 1 | 2 | | 2020-12-8 | honda | 2 | 2 | | 2020-12-7 | honda | 3 | 2 | +-----------+-----------+--------------+-----------------+ 解释： 在 2020-12-8，丰田（toyota）有领导者 = [0, 1] 和合伙人 = [0, 1, 2] ，同时本田（honda）有领导者 = [1, 2] 和合伙人 = [1, 2]。 在 2020-12-7，丰田（toyota）有领导者 = [0] 和合伙人 = [1, 2] ，同时本田（honda）有领导者 = [0, 1, 2] 和合伙人 = [1, 2]。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用 Pandas 库进行数据处理，通过 groupby 和 nunique 函数来计算每个 date_id 和 make_name 下的不同 lead_id 和 partner_id 的数量。

算法步骤:
1. 读取输入数据并转换为 Pandas DataFrame。
2. 使用 groupby 按 date_id 和 make_name 分组。
3. 使用 nunique 计算每组中不同 lead_id 和 partner_id 的数量。
4. 重置索引并返回结果。

关键点:
- 使用 Pandas 库进行高效的数据处理。
- 通过 groupby 和 nunique 函数简化计算过程。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是输入数据的行数。Pandas 的 groupby 和 nunique 操作的时间复杂度接近线性。
空间复杂度: O(n)，存储中间结果所需的空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

import pandas as pd
from typing import List

def daily_leads_and_partners(daily_sales: List[List[str]]) -> pd.DataFrame:
    """
    计算每个 date_id 和 make_name 下的不同 lead_id 和 partner_id 的数量。
    """
    # 将输入数据转换为 Pandas DataFrame
    df = pd.DataFrame(daily_sales, columns=["date_id", "make_name", "lead_id", "partner_id"])
    
    # 将 lead_id 和 partner_id 转换为整数类型
    df["lead_id"] = df["lead_id"].astype(int)
    df["partner_id"] = df["partner_id"].astype(int)
    
    # 按 date_id 和 make_name 分组，并计算不同 lead_id 和 partner_id 的数量
    result = df.groupby(["date_id", "make_name"]).agg(
        unique_leads=("lead_id", "nunique"),
        unique_partners=("partner_id", "nunique")
    ).reset_index()
    
    return result

# 测试用例
if __name__ == "__main__":
    daily_sales = [
        ["2020-12-8", "toyota", "0", "1"],
        ["2020-12-8", "toyota", "1", "0"],
        ["2020-12-8", "toyota", "1", "2"],
        ["2020-12-7", "toyota", "0", "2"],
        ["2020-12-7", "toyota", "0", "1"],
        ["2020-12-8", "honda", "1", "2"],
        ["2020-12-8", "honda", "2", "1"],
        ["2020-12-7", "honda", "0", "1"],
        ["2020-12-7", "honda", "1", "2"],
        ["2020-12-7", "honda", "2", "1"]
    ]
    
    result = daily_leads_and_partners(daily_sales)
    print(result)