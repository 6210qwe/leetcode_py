# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 152
标题: Maximum Product Subarray
难度: medium
链接: https://leetcode.cn/problems/maximum-product-subarray/
题目类型: 数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
152. 乘积最大子数组 - 给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续 子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 测试用例的答案是一个 32-位 整数。 请注意，一个只包含一个元素的数组的乘积是这个元素的值。 示例 1: 输入: nums = [2,3,-2,4] 输出: 6 解释: 子数组 [2,3] 有最大乘积 6。 示例 2: 输入: nums = [-2,0,-1] 输出: 0 解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 提示: * 1 <= nums.length <= 2 * 104 * -10 <= nums[i] <= 10 * nums 的任何子数组的乘积都 保证 是一个 32-位 整数
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 动态规划，同时维护最大值和最小值（因为负数会反转大小）

算法步骤:
1. 遍历数组，对于每个元素，计算以它为结尾的最大乘积和最小乘积
2. 由于负数会反转大小，需要同时维护最大值和最小值
3. 更新全局最大乘积

关键点:
- 负数会反转大小，需要同时维护最大值和最小值
- 时间复杂度O(n)，空间复杂度O(1)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 只需遍历一次数组
空间复杂度: O(1) - 只使用常数额外空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from leetcode_solutions.utils.solution import create_solution


def maximum_product_subarray(nums: List[int]) -> int:
    """
    函数式接口 - 计算乘积最大子数组
    
    实现思路:
    动态规划，同时维护最大值和最小值（因为负数会反转大小）。
    
    Args:
        nums: 整数数组
        
    Returns:
        乘积最大的子数组的乘积
        
    Example:
        >>> maximum_product_subarray([2, 3, -2, 4])
        6
    """
    if not nums:
        return 0
    
    max_product = min_product = result = nums[0]
    
    for i in range(1, len(nums)):
        if nums[i] < 0:
            max_product, min_product = min_product, max_product
        
        max_product = max(nums[i], max_product * nums[i])
        min_product = min(nums[i], min_product * nums[i])
        
        result = max(result, max_product)
    
    return result


# 自动生成Solution类（无需手动编写）
Solution = create_solution(maximum_product_subarray)
