# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3
标题: 无重复字符的最长子串
难度: medium
链接: https://leetcode.cn/problems/longest-substring-without-repeating-characters/
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。

示例1:
输入: s = "abcabcbb"
输出: 3
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

示例2:
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。

示例3:
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是子串的长度，"pwke" 是一个子序列，不是子串。

约束条件:
- 0 <= s.length <= 5 * 10^4
- s 由英文字母、数字、符号和空格组成
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 滑动窗口 + 哈希表，维护一个不包含重复字符的窗口

算法步骤:
1. 使用哈希表char_map记录每个字符最后出现的位置
2. 使用left和right两个指针维护滑动窗口
3. 遍历字符串，对于每个字符:
   - 如果字符在哈希表中且位置在left之后，说明窗口内有重复
   - 将left移动到重复字符的下一个位置
   - 更新字符的最新位置到哈希表
   - 更新最大长度：max_len = max(max_len, right - left + 1)
4. 返回最大长度

关键点:
- 滑动窗口的思想：当遇到重复字符时，移动左边界
- 哈希表存储字符最后出现的位置，可以快速定位重复字符
- 只需要一次遍历，时间复杂度O(n)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 只需遍历一次字符串，n为字符串长度
空间复杂度: O(min(m, n)) - 哈希表最多存储min(字符集大小, 字符串长度)个字符
"""

# ============================================================================
# 代码实现
# ============================================================================

from leetcode_solutions.utils.solution import create_solution


def length_of_longest_substring(s: str) -> int:
    """
    函数式接口 - 滑动窗口 + 哈希表实现
    
    实现思路:
    使用滑动窗口维护一个不包含重复字符的子串，用哈希表记录字符最后出现的位置。
    
    Args:
        s: 输入字符串
        
    Returns:
        最长无重复字符子串的长度
        
    Example:
        >>> length_of_longest_substring("abcabcbb")
        3
        >>> length_of_longest_substring("bbbbb")
        1
        >>> length_of_longest_substring("pwwkew")
        3
    """
    if not s:
        return 0
    
    char_map = {}  # 字符 -> 最后出现的位置
    left = 0  # 滑动窗口左边界
    max_len = 0  # 最大长度
    
    for right, char in enumerate(s):
        # 如果字符已存在且在当前窗口内，移动左边界
        if char in char_map and char_map[char] >= left:
            left = char_map[char] + 1
        # 更新字符的最新位置
        char_map[char] = right
        # 更新最大长度
        max_len = max(max_len, right - left + 1)
    
    return max_len


# 自动生成Solution类（无需手动编写）
Solution = create_solution(length_of_longest_substring)

