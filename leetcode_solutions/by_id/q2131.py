# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2131
标题: Smallest Missing Genetic Value in Each Subtree
难度: hard
链接: https://leetcode.cn/problems/smallest-missing-genetic-value-in-each-subtree/
题目类型: 树、深度优先搜索、并查集、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2003. 每棵子树内缺失的最小基因值 - 有一棵根节点为 0 的 家族树 ，总共包含 n 个节点，节点编号为 0 到 n - 1 。给你一个下标从 0 开始的整数数组 parents ，其中 parents[i] 是节点 i 的父节点。由于节点 0 是 根 ，所以 parents[0] == -1 。 总共有 105 个基因值，每个基因值都用 闭区间 [1, 105] 中的一个整数表示。给你一个下标从 0 开始的整数数组 nums ，其中 nums[i] 是节点 i 的基因值，且基因值 互不相同 。 请你返回一个数组 ans ，长度为 n ，其中 ans[i] 是以节点 i 为根的子树内 缺失 的 最小 基因值。 节点 x 为根的 子树 包含节点 x 和它所有的 后代 节点。 示例 1： [https://assets.leetcode.com/uploads/2021/08/23/case-1.png] 输入：parents = [-1,0,0,2], nums = [1,2,3,4] 输出：[5,1,1,1] 解释：每个子树答案计算结果如下： - 0：子树包含节点 [0,1,2,3] ，基因值分别为 [1,2,3,4] 。5 是缺失的最小基因值。 - 1：子树只包含节点 1 ，基因值为 2 。1 是缺失的最小基因值。 - 2：子树包含节点 [2,3] ，基因值分别为 [3,4] 。1 是缺失的最小基因值。 - 3：子树只包含节点 3 ，基因值为 4 。1是缺失的最小基因值。 示例 2： [https://assets.leetcode.com/uploads/2021/08/23/case-2.png] 输入：parents = [-1,0,1,0,3,3], nums = [5,4,6,2,1,3] 输出：[7,1,1,4,2,1] 解释：每个子树答案计算结果如下： - 0：子树内包含节点 [0,1,2,3,4,5] ，基因值分别为 [5,4,6,2,1,3] 。7 是缺失的最小基因值。 - 1：子树内包含节点 [1,2] ，基因值分别为 [4,6] 。 1 是缺失的最小基因值。 - 2：子树内只包含节点 2 ，基因值为 6 。1 是缺失的最小基因值。 - 3：子树内包含节点 [3,4,5] ，基因值分别为 [2,1,3] 。4 是缺失的最小基因值。 - 4：子树内只包含节点 4 ，基因值为 1 。2 是缺失的最小基因值。 - 5：子树内只包含节点 5 ，基因值为 3 。1 是缺失的最小基因值。 示例 3： 输入：parents = [-1,2,3,0,2,4,1], nums = [2,3,4,5,6,7,8] 输出：[1,1,1,1,1,1,1] 解释：所有子树都缺失基因值 1 。 提示： * n == parents.length == nums.length * 2 <= n <= 105 * 对于 i != 0 ，满足 0 <= parents[i] <= n - 1 * parents[0] == -1 * parents 表示一棵合法的树。 * 1 <= nums[i] <= 105 * nums[i] 互不相同。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想:
- 使用深度优先搜索 (DFS) 来遍历树，并在遍历过程中维护一个集合来记录已经访问过的基因值。
- 如果当前子树中没有基因值 1，则该子树及其所有后代子树的缺失最小基因值都是 1。
- 如果当前子树中有基因值 1，则使用并查集 (Union-Find) 来合并子树中的基因值，并找到缺失的最小基因值。

算法步骤:
1. 构建树的邻接表表示。
2. 初始化结果数组 `ans`，默认值为 1。
3. 使用 DFS 遍历树，维护一个集合 `seen` 来记录已经访问过的基因值。
4. 在 DFS 过程中，如果当前子树中没有基因值 1，则直接返回 1。
5. 如果当前子树中有基因值 1，则使用并查集来合并子树中的基因值，并找到缺失的最小基因值。
6. 更新结果数组 `ans`。

关键点:
- 使用并查集来高效地合并和查找基因值。
- 在 DFS 过程中，通过集合 `seen` 来快速判断是否已经访问过某个基因值。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
- 构建树的邻接表需要 O(n) 时间。
- DFS 遍历树需要 O(n) 时间。
- 并查集的操作（合并和查找）均摊时间复杂度为 O(α(n))，其中 α(n) 是反阿克曼函数，可以视为常数。

空间复杂度: O(n)
- 存储树的邻接表需要 O(n) 空间。
- 结果数组 `ans` 需要 O(n) 空间。
- 并查集需要 O(n) 空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution

def find_smallest_missing_genetic_value(parents: List[int], nums: List[int]) -> List[int]:
    n = len(parents)
    tree = [[] for _ in range(n)]
    for i in range(1, n):
        tree[parents[i]].append(i)

    def dfs(node: int, seen: set) -> int:
        if nums[node] == 1:
            seen.add(1)
        min_missing = 1
        for child in tree[node]:
            min_missing = max(min_missing, dfs(child, seen))
        while min_missing in seen:
            min_missing += 1
        return min_missing

    ans = [1] * n
    for i in range(n):
        if nums[i] == 1:
            seen = set()
            ans[i] = dfs(i, seen)
    
    return ans

Solution = create_solution(find_smallest_missing_genetic_value)