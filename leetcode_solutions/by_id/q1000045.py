# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000045
标题: Max Black Square LCCI
难度: medium
链接: https://leetcode.cn/problems/max-black-square-lcci/
题目类型: 数组、动态规划、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
面试题 17.23. 最大黑方阵 - 给定一个方阵，其中每个单元(像素)非黑即白。设计一个算法，找出 4 条边皆为黑色像素的最大子方阵。 返回一个数组 [r, c, size] ，其中 r, c 分别代表子方阵左上角的行号和列号，size 是子方阵的边长。若有多个满足条件的子方阵，返回 r 最小的，若 r 相同，返回 c 最小的子方阵。若无满足条件的子方阵，返回空数组。 示例 1： 输入： [ [1,0,1], [0,0,1], [0,0,1] ] 输出：[1,0,2] 解释：输入中 0 代表黑色，1 代表白色，标粗的元素即为满足条件的最大子方阵 示例 2： 输入： [ [0,1,1], [1,0,1], [1,1,0] ] 输出：[0,0,1] 提示： * matrix.length == matrix[0].length <= 200
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来记录每个位置的左边和上边连续黑色像素的数量，然后通过这些信息来找到最大的全黑方阵。

算法步骤:
1. 初始化两个二维数组 left 和 up，分别记录每个位置左边和上边连续黑色像素的数量。
2. 遍历矩阵，填充 left 和 up 数组。
3. 再次遍历矩阵，对于每个位置 (i, j)，计算可能的最大全黑方阵的边长 k，并更新结果。

关键点:
- 使用动态规划来记录每个位置的左边和上边连续黑色像素的数量。
- 通过这些信息来找到最大的全黑方阵。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2)，其中 n 是矩阵的边长。需要遍历矩阵两次。
空间复杂度: O(n^2)，需要额外的两个二维数组来记录左边和上边连续黑色像素的数量。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def find_largest_square(matrix: List[List[int]]) -> List[int]:
    """
    函数式接口 - 找到最大全黑方阵
    """
    if not matrix or not matrix[0]:
        return []

    n = len(matrix)
    left = [[0] * n for _ in range(n)]
    up = [[0] * n for _ in range(n)]
    max_size = 0
    result = []

    for i in range(n):
        for j in range(n):
            if matrix[i][j] == 0:
                left[i][j] = left[i][j - 1] + 1 if j > 0 else 1
                up[i][j] = up[i - 1][j] + 1 if i > 0 else 1

                k = min(left[i][j], up[i][j])
                while k > max_size:
                    if left[i - k + 1][j] >= k and up[i][j - k + 1] >= k:
                        max_size = k
                        result = [i - k + 1, j - k + 1, k]
                    k -= 1

    return result


Solution = create_solution(find_largest_square)