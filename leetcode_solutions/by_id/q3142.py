# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3142
标题: Longest Unequal Adjacent Groups Subsequence II
难度: medium
链接: https://leetcode.cn/problems/longest-unequal-adjacent-groups-subsequence-ii/
题目类型: 数组、字符串、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2901. 最长相邻不相等子序列 II - 给定一个字符串数组 words ，和一个数组 groups ，两个数组长度都是 n 。 两个长度相等字符串的 汉明距离 定义为对应位置字符 不同 的数目。 你需要从下标 [0, 1, ..., n - 1] 中选出一个 最长子序列 ，将这个子序列记作长度为 k 的 [i0, i1, ..., ik - 1] ，它需要满足以下条件： * 相邻 下标对应的 groups 值 不同。即，对于所有满足 0 < j + 1 < k 的 j 都有 groups[ij] != groups[ij + 1] 。 * 对于所有 0 < j + 1 < k 的下标 j ，都满足 words[ij] 和 words[ij + 1] 的长度 相等 ，且两个字符串之间的 汉明距离 为 1 。 请你返回一个字符串数组，它是下标子序列 依次 对应 words 数组中的字符串连接形成的字符串数组。如果有多个答案，返回任意一个。 子序列 指的是从原数组中删掉一些（也可能一个也不删掉）元素，剩余元素不改变相对位置得到的新的数组。 注意：words 中的字符串长度可能 不相等 。 示例 1： 输入：words = ["bab","dab","cab"], groups = [1,2,2] 输出：["bab","cab"] 解释：一个可行的子序列是 [0,2] 。 - groups[0] != groups[2] - words[0].length == words[2].length 且它们之间的汉明距离为 1 。 所以一个可行的答案是 [words[0],words[2]] = ["bab","cab"] 。 另一个可行的子序列是 [0,1] 。 - groups[0] != groups[1] - words[0].length = words[1].length 且它们之间的汉明距离为 1 。 所以另一个可行的答案是 [words[0],words[1]] = ["bab","dab"] 。 符合题意的最长子序列的长度为 2 。 示例 2： 输入：words = ["a","b","c","d"], groups = [1,2,3,4] 输出：["a","b","c","d"] 解释：我们选择子序列 [0,1,2,3] 。 它同时满足两个条件。 所以答案为 [words[0],words[1],words[2],words[3]] = ["a","b","c","d"] 。 它是所有下标子序列里最长且满足所有条件的。 所以它是唯一的答案。 提示： * 1 <= n == words.length == groups.length <= 1000 * 1 <= words[i].length <= 10 * 1 <= groups[i] <= n * words 中的字符串 互不相同 。 * words[i] 只包含小写英文字母。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们定义 dp[i] 为以第 i 个单词结尾的最长有效子序列的长度，并记录其前驱节点。通过遍历每个单词，检查其与之前单词的关系，更新 dp 数组。

算法步骤:
1. 初始化 dp 数组，dp[i] 表示以第 i 个单词结尾的最长有效子序列的长度。
2. 遍历每个单词，对于每个单词，再遍历之前的单词，检查是否满足条件（groups 不同且汉明距离为 1）。
3. 更新 dp 数组，并记录前驱节点。
4. 通过 dp 数组找到最长的有效子序列，并构造结果。

关键点:
- 动态规划的状态转移方程：dp[i] = max(dp[i], dp[j] + 1)，其中 j < i 且满足条件。
- 记录前驱节点以便构造最终结果。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2 * m)，其中 n 是 words 的长度，m 是每个单词的最大长度。
空间复杂度: O(n)，用于存储 dp 数组和前驱节点。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def solution_function_name(words: List[str], groups: List[int]) -> List[str]:
    """
    函数式接口 - 实现最优解法
    """
    n = len(words)
    dp = [1] * n
    prev = [-1] * n
    max_len = 1
    max_idx = 0

    def hamming_distance(s1: str, s2: str) -> int:
        return sum(c1 != c2 for c1, c2 in zip(s1, s2))

    for i in range(1, n):
        for j in range(i):
            if groups[i] != groups[j] and len(words[i]) == len(words[j]) and hamming_distance(words[i], words[j]) == 1:
                if dp[j] + 1 > dp[i]:
                    dp[i] = dp[j] + 1
                    prev[i] = j
                    if dp[i] > max_len:
                        max_len = dp[i]
                        max_idx = i

    result = []
    while max_idx != -1:
        result.append(words[max_idx])
        max_idx = prev[max_idx]

    return result[::-1]

Solution = create_solution(solution_function_name)