# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3638
标题: Minimum Operations to Make Character Frequencies Equal
难度: hard
链接: https://leetcode.cn/problems/minimum-operations-to-make-character-frequencies-equal/
题目类型: 哈希表、字符串、动态规划、计数、枚举
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3389. 使字符频率相等的最少操作次数 - 给你一个字符串 s 。 如果字符串 t 中的字符出现次数相等，那么我们称 t 为 好的 。 你可以执行以下操作 任意次 ： * 从 s 中删除一个字符。 * 往 s 中添加一个字符。 * 将 s 中一个字母变成字母表中下一个字母。 注意 ，第三个操作不能将 'z' 变为 'a' 。 请你返回将 s 变 好 的 最少 操作次数。 示例 1： 输入：s = "acab" 输出：1 解释： 删掉一个字符 'a' ，s 变为好的。 示例 2： 输入：s = "wddw" 输出：0 解释： s 一开始就是好的，所以不需要执行任何操作。 示例 3： 输入：s = "aaabc" 输出：2 解释： 通过以下操作，将 s 变好： * 将一个 'a' 变为 'b' 。 * 往 s 中插入一个 'c' 。 提示： * 1 <= s.length <= 2 * 104 * s 只包含小写英文字母。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用计数数组记录每个字符的频率，然后枚举所有可能的目标频率，计算最小操作次数。

算法步骤:
1. 计算每个字符的频率。
2. 枚举所有可能的目标频率，计算将所有字符频率调整为目标频率所需的最小操作次数。
3. 返回最小的操作次数。

关键点:
- 使用计数数组记录字符频率。
- 枚举所有可能的目标频率，计算最小操作次数。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n + k^2)，其中 n 是字符串长度，k 是字符种类数（最多 26）。
空间复杂度: O(k)，其中 k 是字符种类数（最多 26）。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def min_operations_to_equal_freq(s: str) -> int:
    """
    函数式接口 - 计算使字符频率相等的最少操作次数
    """
    # 计算每个字符的频率
    freq = [0] * 26
    for char in s:
        freq[ord(char) - ord('a')] += 1
    
    # 计算非零频率的字符数量
    non_zero_freq = [f for f in freq if f > 0]
    
    # 枚举所有可能的目标频率
    min_ops = float('inf')
    for target in range(1, max(non_zero_freq) + 1):
        ops = 0
        for f in non_zero_freq:
            if f < target:
                ops += target - f
            else:
                ops += f - target
        min_ops = min(min_ops, ops)
    
    return min_ops


Solution = create_solution(min_operations_to_equal_freq)