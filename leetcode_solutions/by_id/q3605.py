# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3605
标题: Construct the Minimum Bitwise Array I
难度: easy
链接: https://leetcode.cn/problems/construct-the-minimum-bitwise-array-i/
题目类型: 位运算、数组
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3314. 构造最小位运算数组 I - 给你一个长度为 n 的 质数 数组 nums 。你的任务是返回一个长度为 n 的数组 ans ，对于每个下标 i ，以下 条件 均成立： * ans[i] OR (ans[i] + 1) == nums[i] 除此以外，你需要 最小化 结果数组里每一个 ans[i] 。 如果没法找到符合 条件 的 ans[i] ，那么 ans[i] = -1 。 质数 指的是一个大于 1 的自然数，且它只有 1 和自己两个因数。 示例 1： 输入：nums = [2,3,5,7] 输出：[-1,1,4,3] 解释： * 对于 i = 0 ，不存在 ans[0] 满足 ans[0] OR (ans[0] + 1) = 2 ，所以 ans[0] = -1 。 * 对于 i = 1 ，满足 ans[1] OR (ans[1] + 1) = 3 的最小 ans[1] 为 1 ，因为 1 OR (1 + 1) = 3 。 * 对于 i = 2 ，满足 ans[2] OR (ans[2] + 1) = 5 的最小 ans[2] 为 4 ，因为 4 OR (4 + 1) = 5 。 * 对于 i = 3 ，满足 ans[3] OR (ans[3] + 1) = 7 的最小 ans[3] 为 3 ，因为 3 OR (3 + 1) = 7 。 示例 2： 输入：nums = [11,13,31] 输出：[9,12,15] 解释： * 对于 i = 0 ，满足 ans[0] OR (ans[0] + 1) = 11 的最小 ans[0] 为 9 ，因为 9 OR (9 + 1) = 11 。 * 对于 i = 1 ，满足 ans[1] OR (ans[1] + 1) = 13 的最小 ans[1] 为 12 ，因为 12 OR (12 + 1) = 13 。 * 对于 i = 2 ，满足 ans[2] OR (ans[2] + 1) = 31 的最小 ans[2] 为 15 ，因为 15 OR (15 + 1) = 31 。 提示： * 1 <= nums.length <= 100 * 2 <= nums[i] <= 1000 * nums[i] 是一个质数。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过位运算找到满足条件的最小值。

算法步骤:
1. 遍历每个质数 num。
2. 检查 num 是否为 2 的幂次方减 1（即 num & (num + 1) == 0）。
3. 如果是，则结果为 num - 1；否则结果为 -1。

关键点:
- 通过位运算快速判断和计算结果。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是 nums 的长度。每个质数的处理都是常数时间。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def solution_function_name(nums: List[int]) -> List[int]:
    """
    函数式接口 - 返回满足条件的最小位运算数组
    """
    def find_min_value(num: int) -> int:
        # 检查 num 是否为 2 的幂次方减 1
        if num & (num + 1) == 0:
            return num - 1
        else:
            return -1

    # 遍历每个质数并计算结果
    return [find_min_value(num) for num in nums]

Solution = create_solution(solution_function_name)