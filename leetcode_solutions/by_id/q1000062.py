# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000062
标题: 二叉树任务调度
难度: hard
链接: https://leetcode.cn/problems/er-cha-shu-ren-wu-diao-du/
题目类型: 树、深度优先搜索、动态规划、二叉树
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCP 10. 二叉树任务调度 - 任务调度优化是计算机性能优化的关键任务之一。在任务众多时，不同的调度策略可能会得到不同的总体执行时间，因此寻求一个最优的调度方案是非常有必要的。 通常任务之间是存在依赖关系的，即对于某个任务，你需要先完成他的前导任务（如果非空），才能开始执行该任务。我们保证任务的依赖关系是一棵二叉树，其中 root 为根任务，root.left 和 root.right 为他的两个前导任务（可能为空），root.val 为其自身的执行时间。 在一个 CPU 核执行某个任务时，我们可以在任何时刻暂停当前任务的执行，并保留当前执行进度。在下次继续执行该任务时，会从之前停留的进度开始继续执行。暂停的时间可以不是整数。 现在，系统有两个 CPU 核，即我们可以同时执行两个任务，但是同一个任务不能同时在两个核上执行。给定这颗任务树，请求出所有任务执行完毕的最小时间。 示例 1： > image.png [https://pic.leetcode.cn/3522fbf8ce4ebb20b79019124eb9870109fdfe97fe9da99f6c20c07ceb1c60b3-image.png] > > 输入：root = [47, 74, 31] > > 输出：121 > > 解释：根节点的左右节点可以并行执行31分钟，剩下的43+47分钟只能串行执行，因此总体执行时间是121分钟。 示例 2： > image.png [https://pic.leetcode.cn/13accf172ee4a660d241e25901595d55b759380b090890a17e6e7bd51a143e3f-image.png] > > 输入：root = [15, 21, null, 24, null, 27, 26] > > 输出：87 示例 3： > image.png [https://pic.leetcode.cn/bef743a12591aafb9047dd95d335b8083dfa66e8fdedc63f50fd406b4a9d163a-image.png] > > 输入：root = [1,3,2,null,null,4,4] > > 输出：7.5 限制： * 1 <= 节点数量 <= 1000 * 1 <= 单节点执行时间 <= 1000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划和深度优先搜索 (DFS) 来计算每个节点的最小执行时间。对于每个节点，我们需要考虑其子节点的执行时间，并选择最优的调度策略。

算法步骤:
1. 定义一个递归函数 `dfs`，用于计算每个节点的最小执行时间和子节点的最大执行时间。
2. 对于每个节点，计算其左子节点和右子节点的最小执行时间和最大执行时间。
3. 计算当前节点的最小执行时间和最大执行时间。
4. 返回根节点的最小执行时间。

关键点:
- 通过递归遍历树来计算每个节点的最小执行时间。
- 选择最优的调度策略，使得总执行时间最小化。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是节点的数量。每个节点只会被访问一次。
空间复杂度: O(h)，其中 h 是树的高度。递归调用栈的深度最多为树的高度。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution

def dfs(node: TreeNode) -> (float, float):
    if not node:
        return 0, 0
    
    left_min, left_max = dfs(node.left)
    right_min, right_max = dfs(node.right)
    
    # 计算当前节点的最小执行时间和最大执行时间
    current_min = max(left_min, right_min) + node.val
    current_max = max(left_max, right_max, (left_min + right_min + node.val) / 2)
    
    return current_min, current_max

def solution_function_name(root: Optional[TreeNode]) -> float:
    """
    函数式接口 - 计算二叉树任务调度的最小执行时间
    """
    min_time, _ = dfs(root)
    return min_time

Solution = create_solution(solution_function_name)