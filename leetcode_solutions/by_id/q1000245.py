# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000245
标题: 打家劫舍
难度: medium
链接: https://leetcode.cn/problems/Gu0c2T/
题目类型: 数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCR 089. 打家劫舍 - 一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响小偷偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组 nums ，请计算 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1： 输入：nums = [1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2： 输入：nums = [2,7,9,3,1] 输出：12 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 提示： * 1 <= nums.length <= 100 * 0 <= nums[i] <= 400 注意：本题与主站 198 题相同： https://leetcode.cn/problems/house-robber/ [https://leetcode.cn/problems/house-robber/]
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 动态规划，经典打家劫舍

算法步骤:
1. 定义 dp[i] 为前 i 间房屋（下标 0..i-1）能偷到的最大金额
2. 初始：
   - dp[0] = 0 （没有房）
   - dp[1] = nums[0]
3. 状态转移：
   - 对于 i >= 2，有 dp[i] = max(dp[i-1], dp[i-2] + nums[i-1])
     即第 i-1 间房偷或不偷
4. 答案为 dp[n]，其中 n = len(nums)
5. 可用滚动变量 prev2, prev1 代替 dp 数组：
   - prev2 = dp[i-2], prev1 = dp[i-1]
   - cur = max(prev1, prev2 + nums[i-1])

关键点:
- 相邻不能同时偷，所以每个位置只有偷/不偷两种选择
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(1)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def rob(nums: List[int]) -> int:
    """
    函数式接口 - 打家劫舍
    """
    n = len(nums)
    if n == 1:
        return nums[0]
    prev2 = 0          # dp[0]
    prev1 = nums[0]    # dp[1]
    for i in range(2, n + 1):
        cur = max(prev1, prev2 + nums[i - 1])
        prev2, prev1 = prev1, cur
    return prev1


Solution = create_solution(rob)
