# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1008
标题: Binary Tree Cameras
难度: hard
链接: https://leetcode.cn/problems/binary-tree-cameras/
题目类型: 树、深度优先搜索、动态规划、二叉树
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
968. 监控二叉树 - 给定一个二叉树，我们在树的节点上安装摄像头。 节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。 计算监控树的所有节点所需的最小摄像头数量。 示例 1： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png] 输入：[0,0,null,0,0] 输出：1 解释：如图所示，一台摄像头足以监控所有节点。 示例 2： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_02.png] 输入：[0,0,null,0,null,0,null,null,0] 输出：2 解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。 提示： 1. 给定树的节点数的范围是 [1, 1000]。 2. 每个节点的值都是 0。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用深度优先搜索（DFS）从叶子节点向上遍历，通过状态转移来决定每个节点是否需要安装摄像头。

算法步骤:
1. 定义三种状态：0 表示该节点未被覆盖，1 表示该节点被覆盖但没有摄像头，2 表示该节点有摄像头。
2. 从叶子节点开始向上遍历，根据子节点的状态决定当前节点的状态。
3. 如果某个子节点未被覆盖，则当前节点必须安装摄像头。
4. 如果某个子节点有摄像头，则当前节点不需要安装摄像头。
5. 如果所有子节点都被覆盖但没有摄像头，则当前节点可以选择不安装摄像头，但在根节点处需要特殊处理。

关键点:
- 使用 DFS 从叶子节点向上遍历。
- 通过状态转移来决定每个节点是否需要安装摄像头。
- 特殊处理根节点，确保整个树都被覆盖。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是树中节点的数量。每个节点只访问一次。
空间复杂度: O(h)，其中 h 是树的高度。递归调用栈的深度为树的高度。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import Optional
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution

def min_camera_cover(root: Optional[TreeNode]) -> int:
    """
    函数式接口 - 计算监控树的所有节点所需的最小摄像头数量
    """
    def dfs(node):
        if not node:
            return 0, 1  # (摄像头数量, 状态)
        
        l_count, l_state = dfs(node.left)
        r_count, r_state = dfs(node.right)
        
        if l_state == 0 or r_state == 0:  # 子节点未被覆盖
            return l_count + r_count + 1, 2  # 当前节点安装摄像头
        
        if l_state == 2 or r_state == 2:  # 子节点有摄像头
            return l_count + r_count, 1  # 当前节点被覆盖但没有摄像头
        
        return l_count + r_count, 0  # 子节点都被覆盖但没有摄像头
    
    count, state = dfs(root)
    return count + (state == 0)  # 如果根节点未被覆盖，需要再加一个摄像头

Solution = create_solution(min_camera_cover)