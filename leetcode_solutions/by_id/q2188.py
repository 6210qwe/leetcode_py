# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2188
标题: Minimized Maximum of Products Distributed to Any Store
难度: medium
链接: https://leetcode.cn/problems/minimized-maximum-of-products-distributed-to-any-store/
题目类型: 贪心、数组、二分查找
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2064. 分配给商店的最多商品的最小值 - 给你一个整数 n ，表示有 n 间零售商店。总共有 m 种商品，每种商品的数目用一个下标从 0 开始的整数数组 quantities 表示，其中 quantities[i] 表示第 i 种商品的数目。 你需要将 所有商品 分配到零售商店，并遵守这些规则： * 一间商店 至多 只能有 一种商品 ，但一间商店拥有的商品数目可以为 任意 件。 * 分配后，每间商店都会被分配一定数目的商品（可能为 0 件）。用 x 表示所有商店中分配商品数目的最大值，你希望 x 越小越好。也就是说，你想 最小化 分配给任意商店商品数目的 最大值 。 请你返回最小的可能的 x 。 示例 1： 输入：n = 6, quantities = [11,6] 输出：3 解释： 一种最优方案为： - 11 件种类为 0 的商品被分配到前 4 间商店，分配数目分别为：2，3，3，3 。 - 6 件种类为 1 的商品被分配到另外 2 间商店，分配数目分别为：3，3 。 分配给所有商店的最大商品数目为 max(2, 3, 3, 3, 3, 3) = 3 。 示例 2： 输入：n = 7, quantities = [15,10,10] 输出：5 解释：一种最优方案为： - 15 件种类为 0 的商品被分配到前 3 间商店，分配数目为：5，5，5 。 - 10 件种类为 1 的商品被分配到接下来 2 间商店，数目为：5，5 。 - 10 件种类为 2 的商品被分配到最后 2 间商店，数目为：5，5 。 分配给所有商店的最大商品数目为 max(5, 5, 5, 5, 5, 5, 5) = 5 。 示例 3： 输入：n = 1, quantities = [100000] 输出：100000 解释：唯一一种最优方案为： - 所有 100000 件商品 0 都分配到唯一的商店中。 分配给所有商店的最大商品数目为 max(100000) = 100000 。 提示： * m == quantities.length * 1 <= m <= n <= 105 * 1 <= quantities[i] <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用二分查找来找到最小的最大分配值。

算法步骤:
1. 定义一个辅助函数 `is_valid` 来判断在给定的最大分配值 `x` 下，是否可以将所有商品分配到不超过 `n` 个商店。
2. 使用二分查找来找到最小的 `x`，使得 `is_valid(x)` 为真。

关键点:
- 二分查找的范围是从 1 到 `max(quantities)`。
- 辅助函数 `is_valid` 通过计算每个商品需要的商店数量来判断是否满足条件。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m log(max(quantities)))，其中 m 是 `quantities` 的长度，log(max(quantities)) 是二分查找的时间复杂度。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def minimized_maximum(n: int, quantities: List[int]) -> int:
    """
    函数式接口 - 返回最小的可能的最大分配值
    """
    def is_valid(x: int) -> bool:
        # 计算在最大分配值为 x 的情况下，需要的商店数量
        return sum((q + x - 1) // x for q in quantities) <= n

    left, right = 1, max(quantities)
    while left < right:
        mid = (left + right) // 2
        if is_valid(mid):
            right = mid
        else:
            left = mid + 1
    return left


Solution = create_solution(minimized_maximum)