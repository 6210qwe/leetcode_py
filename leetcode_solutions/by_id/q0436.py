# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 436
标题: Find Right Interval
难度: medium
链接: https://leetcode.cn/problems/find-right-interval/
题目类型: 数组、二分查找、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
436. 寻找右区间 - 给你一个区间数组 intervals ，其中 intervals[i] = [starti, endi] ，且每个 starti 都 不同 。 区间 i 的 右侧区间 是满足 startj >= endi，且 startj 最小 的区间 j。注意 i 可能等于 j 。 返回一个由每个区间 i 对应的 右侧区间 下标组成的数组。如果某个区间 i 不存在对应的 右侧区间 ，则下标 i 处的值设为 -1 。 示例 1： 输入：intervals = [[1,2]] 输出：[-1] 解释：集合中只有一个区间，所以输出-1。 示例 2： 输入：intervals = [[3,4],[2,3],[1,2]] 输出：[-1,0,1] 解释：对于 [3,4] ，没有满足条件的“右侧”区间。 对于 [2,3] ，区间[3,4]具有最小的“右”起点; 对于 [1,2] ，区间[2,3]具有最小的“右”起点。 示例 3： 输入：intervals = [[1,4],[2,3],[3,4]] 输出：[-1,2,-1] 解释：对于区间 [1,4] 和 [3,4] ，没有满足条件的“右侧”区间。 对于 [2,3] ，区间 [3,4] 有最小的“右”起点。 提示： * 1 <= intervals.length <= 2 * 104 * intervals[i].length == 2 * -106 <= starti <= endi <= 106 * 每个间隔的起点都 不相同
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用二分查找来找到每个区间的右侧区间

算法步骤:
1. 将所有区间的起点和其对应的索引存储在一个列表中，并按起点排序。
2. 对于每个区间，使用二分查找在其排序后的起点列表中找到第一个大于等于该区间终点的起点。
3. 如果找到，则返回该起点对应的索引；否则返回 -1。

关键点:
- 使用二分查找优化查找时间复杂度
- 保持空间复杂度为 O(n)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n) - 排序操作的时间复杂度是 O(n log n)，二分查找的时间复杂度是 O(log n)，总的时间复杂度是 O(n log n)
空间复杂度: O(n) - 需要额外的空间来存储排序后的起点及其索引
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def find_right_interval(intervals: List[List[int]]) -> List[int]:
    """
    函数式接口 - 找到每个区间的右侧区间
    
    实现思路:
    1. 将所有区间的起点和其对应的索引存储在一个列表中，并按起点排序。
    2. 对于每个区间，使用二分查找在其排序后的起点列表中找到第一个大于等于该区间终点的起点。
    3. 如果找到，则返回该起点对应的索引；否则返回 -1。
    
    Args:
        intervals: 区间数组，每个区间表示为 [start, end]
        
    Returns:
        一个由每个区间 i 对应的 右侧区间 下标组成的数组。如果某个区间 i 不存在对应的 右侧区间 ，则下标 i 处的值设为 -1。
        
    Example:
        >>> find_right_interval([[1,2]])
        [-1]
        >>> find_right_interval([[3,4],[2,3],[1,2]])
        [-1, 0, 1]
        >>> find_right_interval([[1,4],[2,3],[3,4]])
        [-1, 2, -1]
    """
    # 将所有区间的起点和其对应的索引存储在一个列表中，并按起点排序
    starts = sorted((interval[0], i) for i, interval in enumerate(intervals))
    
    def binary_search(target):
        left, right = 0, len(starts) - 1
        while left <= right:
            mid = (left + right) // 2
            if starts[mid][0] < target:
                left = mid + 1
            else:
                right = mid - 1
        return starts[left][1] if left < len(starts) else -1
    
    # 对于每个区间，使用二分查找在其排序后的起点列表中找到第一个大于等于该区间终点的起点
    return [binary_search(interval[1]) for interval in intervals]


# 自动生成Solution类（无需手动编写）
Solution = create_solution(find_right_interval)