# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2695
标题: Find Score of an Array After Marking All Elements
难度: medium
链接: https://leetcode.cn/problems/find-score-of-an-array-after-marking-all-elements/
题目类型: 数组、哈希表、排序、模拟、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2593. 标记所有元素后数组的分数 - 给你一个数组 nums ，它包含若干正整数。 一开始分数 score = 0 ，请你按照下面算法求出最后分数： * 从数组中选择最小且没有被标记的整数。如果有相等元素，选择下标最小的一个。 * 将选中的整数加到 score 中。 * 标记 被选中元素，如果有相邻元素，则同时标记 与它相邻的两个元素 。 * 重复此过程直到数组中所有元素都被标记。 请你返回执行上述算法后最后的分数。 示例 1： 输入：nums = [2,1,3,4,5,2] 输出：7 解释：我们按照如下步骤标记元素： - 1 是最小未标记元素，所以标记它和相邻两个元素：[2,1,3,4,5,2] 。 - 2 是最小未标记元素，所以标记它和左边相邻元素：[2,1,3,4,5,2] 。 - 4 是仅剩唯一未标记的元素，所以我们标记它：[2,1,3,4,5,2] 。 总得分为 1 + 2 + 4 = 7 。 示例 2： 输入：nums = [2,3,5,1,3,2] 输出：5 解释：我们按照如下步骤标记元素： - 1 是最小未标记元素，所以标记它和相邻两个元素：[2,3,5,1,3,2] 。 - 2 是最小未标记元素，由于有两个 2 ，我们选择最左边的一个 2 ，也就是下标为 0 处的 2 ，以及它右边相邻的元素：[2,3,5,1,3,2] 。 - 2 是仅剩唯一未标记的元素，所以我们标记它：[2,3,5,1,3,2] 。 总得分为 1 + 2 + 2 = 5 。 提示： * 1 <= nums.length <= 105 * 1 <= nums[i] <= 106
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用一个最小堆来存储数组中的元素及其索引，每次从堆中取出最小的元素并标记其相邻元素。

算法步骤:
1. 创建一个最小堆，将数组中的每个元素及其索引存入堆中。
2. 初始化一个集合来记录已经标记的元素。
3. 从堆中取出最小的元素，将其值加到总分中，并标记该元素及其相邻元素。
4. 重复步骤3，直到堆为空。

关键点:
- 使用最小堆来高效地获取当前最小的未标记元素。
- 使用集合来记录已经标记的元素，避免重复处理。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是数组的长度。插入和删除堆的操作时间复杂度为 O(log n)，总共需要进行 n 次操作。
空间复杂度: O(n)，用于存储堆和已标记的元素集合。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def find_score_of_array(nums: List[int]) -> int:
    """
    返回标记所有元素后数组的分数。
    """
    # 创建一个最小堆，存储 (元素值, 索引)
    min_heap = [(num, i) for i, num in enumerate(nums)]
    heapq.heapify(min_heap)
    
    # 用于记录已经标记的元素
    marked = set()
    
    score = 0
    
    while min_heap:
        num, index = heapq.heappop(min_heap)
        
        # 如果当前元素已经被标记，则跳过
        if index in marked:
            continue
        
        # 将当前元素值加到总分中
        score += num
        
        # 标记当前元素及其相邻元素
        marked.add(index)
        if index > 0:
            marked.add(index - 1)
        if index < len(nums) - 1:
            marked.add(index + 1)
    
    return score

Solution = create_solution(find_score_of_array)