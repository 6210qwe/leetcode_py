# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 638
标题: Shopping Offers
难度: medium
链接: https://leetcode.cn/problems/shopping-offers/
题目类型: 位运算、记忆化搜索、数组、动态规划、回溯、状态压缩
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
638. 大礼包 - 在 LeetCode 商店中， 有 n 件在售的物品。每件物品都有对应的价格。然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。 给你一个整数数组 price 表示物品价格，其中 price[i] 是第 i 件物品的价格。另有一个整数数组 needs 表示购物清单，其中 needs[i] 是需要购买第 i 件物品的数量。 还有一个数组 special 表示大礼包，special[i] 的长度为 n + 1 ，其中 special[i][j] 表示第 i 个大礼包中内含第 j 件物品的数量，且 special[i][n] （也就是数组中的最后一个整数）为第 i 个大礼包的价格。 返回 确切 满足购物清单所需花费的最低价格，你可以充分利用大礼包的优惠活动。你不能购买超出购物清单指定数量的物品，即使那样会降低整体价格。任意大礼包可无限次购买。 示例 1： 输入：price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2] 输出：14 解释：有 A 和 B 两种物品，价格分别为 ¥2 和 ¥5 。 大礼包 1 ，你可以以 ¥5 的价格购买 3A 和 0B 。 大礼包 2 ，你可以以 ¥10 的价格购买 1A 和 2B 。 需要购买 3 个 A 和 2 个 B ， 所以付 ¥10 购买 1A 和 2B（大礼包 2），以及 ¥4 购买 2A 。 示例 2： 输入：price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1] 输出：11 解释：A ，B ，C 的价格分别为 ¥2 ，¥3 ，¥4 。 可以用 ¥4 购买 1A 和 1B ，也可以用 ¥9 购买 2A ，2B 和 1C 。 需要买 1A ，2B 和 1C ，所以付 ¥4 买 1A 和 1B（大礼包 1），以及 ¥3 购买 1B ， ¥4 购买 1C 。 不可以购买超出待购清单的物品，尽管购买大礼包 2 更加便宜。 提示： * n == price.length == needs.length * 1 <= n <= 6 * 0 <= price[i], needs[i] <= 10 * 1 <= special.length <= 100 * special[i].length == n + 1 * 0 <= special[i][j] <= 50 * 生成的输入对于 0 <= j <= n - 1 至少有一个 special[i][j] 非零。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用记忆化搜索来解决这个问题。通过递归地尝试每种可能的大礼包组合，并记录已经计算过的子问题的结果，以避免重复计算。

算法步骤:
1. 定义一个递归函数 `dfs(needs)`，表示满足当前需求 `needs` 的最小花费。
2. 如果 `needs` 已经计算过，则直接返回缓存的结果。
3. 计算不使用任何大礼包时的花费。
4. 对于每个大礼包，如果它可以被使用（即不会超过需求），则递归计算使用该大礼包后的最小花费。
5. 更新并返回最小花费。

关键点:
- 使用记忆化搜索来避免重复计算。
- 递归地尝试每种可能的大礼包组合。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(2^n * m)，其中 n 是物品数量，m 是大礼包数量。每个需求状态最多有 2^n 种，每种状态最多需要检查 m 个大礼包。
空间复杂度: O(2^n)，用于存储记忆化搜索的结果。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from functools import lru_cache

def shopping_offers(price: List[int], special: List[List[int]], needs: List[int]) -> int:
    @lru_cache(None)
    def dfs(needs):
        # 计算不使用任何大礼包时的花费
        cost = sum(p * need for p, need in zip(price, needs))
        
        # 尝试使用每个大礼包
        for offer in special:
            new_needs = []
            for i in range(len(needs)):
                if needs[i] < offer[i]:
                    break
                new_needs.append(needs[i] - offer[i])
            else:
                cost = min(cost, offer[-1] + dfs(tuple(new_needs)))
        
        return cost
    
    return dfs(tuple(needs))

Solution = create_solution(shopping_offers)