# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2574
标题: Count Subarrays With Median K
难度: hard
链接: https://leetcode.cn/problems/count-subarrays-with-median-k/
题目类型: 数组、哈希表、前缀和
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2488. 统计中位数为 K 的子数组 - 给你一个长度为 n 的数组 nums ，该数组由从 1 到 n 的 不同 整数组成。另给你一个正整数 k 。 统计并返回 nums 中的 中位数 等于 k 的非空子数组的数目。 注意： * 数组的中位数是按 递增 顺序排列后位于 中间 的那个元素，如果数组长度为偶数，则中位数是位于中间靠 左 的那个元素。 * 例如，[2,3,1,4] 的中位数是 2 ，[8,4,3,5,1] 的中位数是 4 。 * 子数组是数组中的一个连续部分。 示例 1： 输入：nums = [3,2,1,4,5], k = 4 输出：3 解释：中位数等于 4 的子数组有：[4]、[4,5] 和 [1,4,5] 。 示例 2： 输入：nums = [2,3,1], k = 3 输出：1 解释：[3] 是唯一一个中位数等于 3 的子数组。 提示： * n == nums.length * 1 <= n <= 105 * 1 <= nums[i], k <= n * nums 中的整数互不相同
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用前缀和与哈希表来记录平衡因子（大于k的元素个数减去小于k的元素个数）。

算法步骤:
1. 找到k在数组中的位置。
2. 计算前缀和，并使用哈希表记录每个平衡因子出现的次数。
3. 遍历数组，计算当前的平衡因子，并根据哈希表中的记录更新结果。

关键点:
- 平衡因子的概念：大于k的元素个数减去小于k的元素个数。
- 使用哈希表记录平衡因子出现的次数，以便快速查找。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def count_subarrays_with_median_k(nums: List[int], k: int) -> int:
    """
    统计中位数为K的子数组数量
    """
    n = len(nums)
    k_index = nums.index(k)
    prefix_sum = [0] * (n + 1)
    balance_factor_count = {0: 1}
    result = 0
    
    for i in range(1, n + 1):
        if nums[i - 1] > k:
            prefix_sum[i] = prefix_sum[i - 1] + 1
        elif nums[i - 1] < k:
            prefix_sum[i] = prefix_sum[i - 1] - 1
        else:
            prefix_sum[i] = prefix_sum[i - 1]
        
        if i > k_index:
            result += balance_factor_count.get(prefix_sum[i] - 1, 0)
            result += balance_factor_count.get(prefix_sum[i], 0)
        
        balance_factor_count[prefix_sum[i]] = balance_factor_count.get(prefix_sum[i], 0) + 1
    
    return result

Solution = count_subarrays_with_median_k