# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1491
标题: Number of Times Binary String Is Prefix-Aligned
难度: medium
链接: https://leetcode.cn/problems/number-of-times-binary-string-is-prefix-aligned/
题目类型: 数组
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1375. 二进制字符串前缀一致的次数 - 给你一个长度为 n 、下标从 1 开始的二进制字符串，所有位最开始都是 0 。我们会按步翻转该二进制字符串的所有位（即，将 0 变为 1）。 给你一个下标从 1 开始的整数数组 flips ，其中 flips[i] 表示对应下标 i 的位将会在第 i 步翻转。 二进制字符串 前缀一致 需满足：在第 i 步之后，在 闭 区间 [1, i] 内的所有位都是 1 ，而其他位都是 0 。 返回二进制字符串在翻转过程中 前缀一致 的次数。 示例 1： 输入：flips = [3,2,4,1,5] 输出：2 解释：二进制字符串最开始是 "00000" 。 执行第 1 步：字符串变为 "00100" ，不属于前缀一致的情况。 执行第 2 步：字符串变为 "01100" ，不属于前缀一致的情况。 执行第 3 步：字符串变为 "01110" ，不属于前缀一致的情况。 执行第 4 步：字符串变为 "11110" ，属于前缀一致的情况。 执行第 5 步：字符串变为 "11111" ，属于前缀一致的情况。 在翻转过程中，前缀一致的次数为 2 ，所以返回 2 。 示例 2： 输入：flips = [4,1,2,3] 输出：1 解释：二进制字符串最开始是 "0000" 。 执行第 1 步：字符串变为 "0001" ，不属于前缀一致的情况。 执行第 2 步：字符串变为 "1001" ，不属于前缀一致的情况。 执行第 3 步：字符串变为 "1101" ，不属于前缀一致的情况。 执行第 4 步：字符串变为 "1111" ，属于前缀一致的情况。 在翻转过程中，前缀一致的次数为 1 ，所以返回 1 。 提示： * n == flips.length * 1 <= n <= 5 * 104 * flips 是范围 [1, n] 中所有整数构成的一个排列
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用一个变量来记录当前的最大翻转位置，并在每一步检查是否所有的翻转位置都在当前最大翻转位置之内。

算法步骤:
1. 初始化一个变量 `max_flip` 为 0，用于记录当前的最大翻转位置。
2. 初始化一个变量 `count` 为 0，用于记录前缀一致的次数。
3. 遍历 `flips` 数组：
   - 更新 `max_flip` 为当前翻转位置和 `max_flip` 的最大值。
   - 如果当前步数等于 `max_flip`，则说明前缀一致，增加 `count`。
4. 返回 `count`。

关键点:
- 使用 `max_flip` 来跟踪当前的最大翻转位置。
- 每一步检查当前步数是否等于 `max_flip`，以判断前缀是否一致。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是 `flips` 的长度。我们只需要遍历一次 `flips` 数组。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(flips: List[int]) -> int:
    """
    函数式接口 - 计算二进制字符串前缀一致的次数
    """
    max_flip = 0
    count = 0
    for i, flip in enumerate(flips):
        max_flip = max(max_flip, flip)
        if i + 1 == max_flip:
            count += 1
    return count


Solution = create_solution(solution_function_name)