# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 419
标题: Battleships in a Board
难度: medium
链接: https://leetcode.cn/problems/battleships-in-a-board/
题目类型: 深度优先搜索、数组、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
419. 棋盘上的战舰 - 给你一个大小为 m x n 的矩阵 board 表示棋盘，其中，每个单元格可以是一艘战舰 'X' 或者是一个空位 '.' ，返回在棋盘 board 上放置的 舰队 的数量。 舰队 只能水平或者垂直放置在 board 上。换句话说，舰队只能按 1 x k（1 行，k 列）或 k x 1（k 行，1 列）的形状放置，其中 k 可以是任意大小。两个舰队之间至少有一个水平或垂直的空格分隔 （即没有相邻的舰队）。 示例 1： [https://pic.leetcode.cn/1719200420-KKnzye-image.png] 输入：board = [["X",".",".","X"],[".",".",".","X"],[".",".",".","X"]] 输出：2 示例 2： 输入：board = [["."]] 输出：0 提示： * m == board.length * n == board[i].length * 1 <= m, n <= 200 * board[i][j] 是 '.' 或 'X' 进阶：你可以实现一次扫描算法，并只使用 O(1) 额外空间，并且不修改 board 的值来解决这个问题吗？
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过遍历棋盘，统计每个战舰的左上角部分，从而计算出战舰的数量。

算法步骤:
1. 初始化计数器 count 为 0。
2. 遍历棋盘，对于每个单元格 (i, j)：
   - 如果当前单元格是 'X' 且其左边和上边的单元格都不是 'X'，则说明这是一个新的战舰的左上角。
   - 增加计数器 count。
3. 返回计数器 count。

关键点:
- 通过检查当前单元格的左边和上边的单元格是否为 'X' 来确定是否为一个新的战舰的左上角。
- 只需要一次遍历棋盘，时间复杂度为 O(m * n)，空间复杂度为 O(1)。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m * n) - 需要遍历整个棋盘
空间复杂度: O(1) - 只使用常数级额外空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def battleships_in_a_board(board: List[List[str]]) -> int:
    """
    函数式接口 - 计算棋盘上的战舰数量
    
    实现思路:
    通过遍历棋盘，统计每个战舰的左上角部分，从而计算出战舰的数量。
    
    Args:
        board: 二维字符矩阵，表示棋盘
        
    Returns:
        棋盘上战舰的数量
        
    Example:
        >>> battleships_in_a_board([["X",".",".","X"],[".",".",".","X"],[".",".",".","X"]])
        2
    """
    if not board or not board[0]:
        return 0
    
    count = 0
    m, n = len(board), len(board[0])
    
    for i in range(m):
        for j in range(n):
            if board[i][j] == 'X':
                # 检查左边和上边的单元格是否为 'X'
                if (i == 0 or board[i-1][j] == '.') and (j == 0 or board[i][j-1] == '.'):
                    count += 1
    
    return count


# 自动生成Solution类（无需手动编写）
Solution = create_solution(battleships_in_a_board)