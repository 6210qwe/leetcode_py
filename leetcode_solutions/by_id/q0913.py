# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 913
标题: Random Flip Matrix
难度: medium
链接: https://leetcode.cn/problems/random-flip-matrix/
题目类型: 水塘抽样、哈希表、数学、随机化
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
519. 随机翻转矩阵 - 给你一个 m x n 的二元矩阵 matrix ，且所有值被初始化为 0 。请你设计一个算法，随机选取一个满足 matrix[i][j] == 0 的下标 (i, j) ，并将它的值变为 1 。所有满足 matrix[i][j] == 0 的下标 (i, j) 被选取的概率应当均等。 尽量最少调用内置的随机函数，并且优化时间和空间复杂度。 实现 Solution 类： * Solution(int m, int n) 使用二元矩阵的大小 m 和 n 初始化该对象 * int[] flip() 返回一个满足 matrix[i][j] == 0 的随机下标 [i, j] ，并将其对应格子中的值变为 1 * void reset() 将矩阵中所有的值重置为 0 示例： 输入 ["Solution", "flip", "flip", "flip", "reset", "flip"] [[3, 1], [], [], [], [], []] 输出 [null, [1, 0], [2, 0], [0, 0], null, [2, 0]] 解释 Solution solution = new Solution(3, 1); solution.flip(); // 返回 [1, 0]，此时返回 [0,0]、[1,0] 和 [2,0] 的概率应当相同 solution.flip(); // 返回 [2, 0]，因为 [1,0] 已经返回过了，此时返回 [2,0] 和 [0,0] 的概率应当相同 solution.flip(); // 返回 [0, 0]，根据前面已经返回过的下标，此时只能返回 [0,0] solution.reset(); // 所有值都重置为 0 ，并可以再次选择下标返回 solution.flip(); // 返回 [2, 0]，此时返回 [0,0]、[1,0] 和 [2,0] 的概率应当相同 提示： * 1 <= m, n <= 104 * 每次调用flip 时，矩阵中至少存在一个值为 0 的格子。 * 最多调用 1000 次 flip 和 reset 方法。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用哈希表和水塘抽样来实现随机翻转。

算法步骤:
1. 初始化时，记录矩阵的总大小 `total` 和已翻转的元素集合 `flipped`。
2. 在 `flip` 方法中，使用水塘抽样从剩余未翻转的元素中随机选择一个元素。
3. 将选中的元素标记为已翻转，并更新哈希表。
4. 在 `reset` 方法中，清空已翻转的元素集合 `flipped`。

关键点:
- 使用哈希表记录已翻转的元素，避免直接存储整个矩阵，节省空间。
- 使用水塘抽样保证每个未翻转元素被选中的概率相等。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(1) - 每次 `flip` 和 `reset` 操作的时间复杂度都是常数级别。
空间复杂度: O(min(m * n, k)) - 其中 k 是 `flip` 操作的次数，最坏情况下为 O(m * n)。
"""

# ============================================================================
# 代码实现
# ============================================================================

from random import randint
from typing import List

class Solution:
    def __init__(self, m: int, n: int):
        self.m = m
        self.n = n
        self.total = m * n
        self.flipped = set()

    def flip(self) -> List[int]:
        # 生成一个随机索引
        rand_index = randint(0, self.total - len(self.flipped) - 1)
        
        # 查找实际的未翻转索引
        actual_index = rand_index
        for i in self.flipped:
            if i <= actual_index:
                actual_index += 1
        
        # 记录翻转
        self.flipped.add(actual_index)
        
        # 返回对应的行列坐标
        return [actual_index // self.n, actual_index % self.n]

    def reset(self) -> None:
        self.flipped.clear()


# 示例测试
if __name__ == "__main__":
    sol = Solution(3, 1)
    print(sol.flip())  # 可能输出 [1, 0]
    print(sol.flip())  # 可能输出 [2, 0]
    print(sol.flip())  # 可能输出 [0, 0]
    sol.reset()
    print(sol.flip())  # 可能输出 [2, 0]