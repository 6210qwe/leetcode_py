# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2553
标题: Total Cost to Hire K Workers
难度: medium
链接: https://leetcode.cn/problems/total-cost-to-hire-k-workers/
题目类型: 数组、双指针、模拟、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2462. 雇佣 K 位工人的总代价 - 给你一个下标从 0 开始的整数数组 costs ，其中 costs[i] 是雇佣第 i 位工人的代价。 同时给你两个整数 k 和 candidates 。我们想根据以下规则恰好雇佣 k 位工人： * 总共进行 k 轮雇佣，且每一轮恰好雇佣一位工人。 * 在每一轮雇佣中，从最前面 candidates 和最后面 candidates 人中选出代价最小的一位工人，如果有多位代价相同且最小的工人，选择下标更小的一位工人。 * 比方说，costs = [3,2,7,7,1,2] 且 candidates = 2 ，第一轮雇佣中，我们选择第 4 位工人，因为他的代价最小 [3,2,7,7,1,2] 。 * 第二轮雇佣，我们选择第 1 位工人，因为他们的代价与第 4 位工人一样都是最小代价，而且下标更小，[3,2,7,7,2] 。注意每一轮雇佣后，剩余工人的下标可能会发生变化。 * 如果剩余员工数目不足 candidates 人，那么下一轮雇佣他们中代价最小的一人，如果有多位代价相同且最小的工人，选择下标更小的一位工人。 * 一位工人只能被选择一次。 返回雇佣恰好 k 位工人的总代价。 示例 1： 输入：costs = [17,12,10,2,7,2,11,20,8], k = 3, candidates = 4 输出：11 解释：我们总共雇佣 3 位工人。总代价一开始为 0 。 - 第一轮雇佣，我们从 [17,12,10,2,7,2,11,20,8] 中选择。最小代价是 2 ，有两位工人，我们选择下标更小的一位工人，即第 3 位工人。总代价是 0 + 2 = 2 。 - 第二轮雇佣，我们从 [17,12,10,7,2,11,20,8] 中选择。最小代价是 2 ，下标为 4 ，总代价是 2 + 2 = 4 。 - 第三轮雇佣，我们从 [17,12,10,7,11,20,8] 中选择，最小代价是 7 ，下标为 3 ，总代价是 4 + 7 = 11 。注意下标为 3 的工人同时在最前面和最后面 4 位工人中。 总雇佣代价是 11 。 示例 2： 输入：costs = [1,2,4,1], k = 3, candidates = 3 输出：4 解释：我们总共雇佣 3 位工人。总代价一开始为 0 。 - 第一轮雇佣，我们从 [1,2,4,1] 中选择。最小代价为 1 ，有两位工人，我们选择下标更小的一位工人，即第 0 位工人，总代价是 0 + 1 = 1 。注意，下标为 1 和 2 的工人同时在最前面和最后面 3 位工人中。 - 第二轮雇佣，我们从 [2,4,1] 中选择。最小代价为 1 ，下标为 2 ，总代价是 1 + 1 = 2 。 - 第三轮雇佣，少于 3 位工人，我们从剩余工人 [2,4] 中选择。最小代价是 2 ，下标为 0 。总代价为 2 + 2 = 4 。 总雇佣代价是 4 。 提示： * 1 <= costs.length <= 105 * 1 <= costs[i] <= 105 * 1 <= k, candidates <= costs.length
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用两个最小堆来分别存储最前面和最后面的 candidates 个工人，每次从这两个堆中取出最小值，直到雇佣 k 位工人。

算法步骤:
1. 初始化两个最小堆 `left_heap` 和 `right_heap`，分别存储最前面和最后面的 candidates 个工人。
2. 使用两个指针 `left` 和 `right` 分别指向最前面和最后面的候选人。
3. 进行 k 轮雇佣：
   - 从 `left_heap` 和 `right_heap` 中取出最小值，选择较小的一个工人。
   - 将该工人从堆中移除，并更新总代价。
   - 如果 `left` 指针小于 `right` 指针，将新的候选人加入对应的堆中。
4. 返回总代价。

关键点:
- 使用最小堆来高效地获取最小代价的工人。
- 通过双指针确保不会重复添加工人。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(k log c)，其中 k 是雇佣的工人数量，c 是 candidates 的数量。每次从堆中取出元素的时间复杂度是 O(log c)。
空间复杂度: O(c)，用于存储两个最小堆。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def total_cost(costs: List[int], k: int, candidates: int) -> int:
    n = len(costs)
    left_heap = []
    right_heap = []
    left = 0
    right = n - 1
    total_cost = 0

    # 初始化两个最小堆
    for _ in range(candidates):
        if left <= right:
            heapq.heappush(left_heap, (costs[left], left))
            left += 1
        if left <= right:
            heapq.heappush(right_heap, (costs[right], right))
            right -= 1

    for _ in range(k):
        if not right_heap or (left_heap and left_heap[0][0] <= right_heap[0][0]):
            cost, index = heapq.heappop(left_heap)
            total_cost += cost
            if left <= right:
                heapq.heappush(left_heap, (costs[left], left))
                left += 1
        else:
            cost, index = heapq.heappop(right_heap)
            total_cost += cost
            if left <= right:
                heapq.heappush(right_heap, (costs[right], right))
                right -= 1

    return total_cost

Solution = create_solution(total_cost)