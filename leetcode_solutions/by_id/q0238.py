# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 238
标题: Product of Array Except Self
难度: medium
链接: https://leetcode.cn/problems/product-of-array-except-self/
题目类型: 数组、前缀和
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
238. 除了自身以外数组的乘积 - 给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除了 nums[i] 之外其余各元素的乘积 。 题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在 32 位 整数范围内。 请 不要使用除法，且在 O(n) 时间复杂度内完成此题。 示例 1: 输入: nums = [1,2,3,4] 输出: [24,12,8,6] 示例 2: 输入: nums = [-1,1,0,-3,3] 输出: [0,0,9,0,0] 提示： * 2 <= nums.length <= 105 * -30 <= nums[i] <= 30 * 输入 保证 数组 answer[i] 在 32 位 整数范围内 进阶：你可以在 O(1) 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 不被视为 额外空间。）
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用前缀积和后缀积，先计算前缀积，然后从右到左计算后缀积并更新结果

算法步骤:
1. 从左到右计算前缀积，存储在结果数组中
2. 从右到左计算后缀积，同时更新结果数组

关键点:
- 不使用除法，O(1)额外空间（输出数组不算）
- 时间复杂度O(n)，空间复杂度O(1)（不包括输出数组）
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 需要遍历数组两次
空间复杂度: O(1) - 只使用常数额外空间（不包括输出数组）
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from leetcode_solutions.utils.solution import create_solution


def product_of_array_except_self(nums: List[int]) -> List[int]:
    """
    函数式接口 - 除了自身以外数组的乘积
    
    实现思路:
    使用前缀积和后缀积，先计算前缀积，然后从右到左计算后缀积并更新结果。
    
    Args:
        nums: 整数数组
        
    Returns:
        除了自身以外数组的乘积数组
        
    Example:
        >>> product_of_array_except_self([1, 2, 3, 4])
        [24, 12, 8, 6]
    """
    n = len(nums)
    result = [1] * n
    
    # 计算前缀积
    for i in range(1, n):
        result[i] = result[i - 1] * nums[i - 1]
    
    # 计算后缀积并更新结果
    suffix = 1
    for i in range(n - 1, -1, -1):
        result[i] *= suffix
        suffix *= nums[i]
    
    return result


# 自动生成Solution类（无需手动编写）
Solution = create_solution(product_of_array_except_self)
