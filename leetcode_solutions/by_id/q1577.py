# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1577
标题: Probability of a Two Boxes Having The Same Number of Distinct Balls
难度: hard
链接: https://leetcode.cn/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/
题目类型: 数组、数学、动态规划、回溯、组合数学、概率与统计
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1467. 两个盒子中球的颜色数相同的概率 - 桌面上有 2n 个颜色不完全相同的球，球的颜色共有 k 种。给你一个大小为 k 的整数数组 balls ，其中 balls[i] 是颜色为 i 的球的数量。 所有的球都已经 随机打乱顺序 ，前 n 个球放入第一个盒子，后 n 个球放入另一个盒子（请认真阅读示例 2 的解释部分）。 注意：这两个盒子是不同的。例如，两个球颜色分别为 a 和 b，盒子分别为 [] 和 ()，那么 [a] (b) 和 [b] (a) 这两种分配方式是不同的（请认真阅读示例的解释部分）。 请返回「两个盒子中球的颜色数相同」的情况的概率。答案与真实值误差在 10-5 以内，则被视为正确答案 示例 1： 输入：balls = [1,1] 输出：1.00000 解释：球平均分配的方式只有两种： - 颜色为 1 的球放入第一个盒子，颜色为 2 的球放入第二个盒子 - 颜色为 2 的球放入第一个盒子，颜色为 1 的球放入第二个盒子 这两种分配，两个盒子中球的颜色数都相同。所以概率为 2/2 = 1 。 示例 2： 输入：balls = [2,1,1] 输出：0.66667 解释：球的列表为 [1, 1, 2, 3] 随机打乱，得到 12 种等概率的不同打乱方案，每种方案概率为 1/12 ： [1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1] 然后，我们将前两个球放入第一个盒子，后两个球放入第二个盒子。 这 12 种可能的随机打乱方式中的 8 种满足「两个盒子中球的颜色数相同」。 概率 = 8/12 = 0.66667 示例 3： 输入：balls = [1,2,1,2] 输出：0.60000 解释：球的列表为 [1, 2, 2, 3, 4, 4]。要想显示所有 180 种随机打乱方案是很难的，但只检查「两个盒子中球的颜色数相同」的 108 种情况是比较容易的。 概率 = 108 / 180 = 0.6 。 提示： * 1 <= balls.length <= 8 * 1 <= balls[i] <= 6 * sum(balls) 是偶数
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划和组合数学来计算两个盒子中球的颜色数相同的概率。

算法步骤:
1. 计算总的球数 `total_balls` 和总的颜色数 `k`。
2. 初始化一个三维 DP 数组 `dp`，其中 `dp[i][j][x]` 表示前 `i` 种颜色的球放入第一个盒子 `j` 个，且第一个盒子中有 `x` 种不同颜色的概率。
3. 初始化边界条件：`dp[0][0][0] = 1`。
4. 使用动态规划填充 `dp` 数组：
   - 对于每种颜色 `i`，遍历可以放入第一个盒子的球数 `j`。
   - 计算剩余球数 `remaining` 和可以放入第二个盒子的球数 `y`。
   - 更新 `dp` 数组。
5. 计算总的合法分配方案数 `total_ways` 和满足条件的分配方案数 `valid_ways`。
6. 返回 `valid_ways / total_ways` 作为结果。

关键点:
- 使用组合数学计算球的分配方案数。
- 动态规划状态转移方程的设计。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(k * n^2)，其中 k 是颜色数，n 是总球数的一半。
空间复杂度: O(k * n^2)，用于存储 DP 数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution
import math


def get_probability(balls: List[int]) -> float:
    k = len(balls)
    total_balls = sum(balls)
    n = total_balls // 2

    # 初始化 DP 数组
    dp = [[[0 for _ in range(k + 1)] for _ in range(n + 1)] for _ in range(k + 1)]
    dp[0][0][0] = 1

    # 动态规划填充 DP 数组
    for i in range(1, k + 1):
        for j in range(n + 1):
            for x in range(i + 1):
                for b in range(min(balls[i - 1], j) + 1):
                    remaining = balls[i - 1] - b
                    y = min(j - b, x)
                    if remaining >= y and remaining + b == balls[i - 1]:
                        dp[i][j][x] += dp[i - 1][j - b][y] * math.comb(balls[i - 1], b)

    # 计算总的合法分配方案数
    total_ways = sum(dp[k][n][x] for x in range(k + 1))
    valid_ways = sum(dp[k][n][x] for x in range(k + 1) if x == (k - x))

    return valid_ways / total_ways


Solution = create_solution(get_probability)