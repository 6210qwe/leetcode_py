# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 842
标题: Card Flipping Game
难度: medium
链接: https://leetcode.cn/problems/card-flipping-game/
题目类型: 数组、哈希表
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
822. 翻转卡片游戏 - 在桌子上有 n 张卡片，每张卡片的正面和背面都写着一个正数（正面与背面上的数有可能不一样）。 我们可以先翻转任意张卡片，然后选择其中一张卡片。 如果选中的那张卡片背面的数字 x 与任意一张卡片的正面的数字都不同，那么这个数字是我们想要的数字。 哪个数是这些想要的数字中最小的数（找到这些数中的最小值）呢？如果没有一个数字符合要求的，输出 0 。 其中, fronts[i] 和 backs[i] 分别代表第 i 张卡片的正面和背面的数字。 如果我们通过翻转卡片来交换正面与背面上的数，那么当初在正面的数就变成背面的数，背面的数就变成正面的数。 示例 1： 输入：fronts = [1,2,4,4,7], backs = [1,3,4,1,3] 输出：2 解释：假设我们翻转第二张卡片，那么在正面的数变成了 [1,3,4,4,7] ， 背面的数变成了 [1,2,4,1,3]。 接着我们选择第二张卡片，因为现在该卡片的背面的数是 2，2 与任意卡片上正面的数都不同，所以 2 就是我们想要的数字。 示例 2： 输入：fronts = [1], backs = [1] 输出：0 解释： 无论如何翻转都无法得到想要的数字，所以返回 0 。 提示： * n == fronts.length == backs.length * 1 <= n <= 1000 * 1 <= fronts[i], backs[i] <= 2000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用哈希集合来记录那些在正面和背面相同的数字，然后遍历所有数字，找到最小的且不在集合中的数字。

算法步骤:
1. 创建一个集合来存储那些在正面和背面相同的数字。
2. 初始化一个变量 `min_value` 为无穷大。
3. 遍历所有卡片，如果某个数字不在集合中且小于 `min_value`，更新 `min_value`。
4. 返回 `min_value`，如果 `min_value` 仍为无穷大，则返回 0。

关键点:
- 使用集合来快速查找那些在正面和背面相同的数字。
- 遍历所有数字，找到最小的且不在集合中的数字。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def flip_game(fronts: List[int], backs: List[int]) -> int:
    """
    函数式接口 - 实现翻转卡片游戏
    """
    # 创建一个集合来存储那些在正面和背面相同的数字
    same_numbers = set()
    for i in range(len(fronts)):
        if fronts[i] == backs[i]:
            same_numbers.add(fronts[i])
    
    # 初始化最小值
    min_value = float('inf')
    
    # 遍历所有卡片，找到最小的且不在集合中的数字
    for num in fronts + backs:
        if num not in same_numbers and num < min_value:
            min_value = num
    
    # 返回结果
    return min_value if min_value != float('inf') else 0


Solution = create_solution(flip_game)