# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 962
标题: Flip String to Monotone Increasing
难度: medium
链接: https://leetcode.cn/problems/flip-string-to-monotone-increasing/
题目类型: 字符串、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
926. 将字符串翻转到单调递增 - 如果一个二进制字符串，是以一些 0（可能没有 0）后面跟着一些 1（也可能没有 1）的形式组成的，那么该字符串是 单调递增 的。 给你一个二进制字符串 s，你可以将任何 0 翻转为 1 或者将 1 翻转为 0 。 返回使 s 单调递增的最小翻转次数。 示例 1： 输入：s = "00110" 输出：1 解释：翻转最后一位得到 00111. 示例 2： 输入：s = "010110" 输出：2 解释：翻转得到 011111，或者是 000111。 示例 3： 输入：s = "00011000" 输出：2 解释：翻转得到 00000000。 提示： * 1 <= s.length <= 105 * s[i] 为 '0' 或 '1'
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们定义两个状态：
- dp0[i] 表示将前 i 个字符变成以 0 结尾的单调递增字符串所需的最小翻转次数。
- dp1[i] 表示将前 i 个字符变成以 1 结尾的单调递增字符串所需的最小翻转次数。

算法步骤:
1. 初始化 dp0[0] 和 dp1[0]。
2. 遍历字符串，更新 dp0 和 dp1。
3. 最后返回 dp0[n-1] 和 dp1[n-1] 中的最小值。

关键点:
- 通过动态规划，我们可以在线性时间内解决问题。
- 通过维护两个状态，我们可以有效地计算出最小翻转次数。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是字符串的长度。
空间复杂度: O(1)，我们只需要常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def min_flips_mono_incr(s: str) -> int:
    """
    函数式接口 - 计算使字符串单调递增的最小翻转次数
    """
    n = len(s)
    dp0, dp1 = 0, 0  # dp0: 以 0 结尾的最小翻转次数, dp1: 以 1 结尾的最小翻转次数

    for i in range(n):
        if s[i] == '0':
            dp1 = min(dp0, dp1) + 1  # 当前字符为 0，如果以 1 结尾，则需要翻转
        else:
            dp1 = min(dp0, dp1)  # 当前字符为 1，如果以 1 结尾，则不需要翻转
            dp0 += 1  # 当前字符为 1，如果以 0 结尾，则需要翻转

    return min(dp0, dp1)


Solution = create_solution(min_flips_mono_incr)