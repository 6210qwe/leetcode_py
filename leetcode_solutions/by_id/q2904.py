# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2904
标题: Sorting Three Groups
难度: medium
链接: https://leetcode.cn/problems/sorting-three-groups/
题目类型: 数组、二分查找、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2826. 将三个组排序 - 给你一个整数数组 nums 。nums 的每个元素是 1，2 或 3。在每次操作中，你可以删除 nums 中的一个元素。返回使 nums 成为 非递减 顺序所需操作数的 最小值。 示例 1： 输入：nums = [2,1,3,2,1] 输出：3 解释： 其中一个最优方案是删除 nums[0]，nums[2] 和 nums[3]。 示例 2： 输入：nums = [1,3,2,1,3,3] 输出：2 解释： 其中一个最优方案是删除 nums[1] 和 nums[2]。 示例 3： 输入：nums = [2,2,2,2,3,3] 输出：0 解释： nums 已是非递减顺序的。 提示： * 1 <= nums.length <= 100 * 1 <= nums[i] <= 3 进阶：你可以使用 O(n) 时间复杂度以内的算法解决吗？
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决问题。我们定义 dp[i][j] 表示将前 i 个元素变成非递减顺序，并且最后一个元素为 j (j=1,2,3) 所需的最小操作数。

算法步骤:
1. 初始化 dp 数组，dp[i][j] 表示将前 i 个元素变成非递减顺序，并且最后一个元素为 j 所需的最小操作数。
2. 遍历数组，对于每个元素 nums[i]，更新 dp 数组。
3. 最后返回 dp[n][1], dp[n][2], dp[n][3] 中的最小值。

关键点:
- 动态规划的状态转移方程：dp[i][j] = min(dp[i-1][k] + (nums[i-1] != j))，其中 k <= j。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def solution_function_name(nums: List[int]) -> int:
    """
    函数式接口 - 返回使 nums 成为非递减顺序所需操作数的最小值
    """
    n = len(nums)
    if n == 0:
        return 0

    # 初始化 dp 数组
    dp = [[0] * 4 for _ in range(n + 1)]

    # 动态规划填表
    for i in range(1, n + 1):
        for j in range(1, 4):
            dp[i][j] = dp[i - 1][j] + (nums[i - 1] != j)
            for k in range(1, j):
                dp[i][j] = min(dp[i][j], dp[i - 1][k] + (nums[i - 1] != j))

    # 返回最小操作数
    return min(dp[n][1], dp[n][2], dp[n][3])

Solution = create_solution(solution_function_name)