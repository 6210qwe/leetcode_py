# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1669
标题: Minimum Cost to Cut a Stick
难度: hard
链接: https://leetcode.cn/problems/minimum-cost-to-cut-a-stick/
题目类型: 数组、动态规划、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1547. 切棍子的最小成本 - 有一根长度为 n 个单位的木棍，棍上从 0 到 n 标记了若干位置。例如，长度为 6 的棍子可以标记如下： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/08/09/statement.jpg] 给你一个整数数组 cuts ，其中 cuts[i] 表示你需要将棍子切开的位置。 你可以按顺序完成切割，也可以根据需要更改切割的顺序。 每次切割的成本都是当前要切割的棍子的长度，切棍子的总成本是历次切割成本的总和。对棍子进行切割将会把一根木棍分成两根较小的木棍（这两根木棍的长度和就是切割前木棍的长度）。请参阅第一个示例以获得更直观的解释。 返回切棍子的 最小总成本 。 示例 1： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/08/09/e1.jpg] 输入：n = 7, cuts = [1,3,4,5] 输出：16 解释：按 [1, 3, 4, 5] 的顺序切割的情况如下所示： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/08/09/e11.jpg] 第一次切割长度为 7 的棍子，成本为 7 。第二次切割长度为 6 的棍子（即第一次切割得到的第二根棍子），第三次切割为长度 4 的棍子，最后切割长度为 3 的棍子。总成本为 7 + 6 + 4 + 3 = 20 。 而将切割顺序重新排列为 [3, 5, 1, 4] 后，总成本 = 16（如示例图中 7 + 4 + 3 + 2 = 16）。 示例 2： 输入：n = 9, cuts = [5,6,1,4,2] 输出：22 解释：如果按给定的顺序切割，则总成本为 25 。总成本 <= 25 的切割顺序很多，例如，[4, 6, 5, 2, 1] 的总成本 = 22，是所有可能方案中成本最小的。 提示： * 2 <= n <= 10^6 * 1 <= cuts.length <= min(n - 1, 100) * 1 <= cuts[i] <= n - 1 * cuts 数组中的所有整数都 互不相同
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们定义 dp[i][j] 为在区间 [i, j] 内切割木棍的最小成本。通过递归和记忆化搜索来计算每个区间的最小成本。

算法步骤:
1. 将 cuts 数组和边界 0 和 n 加入一个新的数组，并对其进行排序。
2. 定义一个递归函数 dp(i, j)，表示在区间 [cuts[i], cuts[j]] 内切割木棍的最小成本。
3. 对于每个区间 [i, j]，尝试在每个可能的切割点 k (i < k < j) 进行切割，并计算切割成本。
4. 递归地计算左区间 [i, k] 和右区间 [k, j] 的最小成本，并更新 dp(i, j)。
5. 使用记忆化搜索来避免重复计算。

关键点:
- 使用动态规划和记忆化搜索来优化计算。
- 通过递归和记忆化搜索来处理重叠子问题。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m^3)，其中 m 是 cuts 数组的长度。每次递归调用最多需要 m^2 次，每次调用需要 O(m) 时间。
空间复杂度: O(m^2)，用于存储记忆化搜索的结果。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution

def min_cost(n: int, cuts: List[int]) -> int:
    # 在 cuts 数组中加入边界 0 和 n，并对其进行排序
    cuts = [0] + sorted(cuts) + [n]
    m = len(cuts)
    
    # 记忆化搜索
    from functools import lru_cache
    @lru_cache(None)
    def dp(i, j):
        if i + 1 == j:
            return 0
        return min(dp(i, k) + dp(k, j) + (cuts[j] - cuts[i]) for k in range(i + 1, j))
    
    return dp(0, m - 1)

Solution = create_solution(min_cost)