# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 390
标题: Elimination Game
难度: medium
链接: https://leetcode.cn/problems/elimination-game/
题目类型: 递归、数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
390. 消除游戏 - 列表 arr 由在范围 [1, n] 中的所有整数组成，并按严格递增排序。请你对 arr 应用下述算法： * 从左到右，删除第一个数字，然后每隔一个数字删除一个，直到到达列表末尾。 * 重复上面的步骤，但这次是从右到左。也就是，删除最右侧的数字，然后剩下的数字每隔一个删除一个。 * 不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。 给你整数 n ，返回 arr 最后剩下的数字。 示例 1： 输入：n = 9 输出：6 解释： arr = [1, 2, 3, 4, 5, 6, 7, 8, 9] arr = [2, 4, 6, 8] arr = [2, 6] arr = [6] 示例 2： 输入：n = 1 输出：1 提示： * 1 <= n <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 数学递归

算法步骤:
1. 观察规律：每次删除后，剩余数字形成新的序列
2. 从左到右删除：删除后，剩余数字是原序列的偶数位置
3. 从右到左删除：删除后，剩余数字是原序列的奇数位置（从右数）
4. 递归处理，每次规模减半

关键点:
- 使用递归，每次处理规模减半
- 注意方向变化时的索引计算
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(logn) - 每次规模减半
空间复杂度: O(logn) - 递归深度
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def last_remaining(n: int) -> int:
    """
    函数式接口 - 消除游戏
    
    实现思路:
    使用递归，每次处理规模减半，注意方向变化。
    
    Args:
        n: 整数范围[1, n]
        
    Returns:
        最后剩下的数字
        
    Example:
        >>> last_remaining(9)
        6
    """
    def helper(n: int, left_to_right: bool) -> int:
        if n == 1:
            return 1
        
        if left_to_right:
            # 从左到右删除，剩余的是偶数位置
            return 2 * helper(n // 2, False)
        else:
            # 从右到左删除
            if n % 2 == 0:
                # 偶数个，剩余的是奇数位置（从1开始）
                return 2 * helper(n // 2, True) - 1
            else:
                # 奇数个，剩余的是偶数位置
                return 2 * helper(n // 2, True)
    
    return helper(n, True)


# 自动生成Solution类（无需手动编写）
Solution = create_solution(last_remaining)
