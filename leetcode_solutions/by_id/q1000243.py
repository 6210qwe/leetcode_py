# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000243
标题: 使用最小花费爬楼梯
难度: easy
链接: https://leetcode.cn/problems/GzCJIP/
题目类型: 数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCR 088. 使用最小花费爬楼梯 - 数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。 每当爬上一个阶梯都要花费对应的体力值，一旦支付了相应的体力值，就可以选择向上爬一个阶梯或者爬两个阶梯。 请找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。 示例 1： 输入：cost = [10, 15, 20] 输出：15 解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。 示例 2： 输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 输出：6 解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。 提示： * 2 <= cost.length <= 1000 * 0 <= cost[i] <= 999 注意：本题与主站 746 题相同： https://leetcode.cn/problems/min-cost-climbing-stairs/ [https://leetcode.cn/problems/min-cost-climbing-stairs/]
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 动态规划，滚动数组优化空间

算法步骤:
1. 定义 dp[i] 为到达台阶 i 的最小花费（i 可以看作“踏上第 i 级台阶”）
2. 转移方程：
   - dp[0] = cost[0]
   - dp[1] = cost[1]
   - 对于 i >= 2，有 dp[i] = cost[i] + min(dp[i-1], dp[i-2])
3. 到达楼顶可以从最后一级或倒数第二级上楼，因此答案为 min(dp[-1], dp[-2])
4. 可用两个滚动变量 prev2, prev1 分别表示 dp[i-2], dp[i-1]

关键点:
- 起点可以是下标 0 或 1，因此初始状态为 dp[0], dp[1]
- 返回时取末两级最小值
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - n 为 cost 长度
空间复杂度: O(1) - 使用滚动变量
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def min_cost_climbing_stairs(cost: List[int]) -> int:
    """
    函数式接口 - 使用最小花费爬楼梯
    """
    n = len(cost)
    if n == 2:
        return min(cost[0], cost[1])

    prev2 = cost[0]
    prev1 = cost[1]
    for i in range(2, n):
        cur = cost[i] + min(prev1, prev2)
        prev2, prev1 = prev1, cur

    return min(prev1, prev2)


Solution = create_solution(min_cost_climbing_stairs)
