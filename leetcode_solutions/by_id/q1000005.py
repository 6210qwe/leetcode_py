# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000005
标题: Pond Sizes LCCI
难度: medium
链接: https://leetcode.cn/problems/pond-sizes-lcci/
题目类型: 深度优先搜索、广度优先搜索、并查集、数组、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
面试题 16.19. 水域大小 - 你有一个用于表示一片土地的整数矩阵land，该矩阵中每个点的值代表对应地点的海拔高度。若值为0则表示水域。由垂直、水平或对角连接的水域为池塘。池塘的大小是指相连接的水域的个数。编写一个方法来计算矩阵中所有池塘的大小，返回值需要从小到大排序。 示例： 输入： [ [0,2,1,0], [0,1,0,1], [1,1,0,1], [0,1,0,1] ] 输出： [1,2,4] 提示： * 0 < len(land) <= 1000 * 0 < len(land[i]) <= 1000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用深度优先搜索（DFS）遍历整个矩阵，找到所有的池塘，并计算每个池塘的大小。

算法步骤:
1. 初始化一个结果列表 `pond_sizes` 来存储每个池塘的大小。
2. 遍历矩阵中的每个元素，如果遇到水域（值为0），则从该位置开始进行DFS。
3. 在DFS过程中，标记访问过的水域，并递归地访问其八个方向上的相邻水域。
4. 计算每个池塘的大小，并将其添加到结果列表中。
5. 对结果列表进行排序并返回。

关键点:
- 使用DFS遍历矩阵，确保每个水域只被访问一次。
- 通过标记访问过的水域来避免重复计算。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m * n)，其中m和n分别是矩阵的行数和列数。每个元素最多被访问一次。
空间复杂度: O(m * n)，在最坏情况下，递归栈的深度可能达到矩阵的大小。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def pond_sizes(land: List[List[int]]) -> List[int]:
    """
    计算矩阵中所有池塘的大小，并返回从小到大排序的结果。
    """
    def dfs(x: int, y: int) -> int:
        if x < 0 or x >= m or y < 0 or y >= n or land[x][y] != 0:
            return 0
        land[x][y] = -1  # 标记已访问
        size = 1
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            size += dfs(nx, ny)
        return size

    m, n = len(land), len(land[0])
    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]
    pond_sizes = []

    for i in range(m):
        for j in range(n):
            if land[i][j] == 0:
                size = dfs(i, j)
                if size > 0:
                    pond_sizes.append(size)

    return sorted(pond_sizes)

Solution = create_solution(pond_sizes)