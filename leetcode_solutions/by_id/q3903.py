# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3903
标题: Inverse Coin Change
难度: medium
链接: https://leetcode.cn/problems/inverse-coin-change/
题目类型: 数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3592. 硬币面值还原 - 给你一个 从 1 开始计数 的整数数组 numWays，其中 numWays[i] 表示使用某些 固定 面值的硬币（每种面值可以使用无限次）凑出总金额 i 的方法数。每种面值都是一个 正整数 ，并且其值 最多 为 numWays.length。 然而，具体的硬币面值已经 丢失 。你的任务是还原出可能生成这个 numWays 数组的面值集合。 返回一个按从小到大顺序排列的数组，其中包含所有可能的 唯一 整数面值。 如果不存在这样的集合，返回一个 空 数组。 示例 1： 输入： numWays = [0,1,0,2,0,3,0,4,0,5] 输出： [2,4,6] 解释： 金额 方法数 解释 1 0 无法用硬币凑出总金额 1。 2 1 唯一的方法是 [2]。 3 0 无法用硬币凑出总金额 3。 4 2 可以用 [2, 2] 或 [4]。 5 0 无法用硬币凑出总金额 5。 6 3 可以用 [2, 2, 2]、[2, 4] 或 [6]。 7 0 无法用硬币凑出总金额 7。 8 4 可以用 [2, 2, 2, 2]、[2, 2, 4]、[2, 6] 或 [4, 4]。 9 0 无法用硬币凑出总金额 9。 10 5 可以用 [2, 2, 2, 2, 2]、[2, 2, 2, 4]、[2, 4, 4]、[2, 2, 6] 或 [4, 6]。 示例 2： 输入： numWays = [1,2,2,3,4] 输出： [1,2,5] 解释： 金额 方法数 解释 1 1 唯一的方法是 [1]。 2 2 可以用 [1, 1] 或 [2]。 3 2 可以用 [1, 1, 1] 或 [1, 2]。 4 3 可以用 [1, 1, 1, 1]、[1, 1, 2] 或 [2, 2]。 5 4 可以用 [1, 1, 1, 1, 1]、[1, 1, 1, 2]、[1, 2, 2] 或 [5]。 示例 3： 输入： numWays = [1,2,3,4,15] 输出： [] 解释： 没有任何面值集合可以生成该数组。 提示： * 1 <= numWays.length <= 100 * 0 <= numWays[i] <= 2 * 108
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来验证每个可能的硬币面值，并通过递归检查是否能生成给定的 numWays 数组。

算法步骤:
1. 初始化一个空的结果列表 `result`。
2. 遍历每个可能的硬币面值 `i`，从 1 到 `numWays.length`。
3. 对于每个面值 `i`，检查 `numWays[i]` 是否为 1，如果是，则将 `i` 加入结果列表。
4. 使用递归函数 `check_ways` 来验证当前面值集合是否能生成 `numWays` 数组。
5. 如果验证成功，返回结果列表；否则，继续检查下一个面值。

关键点:
- 动态规划用于验证每个可能的硬币面值。
- 递归函数 `check_ways` 用于验证当前面值集合是否能生成 `numWays` 数组。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2)，其中 n 是 numWays 的长度。最坏情况下需要遍历所有可能的面值并进行递归验证。
空间复杂度: O(n)，递归调用栈的深度最多为 n。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution

def solution_function_name(numWays: List[int]) -> List[int]:
    """
    函数式接口 - 实现硬币面值还原
    """
    def check_ways(coins: List[int], target: int) -> bool:
        dp = [0] * (target + 1)
        dp[0] = 1
        for coin in coins:
            for i in range(coin, target + 1):
                dp[i] += dp[i - coin]
        return dp == numWays[:target + 1]

    result = []
    for i in range(1, len(numWays)):
        if numWays[i] == 1:
            result.append(i)
            if not check_ways(result, i):
                return []
    return result

Solution = create_solution(solution_function_name)