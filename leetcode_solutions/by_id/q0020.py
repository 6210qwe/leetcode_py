# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 20
标题: Valid Parentheses
难度: easy
链接: https://leetcode.cn/problems/valid-parentheses/
题目类型: 栈、字符串
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
20. 有效的括号 - 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 1. 左括号必须用相同类型的右括号闭合。 2. 左括号必须以正确的顺序闭合。 3. 每个右括号都有一个对应的相同类型的左括号。 示例 1： 输入：s = "()" 输出：true 示例 2： 输入：s = "()[]{}" 输出：true 示例 3： 输入：s = "(]" 输出：false 示例 4： 输入：s = "([])" 输出：true 示例 5： 输入：s = "([)]" 输出：false 提示： * 1 <= s.length <= 104 * s 仅由括号 '()[]{}' 组成
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用栈来匹配括号，遇到左括号入栈，遇到右括号检查是否匹配

算法步骤:
1. 创建栈和括号映射表（右括号到左括号的映射）
2. 遍历字符串：
   - 如果是左括号，入栈
   - 如果是右括号：
     * 如果栈为空或栈顶元素不匹配，返回False
     * 否则，弹出栈顶元素
3. 遍历结束后，如果栈为空则返回True，否则返回False

关键点:
- 使用栈来维护未匹配的左括号
- 右括号必须与最近的左括号匹配
- 时间复杂度O(n)，空间复杂度O(n)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 只需遍历字符串一次，n为字符串长度
空间复杂度: O(n) - 最坏情况下栈中存储n/2个左括号
"""

# ============================================================================
# 代码实现
# ============================================================================

from leetcode_solutions.utils.solution import create_solution


def is_valid(s: str) -> bool:
    """
    函数式接口 - 栈实现
    
    实现思路:
    使用栈来匹配括号，遇到左括号入栈，遇到右括号检查是否与栈顶左括号匹配。
    
    Args:
        s: 括号字符串
        
    Returns:
        如果括号有效返回True，否则返回False
        
    Example:
        >>> is_valid("()")
        True
        >>> is_valid("()[]{}")
        True
        >>> is_valid("(]")
        False
    """
    # 右括号到左括号的映射
    mapping = {')': '(', '}': '{', ']': '['}
    stack = []
    
    for char in s:
        if char in mapping:
            # 右括号：检查是否匹配
            if not stack or stack.pop() != mapping[char]:
                return False
        else:
            # 左括号：入栈
            stack.append(char)
    
    # 栈为空说明所有括号都匹配
    return len(stack) == 0


# 自动生成Solution类（无需手动编写）
Solution = create_solution(is_valid)
