# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2124
标题: First Day Where You Have Been in All the Rooms
难度: medium
链接: https://leetcode.cn/problems/first-day-where-you-have-been-in-all-the-rooms/
题目类型: 数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1997. 访问完所有房间的第一天 - 你需要访问 n 个房间，房间从 0 到 n - 1 编号。同时，每一天都有一个日期编号，从 0 开始，依天数递增。你每天都会访问一个房间。 最开始的第 0 天，你访问 0 号房间。给你一个长度为 n 且 下标从 0 开始 的数组 nextVisit 。在接下来的几天中，你访问房间的 次序 将根据下面的 规则 决定： * 假设某一天，你访问 i 号房间。 * 如果算上本次访问，访问 i 号房间的次数为 奇数 ，那么 第二天 需要访问 nextVisit[i] 所指定的房间，其中 0 <= nextVisit[i] <= i 。 * 如果算上本次访问，访问 i 号房间的次数为 偶数 ，那么 第二天 需要访问 (i + 1) mod n 号房间。 请返回你访问完所有房间的第一天的日期编号。题目数据保证总是存在这样的一天。由于答案可能很大，返回对 109 + 7 取余后的结果。 示例 1： 输入：nextVisit = [0,0] 输出：2 解释： - 第 0 天，你访问房间 0 。访问 0 号房间的总次数为 1 ，次数为奇数。 下一天你需要访问房间的编号是 nextVisit[0] = 0 - 第 1 天，你访问房间 0 。访问 0 号房间的总次数为 2 ，次数为偶数。 下一天你需要访问房间的编号是 (0 + 1) mod 2 = 1 - 第 2 天，你访问房间 1 。这是你第一次完成访问所有房间的那天。 示例 2： 输入：nextVisit = [0,0,2] 输出：6 解释： 你每天访问房间的次序是 [0,0,1,0,0,1,2,...] 。 第 6 天是你访问完所有房间的第一天。 示例 3： 输入：nextVisit = [0,1,2,0] 输出：6 解释： 你每天访问房间的次序是 [0,0,1,1,2,2,3,...] 。 第 6 天是你访问完所有房间的第一天。 提示： * n == nextVisit.length * 2 <= n <= 105 * 0 <= nextVisit[i] <= i
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来记录访问每个房间的天数，并利用前缀和的思想来计算访问下一个房间的天数。

算法步骤:
1. 初始化一个长度为 n 的数组 dp，dp[i] 表示访问到第 i 个房间所需的天数。
2. 初始化 dp[0] = 0，表示第 0 天访问了第 0 个房间。
3. 从第 1 个房间开始遍历到第 n-1 个房间：
   - 计算访问当前房间的天数 dp[i] = dp[i-1] + 1 + dp[i-1] - dp[nextVisit[i-1]]。
   - 对结果取模 10^9 + 7。
4. 返回 dp[n-1]。

关键点:
- 使用 dp 数组记录访问每个房间的天数。
- 利用前缀和的思想来计算访问下一个房间的天数。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def first_day_visited_all_rooms(nextVisit: List[int]) -> int:
    n = len(nextVisit)
    MOD = 10**9 + 7
    dp = [0] * n
    
    for i in range(1, n):
        dp[i] = (dp[i - 1] + 1 + dp[i - 1] - dp[nextVisit[i - 1]] + MOD) % MOD
    
    return dp[-1]

Solution = create_solution(first_day_visited_all_rooms)