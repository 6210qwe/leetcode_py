# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1802
标题: Number of Students Unable to Eat Lunch
难度: easy
链接: https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/
题目类型: 栈、队列、数组、模拟
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1700. 无法吃午餐的学生数量 - 学校的自助午餐提供圆形和方形的三明治，分别用数字 0 和 1 表示。所有学生站在一个队列里，每个学生要么喜欢圆形的要么喜欢方形的。 餐厅里三明治的数量与学生的数量相同。所有三明治都放在一个 栈 里，每一轮： * 如果队列最前面的学生 喜欢 栈顶的三明治，那么会 拿走它 并离开队列。 * 否则，这名学生会 放弃这个三明治 并回到队列的尾部。 这个过程会一直持续到队列里所有学生都不喜欢栈顶的三明治为止。 给你两个整数数组 students 和 sandwiches ，其中 sandwiches[i] 是栈里面第 i 个三明治的类型（i = 0 是栈的顶部）， students[j] 是初始队列里第 j 名学生对三明治的喜好（j = 0 是队列的最开始位置）。请你返回无法吃午餐的学生数量。 示例 1： 输入：students = [1,1,0,0], sandwiches = [0,1,0,1] 输出：0 解释： - 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [1,0,0,1]。 - 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [0,0,1,1]。 - 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [0,1,1]，三明治栈为 sandwiches = [1,0,1]。 - 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [1,1,0]。 - 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [1,0]，三明治栈为 sandwiches = [0,1]。 - 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [0,1]。 - 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [1]，三明治栈为 sandwiches = [1]。 - 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = []，三明治栈为 sandwiches = []。 所以所有学生都有三明治吃。 示例 2： 输入：students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1] 输出：3 提示： * 1 <= students.length, sandwiches.length <= 100 * students.length == sandwiches.length * sandwiches[i] 要么是 0 ，要么是 1 。 * students[i] 要么是 0 ，要么是 1 。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 模拟队列，统计无法匹配的学生数量

算法步骤:
1. 统计学生和三明治的数量
2. 如果栈顶三明治没有学生喜欢，返回剩余学生数
3. 否则匹配并移除

关键点:
- 模拟队列
- 统计数量
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - n为学生数量
空间复杂度: O(1) - 只使用常数额外空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from collections import Counter
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def count_students(students: List[int], sandwiches: List[int]) -> int:
    """
    函数式接口 - 无法吃午餐的学生数量
    
    实现思路:
    模拟队列：统计无法匹配的学生数量。
    
    Args:
        students: 学生数组
        sandwiches: 三明治数组
        
    Returns:
        无法吃午餐的学生数量
        
    Example:
        >>> count_students([1,1,0,0], [0,1,0,1])
        0
    """
    count = Counter(students)
    
    for sandwich in sandwiches:
        if count[sandwich] > 0:
            count[sandwich] -= 1
        else:
            # 没有学生喜欢这个三明治
            break
    
    return sum(count.values())


Solution = create_solution(count_students)
