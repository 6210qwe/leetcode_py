# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 768
标题: Partition Labels
难度: medium
链接: https://leetcode.cn/problems/partition-labels/
题目类型: 贪心、哈希表、双指针、字符串
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
763. 划分字母区间 - 给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串 "ababcc" 能够被分为 ["abab", "cc"]，但类似 ["aba", "bcc"] 或 ["ab", "ab", "cc"] 的划分是非法的。 注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。 返回一个表示每个字符串片段的长度的列表。 示例 1： 输入：s = "ababcbacadefegdehijhklij" 输出：[9,7,8] 解释： 划分结果为 "ababcbaca"、"defegde"、"hijhklij" 。 每个字母最多出现在一个片段中。 像 "ababcbacadefegde", "hijhklij" 这样的划分是错误的，因为划分的片段数较少。 示例 2： 输入：s = "eccbbbbdec" 输出：[10] 提示： * 1 <= s.length <= 500 * s 仅由小写英文字母组成
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用贪心算法，通过记录每个字符最后出现的位置来确定分割点。

算法步骤:
1. 遍历字符串，记录每个字符最后出现的位置。
2. 再次遍历字符串，使用两个变量 `start` 和 `end` 来确定当前片段的起始和结束位置。
3. 当遍历到 `end` 位置时，将当前片段的长度加入结果列表，并更新 `start` 为 `end + 1`。

关键点:
- 通过记录每个字符最后出现的位置，可以确保每个字符只出现在一个片段中。
- 使用贪心算法，每次找到当前片段的最远边界，从而保证片段数量最多。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是字符串的长度。我们需要两次遍历字符串。
空间复杂度: O(1)，额外空间主要用于存储结果列表和字符最后出现的位置。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def partition_labels(s: str) -> List[int]:
    """
    函数式接口 - 将字符串 s 划分为尽可能多的片段，同一字母最多出现在一个片段中。
    """
    # 记录每个字符最后出现的位置
    last_occurrence = {char: idx for idx, char in enumerate(s)}
    
    result = []
    start, end = 0, 0
    
    for i, char in enumerate(s):
        # 更新当前片段的结束位置
        end = max(end, last_occurrence[char])
        
        # 当遍历到当前片段的结束位置时，记录片段长度
        if i == end:
            result.append(end - start + 1)
            start = i + 1
    
    return result

Solution = create_solution(partition_labels)