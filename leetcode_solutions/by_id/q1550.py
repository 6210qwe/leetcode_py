# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1550
标题: Find the Kth Smallest Sum of a Matrix With Sorted Rows
难度: hard
链接: https://leetcode.cn/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/
题目类型: 数组、二分查找、矩阵、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1439. 有序矩阵中的第 k 个最小数组和 - 给你一个 m * n 的矩阵 mat，以及一个整数 k ，矩阵中的每一行都以非递减的顺序排列。 你可以从每一行中选出 1 个元素形成一个数组。返回所有可能数组中的第 k 个 最小 数组和。 示例 1： 输入：mat = [[1,3,11],[2,4,6]], k = 5 输出：7 解释：从每一行中选出一个元素，前 k 个和最小的数组分别是： [1,2], [1,4], [3,2], [3,4], [1,6]。其中第 5 个的和是 7 。 示例 2： 输入：mat = [[1,3,11],[2,4,6]], k = 9 输出：17 示例 3： 输入：mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7 输出：9 解释：从每一行中选出一个元素，前 k 个和最小的数组分别是： [1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]。其中第 7 个的和是 9 。 示例 4： 输入：mat = [[1,1,10],[2,2,9]], k = 7 输出：12 提示： * m == mat.length * n == mat.length[i] * 1 <= m, n <= 40 * 1 <= k <= min(200, n ^ m) * 1 <= mat[i][j] <= 5000 * mat[i] 是一个非递减数组
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用优先队列（最小堆）来维护当前最小的 k 个和。

算法步骤:
1. 初始化一个最小堆，将第一行的所有元素加入堆中。
2. 对于每一行，从堆中取出当前最小的 k 个和，然后与当前行的每个元素相加，再将新的和加入堆中。
3. 最后，堆顶元素即为第 k 小的和。

关键点:
- 使用最小堆来高效地维护当前最小的 k 个和。
- 每次只处理当前行的元素，避免不必要的计算。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m * n * log k)，其中 m 是矩阵的行数，n 是矩阵的列数。
空间复杂度: O(k)，用于存储最小堆。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def kth_smallest(mat: List[List[int]], k: int) -> int:
    """
    返回有序矩阵中的第 k 个最小数组和。
    """
    m, n = len(mat), len(mat[0])
    heap = [(sum(row[0] for row in mat), [0] * m)]
    
    visited = set(heap[0][1])
    
    while k > 0:
        current_sum, indices = heapq.heappop(heap)
        k -= 1
        if k == 0:
            return current_sum
        
        for i in range(m):
            if indices[i] + 1 < n:
                new_indices = list(indices)
                new_indices[i] += 1
                new_tuple = (current_sum - mat[i][indices[i]] + mat[i][new_indices[i]], new_indices)
                
                if tuple(new_indices) not in visited:
                    visited.add(tuple(new_indices))
                    heapq.heappush(heap, new_tuple)

Solution = create_solution(kth_smallest)