# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 938
标题: Numbers At Most N Given Digit Set
难度: hard
链接: https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/
题目类型: 数组、数学、字符串、二分查找、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
902. 最大为 N 的数字组合 - 给定一个按 非递减顺序 排列的数字数组 digits 。你可以用任意次数 digits[i] 来写的数字。例如，如果 digits = ['1','3','5']，我们可以写数字，如 '13', '551', 和 '1351315'。 返回 可以生成的小于或等于给定整数 n 的正整数的个数 。 示例 1： 输入：digits = ["1","3","5","7"], n = 100 输出：20 解释： 可写出的 20 个数字是： 1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77. 示例 2： 输入：digits = ["1","4","9"], n = 1000000000 输出：29523 解释： 我们可以写 3 个一位数字，9 个两位数字，27 个三位数字， 81 个四位数字，243 个五位数字，729 个六位数字， 2187 个七位数字，6561 个八位数字和 19683 个九位数字。 总共，可以使用D中的数字写出 29523 个整数。 示例 3: 输入：digits = ["7"], n = 8 输出：1 提示： * 1 <= digits.length <= 9 * digits[i].length == 1 * digits[i] 是从 '1' 到 '9' 的数 * digits 中的所有值都 不同 * digits 按 非递减顺序 排列 * 1 <= n <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划和计数方法来计算可以生成的小于或等于给定整数 n 的正整数的个数。

算法步骤:
1. 将 n 转换为字符串形式，方便逐位处理。
2. 初始化结果变量 res 为 0。
3. 计算所有长度小于 n 的数字的数量。
4. 逐位处理 n 的每一位，计算可以生成的数字数量。
5. 如果当前位在 digits 中存在，则继续处理下一位；否则停止。

关键点:
- 通过逐位处理 n 的每一位，可以避免生成所有可能的数字，从而提高效率。
- 使用动态规划的思想，逐位累加可以生成的数字数量。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(d * log(n))，其中 d 是 digits 的长度，log(n) 是 n 的位数。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def atMostNGivenDigitSet(digits: List[str], n: int) -> int:
    n_str = str(n)
    k = len(n_str)
    d = len(digits)
    
    # 计算所有长度小于 n 的数字的数量
    res = sum(d ** i for i in range(1, k))
    
    # 逐位处理 n 的每一位
    for i in range(k):
        prefix_match = False
        for digit in digits:
            if digit < n_str[i]:
                res += d ** (k - i - 1)
            elif digit == n_str[i]:
                prefix_match = True
                break
            else:
                break
        if not prefix_match:
            return res
    
    return res + 1

Solution = create_solution(atMostNGivenDigitSet)