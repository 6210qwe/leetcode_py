# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 445
标题: Add Two Numbers II
难度: medium
链接: https://leetcode.cn/problems/add-two-numbers-ii/
题目类型: 栈、链表、数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
445. 两数相加 II - 给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。 你可以假设除了数字 0 之外，这两个数字都不会以零开头。 示例1： [https://pic.leetcode.cn/1626420025-fZfzMX-image.png] 输入：l1 = [7,2,4,3], l2 = [5,6,4] 输出：[7,8,0,7] 示例2： 输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[8,0,7] 示例3： 输入：l1 = [0], l2 = [0] 输出：[0] 提示： * 链表的长度范围为 [1, 100] * 0 <= node.val <= 9 * 输入数据保证链表代表的数字无前导 0 进阶：如果输入链表不能翻转该如何解决？
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用栈来存储链表中的数字，然后从栈顶依次弹出进行相加。

算法步骤:
1. 将两个链表的值分别压入两个栈中。
2. 从栈顶依次弹出元素进行相加，并处理进位。
3. 构建新的链表并返回。

关键点:
- 使用栈来存储链表中的数字，从而实现从低位到高位的相加。
- 处理进位时要注意边界条件。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n + m) - 其中 n 和 m 分别是两个链表的长度。
空间复杂度: O(n + m) - 使用了两个栈来存储链表中的数字。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.solution import create_solution


def add_two_numbers_ii(l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
    """
    函数式接口 - 将两个链表表示的数字相加，并返回新的链表。

    实现思路:
    使用栈来存储链表中的数字，从栈顶依次弹出进行相加，并处理进位。

    Args:
        l1: 第一个链表的头节点
        l2: 第二个链表的头节点

    Returns:
        新链表的头节点

    Example:
        >>> l1 = ListNode.from_list([7, 2, 4, 3])
        >>> l2 = ListNode.from_list([5, 6, 4])
        >>> result = add_two_numbers_ii(l1, l2)
        >>> print(result.to_list())
        [7, 8, 0, 7]
    """
    stack1, stack2 = [], []
    
    # 将链表中的数字压入栈中
    while l1:
        stack1.append(l1.val)
        l1 = l1.next
    while l2:
        stack2.append(l2.val)
        l2 = l2.next
    
    carry = 0
    head = None
    
    # 从栈顶依次弹出元素进行相加
    while stack1 or stack2 or carry:
        val1 = stack1.pop() if stack1 else 0
        val2 = stack2.pop() if stack2 else 0
        total = val1 + val2 + carry
        carry = total // 10
        new_node = ListNode(total % 10)
        new_node.next = head
        head = new_node
    
    return head


# 自动生成Solution类（无需手动编写）
Solution = create_solution(add_two_numbers_ii)