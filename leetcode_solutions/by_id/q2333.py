# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2333
标题: Count Number of Rectangles Containing Each Point
难度: medium
链接: https://leetcode.cn/problems/count-number-of-rectangles-containing-each-point/
题目类型: 树状数组、数组、哈希表、二分查找、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2250. 统计包含每个点的矩形数目 - 给你一个二维整数数组 rectangles ，其中 rectangles[i] = [li, hi] 表示第 i 个矩形长为 li 高为 hi 。给你一个二维整数数组 points ，其中 points[j] = [xj, yj] 是坐标为 (xj, yj) 的一个点。 第 i 个矩形的 左下角 在 (0, 0) 处，右上角 在 (li, hi) 。 请你返回一个整数数组 count ，长度为 points.length，其中 count[j]是 包含 第 j 个点的矩形数目。 如果 0 <= xj <= li 且 0 <= yj <= hi ，那么我们说第 i 个矩形包含第 j 个点。如果一个点刚好在矩形的 边上 ，这个点也被视为被矩形包含。 示例 1： [https://assets.leetcode.com/uploads/2022/03/02/example1.png] 输入：rectangles = [[1,2],[2,3],[2,5]], points = [[2,1],[1,4]] 输出：[2,1] 解释： 第一个矩形不包含任何点。 第二个矩形只包含一个点 (2, 1) 。 第三个矩形包含点 (2, 1) 和 (1, 4) 。 包含点 (2, 1) 的矩形数目为 2 。 包含点 (1, 4) 的矩形数目为 1 。 所以，我们返回 [2, 1] 。 示例 2： [https://assets.leetcode.com/uploads/2022/03/02/example2.png] 输入：rectangles = [[1,1],[2,2],[3,3]], points = [[1,3],[1,1]] 输出：[1,3] 解释： 第一个矩形只包含点 (1, 1) 。 第二个矩形只包含点 (1, 1) 。 第三个矩形包含点 (1, 3) 和 (1, 1) 。 包含点 (1, 3) 的矩形数目为 1 。 包含点 (1, 1) 的矩形数目为 3 。 所以，我们返回 [1, 3] 。 提示： * 1 <= rectangles.length, points.length <= 5 * 104 * rectangles[i].length == points[j].length == 2 * 1 <= li, xj <= 109 * 1 <= hi, yj <= 100 * 所有 rectangles 互不相同 。 * 所有 points 互不相同 。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用哈希表存储每个高度的矩形数量，然后对每个点进行二分查找。

算法步骤:
1. 初始化一个哈希表 `heights`，键为高度，值为该高度下的所有宽度列表。
2. 对于每个矩形，将其宽度添加到对应高度的列表中。
3. 对每个高度的宽度列表进行排序。
4. 对于每个点，使用二分查找找到包含该点的矩形数量。

关键点:
- 使用哈希表存储高度和对应的宽度列表，便于快速查找。
- 对宽度列表进行排序，以便使用二分查找。
- 二分查找用于快速统计包含点的矩形数量。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n + m log n)，其中 n 是矩形的数量，m 是点的数量。排序操作的时间复杂度为 O(n log n)，每个点的二分查找操作为 O(log n)。
空间复杂度: O(n)，用于存储哈希表中的宽度列表。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from bisect import bisect_left

def count_rectangles(rectangles: List[List[int]], points: List[List[int]]) -> List[int]:
    # 哈希表存储每个高度的矩形宽度列表
    heights = {}
    for l, h in rectangles:
        if h not in heights:
            heights[h] = []
        heights[h].append(l)
    
    # 对每个高度的宽度列表进行排序
    for h in heights:
        heights[h].sort()
    
    result = []
    for x, y in points:
        count = 0
        # 对于每个大于等于 y 的高度，使用二分查找统计包含点的矩形数量
        for h in range(y, 101):
            if h in heights:
                count += len(heights[h]) - bisect_left(heights[h], x)
        result.append(count)
    
    return result

Solution = create_solution(count_rectangles)