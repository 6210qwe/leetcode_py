# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2301
标题: Count Array Pairs Divisible by K
难度: hard
链接: https://leetcode.cn/problems/count-array-pairs-divisible-by-k/
题目类型: 数组、数学、数论
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2183. 统计可以被 K 整除的下标对数目 - 给你一个下标从 0 开始、长度为 n 的整数数组 nums 和一个整数 k ，返回满足下述条件的下标对 (i, j) 的数目： * 0 <= i < j <= n - 1 且 * nums[i] * nums[j] 能被 k 整除。 示例 1： 输入：nums = [1,2,3,4,5], k = 2 输出：7 解释： 共有 7 对下标的对应积可以被 2 整除： (0, 1)、(0, 3)、(1, 2)、(1, 3)、(1, 4)、(2, 3) 和 (3, 4) 它们的积分别是 2、4、6、8、10、12 和 20 。 其他下标对，例如 (0, 2) 和 (2, 4) 的乘积分别是 3 和 15 ，都无法被 2 整除。 示例 2： 输入：nums = [1,2,3,4], k = 5 输出：0 解释：不存在对应积可以被 5 整除的下标对。 提示： * 1 <= nums.length <= 105 * 1 <= nums[i], k <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用最大公约数 (GCD) 和因数分解来优化计算。

算法步骤:
1. 计算每个数与 k 的最大公约数，并统计每个 GCD 的出现次数。
2. 遍历所有可能的 GCD 组合，检查它们的乘积是否能被 k 整除。
3. 根据组合数公式计算满足条件的下标对数目。

关键点:
- 利用 GCD 来减少不必要的计算。
- 通过因数分解和组合数公式来高效计算满足条件的下标对数目。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * sqrt(k))
空间复杂度: O(k)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import math
from collections import Counter

def count_pairs_divisible_by_k(nums: List[int], k: int) -> int:
    """
    计算可以被 k 整除的下标对数目
    """
    gcd_count = Counter(math.gcd(num, k) for num in nums)
    result = 0
    
    for gcd_i, count_i in gcd_count.items():
        for gcd_j, count_j in gcd_count.items():
            if gcd_i * gcd_j % k == 0:
                if gcd_i == gcd_j:
                    result += count_i * (count_i - 1) // 2
                elif gcd_i < gcd_j:
                    result += count_i * count_j
    
    return result

Solution = create_solution(count_pairs_divisible_by_k)