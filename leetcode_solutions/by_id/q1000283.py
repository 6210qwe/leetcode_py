# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000283
标题: 柱状图中最大的矩形
难度: hard
链接: https://leetcode.cn/problems/0ynMMM/
题目类型: 栈、数组、单调栈
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCR 039. 柱状图中最大的矩形 - 给定非负整数数组 heights ，数组中的数字用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 示例 1: [https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg] 输入：heights = [2,1,5,6,2,3] 输出：10 解释：最大的矩形为图中红色区域，面积为 10 示例 2： [https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg] 输入： heights = [2,4] 输出： 4 提示： * 1 <= heights.length <=105 * 0 <= heights[i] <= 104 注意：本题与主站 84 题相同： https://leetcode.cn/problems/largest-rectangle-in-histogram/ [https://leetcode.cn/problems/largest-rectangle-in-histogram/]
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用单调栈来找到每个柱子左右边界，从而计算出以该柱子为高度的最大矩形面积。

算法步骤:
1. 初始化一个栈，用于存储柱子的索引。
2. 在数组的两端添加高度为0的柱子，方便处理边界情况。
3. 遍历数组，对于每个柱子：
   - 如果当前柱子高度小于栈顶柱子高度，则弹出栈顶柱子，并计算以该柱子为高度的最大矩形面积。
   - 将当前柱子的索引入栈。
4. 返回最大矩形面积。

关键点:
- 使用单调递增栈来维护柱子的高度。
- 通过栈顶元素和当前元素的比较，找到每个柱子的左右边界。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是 heights 的长度。每个元素最多被压入和弹出栈一次。
空间复杂度: O(n)，栈的空间复杂度为 O(n)。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List


def largest_rectangle_area(heights: List[int]) -> int:
    """
    函数式接口 - 计算柱状图中最大的矩形面积
    """
    # 在数组的两端添加高度为0的柱子
    heights = [0] + heights + [0]
    stack = []
    max_area = 0

    for i in range(len(heights)):
        while stack and heights[stack[-1]] > heights[i]:
            h = heights[stack.pop()]
            w = i - stack[-1] - 1
            max_area = max(max_area, h * w)
        stack.append(i)

    return max_area


Solution = create_solution(largest_rectangle_area)