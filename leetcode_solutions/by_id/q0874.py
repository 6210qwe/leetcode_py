# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 874
标题: Backspace String Compare
难度: easy
链接: https://leetcode.cn/problems/backspace-string-compare/
题目类型: 栈、双指针、字符串、模拟
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
844. 比较含退格的字符串 - 给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。 注意：如果对空文本输入退格字符，文本继续为空。 示例 1： 输入：s = "ab#c", t = "ad#c" 输出：true 解释：s 和 t 都会变成 "ac"。 示例 2： 输入：s = "ab##", t = "c#d#" 输出：true 解释：s 和 t 都会变成 ""。 示例 3： 输入：s = "a#c", t = "b" 输出：false 解释：s 会变成 "c"，但 t 仍然是 "b"。 提示： * 1 <= s.length, t.length <= 200 * s 和 t 只含有小写字母以及字符 '#' 进阶： * 你可以用 O(n) 的时间复杂度和 O(1) 的空间复杂度解决该问题吗？
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用双指针从后向前遍历字符串，处理退格字符。

算法步骤:
1. 初始化两个指针 i 和 j，分别指向 s 和 t 的末尾。
2. 从后向前遍历字符串，处理退格字符：
   - 如果当前字符是 '#'，则跳过并增加退格计数。
   - 如果当前字符不是 '#' 且退格计数大于 0，则跳过当前字符并减少退格计数。
   - 否则，比较当前字符。
3. 如果所有字符都匹配，则返回 True，否则返回 False。

关键点:
- 从后向前遍历可以避免多次遍历字符串。
- 使用退格计数来处理连续的退格字符。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n + m)，其中 n 和 m 分别是字符串 s 和 t 的长度。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def backspace_compare(s: str, t: str) -> bool:
    """
    函数式接口 - 比较含退格的字符串
    """
    def process_backspaces(text: str, index: int) -> int:
        skip = 0
        while index >= 0:
            if text[index] == '#':
                skip += 1
            elif skip > 0:
                skip -= 1
            else:
                break
            index -= 1
        return index

    i, j = len(s) - 1, len(t) - 1
    while i >= 0 or j >= 0:
        i = process_backspaces(s, i)
        j = process_backspaces(t, j)

        if i >= 0 and j >= 0 and s[i] != t[j]:
            return False

        if (i >= 0) != (j >= 0):
            return False

        i -= 1
        j -= 1

    return True


Solution = create_solution(backspace_compare)