# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1127
标题: Last Stone Weight
难度: easy
链接: https://leetcode.cn/problems/last-stone-weight/
题目类型: 数组、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1046. 最后一块石头的重量 - 有一堆石头，每块石头的重量都是正整数。 每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下： * 如果 x == y，那么两块石头都会被完全粉碎； * 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。 示例： 输入：[2,7,4,1,8,1] 输出：1 解释： 先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]， 再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]， 接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]， 最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。 提示： * 1 <= stones.length <= 30 * 1 <= stones[i] <= 1000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用最大堆来高效地获取和移除最重的石头。

算法步骤:
1. 将所有石头的重量放入一个最大堆中。
2. 每次从堆中取出两个最重的石头，计算它们粉碎后的剩余重量。
3. 如果有剩余重量，将其重新放入堆中。
4. 重复上述过程，直到堆中剩下的石头数量少于2个。
5. 返回堆中剩下的石头重量（如果有的话），否则返回0。

关键点:
- 使用 `heapq` 模块实现最大堆，通过取负数的方式将最小堆转换为最大堆。
- 每次操作堆的时间复杂度为 O(log n)。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是石头的数量。每次插入和删除操作的时间复杂度为 O(log n)，总共进行 n 次操作。
空间复杂度: O(n)，因为需要存储所有的石头重量。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq


def last_stone_weight(stones: List[int]) -> int:
    """
    函数式接口 - 计算最后一块石头的重量
    """
    # 将所有石头的重量转换为负数，以便使用最小堆模拟最大堆
    stones = [-stone for stone in stones]
    heapq.heapify(stones)

    while len(stones) > 1:
        # 取出两个最重的石头
        first = -heapq.heappop(stones)
        second = -heapq.heappop(stones)

        # 计算粉碎后的剩余重量
        if first != second:
            remaining = first - second
            heapq.heappush(stones, -remaining)

    # 如果堆中还有石头，返回其重量，否则返回0
    return -stones[0] if stones else 0


Solution = create_solution(last_stone_weight)