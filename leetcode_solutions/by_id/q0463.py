# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 463
标题: Island Perimeter
难度: easy
链接: https://leetcode.cn/problems/island-perimeter/
题目类型: 深度优先搜索、广度优先搜索、数组、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
463. 岛屿的周长 - 给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] = 1 表示陆地， grid[i][j] = 0 表示水域。 网格中的格子 水平和垂直 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。 岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。 示例 1： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2018/10/12/island.png] 输入：grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]] 输出：16 解释：它的周长是上面图片中的 16 个黄色的边 示例 2： 输入：grid = [[1]] 输出：4 示例 3： 输入：grid = [[1,0]] 输出：4 提示： * row == grid.length * col == grid[i].length * 1 <= row, col <= 100 * grid[i][j] 为 0 或 1
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 遍历每个陆地格子，计算其贡献的周长

算法步骤:
1. 遍历网格，找到所有陆地格子
2. 对每个陆地格子，检查四个方向
3. 如果相邻是水域或边界，贡献1个单位的周长

关键点:
- 每个陆地格子最多贡献4个单位周长
- 相邻的陆地格子会减少周长
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m*n) - 遍历网格
空间复杂度: O(1) - 只使用常数额外空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def island_perimeter(grid: List[List[int]]) -> int:
    """
    函数式接口 - 岛屿的周长
    
    实现思路:
    遍历每个陆地格子，检查四个方向，计算贡献的周长。
    
    Args:
        grid: 二维网格
        
    Returns:
        岛屿的周长
        
    Example:
        >>> island_perimeter([[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]])
        16
    """
    m, n = len(grid), len(grid[0])
    perimeter = 0
    
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    for i in range(m):
        for j in range(n):
            if grid[i][j] == 1:
                for di, dj in directions:
                    ni, nj = i + di, j + dj
                    # 如果是边界或水域，贡献1个单位的周长
                    if ni < 0 or ni >= m or nj < 0 or nj >= n or grid[ni][nj] == 0:
                        perimeter += 1
    
    return perimeter


# 自动生成Solution类（无需手动编写）
Solution = create_solution(island_perimeter)
