# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 205
标题: Isomorphic Strings
难度: easy
链接: https://leetcode.cn/problems/isomorphic-strings/
题目类型: 哈希表、字符串
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
205. 同构字符串 - 给定两个字符串 s 和 t ，判断它们是否是同构的。 如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。 每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。 示例 1： 输入：s = "egg", t = "add" 输出：true 解释： 字符串 s 和 t 可以通过以下方式变得相同： * 将 'e' 映射为 'a'。 * 将 'g' 映射为 'd'。 示例 2： 输入：s = "f11", t = "b23" 输出：false 解释： 字符串 s 和 t 无法变得相同，因为 '1' 需要同时映射到 '2' 和 '3'。 示例 3： 输入：s = "paper", t = "title" 输出：true 提示： * 1 <= s.length <= 5 * 104 * t.length == s.length * s 和 t 由任意有效的 ASCII 字符组成
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用两个哈希表建立双向映射，确保一一对应

算法步骤:
1. 使用两个哈希表分别记录s到t和t到s的映射
2. 遍历字符串，检查映射是否一致
3. 如果映射不一致，返回False

关键点:
- 使用双向映射确保一一对应
- 时间复杂度O(n)，空间复杂度O(n)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 需要遍历字符串一次
空间复杂度: O(n) - 哈希表存储映射
"""

# ============================================================================
# 代码实现
# ============================================================================

from leetcode_solutions.utils.solution import create_solution


def isomorphic_strings(s: str, t: str) -> bool:
    """
    函数式接口 - 同构字符串
    
    实现思路:
    使用两个哈希表建立双向映射，确保一一对应。
    
    Args:
        s: 第一个字符串
        t: 第二个字符串
        
    Returns:
        如果两个字符串同构返回True，否则返回False
        
    Example:
        >>> isomorphic_strings("egg", "add")
        True
    """
    if len(s) != len(t):
        return False
    
    s_to_t = {}
    t_to_s = {}
    
    for i in range(len(s)):
        if s[i] in s_to_t:
            if s_to_t[s[i]] != t[i]:
                return False
        else:
            s_to_t[s[i]] = t[i]
        
        if t[i] in t_to_s:
            if t_to_s[t[i]] != s[i]:
                return False
        else:
            t_to_s[t[i]] = s[i]
    
    return True


# 自动生成Solution类（无需手动编写）
Solution = create_solution(isomorphic_strings)
