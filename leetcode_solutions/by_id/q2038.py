# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2038
标题: Nearest Exit from Entrance in Maze
难度: medium
链接: https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/
题目类型: 广度优先搜索、数组、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1926. 迷宫中离入口最近的出口 - 给你一个 m x n 的迷宫矩阵 maze （下标从 0 开始），矩阵中有空格子（用 '.' 表示）和墙（用 '+' 表示）。同时给你迷宫的入口 entrance ，用 entrance = [entrancerow, entrancecol] 表示你一开始所在格子的行和列。 每一步操作，你可以往 上，下，左 或者 右 移动一个格子。你不能进入墙所在的格子，你也不能离开迷宫。你的目标是找到离 entrance 最近 的出口。出口 的含义是 maze 边界 上的 空格子。entrance 格子 不算 出口。 请你返回从 entrance 到最近出口的最短路径的 步数 ，如果不存在这样的路径，请你返回 -1 。 示例 1： [https://assets.leetcode.com/uploads/2021/06/04/nearest1-grid.jpg] 输入：maze = [["+","+",".","+"],[".",".",".","+"],["+","+","+","."]], entrance = [1,2] 输出：1 解释：总共有 3 个出口，分别位于 (1,0)，(0,2) 和 (2,3) 。 一开始，你在入口格子 (1,2) 处。 - 你可以往左移动 2 步到达 (1,0) 。 - 你可以往上移动 1 步到达 (0,2) 。 从入口处没法到达 (2,3) 。 所以，最近的出口是 (0,2) ，距离为 1 步。 示例 2： [https://assets.leetcode.com/uploads/2021/06/04/nearesr2-grid.jpg] 输入：maze = [["+","+","+"],[".",".","."],["+","+","+"]], entrance = [1,0] 输出：2 解释：迷宫中只有 1 个出口，在 (1,2) 处。 (1,0) 不算出口，因为它是入口格子。 初始时，你在入口与格子 (1,0) 处。 - 你可以往右移动 2 步到达 (1,2) 处。 所以，最近的出口为 (1,2) ，距离为 2 步。 示例 3： [https://assets.leetcode.com/uploads/2021/06/04/nearest3-grid.jpg] 输入：maze = [[".","+"]], entrance = [0,0] 输出：-1 解释：这个迷宫中没有出口。 提示： * maze.length == m * maze[i].length == n * 1 <= m, n <= 100 * maze[i][j] 要么是 '.' ，要么是 '+' 。 * entrance.length == 2 * 0 <= entrancerow < m * 0 <= entrancecol < n * entrance 一定是空格子。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用广度优先搜索（BFS）来找到从入口到最近出口的最短路径。

算法步骤:
1. 初始化队列并将入口位置加入队列。
2. 使用一个集合来记录已经访问过的格子，避免重复访问。
3. 从队列中取出一个格子，检查它是否是出口（在边界上且不是入口）。
4. 如果是出口，返回当前步数；否则，将该格子的四个相邻格子（上、下、左、右）加入队列，并标记为已访问。
5. 如果队列为空且没有找到出口，返回 -1。

关键点:
- 使用 BFS 保证找到的路径是最短路径。
- 使用集合记录已访问的格子，避免重复访问。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m * n)，其中 m 和 n 分别是迷宫的行数和列数。每个格子最多访问一次。
空间复杂度: O(m * n)，队列和已访问集合的最大空间开销。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from collections import deque

def nearest_exit(maze: List[List[str]], entrance: List[int]) -> int:
    rows, cols = len(maze), len(maze[0])
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    queue = deque([(entrance[0], entrance[1], 0)])
    visited = set([(entrance[0], entrance[1])])

    while queue:
        r, c, steps = queue.popleft()
        if (r == 0 or r == rows - 1 or c == 0 or c == cols - 1) and (r, c) != (entrance[0], entrance[1]):
            return steps
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols and maze[nr][nc] == '.' and (nr, nc) not in visited:
                visited.add((nr, nc))
                queue.append((nr, nc, steps + 1))

    return -1

Solution = create_solution(nearest_exit)