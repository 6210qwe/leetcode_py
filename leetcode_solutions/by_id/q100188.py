# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 100188
标题: Sum Lists LCCI
难度: medium
链接: https://leetcode.cn/problems/sum-lists-lcci/
题目类型: 递归、链表、数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
面试题 02.05. 链表求和 - 给定两个用链表表示的整数，每个节点包含一个数位。 这些数位是反向存放的，也就是个位排在链表首部。 编写函数对这两个整数求和，并用链表形式返回结果。 示例： 输入：(7 -> 1 -> 6) + (5 -> 9 -> 2)，即617 + 295 输出：2 -> 1 -> 9，即912 进阶：思考一下，假设这些数位是正向存放的，又该如何解决呢? 示例： 输入：(6 -> 1 -> 7) + (2 -> 9 -> 5)，即617 + 295 输出：9 -> 1 -> 2，即912
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用双指针遍历两个链表，逐位相加并处理进位。

算法步骤:
1. 初始化两个指针分别指向两个链表的头节点。
2. 初始化一个虚拟头节点和一个当前节点指针，用于构建结果链表。
3. 初始化进位变量为0。
4. 遍历两个链表，直到两个链表都为空：
   - 计算当前位的和（包括进位）。
   - 更新进位。
   - 创建新节点并添加到结果链表中。
5. 如果最后还有进位，创建一个新节点并添加到结果链表中。
6. 返回结果链表的头节点。

关键点:
- 使用虚拟头节点简化代码逻辑。
- 处理最后一个进位。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(max(m, n))，其中m和n分别是两个链表的长度。
空间复杂度: O(max(m, n))，结果链表的空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.solution import create_solution

def add_two_numbers(l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
    """
    函数式接口 - 实现链表求和
    """
    dummy_head = ListNode(0)
    current = dummy_head
    carry = 0

    while l1 or l2 or carry:
        val1 = l1.val if l1 else 0
        val2 = l2.val if l2 else 0
        total = val1 + val2 + carry
        carry = total // 10
        current.next = ListNode(total % 10)
        current = current.next

        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next

    return dummy_head.next

Solution = create_solution(add_two_numbers)