# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 649
标题: Dota2 Senate
难度: medium
链接: https://leetcode.cn/problems/dota2-senate/
题目类型: 贪心、队列、字符串
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
649. Dota2 参议院 - Dota2 的世界里有两个阵营：Radiant（天辉）和 Dire（夜魇） Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的 一 项： * 剥夺一名参议员的权利：一名参议员可以使另一名参议员在本轮及所有后续轮次中失去所有权利。 * 宣布胜利：如果参议员发现有权利投票的参议员都是 同一个阵营的 ，他可以宣布胜利并决定在游戏中的有关变化。 给你一个字符串 senate 代表每个参议员的阵营。字母 'R' 和 'D'分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。 以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。 假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 "Radiant" 或 "Dire" 。 示例 1： 输入：senate = "RD" 输出："Radiant" 解释： 第 1 轮时，第一个参议员来自 Radiant 阵营，他可以使用第一项权利让第二个参议员失去所有权利。 这一轮中，第二个参议员将会被跳过，因为他的权利被禁止了。 第 2 轮时，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人。 示例 2： 输入：senate = "RDD" 输出："Dire" 解释： 第 1 轮时，第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利。 这一轮中，第二个来自 Dire 阵营的参议员会将被跳过，因为他的权利被禁止了。 这一轮中，第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利。 因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利 提示： * n == senate.length * 1 <= n <= 104 * senate[i] 为 'R' 或 'D'
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用两个队列分别存储 Radiant 和 Dire 参议员的索引。每次从两个队列中取出索引较小的参议员，并将其重新加入队列，同时将索引较大的参议员移除。

算法步骤:
1. 初始化两个队列，分别存储 Radiant 和 Dire 参议员的索引。
2. 进入循环，直到其中一个队列为空：
   - 从两个队列中分别取出索引最小的参议员。
   - 如果 Radiant 参议员的索引小于 Dire 参议员的索引，则将 Radiant 参议员的索引加上 n 并重新加入队列，否则将 Dire 参议员的索引加上 n 并重新加入队列。
3. 返回非空队列对应的阵营。

关键点:
- 使用队列来存储参议员的索引，确保每次都能取出索引最小的参议员。
- 通过比较索引来决定哪个参议员可以继续投票。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def predict_party_victory(senate: str) -> str:
    """
    函数式接口 - 预测 Dota2 参议院的胜利方
    """
    n = len(senate)
    radiant_queue = []
    dire_queue = []

    # 初始化两个队列
    for i, s in enumerate(senate):
        if s == 'R':
            radiant_queue.append(i)
        else:
            dire_queue.append(i)

    # 模拟投票过程
    while radiant_queue and dire_queue:
        r_index = radiant_queue.pop(0)
        d_index = dire_queue.pop(0)
        if r_index < d_index:
            radiant_queue.append(r_index + n)
        else:
            dire_queue.append(d_index + n)

    return "Radiant" if radiant_queue else "Dire"


Solution = create_solution(predict_party_victory)