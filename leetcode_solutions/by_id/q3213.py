# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3213
标题: Count Subarrays Where Max Element Appears at Least K Times
难度: medium
链接: https://leetcode.cn/problems/count-subarrays-where-max-element-appears-at-least-k-times/
题目类型: 数组、滑动窗口
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2962. 统计最大元素出现至少 K 次的子数组 - 给你一个整数数组 nums 和一个 正整数 k 。 请你统计有多少满足 「 nums 中的 最大 元素」至少出现 k 次的子数组，并返回满足这一条件的子数组的数目。 子数组是数组中的一个连续元素序列。 示例 1： 输入：nums = [1,3,2,3,3], k = 2 输出：6 解释：包含元素 3 至少 2 次的子数组为：[1,3,2,3]、[1,3,2,3,3]、[3,2,3]、[3,2,3,3]、[2,3,3] 和 [3,3] 。 示例 2： 输入：nums = [1,4,2,1], k = 3 输出：0 解释：没有子数组包含元素 4 至少 3 次。 提示： * 1 <= nums.length <= 105 * 1 <= nums[i] <= 106 * 1 <= k <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用滑动窗口来统计满足条件的子数组数量。

算法步骤:
1. 找到数组中的最大元素。
2. 使用滑动窗口来统计当前窗口内最大元素的出现次数。
3. 当窗口内的最大元素出现次数达到 k 时，计算以当前窗口右端点为结尾的子数组数量。
4. 移动窗口右端点，更新窗口内的最大元素出现次数。
5. 如果窗口内的最大元素出现次数超过 k，则移动窗口左端点，减少窗口内的最大元素出现次数。

关键点:
- 使用滑动窗口来高效统计满足条件的子数组数量。
- 通过维护窗口内的最大元素出现次数，确保时间复杂度为 O(n)。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(1)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def count_subarrays(nums: List[int], k: int) -> int:
    """
    函数式接口 - 统计最大元素出现至少 K 次的子数组数量
    """
    max_element = max(nums)
    count = 0
    left = 0
    max_count = 0
    result = 0

    for right in range(len(nums)):
        if nums[right] == max_element:
            max_count += 1

        while max_count >= k:
            if nums[left] == max_element:
                max_count -= 1
            left += 1

        # 计算以当前窗口右端点为结尾的子数组数量
        result += left

    return result

Solution = create_solution(count_subarrays)