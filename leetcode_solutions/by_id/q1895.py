# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1895
标题: Minimum Number of Operations to Move All Balls to Each Box
难度: medium
链接: https://leetcode.cn/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/
题目类型: 数组、字符串、前缀和
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1769. 移动所有球到每个盒子所需的最小操作数 - 有 n 个盒子。给你一个长度为 n 的二进制字符串 boxes ，其中 boxes[i] 的值为 '0' 表示第 i 个盒子是 空 的，而 boxes[i] 的值为 '1' 表示盒子里有 一个 小球。 在一步操作中，你可以将 一个 小球从某个盒子移动到一个与之相邻的盒子中。第 i 个盒子和第 j 个盒子相邻需满足 abs(i - j) == 1 。注意，操作执行后，某些盒子中可能会存在不止一个小球。 返回一个长度为 n 的数组 answer ，其中 answer[i] 是将所有小球移动到第 i 个盒子所需的 最小 操作数。 每个 answer[i] 都需要根据盒子的 初始状态 进行计算。 示例 1： 输入：boxes = "110" 输出：[1,1,3] 解释：每个盒子对应的最小操作数如下： 1) 第 1 个盒子：将一个小球从第 2 个盒子移动到第 1 个盒子，需要 1 步操作。 2) 第 2 个盒子：将一个小球从第 1 个盒子移动到第 2 个盒子，需要 1 步操作。 3) 第 3 个盒子：将一个小球从第 1 个盒子移动到第 3 个盒子，需要 2 步操作。将一个小球从第 2 个盒子移动到第 3 个盒子，需要 1 步操作。共计 3 步操作。 示例 2： 输入：boxes = "001011" 输出：[11,8,5,4,3,4] 提示： * n == boxes.length * 1 <= n <= 2000 * boxes[i] 为 '0' 或 '1'
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用前缀和来计算每个盒子的操作数。

算法步骤:
1. 计算初始状态下所有小球移动到第一个盒子的操作数。
2. 使用两个变量分别记录左侧和右侧的小球数量。
3. 从左到右遍历盒子，更新左侧和右侧的小球数量，并计算每个盒子的操作数。
4. 从右到左遍历盒子，更新左侧和右侧的小球数量，并计算每个盒子的操作数。

关键点:
- 使用前缀和的思想，避免重复计算。
- 通过两次遍历，分别从左到右和从右到左，计算每个盒子的操作数。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(1)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def min_operations(boxes: str) -> List[int]:
    """
    函数式接口 - 计算将所有小球移动到每个盒子所需的最小操作数
    """
    n = len(boxes)
    answer = [0] * n
    left_count, right_count = 0, 0
    left_ops, right_ops = 0, 0
    
    # 计算初始状态下所有小球移动到第一个盒子的操作数
    for i in range(n):
        if boxes[i] == '1':
            left_count += 1
            left_ops += i
    
    # 从左到右遍历盒子，更新左侧和右侧的小球数量，并计算每个盒子的操作数
    for i in range(n):
        answer[i] = left_ops
        if boxes[i] == '1':
            left_count -= 1
        left_ops -= left_count
        
        if boxes[n - 1 - i] == '1':
            right_count += 1
        right_ops += right_count
    
    # 从右到左遍历盒子，更新左侧和右侧的小球数量，并计算每个盒子的操作数
    for i in range(n - 2, -1, -1):
        answer[i] += right_ops
        if boxes[i + 1] == '1':
            right_count -= 1
        right_ops -= right_count
    
    return answer


Solution = create_solution(min_operations)