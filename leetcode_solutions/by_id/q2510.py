# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2510
标题: Maximum Deletions on a String
难度: hard
链接: https://leetcode.cn/problems/maximum-deletions-on-a-string/
题目类型: 字符串、动态规划、字符串匹配、哈希函数、滚动哈希
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2430. 对字母串可执行的最大删除数 - 给你一个仅由小写英文字母组成的字符串 s 。在一步操作中，你可以： * 删除 整个字符串 s ，或者 * 对于满足 1 <= i <= s.length / 2 的任意 i ，如果 s 中的 前 i 个字母和接下来的 i 个字母 相等 ，删除 前 i 个字母。 例如，如果 s = "ababc" ，那么在一步操作中，你可以删除 s 的前两个字母得到 "abc" ，因为 s 的前两个字母和接下来的两个字母都等于 "ab" 。 返回删除 s 所需的最大操作数。 示例 1： 输入：s = "abcabcdabc" 输出：2 解释： - 删除前 3 个字母（"abc"），因为它们和接下来 3 个字母相等。现在，s = "abcdabc"。 - 删除全部字母。 一共用了 2 步操作，所以返回 2 。可以证明 2 是所需的最大操作数。 注意，在第二步操作中无法再次删除 "abc" ，因为 "abc" 的下一次出现并不是位于接下来的 3 个字母。 示例 2： 输入：s = "aaabaab" 输出：4 解释： - 删除第一个字母（"a"），因为它和接下来的字母相等。现在，s = "aabaab"。 - 删除前 3 个字母（"aab"），因为它们和接下来 3 个字母相等。现在，s = "aab"。 - 删除第一个字母（"a"），因为它和接下来的字母相等。现在，s = "ab"。 - 删除全部字母。 一共用了 4 步操作，所以返回 4 。可以证明 4 是所需的最大操作数。 示例 3： 输入：s = "aaaaa" 输出：5 解释：在每一步操作中，都可以仅删除 s 的第一个字母。 提示： * 1 <= s.length <= 4000 * s 仅由小写英文字母组成
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划和滚动哈希来解决这个问题。通过预处理字符串的哈希值，可以在常数时间内比较子字符串是否相等。

算法步骤:
1. 计算字符串的滚动哈希值。
2. 使用动态规划数组 `dp`，其中 `dp[i]` 表示从第 `i` 个字符开始删除的最大操作数。
3. 从后向前遍历字符串，对于每个位置 `i`，尝试所有可能的 `j`，使得 `s[i:j] == s[j:2*j-i]`，更新 `dp[i]`。
4. 最终结果是 `dp[0] + 1`，因为最后一步总是删除整个剩余字符串。

关键点:
- 使用滚动哈希来快速比较子字符串是否相等。
- 动态规划数组 `dp` 用于存储从每个位置开始的最大删除操作数。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def max_deletions(s: str) -> int:
    n = len(s)
    base = 26
    mod = 10**9 + 7
    hash_values = [0] * (n + 1)
    power = [1] * (n + 1)

    # 计算滚动哈希值
    for i in range(1, n + 1):
        hash_values[i] = (hash_values[i - 1] * base + ord(s[i - 1]) - ord('a')) % mod
        power[i] = (power[i - 1] * base) % mod

    def get_hash(l: int, r: int) -> int:
        return (hash_values[r] - hash_values[l] * power[r - l] % mod + mod) % mod

    dp = [0] * n

    # 动态规划计算最大删除操作数
    for i in range(n - 1, -1, -1):
        dp[i] = 1  # 最坏情况下，每次只删除一个字符
        for j in range(i + 1, n + 1):
            if j - i > n - j:
                break
            if get_hash(i, j) == get_hash(j, 2 * j - i):
                dp[i] = max(dp[i], dp[j] + 1)

    return dp[0]


Solution = create_solution(max_deletions)