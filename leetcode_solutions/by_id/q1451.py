# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1451
标题: Minimum Number of Taps to Open to Water a Garden
难度: hard
链接: https://leetcode.cn/problems/minimum-number-of-taps-to-open-to-water-a-garden/
题目类型: 贪心、数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1326. 灌溉花园的最少水龙头数目 - 在 x 轴上有一个一维的花园。花园长度为 n，从点 0 开始，到点 n 结束。 花园里总共有 n + 1 个水龙头，分别位于 [0, 1, ..., n] 。 给你一个整数 n 和一个长度为 n + 1 的整数数组 ranges ，其中 ranges[i] （下标从 0 开始）表示：如果打开点 i 处的水龙头，可以灌溉的区域为 [i - ranges[i], i + ranges[i]] 。 请你返回可以灌溉整个花园的 最少水龙头数目 。如果花园始终存在无法灌溉到的地方，请你返回 -1 。 示例 1： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/01/19/1685_example_1.png] 输入：n = 5, ranges = [3,4,1,1,0,0] 输出：1 解释： 点 0 处的水龙头可以灌溉区间 [-3,3] 点 1 处的水龙头可以灌溉区间 [-3,5] 点 2 处的水龙头可以灌溉区间 [1,3] 点 3 处的水龙头可以灌溉区间 [2,4] 点 4 处的水龙头可以灌溉区间 [4,4] 点 5 处的水龙头可以灌溉区间 [5,5] 只需要打开点 1 处的水龙头即可灌溉整个花园 [0,5] 。 示例 2： 输入：n = 3, ranges = [0,0,0,0] 输出：-1 解释：即使打开所有水龙头，你也无法灌溉整个花园。 提示： * 1 <= n <= 104 * ranges.length == n + 1 * 0 <= ranges[i] <= 100
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用贪心算法来找到最少的水龙头数量。

算法步骤:
1. 将每个水龙头的灌溉范围转换为区间 [left, right]。
2. 对这些区间进行排序，按左端点从小到大排序，如果左端点相同，则按右端点从大到小排序。
3. 使用一个变量 `max_right` 来记录当前可以灌溉到的最远位置。
4. 使用一个变量 `end` 来记录当前已经覆盖的最远位置。
5. 遍历排序后的区间，更新 `max_right` 和 `end`，并记录使用的水龙头数量。
6. 如果 `max_right` 达到了或超过了花园的右边界 `n`，则返回使用的水龙头数量。
7. 如果遍历完所有区间后仍未覆盖整个花园，则返回 -1。

关键点:
- 通过排序和贪心策略，确保每次选择的水龙头都能最大化扩展当前的覆盖范围。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def min_taps_to_water_garden(n: int, ranges: List[int]) -> int:
    """
    返回可以灌溉整个花园的最少水龙头数目。如果花园始终存在无法灌溉到的地方，请返回 -1。
    """
    # 将每个水龙头的灌溉范围转换为区间 [left, right]
    intervals = []
    for i, r in enumerate(ranges):
        if r > 0:
            left = max(0, i - r)
            right = min(n, i + r)
            intervals.append((left, right))
    
    # 按左端点从小到大排序，如果左端点相同，则按右端点从大到小排序
    intervals.sort(key=lambda x: (x[0], -x[1]))
    
    # 初始化变量
    max_right = 0
    end = 0
    count = 0
    
    for interval in intervals:
        if interval[0] > end:
            return -1
        if interval[0] > max_right:
            max_right = end
            count += 1
        end = max(end, interval[1])
        if end >= n:
            return count + 1
    
    return -1

Solution = create_solution(min_taps_to_water_garden)