# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1319
标题: Unique Number of Occurrences
难度: easy
链接: https://leetcode.cn/problems/unique-number-of-occurrences/
题目类型: 数组、哈希表
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1207. 独一无二的出现次数 - 给你一个整数数组 arr，如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。 示例 1： 输入：arr = [1,2,2,1,1,3] 输出：true 解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。 示例 2： 输入：arr = [1,2] 输出：false 示例 3： 输入：arr = [-3,0,1,-3,1,1,1,-3,10,0] 输出：true 提示： * 1 <= arr.length <= 1000 * -1000 <= arr[i] <= 1000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用哈希表统计每个数的出现次数，然后检查这些次数是否唯一。

算法步骤:
1. 使用一个哈希表 `count_map` 统计每个数的出现次数。
2. 使用另一个哈希表 `freq_map` 统计每个出现次数的频率。
3. 如果 `freq_map` 中有任何频率大于 1 的值，则返回 False；否则返回 True。

关键点:
- 使用两个哈希表分别统计出现次数和频率。
- 检查频率是否唯一。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def unique_occurrences(arr: List[int]) -> bool:
    """
    函数式接口 - 检查数组中每个数的出现次数是否唯一
    """
    # 统计每个数的出现次数
    count_map = {}
    for num in arr:
        if num in count_map:
            count_map[num] += 1
        else:
            count_map[num] = 1
    
    # 统计每个出现次数的频率
    freq_map = {}
    for count in count_map.values():
        if count in freq_map:
            return False
        else:
            freq_map[count] = 1
    
    return True


Solution = create_solution(unique_occurrences)