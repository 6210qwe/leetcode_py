# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 422
标题: Valid Word Square
难度: easy
链接: https://leetcode.cn/problems/valid-word-square/
题目类型: 数组、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
422. 有效的单词方块 - 备战技术面试？力扣提供海量技术面试资源，帮助你高效提升编程技能,轻松拿下世界 IT 名企 Dream Offer。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 检查每一行和对应的列是否相等

算法步骤:
1. 遍历每一行
2. 对于每一行，检查其长度是否与当前行号一致
3. 检查当前行的每个字符是否与对应列的字符相等

关键点:
- 注意边界条件，确保不会越界
- 优化时间和空间复杂度
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2) - n 是单词方块的边长，需要遍历所有字符
空间复杂度: O(1) - 只使用了常数级的额外空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def valid_word_square(words: List[str]) -> bool:
    """
    函数式接口 - 检查给定的字符串列表是否构成一个有效的单词方块
    
    实现思路:
    检查每一行和对应的列是否相等
    
    Args:
        words: 字符串列表
        
    Returns:
        如果是有效的单词方块返回 True，否则返回 False
        
    Example:
        >>> valid_word_square(["abcd", "bnrt", "crmy", "dtye"])
        True
        >>> valid_word_square(["abcd", "bnrt", "crm", "dt"])
        False
    """
    n = len(words)
    for i in range(n):
        # 检查当前行的长度是否与行号一致
        if len(words[i]) > n:
            return False
        for j in range(len(words[i])):
            # 检查当前行的每个字符是否与对应列的字符相等
            if j >= n or i >= len(words[j]) or words[i][j] != words[j][i]:
                return False
    return True


# 自动生成Solution类（无需手动编写）
Solution = create_solution(valid_word_square)