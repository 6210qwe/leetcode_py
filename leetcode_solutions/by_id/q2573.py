# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2573
标题: Remove Nodes From Linked List
难度: medium
链接: https://leetcode.cn/problems/remove-nodes-from-linked-list/
题目类型: 栈、递归、链表、单调栈
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2487. 从链表中移除节点 - 给你一个链表的头节点 head 。 移除每个右侧有一个更大数值的节点。 返回修改后链表的头节点 head 。 示例 1： [https://assets.leetcode.com/uploads/2022/10/02/drawio.png] 输入：head = [5,2,13,3,8] 输出：[13,8] 解释：需要移除的节点是 5 ，2 和 3 。 - 节点 13 在节点 5 右侧。 - 节点 13 在节点 2 右侧。 - 节点 8 在节点 3 右侧。 示例 2： 输入：head = [1,1,1,1] 输出：[1,1,1,1] 解释：每个节点的值都是 1 ，所以没有需要移除的节点。 提示： * 给定列表中的节点数目在范围 [1, 105] 内 * 1 <= Node.val <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用递归方法，从链表尾部开始处理，确保每个节点的右侧没有更大的节点。

算法步骤:
1. 递归遍历链表，直到链表尾部。
2. 从链表尾部开始返回最大值，并构建新的链表。
3. 如果当前节点的值小于递归返回的最大值，则跳过当前节点。

关键点:
- 递归处理链表，从尾部开始构建新的链表。
- 使用递归返回的最大值来决定是否保留当前节点。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是链表的长度。每个节点只访问一次。
空间复杂度: O(n)，递归调用栈的深度最多为链表的长度。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.solution import create_solution

def remove_nodes(head: Optional[ListNode]) -> Optional[ListNode]:
    """
    从链表中移除每个右侧有一个更大数值的节点。
    """
    if not head:
        return None
    
    # 递归处理下一个节点
    next_node = remove_nodes(head.next)
    
    # 如果当前节点的值小于下一个节点的值，则跳过当前节点
    if next_node and head.val < next_node.val:
        return next_node
    else:
        head.next = next_node
        return head

Solution = create_solution(remove_nodes)