# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 902
标题: Minimum Number of Refueling Stops
难度: hard
链接: https://leetcode.cn/problems/minimum-number-of-refueling-stops/
题目类型: 贪心、数组、动态规划、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
871. 最低加油次数 - 汽车从起点出发驶向目的地，该目的地位于出发位置东面 target 英里处。 沿途有加油站，用数组 stations 表示。其中 stations[i] = [positioni, fueli] 表示第 i 个加油站位于出发位置东面 positioni 英里处，并且有 fueli 升汽油。 假设汽车油箱的容量是无限的，其中最初有 startFuel 升燃料。它每行驶 1 英里就会用掉 1 升汽油。当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。 为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 -1 。 注意：如果汽车到达加油站时剩余燃料为 0，它仍然可以在那里加油。如果汽车到达目的地时剩余燃料为 0，仍然认为它已经到达目的地。 示例 1： 输入：target = 1, startFuel = 1, stations = [] 输出：0 解释：可以在不加油的情况下到达目的地。 示例 2： 输入：target = 100, startFuel = 1, stations = [[10,100]] 输出：-1 解释：无法抵达目的地，甚至无法到达第一个加油站。 示例 3： 输入：target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]] 输出：2 解释： 出发时有 10 升燃料。 开车来到距起点 10 英里处的加油站，消耗 10 升燃料。将汽油从 0 升加到 60 升。 然后，从 10 英里处的加油站开到 60 英里处的加油站（消耗 50 升燃料）， 并将汽油从 10 升加到 50 升。然后开车抵达目的地。 沿途在两个加油站停靠，所以返回 2 。 提示： * 1 <= target, startFuel <= 109 * 0 <= stations.length <= 500 * 1 <= positioni < positioni+1 < target * 1 <= fueli < 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用最大堆来存储可以加油的加油站，并在需要加油时选择加油量最大的加油站。

算法步骤:
1. 初始化一个最大堆和当前燃料。
2. 遍历每个加油站，如果当前燃料不足以到达下一个加油站或目标，则从堆中取出加油量最大的加油站进行加油。
3. 如果当前燃料仍不足以到达下一个加油站或目标，则返回 -1。
4. 如果遍历完所有加油站并且当前燃料足以到达目标，则返回加油次数。

关键点:
- 使用最大堆来存储可以加油的加油站，确保每次加油时选择加油量最大的加油站。
- 在需要加油时，从堆中取出加油量最大的加油站进行加油。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是加油站的数量。因为每次插入和删除堆的操作都是 O(log n)。
空间复杂度: O(n)，因为最坏情况下堆中会存储所有的加油站。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def min_refuel_stops(target: int, start_fuel: int, stations: List[List[int]]) -> int:
    """
    计算到达目标所需的最少加油次数。
    """
    # 初始化最大堆和当前燃料
    max_heap = []
    current_fuel = start_fuel
    refuel_count = 0
    prev_position = 0
    
    for position, fuel in stations + [[target, 0]]:
        # 计算从上一个加油站到当前加油站的距离
        distance = position - prev_position
        # 检查当前燃料是否足够到达下一个加油站
        while current_fuel < distance and max_heap:
            # 从堆中取出加油量最大的加油站进行加油
            current_fuel -= heapq.heappop(max_heap)
            refuel_count += 1
        # 如果当前燃料仍不足以到达下一个加油站，则返回 -1
        if current_fuel < distance:
            return -1
        # 将当前加油站的燃料加入堆中
        heapq.heappush(max_heap, -fuel)
        # 更新当前位置和当前燃料
        current_fuel -= distance
        prev_position = position
    
    return refuel_count

Solution = min_refuel_stops