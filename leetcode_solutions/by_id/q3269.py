# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3269
标题: Number of Subarrays That Match a Pattern I
难度: medium
链接: https://leetcode.cn/problems/number-of-subarrays-that-match-a-pattern-i/
题目类型: 数组、字符串匹配、哈希函数、滚动哈希
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3034. 匹配模式数组的子数组数目 I - 给你一个下标从 0 开始长度为 n 的整数数组 nums ，和一个下标从 0 开始长度为 m 的整数数组 pattern ，pattern 数组只包含整数 -1 ，0 和 1 。 大小为 m + 1 的子数组 nums[i..j] 如果对于每个元素 pattern[k] 都满足以下条件，那么我们说这个子数组匹配模式数组 pattern ： * 如果 pattern[k] == 1 ，那么 nums[i + k + 1] > nums[i + k] * 如果 pattern[k] == 0 ，那么 nums[i + k + 1] == nums[i + k] * 如果 pattern[k] == -1 ，那么 nums[i + k + 1] < nums[i + k] 请你返回匹配 pattern 的 nums 子数组的 数目 。 示例 1： 输入：nums = [1,2,3,4,5,6], pattern = [1,1] 输出：4 解释：模式 [1,1] 说明我们要找的子数组是长度为 3 且严格上升的。在数组 nums 中，子数组 [1,2,3] ，[2,3,4] ，[3,4,5] 和 [4,5,6] 都匹配这个模式。 所以 nums 中总共有 4 个子数组匹配这个模式。 示例 2： 输入：nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1] 输出：2 解释：这里，模式数组 [1,0,-1] 说明我们需要找的子数组中，第一个元素小于第二个元素，第二个元素等于第三个元素，第三个元素大于第四个元素。在 nums 中，子数组 [1,4,4,1] 和 [3,5,5,3] 都匹配这个模式。 所以 nums 中总共有 2 个子数组匹配这个模式。 提示： * 2 <= n == nums.length <= 100 * 1 <= nums[i] <= 109 * 1 <= m == pattern.length < n * -1 <= pattern[i] <= 1
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用滑动窗口来检查每个子数组是否匹配模式。

算法步骤:
1. 将 `nums` 转换为表示相邻元素关系的数组 `diffs`，其中 `diffs[i]` 表示 `nums[i+1]` 和 `nums[i]` 的关系。
2. 滑动窗口遍历 `diffs`，检查每个长度为 `m` 的子数组是否与 `pattern` 匹配。
3. 计算并返回匹配的子数组数量。

关键点:
- 使用滑动窗口来高效地检查每个子数组。
- 通过比较 `diffs` 和 `pattern` 来判断子数组是否匹配。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * m)，其中 n 是 `nums` 的长度，m 是 `pattern` 的长度。
空间复杂度: O(n)，用于存储 `diffs` 数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def count_matching_subarrays(nums: List[int], pattern: List[int]) -> int:
    n, m = len(nums), len(pattern)
    diffs = []
    
    # 生成 diffs 数组
    for i in range(1, n):
        if nums[i] > nums[i - 1]:
            diffs.append(1)
        elif nums[i] < nums[i - 1]:
            diffs.append(-1)
        else:
            diffs.append(0)
    
    count = 0
    
    # 滑动窗口检查每个子数组
    for i in range(n - m):
        if diffs[i:i + m] == pattern:
            count += 1
    
    return count

Solution = create_solution(count_matching_subarrays)