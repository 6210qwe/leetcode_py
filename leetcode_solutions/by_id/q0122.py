# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 122
标题: Best Time to Buy and Sell Stock II
难度: medium
链接: https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/
题目类型: 贪心、数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
122. 买卖股票的最佳时机 II - 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。然而，你可以在 同一天 多次买卖该股票，但要确保你持有的股票不超过一股。 返回 你能获得的 最大 利润 。 示例 1： 输入：prices = [7,1,5,3,6,4] 输出：7 解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3。 最大总利润为 4 + 3 = 7 。 示例 2： 输入：prices = [1,2,3,4,5] 输出：4 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。 最大总利润为 4 。 示例 3： 输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0。 提示： * 1 <= prices.length <= 3 * 104 * 0 <= prices[i] <= 104
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 贪心算法，只要后一天价格高于前一天就卖出

算法步骤:
1. 遍历价格数组
2. 如果后一天价格高于前一天，累加利润
3. 返回总利润

关键点:
- 贪心策略：只要有利可图就交易
- 时间复杂度O(n)，空间复杂度O(1)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 只需遍历一次数组
空间复杂度: O(1) - 只使用常数额外空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from leetcode_solutions.utils.solution import create_solution


def best_time_to_buy_and_sell_stock_ii(prices: List[int]) -> int:
    """
    函数式接口 - 计算多次买卖股票的最大利润
    
    实现思路:
    贪心算法，只要后一天价格高于前一天就卖出。
    
    Args:
        prices: 股票价格数组
        
    Returns:
        最大利润
        
    Example:
        >>> best_time_to_buy_and_sell_stock_ii([7, 1, 5, 3, 6, 4])
        7
    """
    profit = 0
    
    for i in range(1, len(prices)):
        if prices[i] > prices[i - 1]:
            profit += prices[i] - prices[i - 1]
    
    return profit


# 自动生成Solution类（无需手动编写）
Solution = create_solution(best_time_to_buy_and_sell_stock_ii)
