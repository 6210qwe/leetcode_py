# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3276
标题: Minimum Number of Pushes to Type Word II
难度: medium
链接: https://leetcode.cn/problems/minimum-number-of-pushes-to-type-word-ii/
题目类型: 贪心、哈希表、字符串、计数、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3016. 输入单词需要的最少按键次数 II - 给你一个字符串 word，由小写英文字母组成。 电话键盘上的按键与 不同 小写英文字母集合相映射，可以通过按压按键来组成单词。例如，按键 2 对应 ["a","b","c"]，我们需要按一次键来输入 "a"，按两次键来输入 "b"，按三次键来输入 "c"。 现在允许你将编号为 2 到 9 的按键重新映射到 不同 字母集合。每个按键可以映射到 任意数量 的字母，但每个字母 必须 恰好 映射到 一个 按键上。你需要找到输入字符串 word 所需的 最少 按键次数。 返回重新映射按键后输入 word 所需的 最少 按键次数。 下面给出了一种电话键盘上字母到按键的映射作为示例。注意 1，*，# 和 0 不 对应任何字母。 [https://assets.leetcode.com/uploads/2023/12/26/keypaddesc.png] 示例 1： [https://assets.leetcode.com/uploads/2023/12/26/keypadv1e1.png] 输入：word = "abcde" 输出：5 解释：图片中给出的重新映射方案的输入成本最小。 "a" -> 在按键 2 上按一次 "b" -> 在按键 3 上按一次 "c" -> 在按键 4 上按一次 "d" -> 在按键 5 上按一次 "e" -> 在按键 6 上按一次 总成本为 1 + 1 + 1 + 1 + 1 = 5 。 可以证明不存在其他成本更低的映射方案。 示例 2： [https://assets.leetcode.com/uploads/2023/12/26/keypadv2e2.png] 输入：word = "xyzxyzxyzxyz" 输出：12 解释：图片中给出的重新映射方案的输入成本最小。 "x" -> 在按键 2 上按一次 "y" -> 在按键 3 上按一次 "z" -> 在按键 4 上按一次 总成本为 1 * 4 + 1 * 4 + 1 * 4 = 12 。 可以证明不存在其他成本更低的映射方案。 注意按键 9 没有映射到任何字母：不必让每个按键都存在与之映射的字母，但是每个字母都必须映射到按键上。 示例 3： [https://assets.leetcode.com/uploads/2023/12/27/keypadv2.png] 输入：word = "aabbccddeeffgghhiiiiii" 输出：24 解释：图片中给出的重新映射方案的输入成本最小。 "a" -> 在按键 2 上按一次 "b" -> 在按键 3 上按一次 "c" -> 在按键 4 上按一次 "d" -> 在按键 5 上按一次 "e" -> 在按键 6 上按一次 "f" -> 在按键 7 上按一次 "g" -> 在按键 8 上按一次 "h" -> 在按键 9 上按两次 "i" -> 在按键 9 上按一次 总成本为 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 2 * 2 + 6 * 1 = 24 。 可以证明不存在其他成本更低的映射方案。 提示： * 1 <= word.length <= 105 * word 仅由小写英文字母组成。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过贪心算法，优先将出现频率高的字母分配到按键的前面位置，以减少总的按键次数。

算法步骤:
1. 统计每个字母的出现频率。
2. 将字母按频率从高到低排序。
3. 依次将字母分配到按键上，每8个字母分配到一个新的按键位置，计算总按键次数。

关键点:
- 优先处理频率高的字母，以减少总的按键次数。
- 每8个字母分配到一个新的按键位置，确保按键次数最少。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n + k log k)，其中 n 是 word 的长度，k 是字母种类数（最多 26）。
空间复杂度: O(k)，用于存储字母频率和排序后的字母列表。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def minimum_pushes(word: str) -> int:
    """
    函数式接口 - 计算输入单词所需的最少按键次数
    """
    # 统计每个字母的出现频率
    freq = [0] * 26
    for char in word:
        freq[ord(char) - ord('a')] += 1
    
    # 将字母按频率从高到低排序
    sorted_freq = sorted(freq, reverse=True)
    
    # 计算总按键次数
    total_pushes = 0
    for i, count in enumerate(sorted_freq):
        if count == 0:
            break
        total_pushes += (i // 8 + 1) * count
    
    return total_pushes


Solution = create_solution(minimum_pushes)