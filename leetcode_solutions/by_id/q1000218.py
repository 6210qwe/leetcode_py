# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000218
标题: 变换的迷宫
难度: hard
链接: https://leetcode.cn/problems/Db3wC1/
题目类型: 深度优先搜索、广度优先搜索、数组、动态规划、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCP 31. 变换的迷宫 - 某解密游戏中，有一个 N\*M 的迷宫，迷宫地形会随时间变化而改变，迷宫出口一直位于 `(n-1,m-1)` 位置。迷宫变化规律记录于 `maze` 中，`maze[i]` 表示 `i` 时刻迷宫的地形状态，`"."` 表示可通行空地，`"#"` 表示陷阱。 地形图初始状态记作 `maze[0]`，此时小力位于起点 `(0,0)`。此后每一时刻可选择往上、下、左、右其一方向走一步，或者停留在原地。 小力背包有以下两个魔法卷轴（卷轴使用一次后消失）： + 临时消除术：将指定位置在下一个时刻变为空地； + 永久消除术：将指定位置永久变为空地。 请判断在迷宫变化结束前（含最后时刻），小力能否在不经过任意陷阱的情况下到达迷宫出口呢？ **注意： 输入数据保证起点和终点在所有时刻均为空地。** **示例 1：** >输入：`maze = [[".#.","#.."],["...",".#."],[".##",".#."],["..#",".#."]]` > >输出：`true` > >解释： ![maze.gif](https://pic.leetcode.cn/1615892239-SCIjyf-maze.gif) **示例 2：** >输入：`maze = [[".#.","..."],["...","..."]]` > >输出：`false` > >解释：由于时间不够，小力无法到达终点逃出迷宫。 **示例 3：** >输入：`maze = [["...","...","..."],[".##","###","##."],[".##","###","##."],[".##","###","##."],[".##","###","##."],[".##","###","##."],[".##","###","##."]]` > >输出：`false` > >解释：由于道路不通，小力无法到达终点逃出迷宫。 **提示：** - `1 <= maze.length <= 100` - `1 <= maze[i].length, maze[i][j].length <= 50` - `maze[i][j]` 仅包含 `"."`、`"#"`
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用三维动态规划来记录每个时刻、每个位置的状态，并结合广度优先搜索来遍历所有可能的路径。

算法步骤:
1. 初始化一个三维数组 `dp`，其中 `dp[t][i][j]` 表示在时刻 `t` 时，位置 `(i, j)` 是否可达。
2. 使用队列进行广度优先搜索，从起点 `(0, 0, 0)` 开始，探索所有可能的路径。
3. 在每个位置，考虑四种移动方式（上、下、左、右）和两种魔法卷轴的使用情况。
4. 更新 `dp` 数组，并在找到终点时返回 `True`。
5. 如果遍历完所有可能的路径仍未找到终点，则返回 `False`。

关键点:
- 使用三维数组 `dp` 来记录每个时刻、每个位置的状态。
- 考虑魔法卷轴的使用情况，确保在使用卷轴后更新 `dp` 数组。
- 使用广度优先搜索来遍历所有可能的路径。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(T * N * M)，其中 T 是时间长度，N 和 M 分别是迷宫的行数和列数。
空间复杂度: O(T * N * M)，用于存储 `dp` 数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from collections import deque

def solution(maze: List[List[str]]) -> bool:
    T = len(maze)
    N = len(maze[0])
    M = len(maze[0][0])
    
    # dp[t][i][j] 表示在时刻 t 时，位置 (i, j) 是否可达
    dp = [[[False] * M for _ in range(N)] for _ in range(T)]
    dp[0][0][0] = True
    
    # 方向数组，表示上下左右四个方向
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    # 广度优先搜索
    queue = deque([(0, 0, 0)])  # (t, i, j)
    
    while queue:
        t, i, j = queue.popleft()
        
        if t == T - 1 and i == N - 1 and j == M - 1:
            return True
        
        for dt, di, dj in [(1, 0, 0)] + [(0, di, dj) for di, dj in directions]:
            new_t = t + dt
            new_i = i + di
            new_j = j + dj
            
            if 0 <= new_t < T and 0 <= new_i < N and 0 <= new_j < M:
                if maze[new_t][new_i][new_j] == '.' and not dp[new_t][new_i][new_j]:
                    dp[new_t][new_i][new_j] = True
                    queue.append((new_t, new_i, new_j))
                    
                # 使用临时消除术
                if dt == 1 and maze[t][new_i][new_j] == '#' and not dp[new_t][new_i][new_j]:
                    dp[new_t][new_i][new_j] = True
                    queue.append((new_t, new_i, new_j))
                    
                # 使用永久消除术
                if maze[t][new_i][new_j] == '#' and not dp[t][new_i][new_j]:
                    dp[t][new_i][new_j] = True
                    queue.append((t, new_i, new_j))
    
    return False

Solution = create_solution(solution)