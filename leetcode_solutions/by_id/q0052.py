# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 52
标题: N-Queens II
难度: hard
链接: https://leetcode.cn/problems/n-queens-ii/
题目类型: 回溯
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
52. N 皇后 II - n 皇后问题 研究的是如何将 n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。 给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。 示例 1： [https://assets.leetcode.com/uploads/2020/11/13/queens.jpg] 输入：n = 4 输出：2 解释：如上图所示，4 皇后问题存在两个不同的解法。 示例 2： 输入：n = 1 输出：1 提示： * 1 <= n <= 9
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 回溯算法 + 位运算优化，只计数不记录具体解

算法步骤:
1. 使用三个整数作为位掩码：cols、diag1、diag2
2. 回溯函数backtrack(row, cols, diag1, diag2)：
   - 如果row == n，说明找到一组解，计数+1
   - 否则，对于每一列col：
     * 计算对角线索引
     * 检查位置是否可用
     * 如果可用，标记并递归
     * 回溯，撤销标记
3. 返回计数结果

关键点:
- 与51题类似，但只需要计数，不需要记录具体解
- 使用位运算优化，减少空间和时间开销
- 可以进一步优化，但当前方法已经足够高效
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n!) - 最坏情况需要尝试所有排列
空间复杂度: O(n) - 递归栈深度
"""

# ============================================================================
# 代码实现
# ============================================================================

from leetcode_solutions.utils.solution import create_solution


def total_n_queens(n: int) -> int:
    """
    函数式接口 - 回溯算法 + 位运算优化
    
    实现思路:
    使用回溯算法计算n皇后问题的解的数量，通过位运算快速判断位置是否可用。
    
    Args:
        n: 棋盘大小（n×n）
        
    Returns:
        n皇后问题不同的解决方案的数量
        
    Example:
        >>> total_n_queens(4)
        2
    """
    count = 0
    
    def backtrack(row: int, cols: int, diag1: int, diag2: int):
        """回溯函数"""
        nonlocal count
        if row == n:
            count += 1
            return
        
        for col in range(n):
            # 计算对角线索引
            diag1_idx = row - col + n - 1  # 主对角线
            diag2_idx = row + col  # 副对角线
            
            # 检查位置是否可用
            if (cols & (1 << col)) == 0 and \
               (diag1 & (1 << diag1_idx)) == 0 and \
               (diag2 & (1 << diag2_idx)) == 0:
                # 标记已使用
                cols |= (1 << col)
                diag1 |= (1 << diag1_idx)
                diag2 |= (1 << diag2_idx)
                # 递归
                backtrack(row + 1, cols, diag1, diag2)
                # 回溯：撤销标记
                cols &= ~(1 << col)
                diag1 &= ~(1 << diag1_idx)
                diag2 &= ~(1 << diag2_idx)
    
    backtrack(0, 0, 0, 0)
    return count


# 自动生成Solution类（无需手动编写）
Solution = create_solution(total_n_queens)
