# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3244
标题: Minimize Length of Array Using Operations
难度: medium
链接: https://leetcode.cn/problems/minimize-length-of-array-using-operations/
题目类型: 贪心、数组、数学、数论
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3012. 通过操作使数组长度最小 - 给你一个下标从 0 开始的整数数组 nums ，它只包含 正 整数。 你的任务是通过进行以下操作 任意次 （可以是 0 次） 最小化 nums 的长度： * 在 nums 中选择 两个不同 的下标 i 和 j ，满足 nums[i] > 0 且 nums[j] > 0 。 * 将结果 nums[i] % nums[j] 插入 nums 的结尾。 * 将 nums 中下标为 i 和 j 的元素删除。 请你返回一个整数，它表示进行任意次操作以后 nums 的 最小长度 。 示例 1： 输入：nums = [1,4,3,1] 输出：1 解释：使数组长度最小的一种方法是： 操作 1 ：选择下标 2 和 1 ，插入 nums[2] % nums[1] 到数组末尾，得到 [1,4,3,1,3] ，然后删除下标为 2 和 1 的元素。 nums 变为 [1,1,3] 。 操作 2 ：选择下标 1 和 2 ，插入 nums[1] % nums[2] 到数组末尾，得到 [1,1,3,1] ，然后删除下标为 1 和 2 的元素。 nums 变为 [1,1] 。 操作 3 ：选择下标 1 和 0 ，插入 nums[1] % nums[0] 到数组末尾，得到 [1,1,0] ，然后删除下标为 1 和 0 的元素。 nums 变为 [0] 。 nums 的长度无法进一步减小，所以答案为 1 。 1 是可以得到的最小长度。 示例 2： 输入：nums = [5,5,5,10,5] 输出：2 解释：使数组长度最小的一种方法是： 操作 1 ：选择下标 0 和 3 ，插入 nums[0] % nums[3] 到数组末尾，得到 [5,5,5,10,5,5] ，然后删除下标为 0 和 3 的元素。 nums 变为 [5,5,5,5] 。 操作 2 ：选择下标 2 和 3 ，插入 nums[2] % nums[3] 到数组末尾，得到 [5,5,5,5,0] ，然后删除下标为 2 和 3 的元素。 nums 变为 [5,5,0] 。 操作 3 ：选择下标 0 和 1 ，插入 nums[0] % nums[1] 到数组末尾，得到 [5,5,0,0] ，然后删除下标为 0 和 1 的元素。 nums 变为 [0,0] 。 nums 的长度无法进一步减小，所以答案为 2 。 2 是可以得到的最小长度。 示例 3： 输入：nums = [2,3,4] 输出：1 解释：使数组长度最小的一种方法是： 操作 1 ：选择下标 1 和 2 ，插入 nums[1] % nums[2] 到数组末尾，得到 [2,3,4,3] ，然后删除下标为 1 和 2 的元素。 nums 变为 [2,3] 。 操作 2 ：选择下标 1 和 0 ，插入 nums[1] % nums[0] 到数组末尾，得到 [2,3,1] ，然后删除下标为 1 和 0 的元素。 nums 变为 [1] 。 nums 的长度无法进一步减小，所以答案为 1 。 1 是可以得到的最小长度。 提示： * 1 <= nums.length <= 105 * 1 <= nums[i] <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过不断计算数组中所有元素的最大公约数 (GCD)，最终将数组中的所有元素都变为 GCD。如果 GCD 为 1，则数组的最小长度为 1；否则，数组的最小长度为数组中等于 GCD 的元素个数。

算法步骤:
1. 计算数组中所有元素的最大公约数 (GCD)。
2. 如果 GCD 为 1，则返回 1。
3. 否则，统计数组中等于 GCD 的元素个数，并返回该个数。

关键点:
- 使用欧几里得算法计算 GCD。
- 通过遍历数组来统计等于 GCD 的元素个数。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log(max(nums)))，其中 n 是数组的长度，max(nums) 是数组中的最大值。计算 GCD 的时间复杂度为 O(log(max(nums)))，遍历数组的时间复杂度为 O(n)。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from math import gcd
from functools import reduce

def minimize_array_length(nums: List[int]) -> int:
    """
    函数式接口 - 通过操作使数组长度最小
    """
    # 计算数组中所有元素的最大公约数
    array_gcd = reduce(gcd, nums)
    
    # 如果 GCD 为 1，则返回 1
    if array_gcd == 1:
        return 1
    
    # 统计数组中等于 GCD 的元素个数
    count = sum(1 for num in nums if num == array_gcd)
    
    # 返回数组中等于 GCD 的元素个数
    return count

Solution = create_solution(minimize_array_length)