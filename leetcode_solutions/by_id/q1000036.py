# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000036
标题: Circus Tower LCCI
难度: medium
链接: https://leetcode.cn/problems/circus-tower-lcci/
题目类型: 数组、二分查找、动态规划、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
面试题 17.08. 马戏团人塔 - 有个马戏团正在设计叠罗汉的表演节目，一个人要站在另一人的肩膀上。出于实际和美观的考虑，在上面的人要比下面的人矮一点且轻一点。已知马戏团每个人的身高和体重，请编写代码计算叠罗汉最多能叠几个人。 示例： 输入：height = [65,70,56,75,60,68] weight = [100,150,90,190,95,110] 输出：6 解释：从上往下数，叠罗汉最多能叠 6 层：(56,90), (60,95), (65,100), (68,110), (70,150), (75,190) 提示： * height.length == weight.length <= 10000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过将身高和体重组合成一个二维数组，并按身高升序、体重降序排序，然后使用最长递增子序列（LIS）算法来解决问题。

算法步骤:
1. 将身高和体重组合成一个二维数组。
2. 按照身高升序、体重降序对二维数组进行排序。
3. 使用动态规划或二分查找来找到最长递增子序列（LIS）。

关键点:
- 通过排序和LIS算法，可以有效地找到满足条件的最长序列。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中n是height和weight的长度。排序操作的时间复杂度为O(n log n)，LIS算法的时间复杂度为O(n log n)。
空间复杂度: O(n)，用于存储排序后的数组和LIS数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from bisect import bisect_left

def solution_function_name(height: List[int], weight: List[int]) -> int:
    """
    函数式接口 - 计算叠罗汉最多能叠几个人
    """
    if not height or not weight:
        return 0

    # 将身高和体重组合成一个二维数组
    people = list(zip(height, weight))
    
    # 按身高升序、体重降序排序
    people.sort(key=lambda x: (x[0], -x[1]))

    # 使用LIS算法找到最长递增子序列
    lis = []
    for _, w in people:
        pos = bisect_left(lis, w)
        if pos == len(lis):
            lis.append(w)
        else:
            lis[pos] = w

    return len(lis)

Solution = create_solution(solution_function_name)