# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 834
标题: Ambiguous Coordinates
难度: medium
链接: https://leetcode.cn/problems/ambiguous-coordinates/
题目类型: 字符串、回溯、枚举
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
816. 模糊坐标 - 我们有一些二维坐标，如 "(1, 3)" 或 "(2, 0.5)"，然后我们移除所有逗号，小数点和空格，得到一个字符串S。返回所有可能的原始字符串到一个列表中。 原始的坐标表示法不会存在多余的零，所以不会出现类似于"00", "0.0", "0.00", "1.0", "001", "00.01"或一些其他更小的数来表示坐标。此外，一个小数点前至少存在一个数，所以也不会出现“.1”形式的数字。 最后返回的列表可以是任意顺序的。而且注意返回的两个数字中间（逗号之后）都有一个空格。 示例 1: 输入: "(123)" 输出: ["(1, 23)", "(12, 3)", "(1.2, 3)", "(1, 2.3)"] 示例 2: 输入: "(00011)" 输出: ["(0.001, 1)", "(0, 0.011)"] 解释: 0.0, 00, 0001 或 00.01 是不被允许的。 示例 3: 输入: "(0123)" 输出: ["(0, 123)", "(0, 12.3)", "(0, 1.23)", "(0.1, 23)", "(0.1, 2.3)", "(0.12, 3)"] 示例 4: 输入: "(100)" 输出: [(10, 0)] 解释: 1.0 是不被允许的。 提示: * 4 <= S.length <= 12. * S[0] = "(", S[S.length - 1] = ")", 且字符串 S 中的其他元素都是数字。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过枚举所有可能的分割点，并对每个部分生成所有合法的小数表示，组合成最终的结果。

算法步骤:
1. 去掉输入字符串的括号，得到纯数字字符串。
2. 枚举所有可能的分割点，将字符串分成两部分。
3. 对每部分生成所有合法的小数表示。
4. 将两部分的所有合法小数表示组合成最终结果。

关键点:
- 生成合法的小数表示时，需要处理前导零和小数点位置。
- 组合结果时，确保格式正确。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^3)，其中 n 是字符串 S 的长度。最坏情况下，每个分割点都需要生成所有可能的小数表示。
空间复杂度: O(n^2)，存储所有可能的分割点和小数表示。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def generate_valid_numbers(s: str) -> List[str]:
    """生成 s 的所有合法小数表示。"""
    if s == "0" or s[0] != "0":
        yield s
    for i in range(1, len(s)):
        whole, fractional = s[:i], s[i:]
        if (whole == "0" or not whole.startswith("0")) and fractional[-1] != "0":
            yield f"{whole}.{fractional}"

def ambiguousCoordinates(S: str) -> List[str]:
    """
    返回所有可能的原始字符串到一个列表中。
    """
    S = S[1:-1]  # 去掉括号
    result = []
    
    for i in range(1, len(S)):
        left, right = S[:i], S[i:]
        for l in generate_valid_numbers(left):
            for r in generate_valid_numbers(right):
                result.append(f"({l}, {r})")
    
    return result

Solution = create_solution(ambiguousCoordinates)