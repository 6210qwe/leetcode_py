# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1471
标题: Maximum Students Taking Exam
难度: hard
链接: https://leetcode.cn/problems/maximum-students-taking-exam/
题目类型: 位运算、数组、动态规划、状态压缩、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1349. 参加考试的最大学生数 - 给你一个 m * n 的矩阵 seats 表示教室中的座位分布。如果座位是坏的（不可用），就用 '#' 表示；否则，用 '.' 表示。 学生可以看到左侧、右侧、左上、右上这四个方向上紧邻他的学生的答卷，但是看不到直接坐在他前面或者后面的学生的答卷。请你计算并返回该考场可以容纳的同时参加考试且无法作弊的 最大 学生人数。 学生必须坐在状况良好的座位上。 示例 1： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/02/09/image.png] 输入：seats = [["#",".","#","#",".","#"], [".","#","#","#","#","."], ["#",".","#","#",".","#"]] 输出：4 解释：教师可以让 4 个学生坐在可用的座位上，这样他们就无法在考试中作弊。 示例 2： 输入：seats = [[".","#"], ["#","#"], ["#","."], ["#","#"], [".","#"]] 输出：3 解释：让所有学生坐在可用的座位上。 示例 3： 输入：seats = [["#",".",".",".","#"], [".","#",".","#","."], [".",".","#",".","."], [".","#",".","#","."], ["#",".",".",".","#"]] 输出：10 解释：让学生坐在第 1、3 和 5 列的可用座位上。 提示： * seats 只包含字符 '.' 和'#' * m == seats.length * n == seats[i].length * 1 <= m <= 8 * 1 <= n <= 8
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划和状态压缩来解决这个问题。我们使用一个整数来表示每一行的状态，其中每一位表示一个座位是否被占用。通过状态转移方程来更新每一行的最大学生数。

算法步骤:
1. 初始化一个二维数组 dp，其中 dp[i][state] 表示前 i 行且第 i 行状态为 state 时的最大学生数。
2. 遍历每一行，生成所有可能的状态，并检查这些状态是否有效（即没有相邻的学生）。
3. 对于每个有效状态，更新 dp 数组。
4. 返回 dp 数组中的最大值。

关键点:
- 使用位运算来表示和操作状态。
- 状态转移时需要考虑当前行和前一行的状态。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m * 2^n * n^2)，其中 m 是行数，n 是列数。
空间复杂度: O(m * 2^n)，用于存储 dp 数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def maxStudents(seats: List[List[str]]) -> int:
    m, n = len(seats), len(seats[0])
    valid_states = []
    
    # 生成每一行的有效状态
    for row in seats:
        state = 0
        for seat in row:
            state = (state << 1) | (seat == '.')
        valid_states.append(state)
    
    # 检查状态是否有效
    def is_valid_state(state):
        return (state & (state >> 1)) == 0
    
    # 计算状态中的 1 的个数
    def count_ones(state):
        count = 0
        while state:
            count += state & 1
            state >>= 1
        return count
    
    # 动态规划数组
    dp = [[-1] * (1 << n) for _ in range(m + 1)]
    dp[0][0] = 0
    
    for i in range(1, m + 1):
        for cur_state in range(1 << n):
            if not is_valid_state(cur_state) or (cur_state & valid_states[i - 1]) != cur_state:
                continue
            for prev_state in range(1 << n):
                if (prev_state & (cur_state >> 1)) or (prev_state & (cur_state << 1)):
                    continue
                if dp[i - 1][prev_state] != -1:
                    dp[i][cur_state] = max(dp[i][cur_state], dp[i - 1][prev_state] + count_ones(cur_state))
    
    return max(max(row) for row in dp)

Solution = create_solution(maxStudents)