# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 375
标题: Guess Number Higher or Lower II
难度: medium
链接: https://leetcode.cn/problems/guess-number-higher-or-lower-ii/
题目类型: 数学、动态规划、博弈
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
375. 猜数字大小 II - 我们正在玩一个猜数游戏，游戏规则如下： 1. 我从 1 到 n 之间选择一个数字。 2. 你来猜我选了哪个数字。 3. 如果你猜到正确的数字，就会 赢得游戏 。 4. 如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。 5. 每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。 给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字 。 示例 1： [https://assets.leetcode.com/uploads/2020/09/10/graph.png] 输入：n = 10 输出：16 解释：制胜策略如下： - 数字范围是 [1,10] 。你先猜测数字为 7 。 - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $7 。 - 如果我的数字更大，则下一步需要猜测的数字范围是 [8,10] 。你可以猜测数字为 9 。 - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $9 。 - 如果我的数字更大，那么这个数字一定是 10 。你猜测数字为 10 并赢得游戏，总费用为 $7 + $9 = $16 。 - 如果我的数字更小，那么这个数字一定是 8 。你猜测数字为 8 并赢得游戏，总费用为 $7 + $9 = $16 。 - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,6] 。你可以猜测数字为 3 。 - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $3 。 - 如果我的数字更大，则下一步需要猜测的数字范围是 [4,6] 。你可以猜测数字为 5 。 - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $5 。 - 如果我的数字更大，那么这个数字一定是 6 。你猜测数字为 6 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。 - 如果我的数字更小，那么这个数字一定是 4 。你猜测数字为 4 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。 - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,2] 。你可以猜测数字为 1 。 - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $1 。 - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $7 + $3 + $1 = $11 。 在最糟糕的情况下，你需要支付 $16 。因此，你只需要 $16 就可以确保自己赢得游戏。 示例 2： 输入：n = 1 输出：0 解释：只有一个可能的数字，所以你可以直接猜 1 并赢得游戏，无需支付任何费用。 示例 3： 输入：n = 2 输出：1 解释：有两个可能的数字 1 和 2 。 - 你可以先猜 1 。 - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $1 。 - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $1 。 最糟糕的情况下，你需要支付 $1 。 提示： * 1 <= n <= 200
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 区间动态规划 + 极小化极大（minimax）：在区间 [l,r] 内枚举第一次猜测的数字 x，取最坏情况的花费并优化其最小值

算法步骤:
1. 定义状态：dp[l][r] 表示在猜测区间 [l,r] 内，为保证一定猜中所需支付的最小金额（在最坏情况下）。
2. 边界：当 l >= r 时，区间内至多一个数，此时不需要任何支付，dp[l][r] = 0。
3. 状态转移：对于区间 [l,r]，枚举第一次猜的数字 x（l ≤ x ≤ r）：
   - 若真实数字 < x，则后续区间变为 [l, x-1]，代价为 dp[l][x-1]；
   - 若真实数字 > x，则后续区间变为 [x+1, r]，代价为 dp[x+1][r]；
   - 因为要保证「最坏情况下」也能赢，当前选择 x 的总代价为：cost(x) = x + max(dp[l][x-1], dp[x+1][r])。
   - dp[l][r] = min_{x∈[l,r]} cost(x)。
4. 按区间长度 len = 2..n 递增的顺序填表，最终答案为 dp[1][n]。

关键点:
- 这是典型的「区间 DP + 博弈论」问题，转移中用 max 表示对手的最坏选择，用 min 表示我们的最优策略。
- 可以对 x 的枚举范围做一定剪枝（如不必枚举端点），但在 n ≤ 200 时完整枚举也能通过。
- 注意使用自底向上的填表顺序，确保转移时依赖的子区间已被计算。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^3) - 状态数量 O(n^2)，每个状态枚举 O(n) 个 x；在 n ≤ 200 时可接受，也可通过剪枝略微优化常数。
空间复杂度: O(n^2) - 需要一个 n×n 的 DP 数组存储区间结果。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def guess_number_higher_or_lower_ii(n: int) -> int:
    """
    区间动态规划，返回在 [1, n] 内保证获胜所需的最小金额。
    """
    # dp[l][r]: 猜中区间 [l,r] 内任意数字所需的最小金额
    dp = [[0] * (n + 2) for _ in range(n + 2)]

    for length in range(2, n + 1):
        for l in range(1, n - length + 2):
            r = l + length - 1
            best = float("inf")
            # 枚举第一次猜测的数字 x
            for x in range(l, r + 1):
                cost_left = dp[l][x - 1] if x > l else 0
                cost_right = dp[x + 1][r] if x < r else 0
                cost = x + max(cost_left, cost_right)
                if cost < best:
                    best = cost
            dp[l][r] = 0 if best == float("inf") else best

    return dp[1][n]


# 自动生成Solution类（无需手动编写）
Solution = create_solution(guess_number_higher_or_lower_ii)
