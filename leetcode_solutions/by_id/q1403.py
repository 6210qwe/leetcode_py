# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1403
标题: Palindrome Partitioning III
难度: hard
链接: https://leetcode.cn/problems/palindrome-partitioning-iii/
题目类型: 字符串、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1278. 分割回文串 III - 给你一个由小写字母组成的字符串 s，和一个整数 k。 请你按下面的要求分割字符串： * 首先，你可以将 s 中的部分字符修改为其他的小写英文字母。 * 接着，你需要把 s 分割成 k 个非空且不相交的子串，并且每个子串都是回文串。 请返回以这种方式分割字符串所需修改的最少字符数。 示例 1： 输入：s = "abc", k = 2 输出：1 解释：你可以把字符串分割成 "ab" 和 "c"，并修改 "ab" 中的 1 个字符，将它变成回文串。 示例 2： 输入：s = "aabbc", k = 3 输出：0 解释：你可以把字符串分割成 "aa"、"bb" 和 "c"，它们都是回文串。 示例 3： 输入：s = "leetcode", k = 8 输出：0 提示： * 1 <= k <= s.length <= 100 * s 中只含有小写英文字母。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们定义 `dp[i][j]` 表示将前 `i` 个字符分割成 `j` 个回文子串所需的最小修改次数。

算法步骤:
1. 预处理计算每个子串变成回文串所需的最小修改次数。
2. 初始化 `dp` 数组，`dp[i][1]` 表示将前 `i` 个字符分割成 1 个回文子串所需的最小修改次数。
3. 使用动态规划填充 `dp` 数组，状态转移方程为 `dp[i][k] = min(dp[i][k], dp[j][k-1] + cost[j+1][i])`。
4. 返回 `dp[n][k]` 即为所求结果。

关键点:
- 预处理每个子串变成回文串所需的最小修改次数。
- 动态规划的状态转移方程。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2 * k)
空间复杂度: O(n * k)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def palindrome_partition(s: str, k: int) -> int:
    n = len(s)
    
    # 预处理每个子串变成回文串所需的最小修改次数
    cost = [[0] * n for _ in range(n)]
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            cost[i][j] = cost[i + 1][j - 1] + (s[i] != s[j])
    
    # 初始化 dp 数组
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    for i in range(1, n + 1):
        dp[i][1] = cost[0][i - 1]
    
    # 填充 dp 数组
    for i in range(2, n + 1):
        for j in range(2, min(i, k) + 1):
            for l in range(1, i):
                dp[i][j] = min(dp[i][j], dp[l][j - 1] + cost[l][i - 1])
    
    return dp[n][k]


Solution = create_solution(palindrome_partition)