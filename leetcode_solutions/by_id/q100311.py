# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 100311
标题: 彩灯装饰记录 I
难度: medium
链接: https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/
题目类型: 树、广度优先搜索、二叉树
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCR 149. 彩灯装饰记录 I - 一棵圣诞树记作根节点为 root 的二叉树，节点值为该位置装饰彩灯的颜色编号。请按照从 左 到 右 的顺序返回每一层彩灯编号。 示例 1： [https://pic.leetcode.cn/1694758674-XYrUiV-%E5%89%91%E6%8C%87%20Offer%2032%20-%20I_%E7%A4%BA%E4%BE%8B1.png] 输入：root = [8,17,21,18,null,null,6] 输出：[8,17,21,18,6] 提示： 1. 节点总数 <= 1000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用广度优先搜索（BFS）遍历二叉树，逐层记录节点值。

算法步骤:
1. 初始化一个队列，将根节点加入队列。
2. 初始化一个结果列表，用于存储每一层的节点值。
3. 当队列不为空时，依次处理队列中的节点：
   - 从队列中取出一个节点。
   - 将该节点的值加入结果列表。
   - 如果该节点有左子节点，将左子节点加入队列。
   - 如果该节点有右子节点，将右子节点加入队列。
4. 返回结果列表。

关键点:
- 使用队列进行层次遍历。
- 每次处理一层的所有节点。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是二叉树的节点数。每个节点都被访问一次。
空间复杂度: O(n)，队列在最坏情况下需要存储所有节点。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution

def levelOrder(root: Optional[TreeNode]) -> List[int]:
    """
    函数式接口 - 广度优先搜索实现
    """
    if not root:
        return []

    result = []
    queue = [root]

    while queue:
        node = queue.pop(0)
        result.append(node.val)
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)

    return result

Solution = create_solution(levelOrder)