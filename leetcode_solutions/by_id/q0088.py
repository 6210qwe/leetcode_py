# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 88
标题: Merge Sorted Array
难度: easy
链接: https://leetcode.cn/problems/merge-sorted-array/
题目类型: 数组、双指针、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
88. 合并两个有序数组 - 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。 示例 1： 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 解释：需要合并 [1,2,3] 和 [2,5,6] 。 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。 示例 2： 输入：nums1 = [1], m = 1, nums2 = [], n = 0 输出：[1] 解释：需要合并 [1] 和 [] 。 合并结果是 [1] 。 示例 3： 输入：nums1 = [0], m = 0, nums2 = [1], n = 1 输出：[1] 解释：需要合并的数组是 [] 和 [1] 。 合并结果是 [1] 。 注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。 提示： * nums1.length == m + n * nums2.length == n * 0 <= m, n <= 200 * 1 <= m + n <= 200 * -109 <= nums1[i], nums2[j] <= 109 进阶：你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 从后向前合并，避免覆盖nums1中的元素

算法步骤:
1. 使用三个指针：i指向nums1的最后一个有效元素，j指向nums2的最后一个元素，
   k指向nums1的最后一个位置
2. 从后向前遍历：
   - 如果nums1[i] > nums2[j]，将nums1[i]放到nums1[k]，i--，k--
   - 否则，将nums2[j]放到nums1[k]，j--，k--
3. 如果nums2还有剩余元素，复制到nums1

关键点:
- 从后向前合并，避免覆盖nums1中的元素
- 时间复杂度O(m+n)，空间复杂度O(1)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m+n) - 需要遍历两个数组
空间复杂度: O(1) - 只使用常数额外空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from leetcode_solutions.utils.solution import create_solution


def merge(nums1: List[int], m: int, nums2: List[int], n: int) -> None:
    """
    函数式接口 - 从后向前合并
    
    实现思路:
    从后向前合并两个有序数组，避免覆盖nums1中的元素。
    
    Args:
        nums1: 第一个有序数组，长度为m+n，前m个元素有效
        m: nums1中有效元素的个数
        nums2: 第二个有序数组，长度为n
        n: nums2中元素的个数
        
    Returns:
        None（原地修改nums1）
        
    Example:
        >>> nums1 = [1,2,3,0,0,0]
        >>> merge(nums1, 3, [2,5,6], 3)
        >>> # nums1变为[1,2,2,3,5,6]
    """
    i, j, k = m - 1, n - 1, m + n - 1
    
    # 从后向前合并
    while i >= 0 and j >= 0:
        if nums1[i] > nums2[j]:
            nums1[k] = nums1[i]
            i -= 1
        else:
            nums1[k] = nums2[j]
            j -= 1
        k -= 1
    
    # 如果nums2还有剩余元素，复制到nums1
    while j >= 0:
        nums1[k] = nums2[j]
        j -= 1
        k -= 1


# 自动生成Solution类（无需手动编写）
Solution = create_solution(merge)
