# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1824
标题: Maximum Number of Eaten Apples
难度: medium
链接: https://leetcode.cn/problems/maximum-number-of-eaten-apples/
题目类型: 贪心、数组、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1705. 吃苹果的最大数目 - 有一棵特殊的苹果树，一连 n 天，每天都可以长出若干个苹果。在第 i 天，树上会长出 apples[i] 个苹果，这些苹果将会在 days[i] 天后（也就是说，第 i + days[i] 天时）腐烂，变得无法食用。也可能有那么几天，树上不会长出新的苹果，此时用 apples[i] == 0 且 days[i] == 0 表示。 你打算每天 最多 吃一个苹果来保证营养均衡。注意，你可以在这 n 天之后继续吃苹果。 给你两个长度为 n 的整数数组 days 和 apples ，返回你可以吃掉的苹果的最大数目。 示例 1： 输入：apples = [1,2,3,5,2], days = [3,2,1,4,2] 输出：7 解释：你可以吃掉 7 个苹果： - 第一天，你吃掉第一天长出来的苹果。 - 第二天，你吃掉一个第二天长出来的苹果。 - 第三天，你吃掉一个第二天长出来的苹果。过了这一天，第三天长出来的苹果就已经腐烂了。 - 第四天到第七天，你吃的都是第四天长出来的苹果。 示例 2： 输入：apples = [3,0,0,0,0,2], days = [3,0,0,0,0,2] 输出：5 解释：你可以吃掉 5 个苹果： - 第一天到第三天，你吃的都是第一天长出来的苹果。 - 第四天和第五天不吃苹果。 - 第六天和第七天，你吃的都是第六天长出来的苹果。 提示： * apples.length == n * days.length == n * 1 <= n <= 2 * 104 * 0 <= apples[i], days[i] <= 2 * 104 * 只有在 apples[i] = 0 时，days[i] = 0 才成立
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用最小堆来追踪苹果的过期时间，并优先吃最早过期的苹果。

算法步骤:
1. 初始化一个最小堆，用于存储 (过期日期, 苹果数量)。
2. 遍历每一天：
   - 将当天新长出的苹果加入堆中。
   - 移除堆中已经过期的苹果。
   - 如果堆不为空，吃掉一个最早过期的苹果。
3. 在遍历完所有天数后，继续处理堆中的剩余苹果，直到没有可吃的苹果为止。

关键点:
- 使用最小堆来确保总是先吃最早过期的苹果。
- 每天只吃一个苹果，确保营养均衡。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是 days 数组的长度。每次插入和删除操作的时间复杂度为 O(log n)。
空间复杂度: O(n)，最坏情况下堆中会存储所有的苹果。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def eatenApples(apples: List[int], days: List[int]) -> int:
    """
    返回可以吃掉的苹果的最大数目。
    """
    heap = []
    n = len(apples)
    total_eaten = 0
    current_day = 0
    
    while current_day < n or heap:
        # 添加当天新长出的苹果
        if current_day < n and apples[current_day] > 0:
            heapq.heappush(heap, (current_day + days[current_day], apples[current_day]))
        
        # 移除已经过期的苹果
        while heap and heap[0][0] <= current_day:
            heapq.heappop(heap)
        
        # 吃掉一个最早过期的苹果
        if heap:
            expiration, count = heapq.heappop(heap)
            total_eaten += 1
            if count > 1:
                heapq.heappush(heap, (expiration, count - 1))
        
        current_day += 1
    
    return total_eaten

Solution = create_solution(eatenApples)