# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 115
标题: Distinct Subsequences
难度: hard
链接: https://leetcode.cn/problems/distinct-subsequences/
题目类型: 字符串、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
115. 不同的子序列 - 给你两个字符串 s 和 t ，统计并返回在 s 的 子序列 中 t 出现的个数。 测试用例保证结果在 32 位有符号整数范围内。 示例 1： 输入：s = "rabbbit", t = "rabbit" 输出：3 解释： 如下所示, 有 3 种可以从 s 中得到 "rabbit" 的方案。 rabbbit rabbbit rabbbit 示例 2： 输入：s = "babgbag", t = "bag" 输出：5 解释： 如下所示, 有 5 种可以从 s 中得到 "bag" 的方案。 babgbag babgbag babgbag babgbag babgbag 提示： * 1 <= s.length, t.length <= 1000 * s 和 t 由英文字母组成
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 动态规划，dp[i][j]表示s的前i个字符中t的前j个字符出现的次数

算法步骤:
1. 定义dp[i][j]表示s的前i个字符中t的前j个字符出现的次数
2. 如果s[i-1] == t[j-1]，可以选择匹配或不匹配
3. 如果s[i-1] != t[j-1]，只能不匹配
4. 返回dp[m][n]

关键点:
- 使用动态规划统计子序列个数
- 时间复杂度O(mn)，空间复杂度O(mn)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(mn) - m和n分别是s和t的长度
空间复杂度: O(mn) - dp数组空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from leetcode_solutions.utils.solution import create_solution


def distinct_subsequences(s: str, t: str) -> int:
    """
    函数式接口 - 统计t在s的子序列中出现的次数
    
    实现思路:
    使用动态规划，dp[i][j]表示s的前i个字符中t的前j个字符出现的次数。
    
    Args:
        s: 源字符串
        t: 目标字符串
        
    Returns:
        t在s的子序列中出现的次数
        
    Example:
        >>> distinct_subsequences("rabbbit", "rabbit")
        3
    """
    m, n = len(s), len(t)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # 空字符串是任何字符串的子序列
    for i in range(m + 1):
        dp[i][0] = 1
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s[i - 1] == t[j - 1]:
                # 可以选择匹配或不匹配
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
            else:
                # 只能不匹配
                dp[i][j] = dp[i - 1][j]
    
    return dp[m][n]


# 自动生成Solution类（无需手动编写）
Solution = create_solution(distinct_subsequences)
