# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1431
标题: All Ancestors of a Node in a Directed Acyclic Graph
难度: medium
链接: https://leetcode.cn/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/
题目类型: 深度优先搜索、广度优先搜索、图、拓扑排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2192. 有向无环图中一个节点的所有祖先 - 给你一个正整数 n ，它表示一个 有向无环图 中节点的数目，节点编号为 0 到 n - 1 （包括两者）。 给你一个二维整数数组 edges ，其中 edges[i] = [fromi, toi] 表示图中一条从 fromi 到 toi 的单向边。 请你返回一个数组 answer，其中 answer[i]是第 i 个节点的所有 祖先 ，这些祖先节点 升序 排序。 如果 u 通过一系列边，能够到达 v ，那么我们称节点 u 是节点 v 的 祖先 节点。 示例 1： [https://assets.leetcode.com/uploads/2019/12/12/e1.png] 输入：n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]] 输出：[[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]] 解释： 上图为输入所对应的图。 - 节点 0 ，1 和 2 没有任何祖先。 - 节点 3 有 2 个祖先 0 和 1 。 - 节点 4 有 2 个祖先 0 和 2 。 - 节点 5 有 3 个祖先 0 ，1 和 3 。 - 节点 6 有 5 个祖先 0 ，1 ，2 ，3 和 4 。 - 节点 7 有 4 个祖先 0 ，1 ，2 和 3 。 示例 2： [https://assets.leetcode.com/uploads/2019/12/12/e2.png] 输入：n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]] 输出：[[],[0],[0,1],[0,1,2],[0,1,2,3]] 解释： 上图为输入所对应的图。 - 节点 0 没有任何祖先。 - 节点 1 有 1 个祖先 0 。 - 节点 2 有 2 个祖先 0 和 1 。 - 节点 3 有 3 个祖先 0 ，1 和 2 。 - 节点 4 有 4 个祖先 0 ，1 ，2 和 3 。 提示： * 1 <= n <= 1000 * 0 <= edges.length <= min(2000, n * (n - 1) / 2) * edges[i].length == 2 * 0 <= fromi, toi <= n - 1 * fromi != toi * 图中不会有重边。 * 图是 有向 且 无环 的。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用深度优先搜索 (DFS) 来找到每个节点的所有祖先。

算法步骤:
1. 构建图的邻接表表示。
2. 初始化一个结果列表 `answer`，其中每个元素是一个空集合，用于存储每个节点的祖先。
3. 对于每个节点，使用 DFS 递归地找到其所有祖先，并将这些祖先添加到对应的结果集中。
4. 将结果集转换为升序排列的列表。

关键点:
- 使用集合来存储祖先以避免重复。
- 使用递归来实现 DFS。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n + m)，其中 n 是节点数，m 是边数。每个节点和每条边最多访问一次。
空间复杂度: O(n + m)，存储图的邻接表和递归调用栈的空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def get_ancestors(n: int, edges: List[List[int]]) -> List[List[int]]:
    # 构建图的邻接表表示
    graph = [[] for _ in range(n)]
    for u, v in edges:
        graph[u].append(v)
    
    # 结果列表，每个元素是一个集合，用于存储每个节点的祖先
    answer = [set() for _ in range(n)]
    
    def dfs(node: int, ancestors: set):
        # 将当前节点的祖先添加到结果集中
        answer[node].update(ancestors)
        
        # 递归地找到当前节点的所有后代的祖先
        for neighbor in graph[node]:
            if neighbor not in ancestors:
                dfs(neighbor, ancestors | {node})
    
    # 对每个节点进行 DFS
    for i in range(n):
        dfs(i, set())
    
    # 将结果集转换为升序排列的列表
    return [sorted(ans) for ans in answer]

Solution = create_solution(get_ancestors)