# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3847
标题: Minimum Swaps to Sort by Digit Sum
难度: medium
链接: https://leetcode.cn/problems/minimum-swaps-to-sort-by-digit-sum/
题目类型: 数组、哈希表、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3551. 数位和排序需要的最小交换次数 - 给你一个由 互不相同 的正整数组成的数组 nums，需要根据每个数字的数位和（即每一位数字相加求和）按 升序 对数组进行排序。如果两个数字的数位和相等，则较小的数字排在前面。 返回将 nums 排列为上述排序顺序所需的 最小 交换次数。 一次 交换 定义为交换数组中两个不同位置的值。 示例 1： 输入: nums = [37,100] 输出: 1 解释: * 计算每个整数的数位和：[3 + 7 = 10, 1 + 0 + 0 = 1] → [10, 1] * 根据数位和排序：[100, 37]。将 37 与 100 交换，得到排序后的数组。 * 因此，将 nums 排列为排序顺序所需的最小交换次数为 1。 示例 2： 输入: nums = [22,14,33,7] 输出: 0 解释: * 计算每个整数的数位和：[2 + 2 = 4, 1 + 4 = 5, 3 + 3 = 6, 7 = 7] → [4, 5, 6, 7] * 根据数位和排序：[22, 14, 33, 7]。数组已经是排序好的。 * 因此，将 nums 排列为排序顺序所需的最小交换次数为 0。 示例 3： 输入: nums = [18,43,34,16] 输出: 2 解释: * 计算每个整数的数位和：[1 + 8 = 9, 4 + 3 = 7, 3 + 4 = 7, 1 + 6 = 7] → [9, 7, 7, 7] * 根据数位和排序：[16, 34, 43, 18]。将 18 与 16 交换，再将 43 与 34 交换，得到排序后的数组。 * 因此，将 nums 排列为排序顺序所需的最小交换次数为 2。 提示: * 1 <= nums.length <= 105 * 1 <= nums[i] <= 109 * nums 由 互不相同 的正整数组成。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用贪心算法和并查集来计算最小交换次数。

算法步骤:
1. 计算每个数字的数位和，并将其与原数字一起存储在一个列表中。
2. 将该列表按数位和升序排序，如果数位和相同则按数字本身升序排序。
3. 使用并查集来跟踪每个数字的原始位置和目标位置，计算最小交换次数。

关键点:
- 使用并查集来高效地计算最小交换次数。
- 按数位和和数字本身排序以确保正确排序。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是 nums 的长度。排序操作的时间复杂度是 O(n log n)。
空间复杂度: O(n)，用于存储并查集和排序后的列表。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def find(parent, i):
    if parent[i] != i:
        parent[i] = find(parent, parent[i])
    return parent[i]

def union(parent, rank, x, y):
    root_x = find(parent, x)
    root_y = find(parent, y)
    if root_x != root_y:
        if rank[root_x] < rank[root_y]:
            parent[root_x] = root_y
        elif rank[root_x] > rank[root_y]:
            parent[root_y] = root_x
        else:
            parent[root_y] = root_x
            rank[root_x] += 1

def min_swaps_to_sort_by_digit_sum(nums: List[int]) -> int:
    n = len(nums)
    digit_sums = [(sum(int(digit) for digit in str(num)), num, i) for i, num in enumerate(nums)]
    digit_sums.sort()
    
    parent = list(range(n))
    rank = [0] * n
    
    original_positions = {num: i for i, num in enumerate(nums)}
    target_positions = [original_positions[digit_sum[1]] for digit_sum in digit_sums]
    
    swaps = 0
    for i in range(n):
        if i != target_positions[i]:
            swaps += 1
            union(parent, rank, i, target_positions[i])
    
    return swaps

Solution = create_solution(min_swaps_to_sort_by_digit_sum)