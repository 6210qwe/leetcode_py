# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1684
标题: Find Latest Group of Size M
难度: medium
链接: https://leetcode.cn/problems/find-latest-group-of-size-m/
题目类型: 数组、哈希表、二分查找、模拟
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1562. 查找大小为 M 的最新分组 - 给你一个数组 arr ，该数组表示一个从 1 到 n 的数字排列。有一个长度为 n 的二进制字符串，该字符串上的所有位最初都设置为 0 。 在从 1 到 n 的每个步骤 i 中（假设二进制字符串和 arr 都是从 1 开始索引的情况下），二进制字符串上位于位置 arr[i] 的位将会设为 1 。 给你一个整数 m ，请你找出二进制字符串上存在长度为 m 的一组 1 的最后步骤。一组 1 是一个连续的、由 1 组成的子串，且左右两边不再有可以延伸的 1 。 返回存在长度 恰好 为 m 的 一组 1 的最后步骤。如果不存在这样的步骤，请返回 -1 。 示例 1： 输入：arr = [3,5,1,2,4], m = 1 输出：4 解释： 步骤 1："00100"，由 1 构成的组：["1"] 步骤 2："00101"，由 1 构成的组：["1", "1"] 步骤 3："10101"，由 1 构成的组：["1", "1", "1"] 步骤 4："11101"，由 1 构成的组：["111", "1"] 步骤 5："11111"，由 1 构成的组：["11111"] 存在长度为 1 的一组 1 的最后步骤是步骤 4 。 示例 2： 输入：arr = [3,1,5,4,2], m = 2 输出：-1 解释： 步骤 1："00100"，由 1 构成的组：["1"] 步骤 2："10100"，由 1 构成的组：["1", "1"] 步骤 3："10101"，由 1 构成的组：["1", "1", "1"] 步骤 4："10111"，由 1 构成的组：["1", "111"] 步骤 5："11111"，由 1 构成的组：["11111"] 不管是哪一步骤都无法形成长度为 2 的一组 1 。 示例 3： 输入：arr = [1], m = 1 输出：1 示例 4： 输入：arr = [2,1], m = 2 输出：2 提示： * n == arr.length * 1 <= n <= 10^5 * 1 <= arr[i] <= n * arr 中的所有整数 互不相同 * 1 <= m <= arr.length
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用并查集来维护每个连通块的大小，并在每次插入新的 1 时更新连通块的大小。

算法步骤:
1. 初始化并查集，记录每个位置的父节点和连通块的大小。
2. 遍历 arr，对于每个位置 i，将其置为 1，并更新其左右相邻的连通块。
3. 如果当前连通块的大小等于 m，则记录当前步骤。
4. 最后返回最后一个满足条件的步骤，如果没有则返回 -1。

关键点:
- 使用并查集高效地管理连通块。
- 在每次插入新的 1 时，合并相邻的连通块并更新连通块的大小。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * α(n))，其中 n 是 arr 的长度，α 是反阿克曼函数。
空间复杂度: O(n)，用于存储并查集的数据结构。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.size = [1] * n
        self.count = [0] * (n + 1)
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x != root_y:
            if self.size[root_x] < self.size[root_y]:
                root_x, root_y = root_y, root_x
            self.parent[root_y] = root_x
            self.size[root_x] += self.size[root_y]
            self.count[self.size[root_y]] -= 1
            self.count[self.size[root_x]] += 1

def find_latest_step(arr: List[int], m: int) -> int:
    n = len(arr)
    uf = UnionFind(n)
    last_step = -1
    for step, i in enumerate(arr, start=1):
        i -= 1
        uf.count[uf.size[uf.find(i)]] -= 1
        uf.size[uf.find(i)] += 1
        uf.count[uf.size[uf.find(i)]] += 1
        
        if i > 0 and uf.size[uf.find(i - 1)] > 0:
            uf.union(i, i - 1)
        if i < n - 1 and uf.size[uf.find(i + 1)] > 0:
            uf.union(i, i + 1)
        
        if uf.count[m] > 0:
            last_step = step
    
    return last_step

Solution = create_solution(find_latest_step)