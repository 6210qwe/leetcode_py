# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 5
标题: 最长回文子串
难度: medium
链接: https://leetcode.cn/problems/longest-palindromic-substring/
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
给你一个字符串 s，找到 s 中最长的回文子串。

如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。

示例1:
输入: s = "babad"
输出: "bab"
解释: "aba" 同样是符合题意的答案。

示例2:
输入: s = "cbbd"
输出: "bb"

约束条件:
- 1 <= s.length <= 1000
- s 仅由数字和英文字母组成
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 中心扩展法，从每个可能的中心向两边扩展寻找回文串

算法步骤:
1. 定义辅助函数expand_around_center，从给定的左右位置向两边扩展
2. 遍历字符串的每个位置，作为可能的回文中心:
   - 对于奇数长度回文串：中心是单个字符，left = right = i
   - 对于偶数长度回文串：中心是两个字符之间，left = i, right = i + 1
3. 对每个中心调用expand_around_center，获取以该中心为起点的最长回文串
4. 比较所有回文串，返回最长的

关键点:
- 回文串有两种情况：奇数长度（中心是字符）和偶数长度（中心是字符间）
- 需要同时考虑两种情况
- 中心扩展法比动态规划更直观，且空间复杂度更低
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2) - 需要遍历每个位置作为中心，每个中心最多扩展n/2次
空间复杂度: O(1) - 只使用了常数额外空间（不考虑返回值的空间）
"""

# ============================================================================
# 代码实现
# ============================================================================

from leetcode_solutions.utils.solution import create_solution


def longest_palindrome(s: str) -> str:
    """
    函数式接口 - 中心扩展法实现
    
    实现思路:
    从每个可能的中心位置向两边扩展，寻找最长的回文子串。
    需要同时考虑奇数长度和偶数长度的回文串。
    
    Args:
        s: 输入字符串
        
    Returns:
        最长的回文子串
        
    Example:
        >>> longest_palindrome("babad")
        'bab'
        >>> longest_palindrome("cbbd")
        'bb'
    """
    if not s:
        return ""
    
    def expand_around_center(left: int, right: int) -> str:
        """
        从中心向两边扩展，寻找回文串
        
        Args:
            left: 左边界起始位置
            right: 右边界起始位置
            
        Returns:
            以该中心为起点的最长回文串
        """
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return s[left + 1:right]
    
    longest = ""
    for i in range(len(s)):
        # 奇数长度回文串（中心是字符）
        palindrome1 = expand_around_center(i, i)
        # 偶数长度回文串（中心是字符间）
        palindrome2 = expand_around_center(i, i + 1)
        
        # 更新最长回文串
        longest = max(longest, palindrome1, palindrome2, key=len)
    
    return longest


# 自动生成Solution类（无需手动编写）
Solution = create_solution(longest_palindrome)

