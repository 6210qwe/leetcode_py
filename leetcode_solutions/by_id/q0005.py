# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 5
标题: Longest Palindromic Substring
难度: medium
链接: https://leetcode.cn/problems/longest-palindromic-substring/
题目类型: 双指针、字符串、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
5. 最长回文子串 - 给你一个字符串 s，找到 s 中最长的 回文 子串。 示例 1： 输入：s = "babad" 输出："bab" 解释："aba" 同样是符合题意的答案。 示例 2： 输入：s = "cbbd" 输出："bb" 提示： * 1 <= s.length <= 1000 * s 仅由数字和英文字母组成
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 中心扩展法，从每个可能的中心点向两边扩展寻找回文子串

算法步骤:
1. 遍历字符串，以每个字符和每两个字符之间作为可能的中心点
2. 对于每个中心点，向两边扩展，直到不再是回文
3. 记录最长的回文子串的起始位置和长度
4. 返回最长回文子串

关键点:
- 回文串可能是奇数长度（中心是一个字符）或偶数长度（中心是两个字符之间）
- 中心扩展法的时间复杂度O(n²)，但实际运行效率高，代码简洁
- 相比动态规划，空间复杂度为O(1)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n²) - 对于每个中心点，最多扩展n/2次，共有2n-1个中心点
空间复杂度: O(1) - 只使用常数额外空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from leetcode_solutions.utils.solution import create_solution


def longest_palindrome(s: str) -> str:
    """
    函数式接口 - 中心扩展法实现
    
    实现思路:
    从每个可能的中心点向两边扩展，寻找最长的回文子串。
    
    Args:
        s: 输入字符串
        
    Returns:
        最长的回文子串
        
    Example:
        >>> longest_palindrome("babad")
        'bab'
        >>> longest_palindrome("cbbd")
        'bb'
    """
    if not s:
        return ""
    
    start = 0
    max_len = 1
    
    def expand_around_center(left: int, right: int) -> int:
        """从中心向两边扩展，返回回文串的长度"""
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return right - left - 1
    
    for i in range(len(s)):
        # 奇数长度的回文串（中心是字符）
        len1 = expand_around_center(i, i)
        # 偶数长度的回文串（中心是两个字符之间）
        len2 = expand_around_center(i, i + 1)
        
        # 取较长的回文串
        current_max = max(len1, len2)
        
        if current_max > max_len:
            max_len = current_max
            # 计算起始位置
            start = i - (current_max - 1) // 2
    
    return s[start:start + max_len]


# 自动生成Solution类（无需手动编写）
Solution = create_solution(longest_palindrome)
