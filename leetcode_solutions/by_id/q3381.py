# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3381
标题: Shortest Subarray With OR at Least K I
难度: easy
链接: https://leetcode.cn/problems/shortest-subarray-with-or-at-least-k-i/
题目类型: 位运算、数组、滑动窗口
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3095. 或值至少 K 的最短子数组 I - 给你一个 非负 整数数组 nums 和一个整数 k 。 如果一个数组中所有元素的按位或运算 OR 的值 至少 为 k ，那么我们称这个数组是 特别的 。 请你返回 nums 中 最短特别非空 子数组的长度，如果特别子数组不存在，那么返回 -1 。 示例 1： 输入：nums = [1,2,3], k = 2 输出：1 解释： 子数组 [3] 的按位 OR 值为 3 ，所以我们返回 1 。 注意，[2] 也是一个特别子数组。 示例 2： 输入：nums = [2,1,8], k = 10 输出：3 解释： 子数组 [2,1,8] 的按位 OR 值为 11 ，所以我们返回 3 。 示例 3： 输入：nums = [1,2], k = 0 输出：1 解释： 子数组 [1] 的按位 OR 值为 1 ，所以我们返回 1 。 提示： * 1 <= nums.length <= 50 * 0 <= nums[i] <= 50 * 0 <= k < 64
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用滑动窗口来找到满足条件的最短子数组。

算法步骤:
1. 初始化两个指针 left 和 right，以及当前窗口的按位或值 current_or。
2. 移动右指针 right 扩展窗口，更新 current_or。
3. 每次扩展窗口后，检查 current_or 是否大于等于 k。
4. 如果 current_or 大于等于 k，尝试收缩左指针 left 来找到最短子数组。
5. 记录最短子数组的长度。
6. 如果遍历完数组仍未找到满足条件的子数组，返回 -1。

关键点:
- 使用滑动窗口来动态调整子数组的范围。
- 通过按位或运算来判断当前窗口是否满足条件。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是数组的长度。每个元素最多被访问两次（一次由右指针，一次由左指针）。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def shortest_subarray_with_or_at_least_k(nums: List[int], k: int) -> int:
    """
    函数式接口 - 返回 nums 中最短特别非空子数组的长度，如果特别子数组不存在，返回 -1。
    """
    n = len(nums)
    min_length = float('inf')
    current_or = 0
    left = 0

    for right in range(n):
        current_or |= nums[right]
        while current_or >= k:
            min_length = min(min_length, right - left + 1)
            current_or ^= nums[left]
            left += 1

    return min_length if min_length != float('inf') else -1


Solution = create_solution(shortest_subarray_with_or_at_least_k)