# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3224
标题: Count the Number of Infection Sequences
难度: hard
链接: https://leetcode.cn/problems/count-the-number-of-infection-sequences/
题目类型: 数组、数学、组合数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2954. 统计感冒序列的数目 - 给你一个整数 n 和一个下标从 0 开始的整数数组 sick ，数组按 升序 排序。 有 n 位小朋友站成一排，按顺序编号为 0 到 n - 1 。数组 sick 包含一开始得了感冒的小朋友的位置。如果位置为 i 的小朋友得了感冒，他会传染给下标为 i - 1 或者 i + 1 的小朋友，前提 是被传染的小朋友存在且还没有得感冒。每一秒中， 至多一位 还没感冒的小朋友会被传染。 经过有限的秒数后，队列中所有小朋友都会感冒。感冒序列 指的是 所有 一开始没有感冒的小朋友最后得感冒的顺序序列。请你返回所有感冒序列的数目。 由于答案可能很大，请你将答案对 109 + 7 取余后返回。 注意，感冒序列 不 包含一开始就得了感冒的小朋友的下标。 示例 1： 输入：n = 5, sick = [0,4] 输出：4 解释：一开始，下标为 1 ，2 和 3 的小朋友没有感冒。总共有 4 个可能的感冒序列： - 一开始，下标为 1 和 3 的小朋友可以被传染，因为他们分别挨着有感冒的小朋友 0 和 4 ，令下标为 1 的小朋友先被传染。 然后，下标为 2 的小朋友挨着感冒的小朋友 1 ，下标为 3 的小朋友挨着感冒的小朋友 4 ，两位小朋友都可以被传染，令下标为 2 的小朋友被传染。 最后，下标为 3 的小朋友被传染，因为他挨着感冒的小朋友 2 和 4 ，感冒序列为 [1,2,3] 。 - 一开始，下标为 1 和 3 的小朋友可以被传染，因为他们分别挨着感冒的小朋友 0 和 4 ，令下标为 1 的小朋友先被传染。 然后，下标为 2 的小朋友挨着感冒的小朋友 1 ，下标为 3 的小朋友挨着感冒的小朋友 4 ，两位小朋友都可以被传染，令下标为 3 的小朋友被传染。 最后，下标为 2 的小朋友被传染，因为他挨着感冒的小朋友 1 和 3 ，感冒序列为 [1,3,2] 。 - 感冒序列 [3,1,2] ，被传染的顺序：[0,1,2,3,4] => [0,1,2,3,4] => [0,1,2,3,4] => [0,1,2,3,4] 。 - 感冒序列 [3,2,1] ，被传染的顺序：[0,1,2,3,4] => [0,1,2,3,4] => [0,1,2,3,4] => [0,1,2,3,4] 。 示例 2： 输入：n = 4, sick = [1] 输出：3 解释：一开始，下标为 0 ，2 和 3 的小朋友没有感冒。总共有 3 个可能的感冒序列： - 感冒序列 [0,2,3] ，被传染的顺序：[0,1,2,3] => [0,1,2,3] => [0,1,2,3] => [0,1,2,3] 。 - 感冒序列 [2,0,3] ，被传染的顺序：[0,1,2,3] => [0,1,2,3] => [0,1,2,3] => [0,1,2,3] 。 - 感冒序列 [2,3,0] ，被传染的顺序：[0,1,2,3] => [0,1,2,3] => [0,1,2,3] => [0,1,2,3] 。 提示： * 2 <= n <= 105 * 1 <= sick.length <= n - 1 * 0 <= sick[i] <= n - 1 * sick 按升序排列。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用组合数学和动态规划来计算所有可能的感冒序列。

算法步骤:
1. 计算每个连续未感冒的小朋友段的长度。
2. 使用组合数学计算每个段内的排列数。
3. 使用动态规划计算所有段的排列数的乘积。

关键点:
- 使用阶乘和逆元来高效计算组合数。
- 使用动态规划来处理多个段的情况。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import math

MOD = 10**9 + 7

def mod_inverse(x, p):
    return pow(x, p - 2, p)

def factorial_mod(n, p):
    fact = [1] * (n + 1)
    for i in range(2, n + 1):
        fact[i] = fact[i - 1] * i % p
    return fact

def count_infection_sequences(n: int, sick: List[int]) -> int:
    # 计算每个连续未感冒的小朋友段的长度
    segments = []
    prev = -1
    for s in sick:
        if s > 0 and s - prev > 1:
            segments.append(s - prev - 1)
        prev = s
    if n - 1 - sick[-1] > 0:
        segments.append(n - 1 - sick[-1])

    # 预计算阶乘和逆元
    fact = factorial_mod(n, MOD)
    inv_fact = [mod_inverse(f, MOD) for f in fact]

    def comb(n, k):
        return fact[n] * inv_fact[k] * inv_fact[n - k] % MOD

    # 动态规划计算所有段的排列数的乘积
    dp = [1]
    for length in segments:
        new_dp = [0] * (len(dp) + length)
        for i in range(len(dp)):
            for j in range(length + 1):
                new_dp[i + j] = (new_dp[i + j] + dp[i] * comb(length, j)) % MOD
        dp = new_dp

    return dp[-1]

Solution = create_solution(count_infection_sequences)