# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 775
标题: N-ary Tree Preorder Traversal
难度: easy
链接: https://leetcode.cn/problems/n-ary-tree-preorder-traversal/
题目类型: 栈、树、深度优先搜索
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
589. N 叉树的前序遍历 - 给定一个 n 叉树的根节点 root ，返回 其节点值的 前序遍历 。 n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。 示例 1： [https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png] 输入：root = [1,null,3,2,4,null,5,6] 输出：[1,3,5,6,2,4] 示例 2： [https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png] 输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] 输出：[1,2,3,6,7,11,14,4,8,12,5,9,13,10] 提示： * 节点总数在范围 [0, 104]内 * 0 <= Node.val <= 104 * n 叉树的高度小于或等于 1000 进阶：递归法很简单，你可以使用迭代法完成此题吗?
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用栈进行迭代前序遍历

算法步骤:
1. 初始化一个栈，并将根节点压入栈中。
2. 当栈不为空时，弹出栈顶节点并访问其值。
3. 将当前节点的子节点从右到左依次压入栈中（这样出栈时会按照从左到右的顺序）。

关键点:
- 使用栈来模拟递归调用的过程。
- 子节点从右到左压入栈中，以保证出栈时的顺序正确。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是节点数。每个节点都被访问一次。
空间复杂度: O(n)，最坏情况下，栈中可能会包含所有的节点。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.tree import Node
from leetcode_solutions.utils.solution import create_solution

def solution_function_name(root: 'Node') -> List[int]:
    """
    函数式接口 - 使用栈进行迭代前序遍历
    """
    if not root:
        return []
    
    stack = [root]
    result = []
    
    while stack:
        node = stack.pop()
        result.append(node.val)
        # 将子节点从右到左压入栈中
        for child in reversed(node.children):
            stack.append(child)
    
    return result

Solution = create_solution(solution_function_name)