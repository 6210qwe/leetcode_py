# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1559
标题: Cherry Pickup II
难度: hard
链接: https://leetcode.cn/problems/cherry-pickup-ii/
题目类型: 数组、动态规划、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1463. 摘樱桃 II - 给你一个 rows x cols 的矩阵 grid 来表示一块樱桃地。 grid 中每个格子的数字表示你能获得的樱桃数目。 你有两个机器人帮你收集樱桃，机器人 1 从左上角格子 (0,0) 出发，机器人 2 从右上角格子 (0, cols-1) 出发。 请你按照如下规则，返回两个机器人能收集的最多樱桃数目： * 从格子 (i,j) 出发，机器人可以移动到格子 (i+1, j-1)，(i+1, j) 或者 (i+1, j+1) 。 * 当一个机器人经过某个格子时，它会把该格子内所有的樱桃都摘走，然后这个位置会变成空格子，即没有樱桃的格子。 * 当两个机器人同时到达同一个格子时，它们中只有一个可以摘到樱桃。 * 两个机器人在任意时刻都不能移动到 grid 外面。 * 两个机器人最后都要到达 grid 最底下一行。 示例 1： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/05/30/sample_1_1802.png] 输入：grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]] 输出：24 解释：机器人 1 和机器人 2 的路径在上图中分别用绿色和蓝色表示。 机器人 1 摘的樱桃数目为 (3 + 2 + 5 + 2) = 12 。 机器人 2 摘的樱桃数目为 (1 + 5 + 5 + 1) = 12 。 樱桃总数为： 12 + 12 = 24 。 示例 2： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/05/30/sample_2_1802.png] 输入：grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]] 输出：28 解释：机器人 1 和机器人 2 的路径在上图中分别用绿色和蓝色表示。 机器人 1 摘的樱桃数目为 (1 + 9 + 5 + 2) = 17 。 机器人 2 摘的樱桃数目为 (1 + 3 + 4 + 3) = 11 。 樱桃总数为： 17 + 11 = 28 。 示例 3： 输入：grid = [[1,0,0,3],[0,0,0,3],[0,0,3,3],[9,0,3,3]] 输出：22 示例 4： 输入：grid = [[1,1],[1,1]] 输出：4 提示： * rows == grid.length * cols == grid[i].length * 2 <= rows, cols <= 70 * 0 <= grid[i][j] <= 100
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们定义一个三维数组 dp，其中 dp[r][c1][c2] 表示当机器人 1 在 (r, c1) 且机器人 2 在 (r, c2) 时，能收集到的最大樱桃数。

算法步骤:
1. 初始化 dp 数组，dp[0][0][cols-1] = grid[0][0] + grid[0][cols-1]。
2. 从第 1 行开始，逐行计算 dp 值。
3. 对于每一行 r，遍历所有可能的 (c1, c2) 组合，更新 dp[r][c1][c2]。
4. 更新 dp[r][c1][c2] 时，考虑上一行的所有可能状态 (c1', c2')，选择最大值。
5. 返回 dp[rows-1] 中的最大值。

关键点:
- 动态规划的状态转移方程：dp[r][c1][c2] = max(dp[r-1][c1'][c2']) + grid[r][c1] + (c1 != c2) * grid[r][c2]
- 边界条件处理：确保 c1 和 c2 不越界
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(rows * cols^2)
空间复杂度: O(rows * cols^2)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def cherryPickup(grid: List[List[int]]) -> int:
    rows, cols = len(grid), len(grid[0])
    dp = [[[float('-inf')] * cols for _ in range(cols)] for _ in range(rows)]
    
    # 初始状态
    dp[0][0][cols-1] = grid[0][0] + grid[0][cols-1]
    
    # 动态规划
    for r in range(1, rows):
        for c1 in range(cols):
            for c2 in range(cols):
                for dc1 in [-1, 0, 1]:
                    for dc2 in [-1, 0, 1]:
                        nc1, nc2 = c1 + dc1, c2 + dc2
                        if 0 <= nc1 < cols and 0 <= nc2 < cols:
                            dp[r][c1][c2] = max(dp[r][c1][c2], dp[r-1][nc1][nc2] + grid[r][c1] + (c1 != c2) * grid[r][c2])
    
    # 返回结果
    return max(max(row) for row in dp[rows-1])

Solution = create_solution(cherryPickup)