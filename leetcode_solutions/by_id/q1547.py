# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1547
标题: Destination City
难度: easy
链接: https://leetcode.cn/problems/destination-city/
题目类型: 数组、哈希表、字符串
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1436. 旅行终点站 - 给你一份旅游线路图，该线路图中的旅行线路用数组 paths 表示，其中 paths[i] = [cityAi, cityBi] 表示该线路将会从 cityAi 直接前往 cityBi 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。 题目数据保证线路图会形成一条不存在循环的线路，因此恰有一个旅行终点站。 示例 1： 输入：paths = [["London","New York"],["New York","Lima"],["Lima","Sao Paulo"]] 输出："Sao Paulo" 解释：从 "London" 出发，最后抵达终点站 "Sao Paulo" 。本次旅行的路线是 "London" -> "New York" -> "Lima" -> "Sao Paulo" 。 示例 2： 输入：paths = [["B","C"],["D","B"],["C","A"]] 输出："A" 解释：所有可能的线路是： "D" -> "B" -> "C" -> "A". "B" -> "C" -> "A". "C" -> "A". "A". 显然，旅行终点站是 "A" 。 示例 3： 输入：paths = [["A","Z"]] 输出："Z" 提示： * 1 <= paths.length <= 100 * paths[i].length == 2 * 1 <= cityAi.length, cityBi.length <= 10 * cityAi != cityBi * 所有字符串均由大小写英文字母和空格字符组成。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用集合来记录起点和终点城市，然后找到不在起点集合中的终点城市。

算法步骤:
1. 创建两个集合，一个用于存储所有起点城市，另一个用于存储所有终点城市。
2. 遍历路径列表，将每个路径的起点和终点分别加入对应的集合。
3. 返回在终点城市集合中但不在起点城市集合中的城市。

关键点:
- 使用集合操作来高效地查找终点城市。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是路径的数量。我们需要遍历路径列表一次。
空间复杂度: O(n)，我们使用了两个集合来存储起点和终点城市。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def find_destination_city(paths: List[List[str]]) -> str:
    """
    函数式接口 - 找到旅行的终点站
    """
    # 创建两个集合，一个用于存储所有起点城市，另一个用于存储所有终点城市
    start_cities = set()
    end_cities = set()

    # 遍历路径列表，将每个路径的起点和终点分别加入对应的集合
    for path in paths:
        start_cities.add(path[0])
        end_cities.add(path[1])

    # 返回在终点城市集合中但不在起点城市集合中的城市
    for city in end_cities:
        if city not in start_cities:
            return city

Solution = create_solution(find_destination_city)