# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1825
标题: Find Minimum Time to Finish All Jobs
难度: hard
链接: https://leetcode.cn/problems/find-minimum-time-to-finish-all-jobs/
题目类型: 位运算、数组、动态规划、回溯、状态压缩
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1723. 完成所有工作的最短时间 - 给你一个整数数组 jobs ，其中 jobs[i] 是完成第 i 项工作要花费的时间。 请你将这些工作分配给 k 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 工作时间 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 最大工作时间 得以 最小化 。 返回分配方案中尽可能 最小 的 最大工作时间 。 示例 1： 输入：jobs = [3,2,3], k = 3 输出：3 解释：给每位工人分配一项工作，最大工作时间是 3 。 示例 2： 输入：jobs = [1,2,4,7,8], k = 2 输出：11 解释：按下述方式分配工作： 1 号工人：1、2、8（工作时间 = 1 + 2 + 8 = 11） 2 号工人：4、7（工作时间 = 4 + 7 = 11） 最大工作时间是 11 。 提示： * 1 <= k <= jobs.length <= 12 * 1 <= jobs[i] <= 107
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用二分查找和贪心算法来找到最小的最大工作时间。

算法步骤:
1. 确定二分查找的范围：左边界为 `max(jobs)`，右边界为 `sum(jobs)`。
2. 对于每个中间值 `mid`，使用贪心算法检查是否可以将工作分配给 `k` 个工人，使得每个工人的工作时间不超过 `mid`。
3. 如果可以，则缩小右边界；否则，增加左边界。
4. 最终返回左边界作为结果。

关键点:
- 使用二分查找来优化搜索过程。
- 使用贪心算法来检查当前的 `mid` 是否可行。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log S)，其中 n 是 jobs 的长度，S 是 jobs 的总和。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def can_finish(jobs: List[int], mid: int, k: int) -> bool:
    count = 1
    current_time = 0
    for job in sorted(jobs, reverse=True):
        if current_time + job > mid:
            count += 1
            current_time = 0
        if count > k:
            return False
        current_time += job
    return True

def minimum_time_to_finish_jobs(jobs: List[int], k: int) -> int:
    left, right = max(jobs), sum(jobs)
    while left < right:
        mid = (left + right) // 2
        if can_finish(jobs, mid, k):
            right = mid
        else:
            left = mid + 1
    return left

Solution = create_solution(minimum_time_to_finish_jobs)