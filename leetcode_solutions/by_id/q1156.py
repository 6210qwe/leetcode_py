# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1156
标题: Occurrences After Bigram
难度: easy
链接: https://leetcode.cn/problems/occurrences-after-bigram/
题目类型: 字符串
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1078. Bigram 分词 - 给出第一个词 first 和第二个词 second，考虑在某些文本 text 中可能以 "first second third" 形式出现的情况，其中 second 紧随 first 出现，third 紧随 second 出现。 对于每种这样的情况，将第三个词 "third" 添加到答案中，并返回答案。 示例 1： 输入：text = "alice is a good girl she is a good student", first = "a", second = "good" 输出：["girl","student"] 示例 2： 输入：text = "we will we will rock you", first = "we", second = "will" 输出：["we","rock"] 提示： * 1 <= text.length <= 1000 * text 由小写英文字母和空格组成 * text 中的所有单词之间都由 单个空格字符 分隔 * 1 <= first.length, second.length <= 10 * first 和 second 由小写英文字母组成 * text 不包含任何前缀或尾随空格。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过遍历文本中的每个单词，检查是否存在连续的 "first second third" 序列，并记录第三个词 "third"。

算法步骤:
1. 将文本按空格分割成单词列表。
2. 遍历单词列表，检查是否存在 "first second" 序列。
3. 如果存在，则将紧跟其后的单词 "third" 添加到结果列表中。

关键点:
- 使用单次遍历来检查和记录 "first second third" 序列。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是文本的长度。我们需要遍历整个文本一次。
空间复杂度: O(n)，用于存储分割后的单词列表和结果列表。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def findOcurrences(text: str, first: str, second: str) -> List[str]:
    """
    函数式接口 - 返回所有符合条件的 "third" 词。
    """
    words = text.split()
    result = []
    
    for i in range(len(words) - 2):
        if words[i] == first and words[i + 1] == second:
            result.append(words[i + 2])
    
    return result

Solution = create_solution(findOcurrences)