# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 306
标题: Additive Number
难度: medium
链接: https://leetcode.cn/problems/additive-number/
题目类型: 字符串、回溯
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
306. 累加数 - 累加数 是一个字符串，组成它的数字可以形成累加序列。 一个有效的 累加序列 必须 至少 包含 3 个数。除了最开始的两个数以外，序列中的每个后续数字必须是它之前两个数字之和。 给你一个只包含数字 '0'-'9' 的字符串，编写一个算法来判断给定输入是否是 累加数 。如果是，返回 true ；否则，返回 false 。 说明：累加序列里的数，除数字 0 之外，不会 以 0 开头，所以不会出现 1, 2, 03 或者 1, 02, 3 的情况。 示例 1： 输入："112358" 输出：true 解释：累加序列为: 1, 1, 2, 3, 5, 8 。1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8 示例 2： 输入："199100199" 输出：true 解释：累加序列为: 1, 99, 100, 199。1 + 99 = 100, 99 + 100 = 199 提示： * 1 <= num.length <= 35 * num 仅由数字（0 - 9）组成 进阶：你计划如何处理由过大的整数输入导致的溢出?
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 回溯算法，枚举前两个数字的所有可能分割方式，然后验证后续数字

算法步骤:
1. 枚举第一个数字的所有可能长度
2. 枚举第二个数字的所有可能长度
3. 计算前两个数字的和，验证后续字符串是否以该和开头
4. 递归验证剩余部分

关键点:
- 回溯枚举前两个数字
- 时间复杂度O(n^3)，空间复杂度O(n)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^3) - n为字符串长度
空间复杂度: O(n) - 递归栈深度
"""

# ============================================================================
# 代码实现
# ============================================================================

from leetcode_solutions.utils.solution import create_solution


def additive_number(num: str) -> bool:
    """
    函数式接口 - 累加数
    
    实现思路:
    回溯算法，枚举前两个数字的所有可能分割方式，然后验证后续数字。
    
    Args:
        num: 只包含数字的字符串
        
    Returns:
        是否是累加数
        
    Example:
        >>> additive_number("112358")
        True
    """
    n = len(num)
    
    def is_valid(first: str, second: str, start: int) -> bool:
        """验证从start位置开始，是否满足累加序列"""
        if start == n:
            return True
        
        # 计算和
        total = str(int(first) + int(second))
        
        # 检查后续字符串是否以total开头
        if not num.startswith(total, start):
            return False
        
        # 递归验证
        return is_valid(second, total, start + len(total))
    
    # 枚举前两个数字的长度
    for i in range(1, n // 2 + 1):
        for j in range(1, (n - i) // 2 + 1):
            first = num[:i]
            second = num[i:i+j]
            
            # 检查是否有前导零
            if (len(first) > 1 and first[0] == '0') or (len(second) > 1 and second[0] == '0'):
                continue
            
            if is_valid(first, second, i + j):
                return True
    
    return False


# 自动生成Solution类（无需手动编写）
Solution = create_solution(additive_number)
