# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 50
标题: Pow(x, n)
难度: medium
链接: https://leetcode.cn/problems/powx-n/
题目类型: 递归、数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
50. Pow(x, n) - 实现 pow(x, n) [https://www.cplusplus.com/reference/valarray/pow/] ，即计算 x 的整数 n 次幂函数（即，xn ）。 示例 1： 输入：x = 2.00000, n = 10 输出：1024.00000 示例 2： 输入：x = 2.10000, n = 3 输出：9.26100 示例 3： 输入：x = 2.00000, n = -2 输出：0.25000 解释：2-2 = 1/22 = 1/4 = 0.25 提示： * -100.0 < x < 100.0 * -231 <= n <= 231-1 * n 是一个整数 * 要么 x 不为零，要么 n > 0 。 * -104 <= xn <= 104
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 快速幂算法，将指数n分解为二进制，利用x^(2^k) = (x^(2^(k-1)))^2

算法步骤:
1. 处理特殊情况：n为0返回1，n为负数转换为正数并取倒数
2. 快速幂计算：
   - 初始化result = 1, base = x
   - 当n > 0时：
     * 如果n是奇数，result *= base
     * base *= base（平方）
     * n //= 2（右移一位）
3. 返回result

关键点:
- 利用二进制分解：x^n = x^(b0*2^0 + b1*2^1 + ...) = x^(b0*2^0) * x^(b1*2^1) * ...
- 每次将指数减半，时间复杂度O(log n)
- 处理负数指数：x^(-n) = 1 / x^n
- 处理整数溢出：n可能是-2^31，取绝对值时注意溢出
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(log n) - 指数每次减半
空间复杂度: O(1) - 只使用常数额外空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from leetcode_solutions.utils.solution import create_solution


def powx_n(x: float, n: int) -> float:
    """
    函数式接口 - 快速幂算法
    
    实现思路:
    使用快速幂算法，将指数n分解为二进制形式，通过平方和乘法快速计算x的n次幂。
    
    Args:
        x: 底数
        n: 指数（整数）
        
    Returns:
        x的n次幂
        
    Example:
        >>> powx_n(2.0, 10)
        1024.0
        >>> powx_n(2.0, -2)
        0.25
    """
    # 处理负数指数
    if n < 0:
        x = 1 / x
        n = -n
    
    result = 1.0
    base = x
    
    # 快速幂计算
    while n > 0:
        if n % 2 == 1:  # 如果n是奇数
            result *= base
        base *= base  # 平方
        n //= 2  # 右移一位（相当于除以2）
    
    return result


# 自动生成Solution类（无需手动编写）
Solution = create_solution(powx_n)
