# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 100299
标题: 删除链表的节点
难度: easy
链接: https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/
题目类型: 链表
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCR 136. 删除链表的节点 - 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。 返回删除后的链表的头节点。 示例 1： 输入：head = [4,5,1,9], val = 5 输出：[4,1,9] 解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9. 示例 2： 输入：head = [4,5,1,9], val = 1 输出：[4,5,9] 解释：给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9. 说明： * 题目保证链表中节点的值互不相同 * 若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用双指针法遍历链表，找到要删除的节点并进行删除操作。

算法步骤:
1. 初始化两个指针 `prev` 和 `curr`，分别指向链表的虚拟头节点和实际头节点。
2. 遍历链表，直到找到值为 `val` 的节点或遍历到链表末尾。
3. 如果找到值为 `val` 的节点，将 `prev` 的 `next` 指向 `curr` 的 `next`，从而删除 `curr` 节点。
4. 返回虚拟头节点的 `next` 作为新的链表头。

关键点:
- 使用虚拟头节点简化边界条件处理。
- 双指针法可以有效找到并删除目标节点。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是链表的长度。最坏情况下需要遍历整个链表。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.solution import create_solution


def delete_node(head: Optional[ListNode], val: int) -> Optional[ListNode]:
    """
    删除链表中值为 val 的节点，并返回删除后的链表头节点。
    """
    # 创建虚拟头节点
    dummy = ListNode(0)
    dummy.next = head
    prev, curr = dummy, head

    # 遍历链表
    while curr:
        if curr.val == val:
            prev.next = curr.next
            break
        prev, curr = curr, curr.next

    return dummy.next


Solution = create_solution(delete_node)