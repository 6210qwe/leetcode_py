# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1615
标题: Range Sum of Sorted Subarray Sums
难度: medium
链接: https://leetcode.cn/problems/range-sum-of-sorted-subarray-sums/
题目类型: 数组、双指针、二分查找、前缀和、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1508. 子数组和排序后的区间和 - 给你一个数组 nums ，它包含 n 个正整数。你需要计算所有非空连续子数组的和，并将它们按升序排序，得到一个新的包含 n * (n + 1) / 2 个数字的数组。 请你返回在新数组中下标为 left 到 right （下标从 1 开始）的所有数字和（包括左右端点）。由于答案可能很大，请你将它对 10^9 + 7 取模后返回。 示例 1： 输入：nums = [1,2,3,4], n = 4, left = 1, right = 5 输出：13 解释：所有的子数组和为 1, 3, 6, 10, 2, 5, 9, 3, 7, 4 。将它们升序排序后，我们得到新的数组 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10] 。下标从 le = 1 到 ri = 5 的和为 1 + 2 + 3 + 3 + 4 = 13 。 示例 2： 输入：nums = [1,2,3,4], n = 4, left = 3, right = 4 输出：6 解释：给定数组与示例 1 一样，所以新数组为 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10] 。下标从 le = 3 到 ri = 4 的和为 3 + 3 = 6 。 示例 3： 输入：nums = [1,2,3,4], n = 4, left = 1, right = 10 输出：50 提示： * 1 <= nums.length <= 10^3 * nums.length == n * 1 <= nums[i] <= 100 * 1 <= left <= right <= n * (n + 1) / 2
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用优先队列（最小堆）来维护当前子数组和的最小值，并逐步生成所有子数组和。

算法步骤:
1. 初始化一个最小堆，将每个元素作为单个子数组的和加入堆。
2. 每次从堆中取出最小值，将其加入结果数组，并将该子数组的下一个元素加入堆。
3. 重复上述过程，直到找到第 `right` 个最小的子数组和。
4. 计算结果数组中从 `left-1` 到 `right-1` 的和，并对 10^9 + 7 取模。

关键点:
- 使用最小堆来高效地获取当前最小的子数组和。
- 通过逐步扩展子数组来生成所有可能的子数组和。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2 log n)，其中 n 是数组的长度。每次从堆中取出元素的时间复杂度是 O(log n)，总共需要取出 n * (n + 1) / 2 个元素。
空间复杂度: O(n^2)，因为我们需要存储所有可能的子数组和。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def range_sum(nums: List[int], n: int, left: int, right: int) -> int:
    MOD = 10**9 + 7
    min_heap = []
    
    # 将每个元素作为单个子数组的和加入堆
    for i in range(n):
        heapq.heappush(min_heap, (nums[i], i))
    
    result = 0
    current_sum = 0
    
    # 从堆中取出最小值，直到找到第 `right` 个最小的子数组和
    for k in range(1, right + 1):
        val, idx = heapq.heappop(min_heap)
        if k >= left:
            current_sum += val
            current_sum %= MOD
        if idx < n - 1:
            heapq.heappush(min_heap, (val + nums[idx + 1], idx + 1))
    
    return current_sum

Solution = create_solution(range_sum)