# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2738
标题: Count the Number of K-Free Subsets
难度: medium
链接: https://leetcode.cn/problems/count-the-number-of-k-free-subsets/
题目类型: 数组、数学、动态规划、组合数学、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2638. 统计 K-Free 子集的总数 - 备战技术面试？力扣提供海量技术面试资源，帮助你高效提升编程技能,轻松拿下世界 IT 名企 Dream Offer。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划和组合数学来计算 K-Free 子集的数量。

算法步骤:
1. 对数组进行排序，找到所有长度为 k 的等差子序列。
2. 对于每个等差子序列，使用动态规划计算其 K-Free 子集的数量。
3. 将所有等差子序列的 K-Free 子集数量相乘，得到最终结果。

关键点:
- 通过排序和双指针找到所有长度为 k 的等差子序列。
- 使用动态规划计算每个等差子序列的 K-Free 子集数量。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def count_k_free_subsets(nums: List[int], k: int) -> int:
    MOD = 10**9 + 7
    nums.sort()
    n = len(nums)
    
    def dp(length: int) -> int:
        if length == 0:
            return 1
        if length == 1:
            return 2
        a, b = 1, 2
        for _ in range(2, length + 1):
            a, b = b, (a + b) % MOD
        return b
    
    result = 1
    i = 0
    while i < n:
        j = i + 1
        while j < n and nums[j] - nums[i] < k:
            j += 1
        length = j - i
        result = (result * dp(length)) % MOD
        i = j
    
    return result

Solution = create_solution(count_k_free_subsets)