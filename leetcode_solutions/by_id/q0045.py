# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 45
标题: Jump Game II
难度: medium
链接: https://leetcode.cn/problems/jump-game-ii/
题目类型: 贪心、数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
45. 跳跃游戏 II - 给定一个长度为 n 的 0 索引整数数组 nums。初始位置在下标 0。 每个元素 nums[i] 表示从索引 i 向后跳转的最大长度。换句话说，如果你在索引 i 处，你可以跳转到任意 (i + j) 处： * 0 <= j <= nums[i] 且 * i + j < n 返回到达 n - 1 的最小跳跃次数。测试用例保证可以到达 n - 1。 示例 1: 输入: nums = [2,3,1,1,4] 输出: 2 解释: 跳到最后一个位置的最小跳跃数是 2。 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 示例 2: 输入: nums = [2,3,0,1,4] 输出: 2 提示: * 1 <= nums.length <= 104 * 0 <= nums[i] <= 1000 * 题目保证可以到达 n - 1
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 贪心算法，每次选择能跳得最远的位置

算法步骤:
1. 使用end记录当前能到达的最远位置
2. 使用max_pos记录在当前位置能到达的最远位置
3. 当到达end时，增加跳跃次数，更新end为max_pos

关键点:
- 贪心策略，每次选择最远位置
- 时间复杂度O(n)，空间复杂度O(1)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 需要遍历数组一次
空间复杂度: O(1) - 只使用常数额外空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from leetcode_solutions.utils.solution import create_solution


def jump_game_ii(nums: List[int]) -> int:
    """
    函数式接口 - 跳跃游戏II
    
    实现思路:
    贪心算法，每次选择能跳得最远的位置。
    
    Args:
        nums: 0索引整数数组
        
    Returns:
        到达最后一个位置的最小跳跃次数
        
    Example:
        >>> jump_game_ii([2,3,1,1,4])
        2
    """
    n = len(nums)
    if n <= 1:
        return 0
    
    jumps = 0
    end = 0
    max_pos = 0
    
    for i in range(n - 1):
        max_pos = max(max_pos, i + nums[i])
        if i == end:
            jumps += 1
            end = max_pos
            if end >= n - 1:
                break
    
    return jumps


# 自动生成Solution类（无需手动编写）
Solution = create_solution(jump_game_ii)
