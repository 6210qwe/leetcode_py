# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2954
标题: Maximum Sum of Almost Unique Subarray
难度: medium
链接: https://leetcode.cn/problems/maximum-sum-of-almost-unique-subarray/
题目类型: 数组、哈希表、滑动窗口
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2841. 几乎唯一子数组的最大和 - 给你一个整数数组 nums 和两个正整数 m 和 k 。 请你返回 nums 中长度为 k 的 几乎唯一 子数组的 最大和 ，如果不存在几乎唯一子数组，请你返回 0 。 如果 nums 的一个子数组有至少 m 个互不相同的元素，我们称它是 几乎唯一 子数组。 子数组指的是一个数组中一段连续 非空 的元素序列。 示例 1： 输入：nums = [2,6,7,3,1,7], m = 3, k = 4 输出：18 解释：总共有 3 个长度为 k = 4 的几乎唯一子数组。分别为 [2, 6, 7, 3] ，[6, 7, 3, 1] 和 [7, 3, 1, 7] 。这些子数组中，和最大的是 [2, 6, 7, 3] ，和为 18 。 示例 2： 输入：nums = [5,9,9,2,4,5,4], m = 1, k = 3 输出：23 解释：总共有 5 个长度为 k = 3 的几乎唯一子数组。分别为 [5, 9, 9] ，[9, 9, 2] ，[9, 2, 4] ，[2, 4, 5] 和 [4, 5, 4] 。这些子数组中，和最大的是 [5, 9, 9] ，和为 23 。 示例 3： 输入：nums = [1,2,1,2,1,2,1], m = 3, k = 3 输出：0 解释：输入数组中不存在长度为 k = 3 的子数组含有至少 m = 3 个互不相同元素的子数组。所以不存在几乎唯一子数组，最大和为 0 。 提示： * 1 <= nums.length <= 2 * 104 * 1 <= m <= k <= nums.length * 1 <= nums[i] <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用滑动窗口和哈希表来维护当前窗口内的元素及其频率，并计算窗口内不同元素的数量。

算法步骤:
1. 初始化滑动窗口的左右指针 `left` 和 `right`，以及一个哈希表 `freq` 来记录窗口内元素的频率。
2. 初始化变量 `max_sum` 用于记录最大和，`current_sum` 用于记录当前窗口的和。
3. 滑动窗口从左到右遍历数组：
   - 将 `nums[right]` 加入窗口，并更新 `freq` 和 `current_sum`。
   - 如果窗口大小达到 `k`，检查窗口内不同元素的数量是否大于等于 `m`，如果是则更新 `max_sum`。
   - 移动左指针 `left`，移除 `nums[left]` 并更新 `freq` 和 `current_sum`。
4. 返回 `max_sum`。

关键点:
- 使用滑动窗口和哈希表来高效地维护窗口内的元素及其频率。
- 通过滑动窗口的移动来动态更新窗口内的和及不同元素的数量。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 每个元素最多被处理两次（一次加入窗口，一次移出窗口）。
空间复杂度: O(k) - 哈希表 `freq` 最多存储 `k` 个元素。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def max_sum_of_almost_unique_subarray(nums: List[int], m: int, k: int) -> int:
    """
    返回长度为 k 的几乎唯一子数组的最大和。
    """
    if k > len(nums):
        return 0
    
    left = 0
    current_sum = 0
    max_sum = 0
    freq = {}
    
    for right in range(len(nums)):
        # 将 nums[right] 加入窗口
        current_sum += nums[right]
        freq[nums[right]] = freq.get(nums[right], 0) + 1
        
        # 窗口大小达到 k
        if right - left + 1 == k:
            # 检查窗口内不同元素的数量
            if len(freq) >= m:
                max_sum = max(max_sum, current_sum)
            
            # 移除 nums[left] 并更新窗口
            freq[nums[left]] -= 1
            if freq[nums[left]] == 0:
                del freq[nums[left]]
            current_sum -= nums[left]
            left += 1
    
    return max_sum

Solution = create_solution(max_sum_of_almost_unique_subarray)