# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 356
标题: Line Reflection
难度: medium
链接: https://leetcode.cn/problems/line-reflection/
题目类型: 数组、哈希表、数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
356. 直线镜像 - 备战技术面试？力扣提供海量技术面试资源，帮助你高效提升编程技能,轻松拿下世界 IT 名企 Dream Offer。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 找到可能的对称轴 x = mid，并检查所有点是否关于该直线成镜像

算法步骤:
1. 若点集为空，显然可以视为关于任意直线对称，直接返回 True。
2. 先扫一遍点集，求出所有点的最小横坐标 minX 和最大横坐标 maxX，潜在对称轴为 x = (minX + maxX) / 2。
3. 使用哈希集合存储所有点坐标 (x, y)，方便 O(1) 查询。
4. 再次遍历每个点 (x, y)，计算其关于对称轴的镜像点 x' = minX + maxX - x，检查 (x', y) 是否在集合中，若有任意一个不存在则返回 False。
5. 如果所有点的镜像都存在，则该点集关于直线 x = mid 对称，返回 True。

关键点:
- 对称轴一定是所有点横坐标最小值与最大值的中点，不需要穷举所有直线。
- 使用集合而不是排序+双指针可以避免处理重复点和浮点比较的问题。
- 注意整数与浮点的计算，直接用 minX + maxX - x 作为对称点的横坐标可保证是整数。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 需要两次线性扫描点集。
空间复杂度: O(n) - 需要一个集合保存所有点坐标。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def line_reflection(points: List[List[int]]) -> bool:
    """
    判断给定点集是否关于某条垂直直线对称。

    对称轴必为 minX 和 maxX 的中点，检查每个点的镜像是否都在集合中。
    """
    if not points:
        return True

    min_x = min(x for x, _ in points)
    max_x = max(x for x, _ in points)
    s = {(x, y) for x, y in points}
    s2 = min_x + max_x  # 对称点横坐标之和

    for x, y in points:
        if (s2 - x, y) not in s:
            return False
    return True


# 自动生成Solution类（无需手动编写）
Solution = create_solution(line_reflection)
