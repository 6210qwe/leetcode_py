# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2078
标题: Maximum Compatibility Score Sum
难度: medium
链接: https://leetcode.cn/problems/maximum-compatibility-score-sum/
题目类型: 位运算、数组、动态规划、回溯、状态压缩
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1947. 最大兼容性评分和 - 有一份由 n 个问题组成的调查问卷，每个问题的答案要么是 0（no，否），要么是 1（yes，是）。 这份调查问卷被分发给 m 名学生和 m 名导师，学生和导师的编号都是从 0 到 m - 1 。学生的答案用一个二维整数数组 students 表示，其中 students[i] 是一个整数数组，包含第 i 名学生对调查问卷给出的答案（下标从 0 开始）。导师的答案用一个二维整数数组 mentors 表示，其中 mentors[j] 是一个整数数组，包含第 j 名导师对调查问卷给出的答案（下标从 0 开始）。 每个学生都会被分配给 一名 导师，而每位导师也会分配到 一名 学生。配对的学生与导师之间的兼容性评分等于学生和导师答案相同的次数。 * 例如，学生答案为[1, 0, 1] 而导师答案为 [0, 0, 1] ，那么他们的兼容性评分为 2 ，因为只有第二个和第三个答案相同。 请你找出最优的学生与导师的配对方案，以 最大程度上 提高 兼容性评分和 。 给你 students 和 mentors ，返回可以得到的 最大兼容性评分和 。 示例 1： 输入：students = [[1,1,0],[1,0,1],[0,0,1]], mentors = [[1,0,0],[0,0,1],[1,1,0]] 输出：8 解释：按下述方式分配学生和导师： - 学生 0 分配给导师 2 ，兼容性评分为 3 。 - 学生 1 分配给导师 0 ，兼容性评分为 2 。 - 学生 2 分配给导师 1 ，兼容性评分为 3 。 最大兼容性评分和为 3 + 2 + 3 = 8 。 示例 2： 输入：students = [[0,0],[0,0],[0,0]], mentors = [[1,1],[1,1],[1,1]] 输出：0 解释：任意学生与导师配对的兼容性评分都是 0 。 提示： * m == students.length == mentors.length * n == students[i].length == mentors[j].length * 1 <= m, n <= 8 * students[i][k] 为 0 或 1 * mentors[j][k] 为 0 或 1
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用回溯法来找到所有可能的配对方案，并计算每种方案的兼容性评分和，选择最大值。

算法步骤:
1. 计算每个学生和每个导师之间的兼容性评分。
2. 使用回溯法尝试所有可能的学生和导师的配对方案。
3. 在每一步中，选择一个未分配的学生和一个未分配的导师进行配对，并递归地继续配对其他学生和导师。
4. 递归终止条件是所有学生都已分配完毕，此时计算当前方案的兼容性评分和。
5. 选择最大兼容性评分和作为最终结果。

关键点:
- 使用位掩码来表示哪些学生和导师已被分配。
- 回溯法确保所有可能的配对方案都被考虑。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m!)
空间复杂度: O(m)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def max_compatibility_score_sum(students: List[List[int]], mentors: List[List[int]]) -> int:
    m = len(students)
    n = len(students[0])
    
    # 计算每个学生和每个导师之间的兼容性评分
    compatibility = [[0] * m for _ in range(m)]
    for i in range(m):
        for j in range(m):
            score = sum(a == b for a, b in zip(students[i], mentors[j]))
            compatibility[i][j] = score
    
    # 使用回溯法尝试所有可能的配对方案
    def backtrack(student_idx, used_mask):
        if student_idx == m:
            return 0
        
        max_score = 0
        for mentor_idx in range(m):
            if not (used_mask & (1 << mentor_idx)):
                current_score = compatibility[student_idx][mentor_idx] + backtrack(student_idx + 1, used_mask | (1 << mentor_idx))
                max_score = max(max_score, current_score)
        
        return max_score
    
    return backtrack(0, 0)

Solution = create_solution(max_compatibility_score_sum)