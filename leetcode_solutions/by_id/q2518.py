# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2518
标题: The Employee That Worked on the Longest Task
难度: easy
链接: https://leetcode.cn/problems/the-employee-that-worked-on-the-longest-task/
题目类型: 数组
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2432. 处理用时最长的那个任务的员工 - 共有 n 位员工，每位员工都有一个从 0 到 n - 1 的唯一 id 。 给你一个二维整数数组 logs ，其中 logs[i] = [idi, leaveTimei] ： * idi 是处理第 i 个任务的员工的 id ，且 * leaveTimei 是员工完成第 i 个任务的时刻。所有 leaveTimei 的值都是 唯一 的。 注意，第 i 个任务在第 (i - 1) 个任务结束后立即开始，且第 0 个任务从时刻 0 开始。 返回处理用时最长的那个任务的员工的 id 。如果存在两个或多个员工同时满足，则返回几人中 最小 的 id 。 示例 1： 输入：n = 10, logs = [[0,3],[2,5],[0,9],[1,15]] 输出：1 解释： 任务 0 于时刻 0 开始，且在时刻 3 结束，共计 3 个单位时间。 任务 1 于时刻 3 开始，且在时刻 5 结束，共计 2 个单位时间。 任务 2 于时刻 5 开始，且在时刻 9 结束，共计 4 个单位时间。 任务 3 于时刻 9 开始，且在时刻 15 结束，共计 6 个单位时间。 时间最长的任务是任务 3 ，而 id 为 1 的员工是处理此任务的员工，所以返回 1 。 示例 2： 输入：n = 26, logs = [[1,1],[3,7],[2,12],[7,17]] 输出：3 解释： 任务 0 于时刻 0 开始，且在时刻 1 结束，共计 1 个单位时间。 任务 1 于时刻 1 开始，且在时刻 7 结束，共计 6 个单位时间。 任务 2 于时刻 7 开始，且在时刻 12 结束，共计 5 个单位时间。 任务 3 于时刻 12 开始，且在时刻 17 结束，共计 5 个单位时间。 时间最长的任务是任务 1 ，而 id 为 3 的员工是处理此任务的员工，所以返回 3 。 示例 3： 输入：n = 2, logs = [[0,10],[1,20]] 输出：0 解释： 任务 0 于时刻 0 开始，且在时刻 10 结束，共计 10 个单位时间。 任务 1 于时刻 10 开始，且在时刻 20 结束，共计 10 个单位时间。 时间最长的任务是任务 0 和 1 ，处理这两个任务的员工的 id 分别是 0 和 1 ，所以返回最小的 0 。 提示： * 2 <= n <= 500 * 1 <= logs.length <= 500 * logs[i].length == 2 * 0 <= idi <= n - 1 * 1 <= leaveTimei <= 500 * idi != idi + 1 * leaveTimei 按严格递增顺序排列
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过遍历 logs 数组，计算每个任务的持续时间，并记录最长任务的员工 id。

算法步骤:
1. 初始化变量 max_duration 为 0，用于记录最长任务的持续时间。
2. 初始化变量 employee_id 为 None，用于记录处理最长任务的员工 id。
3. 遍历 logs 数组，对于每个任务：
   - 计算任务的持续时间。
   - 如果当前任务的持续时间大于 max_duration，更新 max_duration 和 employee_id。
   - 如果当前任务的持续时间等于 max_duration 且当前员工 id 小于 employee_id，更新 employee_id。
4. 返回 employee_id。

关键点:
- 使用一次遍历即可找到最长任务的员工 id。
- 在更新最长任务时，需要同时考虑持续时间和员工 id。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m)，其中 m 是 logs 的长度。我们只需要遍历一次 logs 数组。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def find_longest_task_employee(n: int, logs: List[List[int]]) -> int:
    """
    函数式接口 - 找到处理用时最长的那个任务的员工 id
    """
    max_duration = 0
    employee_id = None
    
    for i in range(len(logs)):
        if i == 0:
            duration = logs[i][1]
        else:
            duration = logs[i][1] - logs[i - 1][1]
        
        if duration > max_duration or (duration == max_duration and logs[i][0] < employee_id):
            max_duration = duration
            employee_id = logs[i][0]
    
    return employee_id


Solution = create_solution(find_longest_task_employee)