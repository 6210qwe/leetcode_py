# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000140
标题: 黑白方格画
难度: easy
链接: https://leetcode.cn/problems/ccw6C7/
题目类型: 数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCP 22. 黑白方格画 - 小扣注意到秋日市集上有一个创作黑白方格画的摊位。摊主给每个顾客提供一个固定在墙上的白色画板，画板不能转动。画板上有 `n * n` 的网格。绘画规则为，小扣可以选择任意多行以及任意多列的格子涂成黑色（选择的整行、整列均需涂成黑色），所选行数、列数均可为 0。 小扣希望最终的成品上需要有 `k` 个黑色格子，请返回小扣共有多少种涂色方案。 注意：两个方案中任意一个相同位置的格子颜色不同，就视为不同的方案。 **示例 1：** >输入：`n = 2, k = 2` > >输出：`4` > >解释：一共有四种不同的方案： >第一种方案：涂第一列； >第二种方案：涂第二列； >第三种方案：涂第一行； >第四种方案：涂第二行。 **示例 2：** >输入：`n = 2, k = 1` > >输出：`0` > >解释：不可行，因为第一次涂色至少会涂两个黑格。 **示例 3：** >输入：`n = 2, k = 4` > >输出：`1` > >解释：共有 2*2=4 个格子，仅有一种涂色方案。 **限制：** - `1 <= n <= 6` - `0 <= k <= n * n`
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过组合数学计算所有可能的行和列的选择，使得黑色格子的数量等于 k。

算法步骤:
1. 遍历所有可能的行选择数量 r 和列选择数量 c。
2. 计算选择 r 行和 c 列后黑色格子的数量。
3. 如果黑色格子的数量等于 k，则累加该方案的数量。

关键点:
- 使用组合数公式 C(n, k) 计算从 n 个元素中选择 k 个元素的方案数。
- 通过双重循环遍历所有可能的行和列的选择。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2)
空间复杂度: O(1)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution

def combination(n, k):
    """计算组合数 C(n, k)"""
    if k > n:
        return 0
    if k == 0 or k == n:
        return 1
    k = min(k, n - k)  # 取较小的值以减少计算量
    result = 1
    for i in range(k):
        result *= (n - i)
        result //= (i + 1)
    return result

def solution_function_name(n: int, k: int) -> int:
    """
    函数式接口 - 计算涂色方案数量
    """
    if k == 0:
        return 1  # 不涂任何格子也是一种方案
    if k == n * n:
        return 1  # 涂满整个画板也是一种方案
    
    total_ways = 0
    for r in range(n + 1):  # 遍历所有可能的行选择数量
        for c in range(n + 1):  # 遍历所有可能的列选择数量
            black_cells = r * n + c * n - r * c  # 计算黑色格子的数量
            if black_cells == k:
                total_ways += combination(n, r) * combination(n, c)
    
    return total_ways

Solution = create_solution(solution_function_name)