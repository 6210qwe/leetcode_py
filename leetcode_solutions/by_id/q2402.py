# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2402
标题: Maximum XOR After Operations
难度: medium
链接: https://leetcode.cn/problems/maximum-xor-after-operations/
题目类型: 位运算、数组、数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2317. 操作后的最大异或和 - 给你一个下标从 0 开始的整数数组 nums 。一次操作中，选择 任意 非负整数 x 和一个下标 i ，更新 nums[i] 为 nums[i] AND (nums[i] XOR x) 。 注意，AND 是逐位与运算，XOR 是逐位异或运算。 请你执行 任意次 更新操作，并返回 nums 中所有元素 最大 逐位异或和。 示例 1： 输入：nums = [3,2,4,6] 输出：7 解释：选择 x = 4 和 i = 3 进行操作，num[3] = 6 AND (6 XOR 4) = 6 AND 2 = 2 。 现在，nums = [3, 2, 4, 2] 且所有元素逐位异或得到 3 XOR 2 XOR 4 XOR 2 = 7 。 可知 7 是能得到的最大逐位异或和。 注意，其他操作可能也能得到逐位异或和 7 。 示例 2： 输入：nums = [1,2,3,9,2] 输出：11 解释：执行 0 次操作。 所有元素的逐位异或和为 1 XOR 2 XOR 3 XOR 9 XOR 2 = 11 。 可知 11 是能得到的最大逐位异或和。 提示： * 1 <= nums.length <= 105 * 0 <= nums[i] <= 108
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过逐位分析，我们可以发现对于每一位，如果存在一个1，那么我们可以通过操作将这一位变为1。因此，最大异或和就是将所有位都置为1的结果。

算法步骤:
1. 初始化一个变量 `max_xor` 为0。
2. 对于每一位（从第0位到第31位），检查数组中的所有数字在该位上是否有1。
3. 如果某一位上有1，则将 `max_xor` 的对应位置为1。
4. 返回 `max_xor`。

关键点:
- 通过逐位检查，确保每一位都能被置为1，从而得到最大异或和。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(1)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(nums: List[int]) -> int:
    """
    函数式接口 - 计算操作后的最大异或和
    """
    max_xor = 0
    for bit in range(32):
        # 检查当前位是否有1
        if any((num >> bit) & 1 for num in nums):
            max_xor |= (1 << bit)
    return max_xor


Solution = create_solution(solution_function_name)