# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000560
标题: 补给马车
难度: easy
链接: https://leetcode.cn/problems/hqCnmP/
题目类型: 其他
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCP 72. 补给马车 - 远征队即将开启未知的冒险之旅，不过在此之前，将对补给车队进行最后的检查。`supplies[i]` 表示编号为 `i` 的补给马车装载的物资数量。 考虑到车队过长容易被野兽偷袭，他们决定将车队的长度变为原来的一半（向下取整），计划为： - 找出车队中 **物资之和最小** 两辆 **相邻** 马车，将它们车辆的物资整合为一辆。若存在多组物资之和相同的马车，则取编号最小的两辆马车进行整合； - 重复上述操作直到车队长度符合要求。 请返回车队长度符合要求后，物资的分布情况。 **示例 1：** >输入：`supplies = [7,3,6,1,8]` > >输出：`[10,15]` > >解释： > 第 1 次合并，符合条件的两辆马车为 6,1，合并后的车队为 [7,3,7,8]； > 第 2 次合并，符合条件的两辆马车为 (7,3) 和 (3,7)，取编号最小的 (7,3)，合并后的车队为 [10,7,8]； > 第 3 次合并，符合条件的两辆马车为 7,8，合并后的车队为 [10,15]； >返回 `[10,15]` **示例 2：** >输入：`supplies = [1,3,1,5]` > >输出：`[5,5]` **解释：** - `2 <= supplies.length <= 1000` - `1 <= supplies[i] <= 1000`
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用贪心算法，每次找到物资之和最小的相邻两辆马车进行合并，直到车队长度符合要求。

算法步骤:
1. 初始化一个循环，直到车队长度小于等于目标长度。
2. 在每一轮中，遍历当前车队，找到物资之和最小的相邻两辆马车。
3. 将这两辆马车合并，并更新车队。
4. 重复上述步骤，直到车队长度符合要求。

关键点:
- 每次找到物资之和最小的相邻两辆马车进行合并。
- 合并后更新车队，并继续下一轮操作。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2)，其中 n 是初始车队的长度。每次合并需要 O(n) 的时间来找到最小的相邻两辆马车，最多需要进行 n/2 次合并。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def consolidate_supplies(supplies: List[int]) -> List[int]:
    """
    函数式接口 - 返回车队长度符合要求后，物资的分布情况
    """
    while len(supplies) > (len(supplies) + 1) // 2:
        min_sum = float('inf')
        min_index = -1
        
        for i in range(len(supplies) - 1):
            if supplies[i] + supplies[i + 1] < min_sum:
                min_sum = supplies[i] + supplies[i + 1]
                min_index = i
        
        # 合并找到的两辆马车
        supplies[min_index] = min_sum
        del supplies[min_index + 1]
    
    return supplies

Solution = create_solution(consolidate_supplies)