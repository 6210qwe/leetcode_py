# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 100293
标题: 螺旋遍历二维数组
难度: easy
链接: https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/
题目类型: 数组、矩阵、模拟
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCR 146. 螺旋遍历二维数组 - 给定一个二维数组 array，请返回「螺旋遍历」该数组的结果。 螺旋遍历：从左上角开始，按照 向右、向下、向左、向上 的顺序 依次 提取元素，然后再进入内部一层重复相同的步骤，直到提取完所有元素。 示例 1： 输入：array = [[1,2,3],[8,9,4],[7,6,5]] 输出：[1,2,3,4,5,6,7,8,9] 示例 2： 输入：array = [[1,2,3,4],[12,13,14,5],[11,16,15,6],[10,9,8,7]] 输出：[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16] 限制： * 0 <= array.length <= 100 * 0 <= array[i].length <= 100 注意：本题与主站 54 题相同：https://leetcode.cn/problems/spiral-matrix/ [https://leetcode.cn/problems/spiral-matrix/]
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用四个边界变量来控制遍历的方向和范围。

算法步骤:
1. 初始化四个边界变量：top, bottom, left, right。
2. 按照右、下、左、上的顺序遍历数组，并更新相应的边界变量。
3. 重复步骤2，直到遍历完所有元素。

关键点:
- 使用边界变量来控制遍历的方向和范围。
- 在每次遍历完一个方向后，更新相应的边界变量。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m * n)，其中 m 和 n 分别是矩阵的行数和列数。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def spiral_traverse(matrix: List[List[int]]) -> List[int]:
    """
    函数式接口 - 螺旋遍历二维数组
    """
    if not matrix or not matrix[0]:
        return []

    result = []
    top, bottom = 0, len(matrix) - 1
    left, right = 0, len(matrix[0]) - 1

    while top <= bottom and left <= right:
        # 向右遍历
        for i in range(left, right + 1):
            result.append(matrix[top][i])
        top += 1

        # 向下遍历
        for i in range(top, bottom + 1):
            result.append(matrix[i][right])
        right -= 1

        if top <= bottom:
            # 向左遍历
            for i in range(right, left - 1, -1):
                result.append(matrix[bottom][i])
            bottom -= 1

        if left <= right:
            # 向上遍历
            for i in range(bottom, top - 1, -1):
                result.append(matrix[i][left])
            left += 1

    return result

Solution = create_solution(spiral_traverse)