# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 906
标题: Walking Robot Simulation
难度: medium
链接: https://leetcode.cn/problems/walking-robot-simulation/
题目类型: 数组、哈希表、模拟
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
874. 模拟行走机器人 - 机器人在一个无限大小的 XY 网格平面上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令 commands ： * -2 ：向左转 90 度 * -1 ：向右转 90 度 * 1 <= x <= 9 ：向前移动 x 个单位长度 在网格上有一些格子被视为障碍物 obstacles 。第 i 个障碍物位于网格点 obstacles[i] = (xi, yi) 。 机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，并继续执行下一个命令。 返回机器人距离原点的 最大欧式距离 的 平方 。（即，如果距离为 5 ，则返回 25 ） 注意： * 北方表示 +Y 方向。 * 东方表示 +X 方向。 * 南方表示 -Y 方向。 * 西方表示 -X 方向。 * 原点 [0,0] 可能会有障碍物。 示例 1： 输入：commands = [4,-1,3], obstacles = [] 输出：25 解释： 机器人开始位于 (0, 0)： 1. 向北移动 4 个单位，到达 (0, 4) 2. 右转 3. 向东移动 3 个单位，到达 (3, 4) 距离原点最远的是 (3, 4) ，距离为 32 + 42 = 25 示例 2： 输入：commands = [4,-1,4,-2,4], obstacles = [[2,4]] 输出：65 解释：机器人开始位于 (0, 0)： 1. 向北移动 4 个单位，到达 (0, 4) 2. 右转 3. 向东移动 1 个单位，然后被位于 (2, 4) 的障碍物阻挡，机器人停在 (1, 4) 4. 左转 5. 向北走 4 个单位，到达 (1, 8) 距离原点最远的是 (1, 8) ，距离为 12 + 82 = 65 示例 3： 输入：commands = [6,-1,-1,6], obstacles = [] 输出：36 解释：机器人开始位于 (0, 0): 1. 向北移动 6 个单位，到达 (0, 6). 2. 右转 3. 右转 4. 向南移动 6 个单位，到达 (0, 0). 机器人距离原点最远的点是 (0, 6)，其距离的平方是 62 = 36 个单位。 提示： * 1 <= commands.length <= 104 * commands[i] 的值可以取 -2、-1 或者是范围 [1, 9] 内的一个整数。 * 0 <= obstacles.length <= 104 * -3 * 104 <= xi, yi <= 3 * 104 * 答案保证小于 231
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用方向数组来表示机器人的朝向，并使用集合来存储障碍物的位置，以便快速查找。

算法步骤:
1. 初始化机器人的位置 (0, 0) 和初始方向（北）。
2. 将障碍物列表转换为集合以提高查找效率。
3. 遍历命令列表，根据命令更新机器人的位置和方向：
   - 如果命令是 -2 或 -1，更新方向。
   - 如果命令是正整数，向前移动指定步数，检查每一步是否遇到障碍物。
4. 计算并记录每一步的最大欧氏距离平方。

关键点:
- 使用方向数组来简化方向的更新。
- 使用集合来存储障碍物位置，以便 O(1) 时间复杂度内判断是否遇到障碍物。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n + m)，其中 n 是 commands 的长度，m 是 obstacles 的长度。
空间复杂度: O(m)，用于存储障碍物集合。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def robot_simulation(commands: List[int], obstacles: List[List[int]]) -> int:
    # 方向数组：北、东、南、西
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    # 初始位置和方向
    x, y, direction = 0, 0, 0
    # 将障碍物列表转换为集合
    obstacle_set = set(map(tuple, obstacles))
    max_distance = 0

    for command in commands:
        if command == -2:  # 向左转 90 度
            direction = (direction - 1) % 4
        elif command == -1:  # 向右转 90 度
            direction = (direction + 1) % 4
        else:  # 向前移动 x 个单位
            dx, dy = directions[direction]
            for _ in range(command):
                if (x + dx, y + dy) in obstacle_set:
                    break
                x += dx
                y += dy
            # 更新最大欧氏距离平方
            max_distance = max(max_distance, x**2 + y**2)

    return max_distance

Solution = create_solution(robot_simulation)