# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 763
标题: Special Binary String
难度: hard
链接: https://leetcode.cn/problems/special-binary-string/
题目类型: 递归、字符串
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
761. 特殊的二进制字符串 - 特殊的二进制字符串 是具有以下两个性质的二进制序列： * 0 的数量与 1 的数量相等。 * 二进制序列的每一个前缀码中 1 的数量要大于等于 0 的数量。 给定一个特殊的二进制字符串 s。 一次移动操作包括选择字符串 s 中的两个连续的、非空的、特殊子串，并交换它们。两个字符串是连续的，如果第一个字符串的最后一个字符与第二个字符串的第一个字符的索引相差正好为 1。 返回在字符串上应用任意次操作后可能得到的字典序最大的字符串。 示例 1: 输入: S = "11011000" 输出: "11100100" 解释: 将子串 "10" （在 s[1] 出现） 和 "1100" （在 s[3] 出现）进行交换。 这是在进行若干次操作后按字典序排列最大的结果。 示例 2： 输入：s = "10" 输出："10" 提示： * 1 <= s.length <= 50 * s[i] 为 '0' 或 '1'。 * s 是一个特殊的二进制字符串。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用递归和分治法将字符串分解成多个特殊子串，然后对这些子串进行排序以获得字典序最大的结果。

算法步骤:
1. 定义一个辅助函数 `split_into_special_substrings`，用于将字符串分解成多个特殊子串。
2. 对每个特殊子串递归调用自身，获取其字典序最大的结果。
3. 将处理后的子串按字典序从大到小排序。
4. 拼接排序后的子串，返回最终结果。

关键点:
- 通过递归和分治法将问题分解成更小的子问题。
- 对每个子串进行递归处理，确保每个子串都是字典序最大的。
- 对子串进行排序以获得整体字典序最大的结果。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是字符串的长度。递归调用的时间复杂度为 O(n)，排序的时间复杂度为 O(n log n)。
空间复杂度: O(n)，递归调用栈和存储子串的空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def split_into_special_substrings(s: str) -> List[str]:
    """
    将字符串 s 分解成多个特殊子串。
    """
    count = 0
    start = 0
    result = []
    for i, char in enumerate(s):
        if char == '1':
            count += 1
        else:
            count -= 1
        if count == 0:
            result.append(s[start:i+1])
            start = i + 1
    return result


def make_largest_special(s: str) -> str:
    """
    返回在字符串上应用任意次操作后可能得到的字典序最大的字符串。
    """
    if not s:
        return ""
    
    # 将字符串分解成多个特殊子串
    substrings = split_into_special_substrings(s)
    
    # 对每个特殊子串递归调用自身，获取其字典序最大的结果
    for i in range(len(substrings)):
        substrings[i] = '1' + make_largest_special(substrings[i][1:-1]) + '0'
    
    # 将处理后的子串按字典序从大到小排序
    substrings.sort(reverse=True)
    
    # 拼接排序后的子串，返回最终结果
    return ''.join(substrings)


Solution = create_solution(make_largest_special)