# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1977
标题: Minimum Interval to Include Each Query
难度: hard
链接: https://leetcode.cn/problems/minimum-interval-to-include-each-query/
题目类型: 数组、二分查找、排序、扫描线、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1851. 包含每个查询的最小区间 - 给你一个二维整数数组 intervals ，其中 intervals[i] = [lefti, righti] 表示第 i 个区间开始于 lefti 、结束于 righti（包含两侧取值，闭区间）。区间的 长度 定义为区间中包含的整数数目，更正式地表达是 righti - lefti + 1 。 再给你一个整数数组 queries 。第 j 个查询的答案是满足 lefti <= queries[j] <= righti 的 长度最小区间 i 的长度 。如果不存在这样的区间，那么答案是 -1 。 以数组形式返回对应查询的所有答案。 示例 1： 输入：intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5] 输出：[3,3,1,4] 解释：查询处理如下： - Query = 2 ：区间 [2,4] 是包含 2 的最小区间，答案为 4 - 2 + 1 = 3 。 - Query = 3 ：区间 [2,4] 是包含 3 的最小区间，答案为 4 - 2 + 1 = 3 。 - Query = 4 ：区间 [4,4] 是包含 4 的最小区间，答案为 4 - 4 + 1 = 1 。 - Query = 5 ：区间 [3,6] 是包含 5 的最小区间，答案为 6 - 3 + 1 = 4 。 示例 2： 输入：intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22] 输出：[2,-1,4,6] 解释：查询处理如下： - Query = 2 ：区间 [2,3] 是包含 2 的最小区间，答案为 3 - 2 + 1 = 2 。 - Query = 19：不存在包含 19 的区间，答案为 -1 。 - Query = 5 ：区间 [2,5] 是包含 5 的最小区间，答案为 5 - 2 + 1 = 4 。 - Query = 22：区间 [20,25] 是包含 22 的最小区间，答案为 25 - 20 + 1 = 6 。 提示： * 1 <= intervals.length <= 105 * 1 <= queries.length <= 105 * intervals[i].length == 2 * 1 <= lefti <= righti <= 107 * 1 <= queries[j] <= 107
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用优先队列（最小堆）来维护当前有效的区间，并在遍历查询时动态更新。

算法步骤:
1. 将所有区间按左端点升序排序。
2. 将所有查询按值升序排序，并记录其原始索引。
3. 初始化一个最小堆，用于存储当前有效的区间。
4. 遍历排序后的查询：
   - 移除堆中已经无效的区间（即右端点小于当前查询值的区间）。
   - 将所有左端点小于等于当前查询值的区间加入堆中。
   - 如果堆不为空，堆顶元素即为包含当前查询值的最小区间。
   - 如果堆为空，说明没有区间包含当前查询值，结果为 -1。

关键点:
- 使用最小堆来动态维护当前有效的区间。
- 在遍历查询时，通过堆顶元素获取最小区间。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O((n + m) log n)，其中 n 是 intervals 的长度，m 是 queries 的长度。排序操作的时间复杂度为 O(n log n)，每次插入和删除堆的操作时间复杂度为 O(log n)。
空间复杂度: O(n + m)，需要额外的空间来存储排序后的 intervals 和 queries，以及最小堆。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def minInterval(intervals: List[List[int]], queries: List[int]) -> List[int]:
    # 按左端点升序排序
    intervals.sort(key=lambda x: x[0])
    
    # 将查询按值升序排序，并记录其原始索引
    sorted_queries = sorted(enumerate(queries), key=lambda x: x[1])
    
    # 结果数组
    result = [-1] * len(queries)
    
    # 最小堆
    min_heap = []
    
    # 当前处理到的区间索引
    interval_index = 0
    
    for original_index, query in sorted_queries:
        # 移除堆中已经无效的区间
        while min_heap and min_heap[0][0] < query:
            heapq.heappop(min_heap)
        
        # 将所有左端点小于等于当前查询值的区间加入堆中
        while interval_index < len(intervals) and intervals[interval_index][0] <= query:
            left, right = intervals[interval_index]
            if right >= query:
                heapq.heappush(min_heap, (right - left + 1, right))
            interval_index += 1
        
        # 如果堆不为空，堆顶元素即为包含当前查询值的最小区间
        if min_heap:
            result[original_index] = min_heap[0][0]
    
    return result

Solution = create_solution(minInterval)