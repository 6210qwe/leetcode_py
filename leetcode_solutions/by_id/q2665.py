# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2665
标题: Minimum Time to Repair Cars
难度: medium
链接: https://leetcode.cn/problems/minimum-time-to-repair-cars/
题目类型: 数组、二分查找
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2594. 修车的最少时间 - 给你一个整数数组 ranks ，表示一些机械工的 能力值 。ranksi 是第 i 位机械工的能力值。能力值为 r 的机械工可以在 r * n2 分钟内修好 n 辆车。 同时给你一个整数 cars ，表示总共需要修理的汽车数目。 请你返回修理所有汽车 最少 需要多少时间。 注意：所有机械工可以同时修理汽车。 示例 1： 输入：ranks = [4,2,3,1], cars = 10 输出：16 解释： - 第一位机械工修 2 辆车，需要 4 * 2 * 2 = 16 分钟。 - 第二位机械工修 2 辆车，需要 2 * 2 * 2 = 8 分钟。 - 第三位机械工修 2 辆车，需要 3 * 2 * 2 = 12 分钟。 - 第四位机械工修 4 辆车，需要 1 * 4 * 4 = 16 分钟。 16 分钟是修理完所有车需要的最少时间。 示例 2： 输入：ranks = [5,1,8], cars = 6 输出：16 解释： - 第一位机械工修 1 辆车，需要 5 * 1 * 1 = 5 分钟。 - 第二位机械工修 4 辆车，需要 1 * 4 * 4 = 16 分钟。 - 第三位机械工修 1 辆车，需要 8 * 1 * 1 = 8 分钟。 16 分钟时修理完所有车需要的最少时间。 提示： * 1 <= ranks.length <= 105 * 1 <= ranks[i] <= 100 * 1 <= cars <= 106
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用二分查找来确定最小的时间。我们可以在时间范围内进行二分查找，每次检查当前时间是否足够修理所有车辆。

算法步骤:
1. 初始化二分查找的左右边界，left 为 0，right 为 1e14（一个足够大的数）。
2. 在 left 和 right 之间进行二分查找：
   - 计算中间值 mid。
   - 检查在 mid 时间内是否可以修理完所有车辆。
   - 如果可以，则将 right 更新为 mid；否则，将 left 更新为 mid + 1。
3. 返回 left 作为结果。

关键点:
- 使用二分查找来缩小时间范围。
- 每次检查当前时间是否足够修理所有车辆。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log T)，其中 n 是 ranks 的长度，T 是时间范围的最大值（1e14）。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def can_repair_all_cars(ranks: List[int], cars: int, time: int) -> bool:
    """检查在给定时间内是否可以修理完所有车辆。"""
    total_cars_repaired = sum((time // rank) ** 0.5 for rank in ranks)
    return total_cars_repaired >= cars

def solution_function_name(ranks: List[int], cars: int) -> int:
    """
    函数式接口 - 使用二分查找来确定修理所有车辆所需的最少时间。
    """
    left, right = 0, 10**14
    while left < right:
        mid = (left + right) // 2
        if can_repair_all_cars(ranks, cars, mid):
            right = mid
        else:
            left = mid + 1
    return left

Solution = create_solution(solution_function_name)