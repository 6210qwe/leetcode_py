# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 474
标题: Ones and Zeroes
难度: medium
链接: https://leetcode.cn/problems/ones-and-zeroes/
题目类型: 数组、字符串、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
474. 一和零 - 给你一个二进制字符串数组 strs 和两个整数 m 和 n 。 请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。 如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。 示例 1： 输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3 输出：4 解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。 其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。 示例 2： 输入：strs = ["10", "0", "1"], m = 1, n = 1 输出：2 解释：最大的子集是 {"0", "1"} ，所以答案是 2 。 提示： * 1 <= strs.length <= 600 * 1 <= strs[i].length <= 100 * strs[i] 仅由 '0' 和 '1' 组成 * 1 <= m, n <= 100
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 动态规划，二维背包问题

算法步骤:
1. 统计每个字符串的0和1的个数
2. 使用DP，dp[i][j]表示最多i个0和j个1的最大子集长度
3. 对每个字符串，更新DP数组

关键点:
- 二维背包问题
- 时间复杂度O(len(strs)*m*n)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(len(strs)*m*n) - 遍历字符串和DP数组
空间复杂度: O(m*n) - DP数组空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def ones_and_zeroes(strs: List[str], m: int, n: int) -> int:
    """
    函数式接口 - 一和零
    
    实现思路:
    动态规划：二维背包问题。
    
    Args:
        strs: 二进制字符串数组
        m: 最多0的个数
        n: 最多1的个数
        
    Returns:
        最大子集的长度
        
    Example:
        >>> ones_and_zeroes(["10","0001","111001","1","0"], 5, 3)
        4
    """
    # DP数组：dp[i][j]表示最多i个0和j个1的最大子集长度
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for s in strs:
        zeros = s.count('0')
        ones = s.count('1')
        
        # 从后往前更新，避免重复使用
        for i in range(m, zeros - 1, -1):
            for j in range(n, ones - 1, -1):
                dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)
    
    return dp[m][n]


# 自动生成Solution类（无需手动编写）
Solution = create_solution(ones_and_zeroes)
