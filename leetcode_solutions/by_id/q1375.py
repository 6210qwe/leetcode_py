# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1375
标题: Find Palindrome With Fixed Length
难度: medium
链接: https://leetcode.cn/problems/find-palindrome-with-fixed-length/
题目类型: 数组、数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2217. 找到指定长度的回文数 - 给你一个整数数组 queries 和一个 正 整数 intLength ，请你返回一个数组 answer ，其中 answer[i] 是长度为 intLength 的 正回文数 中第 queries[i] 小的数字，如果不存在这样的回文数，则为 -1 。 回文数 指的是从前往后和从后往前读一模一样的数字。回文数不能有前导 0 。 示例 1： 输入：queries = [1,2,3,4,5,90], intLength = 3 输出：[101,111,121,131,141,999] 解释： 长度为 3 的最小回文数依次是： 101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, ... 第 90 个长度为 3 的回文数是 999 。 示例 2： 输入：queries = [2,4,6], intLength = 4 输出：[1111,1331,1551] 解释： 长度为 4 的前 6 个回文数是： 1001, 1111, 1221, 1331, 1441 和 1551 。 提示： * 1 <= queries.length <= 5 * 104 * 1 <= queries[i] <= 109 * 1 <= intLength <= 15
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过生成回文数的一半来构建完整的回文数。

算法步骤:
1. 计算回文数的一半的长度。
2. 生成所有可能的回文数的一半。
3. 根据查询索引构建完整的回文数。

关键点:
- 通过生成回文数的一半来避免重复计算。
- 处理奇数和偶数长度的回文数。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * m)，其中 n 是 queries 的长度，m 是 intLength 的一半。
空间复杂度: O(n)，存储结果数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def kthPalindrome(queries: List[int], intLength: int) -> List[int]:
    """
    返回长度为 intLength 的第 queries[i] 小的回文数。
    """
    half_length = (intLength + 1) // 2
    start = 10 ** (half_length - 1)
    end = 10 ** half_length - 1
    result = []

    for query in queries:
        if start + query - 1 > end:
            result.append(-1)
        else:
            half_palindrome = str(start + query - 1)
            if intLength % 2 == 0:
                palindrome = half_palindrome + half_palindrome[::-1]
            else:
                palindrome = half_palindrome + half_palindrome[:-1][::-1]
            result.append(int(palindrome))

    return result

Solution = create_solution(kthPalindrome)