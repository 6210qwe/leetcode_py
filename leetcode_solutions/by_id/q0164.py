# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 164
标题: Maximum Gap
难度: medium
链接: https://leetcode.cn/problems/maximum-gap/
题目类型: 数组、桶排序、基数排序、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
164. 最大间距 - 给定一个无序的数组 nums，返回 数组在排序之后，相邻元素之间最大的差值 。如果数组元素个数小于 2，则返回 0 。 您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。 示例 1: 输入: nums = [3,6,9,1] 输出: 3 解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。 示例 2: 输入: nums = [10] 输出: 0 解释: 数组元素个数小于 2，因此返回 0。 提示: * 1 <= nums.length <= 105 * 0 <= nums[i] <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用桶排序，最大间距不会出现在桶内，只会在相邻桶之间

算法步骤:
1. 计算最小值和最大值
2. 计算桶的大小和数量
3. 将元素分配到桶中，记录每个桶的最小值和最大值
4. 遍历桶，计算相邻非空桶之间的最大间距

关键点:
- 使用桶排序实现线性时间复杂度
- 时间复杂度O(n)，空间复杂度O(n)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 需要遍历数组两次
空间复杂度: O(n) - 需要存储桶信息
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from leetcode_solutions.utils.solution import create_solution


def maximum_gap(nums: List[int]) -> int:
    """
    函数式接口 - 计算排序后相邻元素的最大间距
    
    实现思路:
    使用桶排序，最大间距不会出现在桶内，只会在相邻桶之间。
    
    Args:
        nums: 无序整数数组
        
    Returns:
        排序后相邻元素的最大间距
        
    Example:
        >>> maximum_gap([3, 6, 9, 1])
        3
    """
    if len(nums) < 2:
        return 0
    
    min_val, max_val = min(nums), max(nums)
    if min_val == max_val:
        return 0
    
    n = len(nums)
    bucket_size = max(1, (max_val - min_val) // (n - 1))
    bucket_count = (max_val - min_val) // bucket_size + 1
    
    buckets = [[float('inf'), float('-inf')] for _ in range(bucket_count)]
    
    for num in nums:
        idx = (num - min_val) // bucket_size
        buckets[idx][0] = min(buckets[idx][0], num)
        buckets[idx][1] = max(buckets[idx][1], num)
    
    max_gap = 0
    prev_max = buckets[0][1]
    
    for i in range(1, bucket_count):
        if buckets[i][0] != float('inf'):
            max_gap = max(max_gap, buckets[i][0] - prev_max)
            prev_max = buckets[i][1]
    
    return max_gap


# 自动生成Solution类（无需手动编写）
Solution = create_solution(maximum_gap)
