# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1753
标题: Path With Minimum Effort
难度: medium
链接: https://leetcode.cn/problems/path-with-minimum-effort/
题目类型: 深度优先搜索、广度优先搜索、并查集、数组、二分查找、矩阵、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1631. 最小体力消耗路径 - 你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights ，其中 heights[row][col] 表示格子 (row, col) 的高度。一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。你每次可以往 上，下，左，右 四个方向之一移动，你想要找到耗费 体力 最小的一条路径。 一条路径耗费的 体力值 是路径上相邻格子之间 高度差绝对值 的 最大值 决定的。 请你返回从左上角走到右下角的最小 体力消耗值 。 示例 1： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/10/25/ex1.png] 输入：heights = [[1,2,2],[3,8,2],[5,3,5]] 输出：2 解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。 这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。 示例 2： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/10/25/ex2.png] 输入：heights = [[1,2,3],[3,8,4],[5,3,5]] 输出：1 解释：路径 [1,2,3,4,5] 的相邻格子差值绝对值最大为 1 ，比路径 [1,3,5,3,5] 更优。 示例 3： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/10/25/ex3.png] 输入：heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]] 输出：0 解释：上图所示路径不需要消耗任何体力。 提示： * rows == heights.length * columns == heights[i].length * 1 <= rows, columns <= 100 * 1 <= heights[i][j] <= 106
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用 Dijkstra 算法来找到从起点到终点的最小体力消耗路径。

算法步骤:
1. 初始化一个优先队列，并将起点 (0, 0) 加入队列，初始体力消耗为 0。
2. 使用一个二维数组 `dist` 来记录从起点到每个点的最小体力消耗，初始值为无穷大，起点设为 0。
3. 从优先队列中取出当前体力消耗最小的节点，检查其四个方向的邻居节点。
4. 对于每个邻居节点，计算从当前节点到邻居节点的高度差绝对值，更新邻居节点的最小体力消耗。
5. 如果邻居节点的体力消耗被更新，将其加入优先队列。
6. 重复上述过程，直到到达终点 (rows-1, columns-1)。

关键点:
- 使用优先队列来保证每次处理的都是当前体力消耗最小的节点。
- 更新邻居节点的体力消耗时，取当前路径的最大高度差绝对值。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(rows * columns * log(rows * columns))，其中 rows 和 columns 分别是地图的行数和列数。每个节点最多会被处理一次，优先队列的操作时间复杂度为 O(log(rows * columns))。
空间复杂度: O(rows * columns)，用于存储距离数组和优先队列。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def minimum_effort_path(heights: List[List[int]]) -> int:
    rows, cols = len(heights), len(heights[0])
    dist = [[float('inf')] * cols for _ in range(rows)]
    dist[0][0] = 0
    pq = [(0, 0, 0)]  # (effort, row, col)
    
    while pq:
        effort, r, c = heapq.heappop(pq)
        
        if r == rows - 1 and c == cols - 1:
            return effort
        
        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols:
                new_effort = max(effort, abs(heights[r][c] - heights[nr][nc]))
                if new_effort < dist[nr][nc]:
                    dist[nr][nc] = new_effort
                    heapq.heappush(pq, (new_effort, nr, nc))

Solution = create_solution(minimum_effort_path)