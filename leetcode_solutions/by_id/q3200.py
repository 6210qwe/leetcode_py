# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3200
标题: Number of Strings Which Can Be Rearranged to Contain Substring
难度: medium
链接: https://leetcode.cn/problems/number-of-strings-which-can-be-rearranged-to-contain-substring/
题目类型: 数学、动态规划、组合数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2930. 重新排列后包含指定子字符串的字符串数目 - 给你一个整数 n 。 如果一个字符串 s 只包含小写英文字母，且 将 s 的字符重新排列后，新字符串包含 子字符串 "leet" ，那么我们称字符串 s 是一个 好 字符串。 比方说： * 字符串 "lteer" 是好字符串，因为重新排列后可以得到 "leetr" 。 * "letl" 不是好字符串，因为无法重新排列并得到子字符串 "leet" 。 请你返回长度为 n 的好字符串 总 数目。 由于答案可能很大，将答案对 109 + 7 取余 后返回。 子字符串 是一个字符串中一段连续的字符序列。 示例 1： 输入：n = 4 输出：12 解释：总共有 12 个字符串重新排列后包含子字符串 "leet" ："eelt" ，"eetl" ，"elet" ，"elte" ，"etel" ，"etle" ，"leet" ，"lete" ，"ltee" ，"teel" ，"tele" 和 "tlee" 。 示例 2： 输入：n = 10 输出：83943898 解释：长度为 10 的字符串重新排列后包含子字符串 "leet" 的方案数为 526083947580 。所以答案为 526083947580 % (109 + 7) = 83943898 。 提示： * 1 <= n <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划和组合数学来计算满足条件的字符串数量。

算法步骤:
1. 定义状态 dp[i][j] 表示前 i 个字符中，已经包含了 "leet" 的前 j 个字符的数量。
2. 初始化 dp 数组，dp[0][0] = 1。
3. 迭代更新 dp 数组，考虑每一步选择 'l', 'e', 't' 或其他字符的情况。
4. 最终结果是 dp[n][4]，表示长度为 n 的字符串中包含 "leet" 的数量。

关键点:
- 使用动态规划来避免重复计算。
- 使用组合数学来优化计算过程。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(1)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution

MOD = 10**9 + 7

def solution_function_name(n: int) -> int:
    """
    函数式接口 - 计算长度为 n 的好字符串总数目
    """
    if n < 4:
        return 0

    # 动态规划数组
    dp = [0] * 5
    dp[0] = 1

    for i in range(1, n + 1):
        new_dp = [0] * 5
        for j in range(5):
            if j == 0:
                new_dp[j] = (23 * dp[j]) % MOD  # 选择其他字符
            elif j == 1:
                new_dp[j] = (dp[j - 1] + 23 * dp[j]) % MOD  # 选择 'l'
            elif j == 2:
                new_dp[j] = (dp[j - 1] + 23 * dp[j]) % MOD  # 选择 'e'
            elif j == 3:
                new_dp[j] = (dp[j - 1] + 23 * dp[j]) % MOD  # 选择 'e'
            else:
                new_dp[j] = (dp[j - 1] + 23 * dp[j]) % MOD  # 选择 't'
        dp = new_dp

    return dp[4]

Solution = create_solution(solution_function_name)