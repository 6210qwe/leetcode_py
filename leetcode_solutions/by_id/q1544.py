# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1544
标题: Count Good Nodes in Binary Tree
难度: medium
链接: https://leetcode.cn/problems/count-good-nodes-in-binary-tree/
题目类型: 树、深度优先搜索、广度优先搜索、二叉树
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1448. 统计二叉树中好节点的数目 - 给你一棵根为 root 的二叉树，请你返回二叉树中好节点的数目。 「好节点」X 定义为：从根到该节点 X 所经过的节点中，没有任何节点的值大于 X 的值。 示例 1： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/05/16/test_sample_1.png] 输入：root = [3,1,4,3,null,1,5] 输出：4 解释：图中蓝色节点为好节点。 根节点 (3) 永远是个好节点。 节点 4 -> (3,4) 是路径中的最大值。 节点 5 -> (3,4,5) 是路径中的最大值。 节点 3 -> (3,1,3) 是路径中的最大值。 示例 2： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/05/16/test_sample_2.png] 输入：root = [3,3,null,4,2] 输出：3 解释：节点 2 -> (3, 3, 2) 不是好节点，因为 "3" 比它大。 示例 3： 输入：root = [1] 输出：1 解释：根节点是好节点。 提示： * 二叉树中节点数目范围是 [1, 10^5] 。 * 每个节点权值的范围是 [-10^4, 10^4] 。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用深度优先搜索（DFS）遍历二叉树，并在遍历过程中维护当前路径的最大值。

算法步骤:
1. 定义一个递归函数 `dfs`，参数包括当前节点和当前路径的最大值。
2. 如果当前节点为空，返回 0。
3. 初始化好节点计数器 `good_count` 为 0。
4. 如果当前节点的值大于等于当前路径的最大值，则该节点是好节点，`good_count` 加 1。
5. 更新当前路径的最大值为 `max(max_val, current_node.val)`。
6. 递归调用 `dfs` 函数处理左子树和右子树，并将结果累加到 `good_count`。
7. 返回 `good_count`。

关键点:
- 使用递归 DFS 遍历二叉树。
- 在遍历过程中维护当前路径的最大值。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是二叉树的节点数。每个节点只访问一次。
空间复杂度: O(h)，其中 h 是二叉树的高度。递归调用栈的空间复杂度取决于树的高度。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import Optional
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def count_good_nodes_in_binary_tree(root: Optional[TreeNode]) -> int:
    """
    计算二叉树中的好节点数量。
    """
    def dfs(node: Optional[TreeNode], max_val: int) -> int:
        if not node:
            return 0
        
        good_count = 0
        if node.val >= max_val:
            good_count += 1
            max_val = node.val
        
        good_count += dfs(node.left, max_val)
        good_count += dfs(node.right, max_val)
        
        return good_count
    
    return dfs(root, float('-inf'))


Solution = create_solution(count_good_nodes_in_binary_tree)