# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 496
标题: Next Greater Element I
难度: easy
链接: https://leetcode.cn/problems/next-greater-element-i/
题目类型: 栈、数组、哈希表、单调栈
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
496. 下一个更大元素 I - nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。 给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。 对于每个 0 <= i < nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。 返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。 示例 1： 输入：nums1 = [4,1,2], nums2 = [1,3,4,2]. 输出：[-1,3,-1] 解释：nums1 中每个值的下一个更大元素如下所述： - 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。 - 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。 - 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。 示例 2： 输入：nums1 = [2,4], nums2 = [1,2,3,4]. 输出：[3,-1] 解释：nums1 中每个值的下一个更大元素如下所述： - 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。 - 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。 提示： * 1 <= nums1.length <= nums2.length <= 1000 * 0 <= nums1[i], nums2[i] <= 104 * nums1和nums2中所有整数 互不相同 * nums1 中的所有整数同样出现在 nums2 中 进阶：你可以设计一个时间复杂度为 O(nums1.length + nums2.length) 的解决方案吗？
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用单调栈来找到每个元素的下一个更大元素，并使用哈希表存储结果。

算法步骤:
1. 初始化一个空栈和一个哈希表。
2. 从右到左遍历 nums2，对于每个元素：
   - 如果栈不为空且栈顶元素小于当前元素，则弹出栈顶元素。
   - 如果栈为空，则当前元素没有下一个更大元素，记录为 -1。
   - 否则，栈顶元素即为当前元素的下一个更大元素。
   - 将当前元素压入栈中。
3. 遍历 nums1，通过哈希表查找每个元素的下一个更大元素。

关键点:
- 使用单调栈可以在线性时间内找到每个元素的下一个更大元素。
- 哈希表用于快速查找 nums1 中每个元素的下一个更大元素。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n + m) - 其中 n 是 nums1 的长度，m 是 nums2 的长度。遍历 nums2 和 nums1 的时间复杂度分别为 O(m) 和 O(n)。
空间复杂度: O(m) - 哈希表和栈的空间复杂度均为 O(m)。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def next_greater_element_i(nums1: List[int], nums2: List[int]) -> List[int]:
    """
    函数式接口 - 找到 nums1 中每个元素在 nums2 中的下一个更大元素。

    实现思路:
    使用单调栈来找到每个元素的下一个更大元素，并使用哈希表存储结果。

    Args:
        nums1: 数组 nums1
        nums2: 数组 nums2
        
    Returns:
        返回一个长度为 nums1.length 的数组 ans，满足 ans[i] 是 nums1[i] 在 nums2 中的下一个更大元素。
        
    Example:
        >>> next_greater_element_i([4,1,2], [1,3,4,2])
        [-1, 3, -1]
    """
    # 初始化一个空栈和一个哈希表
    stack = []
    next_greater = {}

    # 从右到左遍历 nums2
    for num in reversed(nums2):
        # 弹出所有小于当前元素的栈顶元素
        while stack and stack[-1] <= num:
            stack.pop()
        # 如果栈为空，则当前元素没有下一个更大元素
        if not stack:
            next_greater[num] = -1
        else:
            next_greater[num] = stack[-1]
        # 将当前元素压入栈中
        stack.append(num)

    # 遍历 nums1，通过哈希表查找每个元素的下一个更大元素
    result = [next_greater[num] for num in nums1]
    return result


# 自动生成Solution类（无需手动编写）
Solution = create_solution(next_greater_element_i)