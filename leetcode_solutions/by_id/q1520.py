# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1520
标题: Number of Steps to Reduce a Number in Binary Representation to One
难度: medium
链接: https://leetcode.cn/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/
题目类型: 位运算、字符串、模拟
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1404. 将二进制表示减到 1 的步骤数 - 给你一个以二进制形式表示的数字 s 。请你返回按下述规则将其减少到 1 所需要的步骤数： * 如果当前数字为偶数，则将其除以 2 。 * 如果当前数字为奇数，则将其加上 1 。 题目保证你总是可以按上述规则将测试用例变为 1 。 示例 1： 输入：s = "1101" 输出：6 解释："1101" 表示十进制数 13 。 Step 1) 13 是奇数，加 1 得到 14 Step 2) 14 是偶数，除 2 得到 7 Step 3) 7 是奇数，加 1 得到 8 Step 4) 8 是偶数，除 2 得到 4 Step 5) 4 是偶数，除 2 得到 2 Step 6) 2 是偶数，除 2 得到 1 示例 2： 输入：s = "10" 输出：1 解释："10" 表示十进制数 2 。 Step 1) 2 是偶数，除 2 得到 1 示例 3： 输入：s = "1" 输出：0 提示： * 1 <= s.length <= 500 * s 由字符 '0' 或 '1' 组成。 * s[0] == '1'
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过模拟二进制数的转换过程，逐步将二进制数减少到 1。

算法步骤:
1. 从右到左遍历二进制字符串。
2. 如果遇到 '0'，则直接跳过（相当于除以 2）。
3. 如果遇到 '1'，则需要进行加 1 操作，并处理进位。
4. 记录每一步操作的次数，直到二进制数变为 '1'。

关键点:
- 通过模拟二进制数的转换过程，避免直接将二进制数转换为十进制数进行计算，从而优化时间和空间复杂度。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是二进制字符串的长度。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def number_of_steps_to_reduce_binary(s: str) -> int:
    """
    函数式接口 - 返回将二进制表示减到 1 的步骤数
    """
    steps = 0
    carry = 0
    for i in range(len(s) - 1, 0, -1):
        if s[i] == '1':
            carry = 1
            while carry:
                if s[i] == '1':
                    s = s[:i] + '0' + s[i+1:]
                    steps += 1
                else:
                    break
                i -= 1
            steps += 1  # 加 1 操作
        steps += 1  # 除以 2 操作
    return steps


Solution = create_solution(number_of_steps_to_reduce_binary)