# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 403
标题: Frog Jump
难度: hard
链接: https://leetcode.cn/problems/frog-jump/
题目类型: 数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
403. 青蛙过河 - 一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。 给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃 1 个单位（即只能从单元格 1 跳至单元格 2 ）。 如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。 示例 1： 输入：stones = [0,1,3,5,6,8,12,17] 输出：true 解释：青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。 示例 2： 输入：stones = [0,1,2,3,4,8,9,11] 输出：false 解释：这是因为第 5 和第 6 个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。 提示： * 2 <= stones.length <= 2000 * 0 <= stones[i] <= 231 - 1 * stones[0] == 0 * stones 按严格升序排列
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 动态规划，dp[i][k]表示能否以步长k到达第i块石头

算法步骤:
1. 使用哈希表记录每块石头的位置
2. 使用集合dp[i]记录到达第i块石头时所有可能的步长
3. 对于每块石头，检查能否从前面的石头以k-1、k或k+1步到达
4. 最后检查能否到达最后一块石头

关键点:
- 使用动态规划和集合记录状态
- 时间复杂度O(n^2)，空间复杂度O(n^2)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2) - n为石头数量
空间复杂度: O(n^2) - dp数组空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from leetcode_solutions.utils.solution import create_solution


def frog_jump(stones: List[int]) -> bool:
    """
    函数式接口 - 青蛙过河
    
    实现思路:
    动态规划，dp[i][k]表示能否以步长k到达第i块石头。
    
    Args:
        stones: 石头位置列表（升序）
        
    Returns:
        能否成功过河
        
    Example:
        >>> frog_jump([0, 1, 3, 5, 6, 8, 12, 17])
        True
    """
    n = len(stones)
    # dp[i] 是一个集合，存储到达第i块石头时所有可能的步长
    dp = [set() for _ in range(n)]
    dp[0].add(0)  # 第一块石头，步长为0（起始状态）
    
    stone_positions = {stone: i for i, stone in enumerate(stones)}
    
    for i in range(n):
        for k in dp[i]:
            # 尝试k-1, k, k+1三种步长
            for step in [k - 1, k, k + 1]:
                if step > 0:  # 步长必须大于0
                    next_pos = stones[i] + step
                    if next_pos in stone_positions:
                        next_idx = stone_positions[next_pos]
                        dp[next_idx].add(step)
    
    return len(dp[n - 1]) > 0


# 自动生成Solution类（无需手动编写）
Solution = create_solution(frog_jump)
