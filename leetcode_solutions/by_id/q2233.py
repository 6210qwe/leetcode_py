# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2233
标题: Number of Smooth Descent Periods of a Stock
难度: medium
链接: https://leetcode.cn/problems/number-of-smooth-descent-periods-of-a-stock/
题目类型: 数组、数学、双指针、动态规划、滑动窗口
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2110. 股票平滑下跌阶段的数目 - 给你一个整数数组 prices ，表示一支股票的历史每日股价，其中 prices[i] 是这支股票第 i 天的价格。 一个 平滑下降的阶段 定义为：对于 连续一天或者多天 ，每日股价都比 前一日股价恰好少 1 ，这个阶段第一天的股价没有限制。 请你返回 平滑下降阶段 的数目。 示例 1： 输入：prices = [3,2,1,4] 输出：7 解释：总共有 7 个平滑下降阶段： [3], [2], [1], [4], [3,2], [2,1] 和 [3,2,1] 注意，仅一天按照定义也是平滑下降阶段。 示例 2： 输入：prices = [8,6,7,7] 输出：4 解释：总共有 4 个连续平滑下降阶段：[8], [6], [7] 和 [7] 由于 8 - 6 ≠ 1 ，所以 [8,6] 不是平滑下降阶段。 示例 3： 输入：prices = [1] 输出：1 解释：总共有 1 个平滑下降阶段：[1] 提示： * 1 <= prices.length <= 105 * 1 <= prices[i] <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用滑动窗口来计算平滑下降阶段的数量。

算法步骤:
1. 初始化两个变量 `count` 和 `total`，分别用于记录当前连续下降阶段的长度和总的平滑下降阶段数量。
2. 遍历价格数组，如果当前价格比前一天的价格恰好少 1，则增加 `count`，否则重置 `count` 为 1。
3. 每次更新 `count` 后，将 `count` 加到 `total` 中。
4. 返回 `total` 作为结果。

关键点:
- 使用滑动窗口的思想来计算连续下降阶段的长度。
- 每次更新 `count` 后，将其加到 `total` 中以累加所有平滑下降阶段的数量。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是价格数组的长度。我们只需要遍历一次数组。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(prices: List[int]) -> int:
    """
    函数式接口 - 计算平滑下降阶段的数量
    """
    if not prices:
        return 0

    count = 1
    total = 0

    for i in range(1, len(prices)):
        if prices[i] == prices[i - 1] - 1:
            count += 1
        else:
            count = 1
        total += count

    return total


Solution = create_solution(solution_function_name)