# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 37
标题: Sudoku Solver
难度: hard
链接: https://leetcode.cn/problems/sudoku-solver/
题目类型: 数组、哈希表、回溯、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
37. 解数独 - 编写一个程序，通过填充空格来解决数独问题。 数独的解法需 遵循如下规则： 1. 数字 1-9 在每一行只能出现一次。 2. 数字 1-9 在每一列只能出现一次。 3. 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图） 数独部分空格内已填入了数字，空白格用 '.' 表示。 示例 1： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png] 输入：board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]] 输出：[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]] 解释：输入的数独如上图所示，唯一有效的解决方案如下所示： [ https://assets.leetcode.cn/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714_solutionsvg.png] 提示： * board.length == 9 * board[i].length == 9 * board[i][j] 是一位数字或者 '.' * 题目数据 保证 输入数独仅有一个解
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 回溯算法，尝试在每个空格填入1-9，检查是否有效，如果无效则回溯

算法步骤:
1. 找到第一个空格
2. 尝试填入1-9，检查是否有效
3. 如果有效，递归求解下一个空格
4. 如果所有数字都无效，回溯

关键点:
- 使用回溯算法
- 时间复杂度O(9^m)，m为空格数，空间复杂度O(1)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(9^m) - m为空格数
空间复杂度: O(1) - 只使用常数额外空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from leetcode_solutions.utils.solution import create_solution


def sudoku_solver(board: List[List[str]]) -> None:
    """
    函数式接口 - 解数独
    
    实现思路:
    回溯算法，尝试在每个空格填入1-9，检查是否有效，如果无效则回溯。
    
    Args:
        board: 9x9数独板（原地修改）
        
    Returns:
        None（直接修改board）
        
    Example:
        >>> board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]
        >>> sudoku_solver(board)
    """
    def is_valid(row: int, col: int, num: str) -> bool:
        """检查在(row, col)位置填入num是否有效"""
        for i in range(9):
            # 检查行
            if board[row][i] == num:
                return False
            # 检查列
            if board[i][col] == num:
                return False
            # 检查3x3宫格
            if board[(row // 3) * 3 + i // 3][(col // 3) * 3 + i % 3] == num:
                return False
        return True
    
    def solve() -> bool:
        """回溯求解"""
        for i in range(9):
            for j in range(9):
                if board[i][j] == '.':
                    for num in '123456789':
                        if is_valid(i, j, num):
                            board[i][j] = num
                            if solve():
                                return True
                            board[i][j] = '.'
                    return False
        return True
    
    solve()


# 自动生成Solution类（无需手动编写）
Solution = create_solution(sudoku_solver)
