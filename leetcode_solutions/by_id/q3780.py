# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3780
标题: Permutations III
难度: medium
链接: https://leetcode.cn/problems/permutations-iii/
题目类型: 数组、回溯
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3437. 全排列 III - 备战技术面试？力扣提供海量技术面试资源，帮助你高效提升编程技能,轻松拿下世界 IT 名企 Dream Offer。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用回溯法生成所有可能的排列

算法步骤:
1. 初始化结果列表和当前路径列表
2. 定义回溯函数，参数为当前路径和剩余元素
3. 在回溯函数中，如果剩余元素为空，则将当前路径加入结果列表
4. 否则，遍历剩余元素，选择一个元素加入当前路径，并递归调用回溯函数
5. 递归返回后，从当前路径中移除该元素（回溯）

关键点:
- 使用回溯法生成所有排列
- 通过递归和回溯来构建所有可能的路径
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n!)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def permute(nums: List[int]) -> List[List[int]]:
    """
    生成数组 nums 的所有排列
    """
    def backtrack(path, remaining):
        if not remaining:
            result.append(path[:])
            return
        for i in range(len(remaining)):
            path.append(remaining[i])
            backtrack(path, remaining[:i] + remaining[i+1:])
            path.pop()

    result = []
    backtrack([], nums)
    return result

Solution = create_solution(permute)