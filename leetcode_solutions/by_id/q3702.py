# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3702
标题: Maximum Subarray With Equal Products
难度: easy
链接: https://leetcode.cn/problems/maximum-subarray-with-equal-products/
题目类型: 数组、数学、枚举、数论、滑动窗口
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3411. 最长乘积等价子数组 - 给你一个由 正整数 组成的数组 nums。 如果一个数组 arr 满足 prod(arr) == lcm(arr) * gcd(arr)，则称其为 乘积等价数组 ，其中： * prod(arr) 表示 arr 中所有元素的乘积。 * gcd(arr) 表示 arr 中所有元素的最大公因数 (GCD)。 * lcm(arr) 表示 arr 中所有元素的最小公倍数 (LCM)。 返回数组 nums 的 最长 乘积等价 子数组 的长度。 示例 1： 输入： nums = [1,2,1,2,1,1,1] 输出： 5 解释： 最长的乘积等价子数组是 [1, 2, 1, 1, 1]，其中 prod([1, 2, 1, 1, 1]) = 2， gcd([1, 2, 1, 1, 1]) = 1，以及 lcm([1, 2, 1, 1, 1]) = 2。 示例 2： 输入： nums = [2,3,4,5,6] 输出： 3 解释： 最长的乘积等价子数组是 [3, 4, 5]。 示例 3： 输入： nums = [1,2,3,1,4,5,1] 输出： 5 提示： * 2 <= nums.length <= 100 * 1 <= nums[i] <= 10
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用滑动窗口来找到最长的乘积等价子数组。

算法步骤:
1. 初始化两个指针 left 和 right 来表示当前窗口的左右边界。
2. 使用一个变量 max_length 来记录最长的乘积等价子数组的长度。
3. 在每次移动右指针时，计算当前窗口内的乘积、最大公约数和最小公倍数。
4. 如果当前窗口满足乘积等价条件，则更新 max_length。
5. 如果不满足条件，则移动左指针以缩小窗口，直到满足条件或窗口为空。
6. 返回 max_length。

关键点:
- 使用滑动窗口来高效地找到最长的乘积等价子数组。
- 通过维护当前窗口内的乘积、最大公约数和最小公倍数来判断是否满足乘积等价条件。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2)
空间复杂度: O(1)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import math

def solution_function_name(nums: List[int]) -> int:
    """
    函数式接口 - 找到最长的乘积等价子数组的长度
    """
    def gcd(a: int, b: int) -> int:
        return math.gcd(a, b)

    def lcm(a: int, b: int) -> int:
        return a * b // gcd(a, b)

    n = len(nums)
    max_length = 0

    for left in range(n):
        product = 1
        current_gcd = nums[left]
        current_lcm = nums[left]

        for right in range(left, n):
            product *= nums[right]
            current_gcd = gcd(current_gcd, nums[right])
            current_lcm = lcm(current_lcm, nums[right])

            if product == current_lcm * current_gcd:
                max_length = max(max_length, right - left + 1)

    return max_length

Solution = create_solution(solution_function_name)