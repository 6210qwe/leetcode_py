# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000231
标题: 二进制求和
难度: easy
链接: https://leetcode.cn/problems/JFETK5/
题目类型: 位运算、数学、字符串、模拟
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCR 002. 二进制求和 - 给定两个 01 字符串 a 和 b ，请计算它们的和，并以二进制字符串的形式输出。 输入为 非空 字符串且只包含数字 1 和 0。 示例 1： 输入: a = "11", b = "10" 输出: "101" 示例 2： 输入: a = "1010", b = "1011" 输出: "10101" 提示： * 每个字符串仅由字符 '0' 或 '1' 组成。 * 1 <= a.length, b.length <= 10^4 * 字符串如果不是 "0" ，就都不含前导零。 注意：本题与主站 67 题相同：https://leetcode.cn/problems/add-binary/ [https://leetcode.cn/problems/add-binary/]
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 模拟二进制加法，从低位到高位逐位相加

算法步骤:
1. 使用两个指针 i, j 分别指向字符串 a 和 b 的末尾，维护进位 carry
2. 从后往前遍历，当前位和为 bit_a + bit_b + carry
   - 当前结果位为 sum % 2
   - 新的进位为 sum // 2
3. 将每一位结果加入到结果字符串的末尾（可以先用列表收集，最后反转）
4. 遍历结束后，如果还有进位，补到最高位
5. 反转结果列表并拼接为字符串返回

关键点:
- 注意字符串长度可能不同，越界时当前位按 0 处理
- 结果可能比任一输入字符串多一位（最高位进位）
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(L) - L 为较长字符串的长度
空间复杂度: O(L) - 存储结果字符串
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def add_binary(a: str, b: str) -> str:
    """
    函数式接口 - 二进制求和
    """
    i, j = len(a) - 1, len(b) - 1
    carry = 0
    res: List[str] = []

    while i >= 0 or j >= 0 or carry:
        bit_a = int(a[i]) if i >= 0 else 0
        bit_b = int(b[j]) if j >= 0 else 0
        s = bit_a + bit_b + carry
        res.append(str(s % 2))
        carry = s // 2
        i -= 1
        j -= 1

    return "".join(reversed(res))


Solution = create_solution(add_binary)
