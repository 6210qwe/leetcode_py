# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1370
标题: Count Number of Nice Subarrays
难度: medium
链接: https://leetcode.cn/problems/count-number-of-nice-subarrays/
题目类型: 数组、哈希表、数学、前缀和、滑动窗口
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1248. 统计「优美子数组」 - 给你一个整数数组 nums 和一个整数 k。如果某个连续子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。 请返回这个数组中 「优美子数组」 的数目。 示例 1： 输入：nums = [1,1,2,1,1], k = 3 输出：2 解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。 示例 2： 输入：nums = [2,4,6], k = 1 输出：0 解释：数列中不包含任何奇数，所以不存在优美子数组。 示例 3： 输入：nums = [2,2,2,1,2,2,1,2,2,2], k = 2 输出：16 提示： * 1 <= nums.length <= 50000 * 1 <= nums[i] <= 10^5 * 1 <= k <= nums.length
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用前缀和 + 哈希表来记录奇数的数量，从而快速计算出符合条件的子数组数量。

算法步骤:
1. 初始化一个哈希表 `prefix_count`，用于记录前缀和出现的次数。初始时 `prefix_count[0] = 1`。
2. 遍历数组 `nums`，使用变量 `odd_count` 记录当前遍历到的奇数数量。
3. 对于每个元素，更新 `odd_count`。
4. 检查 `odd_count - k` 是否在 `prefix_count` 中，如果存在，则将其对应的值加到结果中。
5. 更新 `prefix_count` 中 `odd_count` 的出现次数。

关键点:
- 使用前缀和来记录奇数的数量。
- 使用哈希表来快速查找符合条件的前缀和。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是数组 `nums` 的长度。我们只需要遍历一次数组。
空间复杂度: O(n)，哈希表 `prefix_count` 在最坏情况下需要存储 n 个不同的前缀和。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def count_nice_subarrays(nums: List[int], k: int) -> int:
    """
    函数式接口 - 统计「优美子数组」的数量
    """
    prefix_count = {0: 1}
    odd_count = 0
    result = 0
    
    for num in nums:
        if num % 2 == 1:
            odd_count += 1
        if odd_count - k in prefix_count:
            result += prefix_count[odd_count - k]
        prefix_count[odd_count] = prefix_count.get(odd_count, 0) + 1
    
    return result

Solution = create_solution(count_nice_subarrays)