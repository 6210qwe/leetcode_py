# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1065
标题: Binary String With Substrings Representing 1 To N
难度: medium
链接: https://leetcode.cn/problems/binary-string-with-substrings-representing-1-to-n/
题目类型: 位运算、哈希表、字符串、滑动窗口
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1016. 子串能表示从 1 到 N 数字的二进制串 - 给定一个二进制字符串 s 和一个正整数 n，如果对于 [1, n] 范围内的每个整数，其二进制表示都是 s 的 子字符串 ，就返回 true，否则返回 false 。 子字符串 是字符串中连续的字符序列。 示例 1： 输入：s = "0110", n = 3 输出：true 示例 2： 输入：s = "0110", n = 4 输出：false 提示： * 1 <= s.length <= 1000 * s[i] 不是 '0' 就是 '1' * 1 <= n <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用集合存储所有可能的子串，并检查 [1, n] 范围内的每个整数的二进制表示是否在集合中。

算法步骤:
1. 初始化一个集合来存储所有可能的子串。
2. 遍历字符串 s 的所有长度为 1 到 30 的子串（因为 2^30 > 10^9），并将它们加入集合。
3. 遍历 [1, n] 范围内的每个整数，检查其二进制表示是否在集合中。
4. 如果所有整数的二进制表示都在集合中，返回 True；否则返回 False。

关键点:
- 使用集合存储子串以快速查找。
- 限制子串长度为 1 到 30，因为 2^30 > 10^9。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m * min(m, 30))，其中 m 是字符串 s 的长度。遍历字符串 s 的所有长度为 1 到 30 的子串。
空间复杂度: O(m * min(m, 30))，存储所有可能的子串。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def query_string(s: str, n: int) -> bool:
    """
    检查给定的二进制字符串 s 是否包含 [1, n] 范围内所有整数的二进制表示。
    """
    # 初始化集合来存储所有可能的子串
    substrings = set()
    
    # 遍历字符串 s 的所有长度为 1 到 30 的子串
    for i in range(len(s)):
        for j in range(i + 1, min(i + 31, len(s) + 1)):
            substrings.add(s[i:j])
    
    # 检查 [1, n] 范围内的每个整数的二进制表示是否在集合中
    for i in range(1, n + 1):
        if bin(i)[2:] not in substrings:
            return False
    
    return True


Solution = create_solution(query_string)