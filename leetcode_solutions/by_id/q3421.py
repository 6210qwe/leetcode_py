# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3421
标题: Count Pairs That Form a Complete Day I
难度: easy
链接: https://leetcode.cn/problems/count-pairs-that-form-a-complete-day-i/
题目类型: 数组、哈希表、计数
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3184. 构成整天的下标对数目 I - 给你一个整数数组 hours，表示以 小时 为单位的时间，返回一个整数，表示满足 i < j 且 hours[i] + hours[j] 构成 整天 的下标对 i, j 的数目。 整天 定义为时间持续时间是 24 小时的 整数倍 。 例如，1 天是 24 小时，2 天是 48 小时，3 天是 72 小时，以此类推。 示例 1： 输入： hours = [12,12,30,24,24] 输出： 2 解释： 构成整天的下标对分别是 (0, 1) 和 (3, 4)。 示例 2： 输入： hours = [72,48,24,3] 输出： 3 解释： 构成整天的下标对分别是 (0, 1)、(0, 2) 和 (1, 2)。 提示： * 1 <= hours.length <= 100 * 1 <= hours[i] <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用哈希表记录每个小时数出现的次数，然后遍历数组，对于每个小时数，查找其补数（即 24 * k - 当前小时数）在哈希表中的出现次数。

算法步骤:
1. 初始化一个哈希表 `hour_count` 来记录每个小时数出现的次数。
2. 遍历 `hours` 数组，对于每个小时数 `h`，计算其补数 `complement`。
3. 如果 `complement` 在 `hour_count` 中存在，则将 `hour_count[complement]` 加到结果中。
4. 更新 `hour_count` 中当前小时数 `h` 的计数。

关键点:
- 使用哈希表来记录每个小时数的出现次数，从而可以在 O(1) 时间内查找补数。
- 通过遍历数组并更新哈希表，可以在 O(n) 时间复杂度内完成计算。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def count_complete_pairs(hours: List[int]) -> int:
    """
    计算构成整天的下标对数目
    """
    hour_count = {}
    result = 0
    
    for h in hours:
        complement = 24 - (h % 24)
        if complement in hour_count:
            result += hour_count[complement]
        
        if h % 24 in hour_count:
            hour_count[h % 24] += 1
        else:
            hour_count[h % 24] = 1
    
    return result


Solution = create_solution(count_complete_pairs)