# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3234
标题: Double Modular Exponentiation
难度: medium
链接: https://leetcode.cn/problems/double-modular-exponentiation/
题目类型: 数组、数学、模拟
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2961. 双模幂运算 - 给你一个下标从 0 开始的二维数组 variables ，其中 variables[i] = [ai, bi, ci, mi]，以及一个整数 target 。 如果满足以下公式，则下标 i 是 好下标： * 0 <= i < variables.length * ((aibi % 10)ci) % mi == target 返回一个由 好下标 组成的数组，顺序不限 。 示例 1： 输入：variables = [[2,3,3,10],[3,3,3,1],[6,1,1,4]], target = 2 输出：[0,2] 解释：对于 variables 数组中的每个下标 i ： 1) 对于下标 0 ，variables[0] = [2,3,3,10] ，(23 % 10)3 % 10 = 2 。 2) 对于下标 1 ，variables[1] = [3,3,3,1] ，(33 % 10)3 % 1 = 0 。 3) 对于下标 2 ，variables[2] = [6,1,1,4] ，(61 % 10)1 % 4 = 2 。 因此，返回 [0,2] 作为答案。 示例 2： 输入：variables = [[39,3,1000,1000]], target = 17 输出：[] 解释：对于 variables 数组中的每个下标 i ： 1) 对于下标 0 ，variables[0] = [39,3,1000,1000] ，(393 % 10)1000 % 1000 = 1 。 因此，返回 [] 作为答案。 提示： * 1 <= variables.length <= 100 * variables[i] == [ai, bi, ci, mi] * 1 <= ai, bi, ci, mi <= 103 * 0 <= target <= 103
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用快速幂算法计算 (a^b % 10)^c % m，并检查结果是否等于 target。

算法步骤:
1. 定义一个快速幂函数 `mod_pow`，用于计算 (base^exp) % mod。
2. 遍历 variables 数组，对于每个变量，计算 (a^b % 10)^c % m。
3. 如果结果等于 target，则将当前下标添加到结果列表中。
4. 返回结果列表。

关键点:
- 使用快速幂算法可以高效地计算大幂次的模运算。
- 通过两次调用快速幂函数，分别计算 a^b % 10 和 (a^b % 10)^c % m。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * log(max(b, c)))，其中 n 是 variables 的长度，log(max(b, c)) 是快速幂的时间复杂度。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def mod_pow(base: int, exp: int, mod: int) -> int:
    """快速幂算法 (base^exp) % mod"""
    result = 1
    while exp > 0:
        if exp % 2 == 1:
            result = (result * base) % mod
        base = (base * base) % mod
        exp //= 2
    return result

def solution_function_name(variables: List[List[int]], target: int) -> List[int]:
    """
    函数式接口 - 实现双模幂运算
    """
    good_indices = []
    for i, (a, b, c, m) in enumerate(variables):
        # 计算 (a^b % 10)
        ab_mod_10 = mod_pow(a, b, 10)
        # 计算 (ab_mod_10^c % m)
        result = mod_pow(ab_mod_10, c, m)
        if result == target:
            good_indices.append(i)
    return good_indices

Solution = create_solution(solution_function_name)