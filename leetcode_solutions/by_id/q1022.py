# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1022
标题: Unique Paths III
难度: hard
链接: https://leetcode.cn/problems/unique-paths-iii/
题目类型: 位运算、数组、回溯、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
980. 不同路径 III - 在二维网格 grid 上，有 4 种类型的方格： * 1 表示起始方格。且只有一个起始方格。 * 2 表示结束方格，且只有一个结束方格。 * 0 表示我们可以走过的空方格。 * -1 表示我们无法跨越的障碍。 返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目。 每一个无障碍方格都要通过一次，但是一条路径中不能重复通过同一个方格。 示例 1： 输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]] 输出：2 解释：我们有以下两条路径： 1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2) 2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2) 示例 2： 输入：[[1,0,0,0],[0,0,0,0],[0,0,0,2]] 输出：4 解释：我们有以下四条路径： 1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3) 2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3) 3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3) 4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3) 示例 3： 输入：[[0,1],[2,0]] 输出：0 解释： 没有一条路能完全穿过每一个空的方格一次。 请注意，起始和结束方格可以位于网格中的任意位置。 提示： * 1 <= grid.length * grid[0].length <= 20
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用回溯法来遍历所有可能的路径，并记录满足条件的路径数。

算法步骤:
1. 初始化变量：找到起始位置，统计需要访问的空格数。
2. 定义回溯函数，递归地尝试四个方向的移动。
3. 在每次移动后，标记当前格子为已访问，并更新剩余需要访问的空格数。
4. 如果到达终点且所有空格都已访问，则计数加一。
5. 回溯时恢复现场，继续尝试其他路径。

关键点:
- 使用深度优先搜索（DFS）进行回溯。
- 记录已经访问过的格子，避免重复访问。
- 确保每个空格都被访问一次。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(3^(m*n))，其中 m 和 n 分别是网格的行数和列数。每个空格最多有 3 个方向可以选择。
空间复杂度: O(m*n)，递归调用栈的深度最多为 m*n。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def unique_paths_iii(grid: List[List[int]]) -> int:
    rows, cols = len(grid), len(grid[0])
    start_row, start_col = 0, 0
    empty_count = 1  # 包含起始格子

    # 找到起始位置并统计空格数
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == 1:
                start_row, start_col = r, c
            elif grid[r][c] == 0:
                empty_count += 1

    def dfs(r: int, c: int, count: int) -> int:
        if not (0 <= r < rows and 0 <= c < cols) or grid[r][c] == -1:
            return 0
        if grid[r][c] == 2:
            return 1 if count == 0 else 0
        grid[r][c] = -1  # 标记为已访问
        count -= 1
        total_paths = (
            dfs(r + 1, c, count)
            + dfs(r - 1, c, count)
            + dfs(r, c + 1, count)
            + dfs(r, c - 1, count)
        )
        grid[r][c] = 0  # 回溯
        count += 1
        return total_paths

    return dfs(start_row, start_col, empty_count)


Solution = create_solution(unique_paths_iii)