# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 310
标题: Minimum Height Trees
难度: medium
链接: https://leetcode.cn/problems/minimum-height-trees/
题目类型: 深度优先搜索、广度优先搜索、图、拓扑排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
310. 最小高度树 - 树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，任何一个没有简单环路的连通图都是一棵树。 给你一棵包含 n 个节点的树，标记为 0 到 n - 1 。给定数字 n 和一个有 n - 1 条无向边的 edges 列表（每一个边都是一对标签），其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 之间存在一条无向边。 可选择树中任何一个节点作为根。当选择节点 x 作为根节点时，设结果树的高度为 h 。在所有可能的树中，具有最小高度的树（即，min(h)）被称为 最小高度树 。 请你找到所有的 最小高度树 并按 任意顺序 返回它们的根节点标签列表。 树的 高度 是指根节点和叶子节点之间最长向下路径上边的数量。 示例 1： [https://assets.leetcode.com/uploads/2020/09/01/e1.jpg] 输入：n = 4, edges = [[1,0],[1,2],[1,3]] 输出：[1] 解释：如图所示，当根是标签为 1 的节点时，树的高度是 1 ，这是唯一的最小高度树。 示例 2： [https://assets.leetcode.com/uploads/2020/09/01/e2.jpg] 输入：n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]] 输出：[3,4] 提示： * 1 <= n <= 2 * 104 * edges.length == n - 1 * 0 <= ai, bi < n * ai != bi * 所有 (ai, bi) 互不相同 * 给定的输入 保证 是一棵树，并且 不会有重复的边
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用拓扑排序，从叶子节点开始逐层删除，最后剩下的1-2个节点就是最小高度树的根

算法步骤:
1. 构建邻接表和度数组
2. 将所有度为1的节点（叶子节点）加入队列
3. 逐层删除叶子节点，更新相邻节点的度
4. 最后剩下的1-2个节点就是答案

关键点:
- 使用拓扑排序找中心节点
- 时间复杂度O(n)，空间复杂度O(n)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 需要访问每个节点一次
空间复杂度: O(n) - 邻接表和队列空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from collections import deque, defaultdict
from leetcode_solutions.utils.solution import create_solution


def minimum_height_trees(n: int, edges: List[List[int]]) -> List[int]:
    """
    函数式接口 - 最小高度树
    
    实现思路:
    使用拓扑排序，从叶子节点开始逐层删除，最后剩下的1-2个节点就是最小高度树的根。
    
    Args:
        n: 节点数
        edges: 边列表
        
    Returns:
        所有最小高度树的根节点标签列表
        
    Example:
        >>> minimum_height_trees(4, [[1,0],[1,2],[1,3]])
        [1]
    """
    if n == 1:
        return [0]
    
    adj = defaultdict(list)
    degree = [0] * n
    
    for u, v in edges:
        adj[u].append(v)
        adj[v].append(u)
        degree[u] += 1
        degree[v] += 1
    
    # 将所有叶子节点加入队列
    queue = deque([i for i in range(n) if degree[i] == 1])
    remaining = n
    
    while remaining > 2:
        size = len(queue)
        remaining -= size
        
        for _ in range(size):
            node = queue.popleft()
            for neighbor in adj[node]:
                degree[neighbor] -= 1
                if degree[neighbor] == 1:
                    queue.append(neighbor)
    
    return list(queue)


# 自动生成Solution类（无需手动编写）
Solution = create_solution(minimum_height_trees)
