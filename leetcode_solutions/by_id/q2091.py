# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2091
标题: Number of Ways to Separate Numbers
难度: hard
链接: https://leetcode.cn/problems/number-of-ways-to-separate-numbers/
题目类型: 字符串、动态规划、后缀数组
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1977. 划分数字的方案数 - 你写下了若干 正整数 ，并将它们连接成了一个字符串 num 。但是你忘记给这些数字之间加逗号了。你只记得这一列数字是 非递减 的且 没有 任何数字有前导 0 。 请你返回有多少种可能的 正整数数组 可以得到字符串 num 。由于答案可能很大，将结果对 109 + 7 取余 后返回。 示例 1： 输入：num = "327" 输出：2 解释：以下为可能的方案： 3, 27 327 示例 2： 输入：num = "094" 输出：0 解释：不能有数字有前导 0 ，且所有数字均为正数。 示例 3： 输入：num = "0" 输出：0 解释：不能有数字有前导 0 ，且所有数字均为正数。 示例 4： 输入：num = "9999999999999" 输出：101 提示： * 1 <= num.length <= 3500 * num 只含有数字 '0' 到 '9' 。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划和后缀数组来解决这个问题。

算法步骤:
1. 初始化后缀数组 suffixes，其中 suffixes[i] 表示从位置 i 开始的后缀是否可以作为非递减序列的一部分。
2. 初始化 dp 数组，其中 dp[i] 表示从位置 i 开始的子字符串可以划分成多少种非递减序列。
3. 从右向左遍历字符串，更新 dp 和 suffixes 数组。
4. 最终结果保存在 dp[0] 中。

关键点:
- 使用后缀数组来快速判断当前子字符串是否可以作为非递减序列的一部分。
- 动态规划的状态转移方程需要考虑当前子字符串和后续子字符串的关系。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2)，其中 n 是字符串的长度。每个位置最多需要比较 n 次。
空间复杂度: O(n)，用于存储 dp 和 suffixes 数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def number_of_ways_to_separate_numbers(num: str) -> int:
    MOD = 10**9 + 7
    n = len(num)
    
    # 后缀数组，suffixes[i] 表示从位置 i 开始的后缀是否可以作为非递减序列的一部分
    suffixes = [False] * (n + 1)
    suffixes[n] = True
    
    # dp 数组，dp[i] 表示从位置 i 开始的子字符串可以划分成多少种非递减序列
    dp = [0] * (n + 1)
    dp[n] = 1
    
    for i in range(n - 1, -1, -1):
        if num[i] == '0':
            continue
        
        current_num = 0
        for j in range(i, n):
            current_num = current_num * 10 + int(num[j])
            if current_num > 2**63 - 1:
                break
            
            if j + 1 < n and num[j + 1] != '0' and suffixes[j + 1]:
                dp[i] += dp[j + 1]
                dp[i] %= MOD
                suffixes[i] = True
    
    return dp[0]


Solution = create_solution(number_of_ways_to_separate_numbers)