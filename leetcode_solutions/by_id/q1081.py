# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1081
标题: Video Stitching
难度: medium
链接: https://leetcode.cn/problems/video-stitching/
题目类型: 贪心、数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1024. 视频拼接 - 你将会获得一系列视频片段，这些片段来自于一项持续时长为 time 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。 使用数组 clips 描述所有的视频片段，其中 clips[i] = [starti, endi] 表示：某个视频片段开始于 starti 并于 endi 结束。 甚至可以对这些片段自由地再剪辑： * 例如，片段 [0, 7] 可以剪切成 [0, 1] + [1, 3] + [3, 7] 三部分。 我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, time]）。返回所需片段的最小数目，如果无法完成该任务，则返回 -1 。 示例 1： 输入：clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], time = 10 输出：3 解释： 选中 [0,2], [8,10], [1,9] 这三个片段。 然后，按下面的方案重制比赛片段： 将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。 现在手上的片段为 [0,2] + [2,8] + [8,10]，而这些覆盖了整场比赛 [0, 10]。 示例 2： 输入：clips = [[0,1],[1,2]], time = 5 输出：-1 解释： 无法只用 [0,1] 和 [1,2] 覆盖 [0,5] 的整个过程。 示例 3： 输入：clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], time = 9 输出：3 解释： 选取片段 [0,4], [4,7] 和 [6,9] 。 提示： * 1 <= clips.length <= 100 * 0 <= starti <= endi <= 100 * 1 <= time <= 100
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用贪心算法来选择最少的片段覆盖整个时间范围。

算法步骤:
1. 按片段的起始时间排序。
2. 初始化当前覆盖的结束时间为 0，片段计数为 0。
3. 遍历所有片段，选择能覆盖当前结束时间且结束时间最远的片段。
4. 更新当前覆盖的结束时间和片段计数。
5. 如果当前覆盖的结束时间已经大于等于目标时间，返回片段计数。
6. 如果遍历完所有片段仍无法覆盖目标时间，返回 -1。

关键点:
- 通过贪心选择每次能覆盖当前结束时间且结束时间最远的片段，确保使用最少的片段。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是 clips 的长度。排序操作的时间复杂度为 O(n log n)，遍历操作为 O(n)。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def video_stitching(clips: List[List[int]], time: int) -> int:
    """
    使用贪心算法来选择最少的片段覆盖整个时间范围。
    """
    # 按片段的起始时间排序
    clips.sort(key=lambda x: (x[0], -x[1]))
    
    # 初始化当前覆盖的结束时间和片段计数
    current_end, next_end = 0, 0
    count = 0
    
    for i in range(len(clips)):
        if clips[i][0] > current_end:
            # 如果当前片段的起始时间大于当前覆盖的结束时间，无法继续覆盖
            break
        
        # 选择能覆盖当前结束时间且结束时间最远的片段
        if clips[i][0] <= current_end:
            next_end = max(next_end, clips[i][1])
        
        # 如果当前片段是最后一个能覆盖当前结束时间的片段
        if i == len(clips) - 1 or clips[i + 1][0] > current_end:
            # 更新当前覆盖的结束时间和片段计数
            current_end = next_end
            count += 1
            
            # 如果当前覆盖的结束时间已经大于等于目标时间，返回片段计数
            if current_end >= time:
                return count
    
    # 如果遍历完所有片段仍无法覆盖目标时间，返回 -1
    return -1

Solution = create_solution(video_stitching)