# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3759
标题: Choose K Elements With Maximum Sum
难度: medium
链接: https://leetcode.cn/problems/choose-k-elements-with-maximum-sum/
题目类型: 数组、排序、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3478. 选出和最大的 K 个元素 - 给你两个整数数组，nums1 和 nums2，长度均为 n，以及一个正整数 k 。 对从 0 到 n - 1 每个下标 i ，执行下述操作： * 找出所有满足 nums1[j] 小于 nums1[i] 的下标 j 。 * 从这些下标对应的 nums2[j] 中选出 至多 k 个，并 最大化 这些值的总和作为结果。 返回一个长度为 n 的数组 answer ，其中 answer[i] 表示对应下标 i 的结果。 示例 1： 输入：nums1 = [4,2,1,5,3], nums2 = [10,20,30,40,50], k = 2 输出：[80,30,0,80,50] 解释： * 对于 i = 0 ：满足 nums1[j] < nums1[0] 的下标为 [1, 2, 4] ，选出其中值最大的两个，结果为 50 + 30 = 80 。 * 对于 i = 1 ：满足 nums1[j] < nums1[1] 的下标为 [2] ，只能选择这个值，结果为 30 。 * 对于 i = 2 ：不存在满足 nums1[j] < nums1[2] 的下标，结果为 0 。 * 对于 i = 3 ：满足 nums1[j] < nums1[3] 的下标为 [0, 1, 2, 4] ，选出其中值最大的两个，结果为 50 + 30 = 80 。 * 对于 i = 4 ：满足 nums1[j] < nums1[4] 的下标为 [1, 2] ，选出其中值最大的两个，结果为 30 + 20 = 50 。 示例 2： 输入：nums1 = [2,2,2,2], nums2 = [3,1,2,3], k = 1 输出：[0,0,0,0] 解释：由于 nums1 中的所有元素相等，不存在满足条件 nums1[j] < nums1[i]，所有位置的结果都是 0 。 提示： * n == nums1.length == nums2.length * 1 <= n <= 105 * 1 <= nums1[i], nums2[i] <= 106 * 1 <= k <= n
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用堆（优先队列）来维护每个下标 i 的最大 k 个 nums2[j] 值。

算法步骤:
1. 将 nums1 和 nums2 按照 nums1 的值进行排序。
2. 使用一个最小堆来维护当前下标 i 的前 k 个最大 nums2[j] 值。
3. 遍历排序后的数组，对于每个下标 i，将所有满足 nums1[j] < nums1[i] 的 nums2[j] 值加入堆中。
4. 如果堆的大小超过 k，则弹出堆顶元素。
5. 计算堆中元素的总和作为结果。

关键点:
- 使用堆来高效地维护前 k 个最大值。
- 通过排序和二分查找来快速找到满足条件的下标。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n + n log k) - 排序的时间复杂度是 O(n log n)，堆操作的时间复杂度是 O(log k)。
空间复杂度: O(n + k) - 存储排序后的数组和堆的空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def max_sum_k_elements(nums1: List[int], nums2: List[int], k: int) -> List[int]:
    n = len(nums1)
    indices = list(range(n))
    indices.sort(key=lambda x: nums1[x])
    
    result = [0] * n
    min_heap = []
    
    for i in range(n):
        while min_heap and nums1[indices[i]] > nums1[min_heap[0][1]]:
            _, j = heapq.heappop(min_heap)
            if len(min_heap) < k:
                heapq.heappush(min_heap, (nums2[j], j))
        
        heapq.heappush(min_heap, (nums2[indices[i]], indices[i]))
        if len(min_heap) > k:
            heapq.heappop(min_heap)
        
        result[indices[i]] = sum(val for val, _ in min_heap)
    
    return result

Solution = create_solution(max_sum_k_elements)