# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 634
标题: Find the Derangement of An Array
难度: medium
链接: https://leetcode.cn/problems/find-the-derangement-of-an-array/
题目类型: 数学、动态规划、组合数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
634. 寻找数组的错位排列 - 备战技术面试？力扣提供海量技术面试资源，帮助你高效提升编程技能,轻松拿下世界 IT 名企 Dream Offer。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划计算错位排列数

算法步骤:
1. 定义一个数组 dp，其中 dp[i] 表示 i 个元素的错位排列数。
2. 初始化 dp[0] = 1 和 dp[1] = 0。
3. 使用递推公式 dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) 计算 dp[n]。

关键点:
- 错位排列的递推公式为 D(n) = (n - 1) * (D(n - 1) + D(n - 2))
- 使用模运算防止整数溢出
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def find_derangement(n: int) -> int:
    """
    函数式接口 - 计算 n 个元素的错位排列数
    """
    if n == 0:
        return 1
    if n == 1:
        return 0

    MOD = 10**9 + 7
    dp = [0] * (n + 1)
    dp[0] = 1
    dp[1] = 0

    for i in range(2, n + 1):
        dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % MOD

    return dp[n]


Solution = create_solution(find_derangement)