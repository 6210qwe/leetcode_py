# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000266
标题: 打家劫舍 II
难度: medium
链接: https://leetcode.cn/problems/PzWKhm/
题目类型: 数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCR 090. 打家劫舍 II - 一个专业的小偷，计划偷窃一个环形街道上沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。 给定一个代表每个房屋存放金额的非负整数数组 nums ，请计算 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。 示例 1： 输入：nums = [2,3,2] 输出：3 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例 2： 输入：nums = [1,2,3,1] 输出：4 解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 3： 输入：nums = [0] 输出：0 提示： * 1 <= nums.length <= 100 * 0 <= nums[i] <= 1000 注意：本题与主站 213 题相同： https://leetcode.cn/problems/house-robber-ii/ [https://leetcode.cn/problems/house-robber-ii/]
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过将环形问题转化为两个线性问题来解决。分别考虑不包含首尾元素的情况，然后取最大值。

算法步骤:
1. 如果数组长度为1，直接返回该元素。
2. 将问题分为两个子问题：不包含最后一个元素的子数组和不包含第一个元素的子数组。
3. 对每个子数组应用打家劫舍I的动态规划解法。
4. 返回两个子问题的最大值。

关键点:
- 通过分治法将环形问题转化为两个线性问题。
- 使用动态规划求解线性问题。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(1)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def rob(nums: List[int]) -> int:
    def linear_rob(nums: List[int]) -> int:
        prev, curr = 0, 0
        for num in nums:
            prev, curr = curr, max(prev + num, curr)
        return curr
    
    if len(nums) == 1:
        return nums[0]
    
    return max(linear_rob(nums[:-1]), linear_rob(nums[1:]))

Solution = create_solution(rob)