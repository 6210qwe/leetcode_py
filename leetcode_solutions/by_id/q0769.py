# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 769
标题: Largest Plus Sign
难度: medium
链接: https://leetcode.cn/problems/largest-plus-sign/
题目类型: 数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
764. 最大加号标志 - 在一个 n x n 的矩阵 grid 中，除了在数组 mines 中给出的元素为 0，其他每个元素都为 1。mines[i] = [xi, yi]表示 grid[xi][yi] == 0 返回 grid 中包含 1 的最大的 轴对齐 加号标志的阶数 。如果未找到加号标志，则返回 0 。 一个 k 阶由 1 组成的 “轴对称”加号标志 具有中心网格 grid[r][c] == 1 ，以及4个从中心向上、向下、向左、向右延伸，长度为 k-1，由 1 组成的臂。注意，只有加号标志的所有网格要求为 1 ，别的网格可能为 0 也可能为 1 。 示例 1： [https://assets.leetcode.com/uploads/2021/06/13/plus1-grid.jpg] 输入: n = 5, mines = [[4, 2]] 输出: 2 解释: 在上面的网格中，最大加号标志的阶只能是2。一个标志已在图中标出。 示例 2： [https://assets.leetcode.com/uploads/2021/06/13/plus2-grid.jpg] 输入: n = 1, mines = [[0, 0]] 输出: 0 解释: 没有加号标志，返回 0 。 提示： * 1 <= n <= 500 * 1 <= mines.length <= 5000 * 0 <= xi, yi < n * 每一对 (xi, yi) 都 不重复
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来计算每个位置的最大加号标志阶数。

算法步骤:
1. 初始化一个 n x n 的矩阵 dp，其中 dp[i][j] 表示以 (i, j) 为中心的最大加号标志的阶数。
2. 将 mines 中的位置标记为 0，其余位置标记为 1。
3. 从四个方向（上、下、左、右）分别计算每个位置的最大连续 1 的长度。
4. 对于每个位置 (i, j)，dp[i][j] 取四个方向中的最小值。
5. 找到 dp 矩阵中的最大值。

关键点:
- 使用四个方向的动态规划来计算每个位置的最大加号标志阶数。
- 通过取四个方向中的最小值来确定当前点的最大加号标志阶数。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2)
空间复杂度: O(n^2)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(n: int, mines: List[List[int]]) -> int:
    """
    函数式接口 - 实现最大加号标志的阶数
    """
    # 初始化网格
    grid = [[1] * n for _ in range(n)]
    for x, y in mines:
        grid[x][y] = 0
    
    # 动态规划数组
    dp = [[0] * n for _ in range(n)]
    
    # 计算从左到右和从上到下的最大连续 1 的长度
    left, up = [0] * n, [0] * n
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 1:
                left[j] += 1
                up[i] += 1
                dp[i][j] = min(left[j], up[i])
            else:
                left[j] = 0
                up[i] = 0
    
    # 计算从右到左和从下到上的最大连续 1 的长度
    right, down = [0] * n, [0] * n
    for i in range(n - 1, -1, -1):
        for j in range(n - 1, -1, -1):
            if grid[i][j] == 1:
                right[j] += 1
                down[i] += 1
                dp[i][j] = min(dp[i][j], right[j], down[i])
            else:
                right[j] = 0
                down[i] = 0
    
    # 找到 dp 矩阵中的最大值
    return max(max(row) for row in dp)


Solution = create_solution(solution_function_name)