# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2818
标题: Maximum Strictly Increasing Cells in a Matrix
难度: hard
链接: https://leetcode.cn/problems/maximum-strictly-increasing-cells-in-a-matrix/
题目类型: 记忆化搜索、数组、哈希表、二分查找、动态规划、矩阵、有序集合、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2713. 矩阵中严格递增的单元格数 - 给你一个下标从 1 开始、大小为 m x n 的整数矩阵 mat，你可以选择任一单元格作为 起始单元格 。 从起始单元格出发，你可以移动到 同一行或同一列 中的任何其他单元格，但前提是目标单元格的值 严格大于 当前单元格的值。 你可以多次重复这一过程，从一个单元格移动到另一个单元格，直到无法再进行任何移动。 请你找出从某个单元开始访问矩阵所能访问的 单元格的最大数量 。 返回一个表示可访问单元格最大数量的整数。 示例 1： [https://assets.leetcode.com/uploads/2023/04/23/diag1drawio.png] 输入：mat = [[3,1],[3,4]] 输出：2 解释：上图展示了从第 1 行、第 2 列的单元格开始，可以访问 2 个单元格。可以证明，无论从哪个单元格开始，最多只能访问 2 个单元格，因此答案是 2 。 示例 2： [https://assets.leetcode.com/uploads/2023/04/23/diag3drawio.png] 输入：mat = [[1,1],[1,1]] 输出：1 解释：由于目标单元格必须严格大于当前单元格，在本示例中只能访问 1 个单元格。 示例 3： [https://assets.leetcode.com/uploads/2023/04/23/diag4drawio.png] 输入：mat = [[3,1,6],[-9,5,7]] 输出：4 解释：上图展示了从第 2 行、第 1 列的单元格开始，可以访问 4 个单元格。可以证明，无论从哪个单元格开始，最多只能访问 4 个单元格，因此答案是 4 。 提示： * m == mat.length * n == mat[i].length * 1 <= m, n <= 105 * 1 <= m * n <= 105 * -105 <= mat[i][j] <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划和有序集合来解决这个问题。

算法步骤:
1. 将所有单元格按值从小到大排序。
2. 使用两个数组 `row_max` 和 `col_max` 来记录每行和每列的最大路径长度。
3. 遍历排序后的单元格，更新每个单元格的最大路径长度，并更新 `row_max` 和 `col_max`。
4. 最后返回 `row_max` 和 `col_max` 中的最大值。

关键点:
- 使用有序集合来高效地找到每个单元格的前驱单元格。
- 动态规划的状态转移方程为 `dp[i][j] = max(row_max[i], col_max[j]) + 1`。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m * n * log(m * n)) - 排序的时间复杂度为 O(m * n * log(m * n))，遍历的时间复杂度为 O(m * n)。
空间复杂度: O(m * n) - 使用了额外的数组来存储每行和每列的最大路径长度。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from sortedcontainers import SortedList

def max_increasing_cells(mat: List[List[int]]) -> int:
    m, n = len(mat), len(mat[0])
    cells = [(val, i, j) for i, row in enumerate(mat) for j, val in enumerate(row)]
    cells.sort()

    row_max = [0] * m
    col_max = [0] * n
    dp = [[0] * n for _ in range(m)]

    for val, i, j in cells:
        dp[i][j] = max(row_max[i], col_max[j]) + 1
        row_max[i] = max(row_max[i], dp[i][j])
        col_max[j] = max(col_max[j], dp[i][j])

    return max(max(row_max), max(col_max))

Solution = create_solution(max_increasing_cells)