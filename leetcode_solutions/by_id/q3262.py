# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3262
标题: Find Polygon With the Largest Perimeter
难度: medium
链接: https://leetcode.cn/problems/find-polygon-with-the-largest-perimeter/
题目类型: 贪心、数组、前缀和、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2971. 找到最大周长的多边形 - 给你一个长度为 n 的 正 整数数组 nums 。 多边形 指的是一个至少有 3 条边的封闭二维图形。多边形的 最长边 一定 小于 所有其他边长度之和。 如果你有 k （k >= 3）个 正 数 a1，a2，a3, ...，ak 满足 a1 <= a2 <= a3 <= ... <= ak 且 a1 + a2 + a3 + ... + ak-1 > ak ，那么 一定 存在一个 k 条边的多边形，每条边的长度分别为 a1 ，a2 ，a3 ， ...，ak 。 一个多边形的 周长 指的是它所有边之和。 请你返回从 nums 中可以构造的 多边形 的 最大周长 。如果不能构造出任何多边形，请你返回 -1 。 示例 1： 输入：nums = [5,5,5] 输出：15 解释：nums 中唯一可以构造的多边形为三角形，每条边的长度分别为 5 ，5 和 5 ，周长为 5 + 5 + 5 = 15 。 示例 2： 输入：nums = [1,12,1,2,5,50,3] 输出：12 解释：最大周长多边形为五边形，每条边的长度分别为 1 ，1 ，2 ，3 和 5 ，周长为 1 + 1 + 2 + 3 + 5 = 12 。 我们无法构造一个包含变长为 12 或者 50 的多边形，因为其他边之和没法大于两者中的任何一个。 所以最大周长为 12 。 示例 3： 输入：nums = [5,5,50] 输出：-1 解释：无法构造任何多边形，因为多边形至少要有 3 条边且 50 > 5 + 5 。 提示： * 3 <= n <= 105 * 1 <= nums[i] <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 对数组进行排序，然后从最长边开始尝试构建多边形，直到找到满足条件的最大周长。

算法步骤:
1. 对数组进行排序。
2. 计算前缀和。
3. 从最长边开始，检查是否满足多边形条件（即当前边小于其余边之和）。
4. 如果满足条件，计算周长并更新最大周长。
5. 返回最大周长，如果没有找到符合条件的多边形则返回 -1。

关键点:
- 通过排序和前缀和快速判断多边形条件。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n) - 排序的时间复杂度。
空间复杂度: O(n) - 前缀和数组的空间复杂度。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def solution_function_name(nums: List[int]) -> int:
    """
    函数式接口 - 找到最大周长的多边形
    """
    if len(nums) < 3:
        return -1
    
    # 对数组进行排序
    nums.sort()
    
    # 计算前缀和
    prefix_sum = [0] * (len(nums) + 1)
    for i in range(1, len(nums) + 1):
        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]
    
    max_perimeter = -1
    
    # 从最长边开始，检查是否满足多边形条件
    for i in range(len(nums) - 1, 1, -1):
        if nums[i] < prefix_sum[i]:
            max_perimeter = prefix_sum[i + 1]
            break
    
    return max_perimeter

Solution = create_solution(solution_function_name)