# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1130
标题: Last Stone Weight II
难度: medium
链接: https://leetcode.cn/problems/last-stone-weight-ii/
题目类型: 数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1049. 最后一块石头的重量 II - 有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。 每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下： * 如果 x == y，那么两块石头都会被完全粉碎； * 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。 示例 1： 输入：stones = [2,7,4,1,8,1] 输出：1 解释： 组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]， 组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]， 组合 2 和 1，得到 1，所以数组转化为 [1,1,1]， 组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。 示例 2： 输入：stones = [31,26,33,21,40] 输出：5 提示： * 1 <= stones.length <= 30 * 1 <= stones[i] <= 100
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 将问题转化为一个背包问题，目标是将石头分成两堆，使得两堆的重量差最小。

算法步骤:
1. 计算所有石头的总重量 `total_weight`。
2. 目标是找到一个子集，使其重量尽可能接近 `total_weight // 2`。
3. 使用动态规划来解决这个问题，定义 `dp[i]` 表示是否可以凑出重量 `i`。
4. 初始化 `dp[0] = True`，表示重量为 0 是可以凑出来的。
5. 遍历每个石头，更新 `dp` 数组。
6. 最后，找到最大的 `i` 使得 `dp[i]` 为 `True`，计算 `total_weight - 2 * i` 即为最小的可能重量。

关键点:
- 将问题转化为背包问题，使用动态规划求解。
- 动态规划的状态转移方程为 `dp[j] = dp[j] or dp[j - stone]`。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * sum(stones))，其中 n 是石头的数量，sum(stones) 是石头的总重量。
空间复杂度: O(sum(stones))，用于存储动态规划数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def last_stone_weight_ii(stones: List[int]) -> int:
    """
    函数式接口 - 返回最后一块石头的最小可能重量
    """
    total_weight = sum(stones)
    target = total_weight // 2
    dp = [False] * (target + 1)
    dp[0] = True
    
    for stone in stones:
        for j in range(target, stone - 1, -1):
            dp[j] = dp[j] or dp[j - stone]
    
    for i in range(target, -1, -1):
        if dp[i]:
            return total_weight - 2 * i

Solution = create_solution(last_stone_weight_ii)