# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2616
标题: Maximal Score After Applying K Operations
难度: medium
链接: https://leetcode.cn/problems/maximal-score-after-applying-k-operations/
题目类型: 贪心、数组、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2530. 执行 K 次操作后的最大分数 - 给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。你的 起始分数 为 0 。 在一步 操作 中： 1. 选出一个满足 0 <= i < nums.length 的下标 i ， 2. 将你的 分数 增加 nums[i] ，并且 3. 将 nums[i] 替换为 ceil(nums[i] / 3) 。 返回在 恰好 执行 k 次操作后，你可能获得的最大分数。 向上取整函数 ceil(val) 的结果是大于或等于 val 的最小整数。 示例 1： 输入：nums = [10,10,10,10,10], k = 5 输出：50 解释：对数组中每个元素执行一次操作。最后分数是 10 + 10 + 10 + 10 + 10 = 50 。 示例 2： 输入：nums = [1,10,3,3,3], k = 3 输出：17 解释：可以执行下述操作： 第 1 步操作：选中 i = 1 ，nums 变为 [1,4,3,3,3] 。分数增加 10 。 第 2 步操作：选中 i = 1 ，nums 变为 [1,2,3,3,3] 。分数增加 4 。 第 3 步操作：选中 i = 2 ，nums 变为 [1,2,1,3,3] 。分数增加 3 。 最后分数是 10 + 4 + 3 = 17 。 提示： * 1 <= nums.length, k <= 105 * 1 <= nums[i] <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用最大堆来维护当前数组中的最大值，每次取出最大值进行操作，并将新的值重新加入堆中。

算法步骤:
1. 初始化一个最大堆，并将所有元素加入堆中。
2. 进行 k 次操作：
   - 从堆中取出最大值，将其加入分数。
   - 计算新的值（即 ceil(原值 / 3)），并将新值重新加入堆中。
3. 返回最终的分数。

关键点:
- 使用最大堆来高效地获取和更新最大值。
- 使用负数来实现 Python 的 heapq 模块作为最大堆。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(k log n)，其中 n 是数组的长度，k 是操作次数。每次操作涉及堆的插入和删除操作，时间复杂度为 O(log n)。
空间复杂度: O(n)，用于存储堆。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def maximal_score_after_k_operations(nums: List[int], k: int) -> int:
    """
    函数式接口 - 执行 K 次操作后的最大分数
    """
    # 将所有元素加入最大堆
    max_heap = [-num for num in nums]
    heapq.heapify(max_heap)
    
    score = 0
    for _ in range(k):
        # 取出最大值并加入分数
        max_value = -heapq.heappop(max_heap)
        score += max_value
        
        # 计算新的值并重新加入堆中
        new_value = -(-max_value // 3)
        heapq.heappush(max_heap, new_value)
    
    return score


Solution = create_solution(maximal_score_after_k_operations)