# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 959
标题: 3Sum With Multiplicity
难度: medium
链接: https://leetcode.cn/problems/3sum-with-multiplicity/
题目类型: 数组、哈希表、双指针、计数、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
923. 三数之和的多种可能 - 给定一个整数数组 arr ，以及一个整数 target 作为目标值，返回满足 i < j < k 且 arr[i] + arr[j] + arr[k] == target 的元组 i, j, k 的数量。 由于结果会非常大，请返回 109 + 7 的模。 示例 1： 输入：arr = [1,1,2,2,3,3,4,4,5,5], target = 8 输出：20 解释： 按值枚举(arr[i], arr[j], arr[k])： (1, 2, 5) 出现 8 次； (1, 3, 4) 出现 8 次； (2, 2, 4) 出现 2 次； (2, 3, 3) 出现 2 次。 示例 2： 输入：arr = [1,1,2,2,2,2], target = 5 输出：12 解释： arr[i] = 1, arr[j] = arr[k] = 2 出现 12 次： 我们从 [1,1] 中选择一个 1，有 2 种情况， 从 [2,2,2,2] 中选出两个 2，有 6 种情况。 提示： * 3 <= arr.length <= 3000 * 0 <= arr[i] <= 100 * 0 <= target <= 300
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用哈希表记录每个元素的出现次数，然后通过两层循环和哈希表查找来计算满足条件的三元组数量。

算法步骤:
1. 使用 Counter 记录数组中每个元素的出现次数。
2. 遍历数组中的每一对元素 (i, j)，计算它们的和 sum_ij。
3. 在哈希表中查找 target - sum_ij 的出现次数，并累加到结果中。
4. 特殊处理重复元素的情况，确保不重复计算。

关键点:
- 使用 Counter 来高效统计元素出现次数。
- 通过哈希表查找来快速计算满足条件的三元组数量。
- 处理重复元素时，使用组合数学公式来避免重复计算。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from collections import Counter

def threeSumMulti(arr: List[int], target: int) -> int:
    MOD = 10**9 + 7
    count = Counter(arr)
    keys = sorted(count.keys())
    result = 0

    for i in range(len(keys)):
        for j in range(i, len(keys)):
            k = target - keys[i] - keys[j]
            if k in count:
                if i < j < k:
                    result += count[keys[i]] * count[keys[j]] * count[k]
                elif i == j < k:
                    result += count[keys[i]] * (count[keys[i]] - 1) // 2 * count[k]
                elif i < j == k:
                    result += count[keys[i]] * count[keys[j]] * (count[keys[j]] - 1) // 2
                elif i == j == k:
                    result += count[keys[i]] * (count[keys[i]] - 1) * (count[keys[i]] - 2) // 6

    return result % MOD

Solution = create_solution(threeSumMulti)