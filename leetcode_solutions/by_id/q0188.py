# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 188
标题: Best Time to Buy and Sell Stock IV
难度: hard
链接: https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/
题目类型: 数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
188. 买卖股票的最佳时机 IV - 给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1： 输入：k = 2, prices = [2,4,1] 输出：2 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。 示例 2： 输入：k = 2, prices = [3,2,6,5,0,3] 输出：7 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。 随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。 提示： * 1 <= k <= 100 * 1 <= prices.length <= 1000 * 0 <= prices[i] <= 1000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 动态规划，dp[i][j][0/1]表示第i天完成j笔交易，持有/不持有股票的最大利润

算法步骤:
1. 如果k >= n/2，相当于可以无限次交易，使用贪心
2. 否则使用DP：buy[i][j]表示第i天完成j笔交易且持有股票的最大利润
3. sell[i][j]表示第i天完成j笔交易且不持有股票的最大利润

关键点:
- 优化：如果k很大，相当于无限次交易
- 空间优化：只使用一维数组
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n*k) - n为天数，k为交易次数
空间复杂度: O(k) - 优化后空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def max_profit(k: int, prices: List[int]) -> int:
    """
    函数式接口 - 买卖股票的最佳时机 IV
    
    实现思路:
    动态规划：如果k很大则用贪心，否则用DP。
    
    Args:
        k: 最多交易次数
        prices: 股票价格数组
        
    Returns:
        最大利润
        
    Example:
        >>> max_profit(2, [2,4,1])
        2
    """
    n = len(prices)
    if n < 2:
        return 0
    
    # 如果k >= n/2，相当于可以无限次交易
    if k >= n // 2:
        profit = 0
        for i in range(1, n):
            if prices[i] > prices[i-1]:
                profit += prices[i] - prices[i-1]
        return profit
    
    # DP：buy[j]表示完成j笔交易且持有股票的最大利润
    # sell[j]表示完成j笔交易且不持有股票的最大利润
    buy = [-float('inf')] * (k + 1)
    sell = [0] * (k + 1)
    
    for price in prices:
        for j in range(k, 0, -1):
            sell[j] = max(sell[j], buy[j] + price)
            buy[j] = max(buy[j], sell[j-1] - price)
    
    return sell[k]


# 自动生成Solution类（无需手动编写）
Solution = create_solution(max_profit)
