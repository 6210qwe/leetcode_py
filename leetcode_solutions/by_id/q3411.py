# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3411
标题: Find Products of Elements of Big Array
难度: hard
链接: https://leetcode.cn/problems/find-products-of-elements-of-big-array/
题目类型: 位运算、数组、二分查找
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3145. 大数组元素的乘积 - 一个非负整数 x 的 强数组 指的是满足元素为 2 的幂且元素总和为 x 的最短有序数组。下表说明了如何确定 强数组 的示例。可以证明，x 对应的强数组是独一无二的。 数字 二进制表示 强数组 1 00001 [1] 8 01000 [8] 10 01010 [2, 8] 13 01101 [1, 4, 8] 23 10111 [1, 2, 4, 16] 我们将每一个升序的正整数 i （即1，2，3等等）的 强数组 连接得到数组 big_nums ，big_nums 开始部分为 [1, 2, 1, 2, 4, 1, 4, 2, 4, 1, 2, 4, 8, ...] 。 给你一个二维整数数组 queries ，其中 queries[i] = [fromi, toi, modi] ，你需要计算 (big_nums[fromi] * big_nums[fromi + 1] * ... * big_nums[toi]) % modi 。 请你返回一个整数数组 answer ，其中 answer[i] 是第 i 个查询的答案。 示例 1： 输入：queries = [[1,3,7]] 输出：[4] 解释： 只有一个查询。 big_nums[1..3] = [2,1,2] 。它们的乘积为 4。结果为 4 % 7 = 4。 示例 2： 输入：queries = [[2,5,3],[7,7,4]] 输出：[2,2] 解释： 有两个查询。 第一个查询：big_nums[2..5] = [1,2,4,1] 。它们的乘积为 8 。结果为 8 % 3 = 2。 第二个查询：big_nums[7] = 2 。结果为 2 % 4 = 2。 提示： * 1 <= queries.length <= 500 * queries[i].length == 3 * 0 <= queries[i][0] <= queries[i][1] <= 1015 * 1 <= queries[i][2] <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 利用二进制表示来快速计算 big_nums 中的元素，并使用模乘法来处理大范围的乘积。

算法步骤:
1. 将每个查询中的 from 和 to 转换为对应的二进制表示。
2. 计算从 from 到 to 的所有元素的乘积，并在每一步中取模以防止溢出。
3. 返回每个查询的结果。

关键点:
- 使用二进制表示来快速找到 big_nums 中的元素。
- 使用模乘法来处理大范围的乘积。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(q * log(to)), 其中 q 是查询的数量，to 是查询范围的上限。
空间复杂度: O(1), 除了输入和输出外，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def solution_function_name(queries: List[List[int]]) -> List[int]:
    """
    函数式接口 - 实现最优解法
    """
    def get_bit(num: int, bit: int) -> int:
        """获取 num 的第 bit 位的值（从右到左，0 索引开始）"""
        return (num >> bit) & 1

    def product_of_range(from_val: int, to_val: int, mod: int) -> int:
        """计算从 from_val 到 to_val 的乘积，并对 mod 取模"""
        result = 1
        for i in range(from_val, to_val + 1):
            bit = 0
            while (i >> bit) > 0:
                if get_bit(i, bit):
                    result = (result * (1 << bit)) % mod
                bit += 1
        return result

    results = []
    for query in queries:
        from_val, to_val, mod = query
        results.append(product_of_range(from_val, to_val, mod))
    return results

Solution = create_solution(solution_function_name)