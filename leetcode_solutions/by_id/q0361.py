# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 361
标题: Bomb Enemy
难度: medium
链接: https://leetcode.cn/problems/bomb-enemy/
题目类型: 数组、动态规划、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
361. 轰炸敌人 - 备战技术面试？力扣提供海量技术面试资源，帮助你高效提升编程技能,轻松拿下世界 IT 名企 Dream Offer。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 行列预处理，按行列统计在当前连续段内可炸死的敌人数，遇到墙 `W` 重新计算。

算法步骤:
1. 设 m,n 为网格行列数，使用一维变量 `row_hit` 记录当前行从当前列向右在遇到墙前的敌人数；使用数组 `col_hit[j]` 记录当前列从当前行向下在遇到墙前的敌人数。
2. 遍历每个格子 (i,j)：
   - 若 j==0 或左边是墙，则从 j 往右扫到墙或边界，统计这一段中的敌人数，更新 `row_hit`。
   - 若 i==0 或上边是墙，则从 i 往下扫到墙或边界，统计这一段中的敌人数，更新 `col_hit[j]`。
3. 若当前格子是空地 `0`，则在该处放炸弹能炸死的敌人数为 `row_hit + col_hit[j]`，更新答案最大值。

关键点:
- 避免对每个空地都四向扫描，通过复用行/列连续段的统计结果将复杂度降到 O(mn)。
- 每当跨过墙 `W` 才重新统计，保证计数准确。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(mn)，每一行、每一列的连续段最多被扫描一次。
空间复杂度: O(n)，只需 `col_hit` 数组和常数额外变量。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def bomb_enemy(grid: List[List[str]]) -> int:
    """
    在网格中放置一枚炸弹，计算最多能炸死多少敌人。

    对每行每列做预处理，统计连续段中敌人数，遇到墙重置。
    """
    if not grid or not grid[0]:
        return 0

    m, n = len(grid), len(grid[0])
    row_hit = 0
    col_hit = [0] * n
    ans = 0

    for i in range(m):
        for j in range(n):
            if j == 0 or grid[i][j - 1] == 'W':
                row_hit = 0
                k = j
                while k < n and grid[i][k] != 'W':
                    if grid[i][k] == 'E':
                        row_hit += 1
                    k += 1

            if i == 0 or grid[i - 1][j] == 'W':
                col_hit[j] = 0
                k = i
                while k < m and grid[k][j] != 'W':
                    if grid[k][j] == 'E':
                        col_hit[j] += 1
                    k += 1

            if grid[i][j] == '0':
                ans = max(ans, row_hit + col_hit[j])

    return ans


# 自动生成Solution类（无需手动编写）
Solution = create_solution(bomb_enemy)
