# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 179
标题: Largest Number
难度: medium
链接: https://leetcode.cn/problems/largest-number/
题目类型: 贪心、数组、字符串、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
179. 最大数 - 给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。 注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。 示例 1： 输入：nums = [10,2] 输出："210" 示例 2： 输入：nums = [3,30,34,5,9] 输出："9534330" 提示： * 1 <= nums.length <= 100 * 0 <= nums[i] <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 自定义排序规则，比较两个数字拼接后的大小

算法步骤:
1. 将数字转换为字符串
2. 自定义排序规则：比较str(a)+str(b)和str(b)+str(a)
3. 按自定义规则排序后拼接
4. 处理前导零的情况

关键点:
- 自定义排序比较函数
- 时间复杂度O(nlogn)，空间复杂度O(n)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(nlogn) - 排序的时间复杂度
空间复杂度: O(n) - 存储字符串数组
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from functools import cmp_to_key
from leetcode_solutions.utils.solution import create_solution


def largest_number(nums: List[int]) -> str:
    """
    函数式接口 - 最大数
    
    实现思路:
    自定义排序规则，比较两个数字拼接后的大小。
    
    Args:
        nums: 非负整数数组
        
    Returns:
        重新排列后组成的最大数字字符串
        
    Example:
        >>> largest_number([10, 2])
        '210'
    """
    # 转换为字符串数组
    nums_str = [str(num) for num in nums]
    
    # 自定义排序：比较拼接后的字符串
    def compare(x: str, y: str) -> int:
        if x + y > y + x:
            return -1
        elif x + y < y + x:
            return 1
        else:
            return 0
    
    # 排序
    nums_str.sort(key=cmp_to_key(compare))
    
    # 处理前导零
    result = ''.join(nums_str)
    if result[0] == '0':
        return '0'
    
    return result


# 自动生成Solution类（无需手动编写）
Solution = create_solution(largest_number)
