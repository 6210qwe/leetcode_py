# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1617
标题: Stone Game IV
难度: hard
链接: https://leetcode.cn/problems/stone-game-iv/
题目类型: 数学、动态规划、博弈
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1510. 石子游戏 IV - Alice 和 Bob 两个人轮流玩一个游戏，Alice 先手。 一开始，有 n 个石子堆在一起。每个人轮流操作，正在操作的玩家可以从石子堆里拿走 任意 非零 平方数 个石子。 如果石子堆里没有石子了，则无法操作的玩家输掉游戏。 给你正整数 n ，且已知两个人都采取最优策略。如果 Alice 会赢得比赛，那么返回 True ，否则返回 False 。 示例 1： 输入：n = 1 输出：true 解释：Alice 拿走 1 个石子并赢得胜利，因为 Bob 无法进行任何操作。 示例 2： 输入：n = 2 输出：false 解释：Alice 只能拿走 1 个石子，然后 Bob 拿走最后一个石子并赢得胜利（2 -> 1 -> 0）。 示例 3： 输入：n = 4 输出：true 解释：n 已经是一个平方数，Alice 可以一次全拿掉 4 个石子并赢得胜利（4 -> 0）。 示例 4： 输入：n = 7 输出：false 解释：当 Bob 采取最优策略时，Alice 无法赢得比赛。 如果 Alice 一开始拿走 4 个石子， Bob 会拿走 1 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -> 3 -> 2 -> 1 -> 0）。 如果 Alice 一开始拿走 1 个石子， Bob 会拿走 4 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -> 6 -> 2 -> 1 -> 0）。 示例 5： 输入：n = 17 输出：false 解释：如果 Bob 采取最优策略，Alice 无法赢得胜利。 提示： * 1 <= n <= 10^5
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。定义 dp[i] 表示当前有 i 个石子时，当前玩家是否能够获胜。状态转移方程为：
dp[i] = not dp[i - k*k] for k in range(1, int(i**0.5) + 1)。

算法步骤:
1. 初始化 dp 数组，长度为 n+1，dp[0] = False，表示没有石子时当前玩家输。
2. 遍历从 1 到 n 的每个状态 i，对于每个 i，检查所有可能的平方数 k*k，如果存在一个 k 使得 dp[i - k*k] 为 False，则 dp[i] 为 True。
3. 返回 dp[n]。

关键点:
- 动态规划的状态转移方程。
- 使用平方数作为步长。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * sqrt(n))，其中 n 是石子的数量。我们需要遍历从 1 到 n 的每个状态，并对每个状态检查所有可能的平方数。
空间复杂度: O(n)，需要一个大小为 n+1 的 dp 数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(n: int) -> bool:
    """
    函数式接口 - 使用动态规划解决石子游戏 IV 问题
    """
    # 初始化 dp 数组
    dp = [False] * (n + 1)
    
    # 动态规划状态转移
    for i in range(1, n + 1):
        for k in range(1, int(i**0.5) + 1):
            if not dp[i - k * k]:
                dp[i] = True
                break
    
    return dp[n]


Solution = create_solution(solution_function_name)