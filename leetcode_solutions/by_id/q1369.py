# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1369
标题: Minimum Swaps to Make Strings Equal
难度: medium
链接: https://leetcode.cn/problems/minimum-swaps-to-make-strings-equal/
题目类型: 贪心、数学、字符串
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1247. 交换字符使得字符串相同 - 有两个长度相同的字符串 s1 和 s2，且它们其中 只含有 字符 "x" 和 "y"，你需要通过「交换字符」的方式使这两个字符串相同。 每次「交换字符」的时候，你都可以在两个字符串中各选一个字符进行交换。 交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换 s1[i] 和 s2[j]，但不能交换 s1[i] 和 s1[j]。 最后，请你返回使 s1 和 s2 相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回 -1 。 示例 1： 输入：s1 = "xx", s2 = "yy" 输出：1 解释： 交换 s1[0] 和 s2[1]，得到 s1 = "yx"，s2 = "yx"。 示例 2： 输入：s1 = "xy", s2 = "yx" 输出：2 解释： 交换 s1[0] 和 s2[0]，得到 s1 = "yy"，s2 = "xx" 。 交换 s1[0] 和 s2[1]，得到 s1 = "xy"，s2 = "xy" 。 注意，你不能交换 s1[0] 和 s1[1] 使得 s1 变成 "yx"，因为我们只能交换属于两个不同字符串的字符。 示例 3： 输入：s1 = "xx", s2 = "xy" 输出：-1 提示： * 1 <= s1.length, s2.length <= 1000 * s1.length == s2.length * s1, s2 只包含 'x' 或 'y'。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 统计不匹配的字符对，并根据字符对的类型计算最小交换次数。

算法步骤:
1. 统计 s1 和 s2 中不匹配的字符对 (x, y) 和 (y, x) 的数量。
2. 根据不匹配字符对的数量和类型计算最小交换次数：
   - 如果 (x, y) 和 (y, x) 的数量都是偶数，则每对 (x, y) 和 (y, x) 需要 1 次交换。
   - 如果 (x, y) 和 (y, x) 的数量都是奇数，则需要额外的 2 次交换来处理剩余的一对。
   - 如果 (x, y) 和 (y, x) 的数量一个是奇数一个是偶数，则无法通过交换使两个字符串相等，返回 -1。

关键点:
- 通过统计不匹配的字符对来简化问题。
- 根据字符对的类型和数量计算最小交换次数。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是字符串的长度，因为我们需要遍历字符串一次。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def minimum_swap(s1: str, s2: str) -> int:
    """
    计算使 s1 和 s2 相同的最小交换次数。
    """
    # 统计不匹配的字符对
    xy_count = 0
    yx_count = 0
    for c1, c2 in zip(s1, s2):
        if c1 != c2:
            if c1 == 'x':
                xy_count += 1
            else:
                yx_count += 1
    
    # 检查是否可以交换成功
    if (xy_count + yx_count) % 2 != 0:
        return -1
    
    # 计算最小交换次数
    swaps = xy_count // 2 + yx_count // 2
    if xy_count % 2 != 0:
        swaps += 2
    
    return swaps


Solution = create_solution(minimum_swap)