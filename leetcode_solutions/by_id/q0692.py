# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 692
标题: Top K Frequent Words
难度: medium
链接: https://leetcode.cn/problems/top-k-frequent-words/
题目类型: 字典树、数组、哈希表、字符串、桶排序、计数、排序、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
692. 前K个高频单词 - 给定一个单词列表 words 和一个整数 k ，返回前 k 个出现次数最多的单词。 返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率， 按字典顺序 排序。 示例 1： 输入: words = ["i", "love", "leetcode", "i", "love", "coding"], k = 2 输出: ["i", "love"] 解析: "i" 和 "love" 为出现次数最多的两个单词，均为2次。 注意，按字母顺序 "i" 在 "love" 之前。 示例 2： 输入: ["the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"], k = 4 输出: ["the", "is", "sunny", "day"] 解析: "the", "is", "sunny" 和 "day" 是出现次数最多的四个单词， 出现次数依次为 4, 3, 2 和 1 次。 注意： * 1 <= words.length <= 500 * 1 <= words[i].length <= 10 * words[i] 由小写英文字母组成。 * k 的取值范围是 [1, 不同 words[i] 的数量] 进阶：尝试以 O(n log k) 时间复杂度和 O(n) 空间复杂度解决。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用哈希表统计词频，然后使用最小堆来获取前 k 个高频单词。

算法步骤:
1. 使用哈希表统计每个单词的出现频率。
2. 使用一个大小为 k 的最小堆来存储前 k 个高频单词。
3. 最后从堆中取出单词并按频率降序和字典序升序排列。

关键点:
- 使用最小堆来保持前 k 个高频单词，并在插入时维护堆的大小。
- 自定义比较器来处理频率相同但字典序不同的情况。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log k)，其中 n 是单词的数量，k 是需要返回的高频单词数量。构建哈希表的时间复杂度是 O(n)，维护最小堆的时间复杂度是 O(n log k)。
空间复杂度: O(n + k)，哈希表的空间复杂度是 O(n)，最小堆的空间复杂度是 O(k)。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def top_k_frequent(words: List[str], k: int) -> List[str]:
    """
    返回前 k 个出现次数最多的单词。
    """
    # 统计每个单词的出现频率
    word_count = {}
    for word in words:
        word_count[word] = word_count.get(word, 0) + 1

    # 定义一个最小堆，用于存储前 k 个高频单词
    heap = []
    for word, freq in word_count.items():
        heapq.heappush(heap, (-freq, word))
        if len(heap) > k:
            heapq.heappop(heap)

    # 从堆中取出单词并按频率降序和字典序升序排列
    result = []
    while heap:
        freq, word = heapq.heappop(heap)
        result.append(word)
    return result[::-1]


Solution = create_solution(top_k_frequent)