# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1178
标题: Valid Palindrome III
难度: hard
链接: https://leetcode.cn/problems/valid-palindrome-iii/
题目类型: 字符串、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
给定一个字符串 s 和一个整数 k，判断是否可以通过删除最多 k 个字符将 s 变成回文串。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。定义 dp[i][j] 表示子串 s[i...j] 成为回文串需要删除的最少字符数。

算法步骤:
1. 初始化一个二维数组 dp，其中 dp[i][j] 表示 s[i...j] 成为回文串需要删除的最少字符数。
2. 对于单个字符，dp[i][i] = 0。
3. 对于长度为 2 的子串，如果 s[i] == s[j]，则 dp[i][j] = 0；否则 dp[i][j] = 1。
4. 对于长度大于 2 的子串，如果 s[i] == s[j]，则 dp[i][j] = dp[i+1][j-1]；否则 dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1。
5. 最后检查 dp[0][n-1] 是否小于等于 k。

关键点:
- 动态规划的状态转移方程。
- 边界条件的处理。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2)，其中 n 是字符串 s 的长度。
空间复杂度: O(n^2)，用于存储动态规划表。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(s: str, k: int) -> bool:
    """
    函数式接口 - 判断是否可以通过删除最多 k 个字符将 s 变成回文串
    """
    n = len(s)
    if n <= 1:
        return True

    # 初始化 dp 数组
    dp = [[0] * n for _ in range(n)]

    # 填充 dp 数组
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            if s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1]
            else:
                dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1

    # 检查 dp[0][n-1] 是否小于等于 k
    return dp[0][n - 1] <= k


Solution = create_solution(solution_function_name)