# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3494
标题: Minimum Cost for Cutting Cake I
难度: medium
链接: https://leetcode.cn/problems/minimum-cost-for-cutting-cake-i/
题目类型: 贪心、数组、双指针、动态规划、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3218. 切蛋糕的最小总开销 I - 有一个 m x n 大小的矩形蛋糕，需要切成 1 x 1 的小块。 给你整数 m ，n 和两个数组： * horizontalCut 的大小为 m - 1 ，其中 horizontalCut[i] 表示沿着水平线 i 切蛋糕的开销。 * verticalCut 的大小为 n - 1 ，其中 verticalCut[j] 表示沿着垂直线 j 切蛋糕的开销。 一次操作中，你可以选择任意不是 1 x 1 大小的矩形蛋糕并执行以下操作之一： 1. 沿着水平线 i 切开蛋糕，开销为 horizontalCut[i] 。 2. 沿着垂直线 j 切开蛋糕，开销为 verticalCut[j] 。 每次操作后，这块蛋糕都被切成两个独立的小蛋糕。 每次操作的开销都为最开始对应切割线的开销，并且不会改变。 请你返回将蛋糕全部切成 1 x 1 的蛋糕块的 最小 总开销。 示例 1： 输入：m = 3, n = 2, horizontalCut = [1,3], verticalCut = [5] 输出：13 解释： [https://assets.leetcode.com/uploads/2024/06/04/ezgifcom-animated-gif-maker-1.gif] * 沿着垂直线 0 切开蛋糕，开销为 5 。 * 沿着水平线 0 切开 3 x 1 的蛋糕块，开销为 1 。 * 沿着水平线 0 切开 3 x 1 的蛋糕块，开销为 1 。 * 沿着水平线 1 切开 2 x 1 的蛋糕块，开销为 3 。 * 沿着水平线 1 切开 2 x 1 的蛋糕块，开销为 3 。 总开销为 5 + 1 + 1 + 3 + 3 = 13 。 示例 2： 输入：m = 2, n = 2, horizontalCut = [7], verticalCut = [4] 输出：15 解释： * 沿着水平线 0 切开蛋糕，开销为 7 。 * 沿着垂直线 0 切开 1 x 2 的蛋糕块，开销为 4 。 * 沿着垂直线 0 切开 1 x 2 的蛋糕块，开销为 4 。 总开销为 7 + 4 + 4 = 15 。 提示： * 1 <= m, n <= 20 * horizontalCut.length == m - 1 * verticalCut.length == n - 1 * 1 <= horizontalCut[i], verticalCut[i] <= 103
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用贪心算法，每次选择当前最小的切割线进行切割。

算法步骤:
1. 将所有水平切割线和垂直切割线的开销放入一个列表中。
2. 对这个列表进行排序，按开销从小到大排序。
3. 依次选择开销最小的切割线进行切割，直到所有切割线都被使用。

关键点:
- 通过排序来确保每次选择的都是当前最小的切割线。
- 由于每次切割都会将蛋糕分成更小的部分，因此总开销是所有切割线开销的累加。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O((m + n) log (m + n))，因为排序的时间复杂度是 O((m + n) log (m + n))。
空间复杂度: O(m + n)，用于存储所有的切割线及其开销。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def minimum_cost_for_cutting_cake(m: int, n: int, horizontal_cut: List[int], vertical_cut: List[int]) -> int:
    """
    返回将蛋糕全部切成 1 x 1 的蛋糕块的最小总开销。
    """
    # 将所有切割线的开销放入一个列表中
    cuts = [(cost, 'h') for cost in horizontal_cut] + [(cost, 'v') for cost in vertical_cut]
    
    # 按开销从小到大排序
    cuts.sort()
    
    # 初始化水平和垂直切割线的数量
    h_count = m - 1
    v_count = n - 1
    
    total_cost = 0
    
    # 依次选择开销最小的切割线进行切割
    for cost, direction in cuts:
        if direction == 'h' and h_count > 0:
            total_cost += cost * v_count
            h_count -= 1
        elif direction == 'v' and v_count > 0:
            total_cost += cost * h_count
            v_count -= 1
    
    return total_cost

Solution = create_solution(minimum_cost_for_cutting_cake)