# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 100184
标题: Palindrome Permutation LCCI
难度: easy
链接: https://leetcode.cn/problems/palindrome-permutation-lcci/
题目类型: 位运算、哈希表、字符串
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
面试题 01.04. 回文排列 - 给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。 回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。 回文串不一定是字典当中的单词。 示例1： 输入："tactcoa" 输出：true（排列有"tacocat"、"atcocta"，等等）
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用哈希表统计字符出现的次数，然后检查是否有超过一个字符出现了奇数次。

算法步骤:
1. 初始化一个哈希表来记录每个字符的出现次数。
2. 遍历字符串，更新哈希表中每个字符的计数。
3. 检查哈希表中出现奇数次的字符数量，如果超过一个，则不能构成回文排列。

关键点:
- 只有一个字符可以出现奇数次，其余字符必须出现偶数次。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是字符串的长度。我们需要遍历整个字符串一次。
空间复杂度: O(1)，虽然使用了哈希表，但由于字符集是有限的（ASCII 或 Unicode），因此空间复杂度可以视为常数。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def can_permute_palindrome(s: str) -> bool:
    """
    判断给定字符串是否可以通过重新排列形成回文串。
    """
    char_count = {}
    
    # 统计每个字符的出现次数
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    
    # 检查出现奇数次的字符数量
    odd_count = 0
    for count in char_count.values():
        if count % 2 != 0:
            odd_count += 1
            if odd_count > 1:
                return False
    
    return True


Solution = create_solution(can_permute_palindrome)