# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 696
标题: Count Binary Substrings
难度: easy
链接: https://leetcode.cn/problems/count-binary-substrings/
题目类型: 双指针、字符串
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
696. 计数二进制子串 - 给定一个字符串 s，统计并返回具有相同数量 0 和 1 的非空（连续）子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是成组连续的。 重复出现（不同位置）的子串也要统计它们出现的次数。 示例 1： 输入：s = "00110011" 输出：6 解释：6 个子串满足具有相同数量的连续 1 和 0 ："0011"、"01"、"1100"、"10"、"0011" 和 "01" 。 注意，一些重复出现的子串（不同位置）要统计它们出现的次数。 另外，"00110011" 不是有效的子串，因为所有的 0（还有 1 ）没有组合在一起。 示例 2： 输入：s = "10101" 输出：4 解释：有 4 个子串："10"、"01"、"10"、"01" ，具有相同数量的连续 1 和 0 。 提示： * 1 <= s.length <= 105 * s[i] 为 '0' 或 '1'
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用双指针法来遍历字符串，记录每个连续字符段的长度，然后比较相邻段的长度来计算符合条件的子串数量。

算法步骤:
1. 初始化两个变量 `prev` 和 `curr` 分别记录前一段和当前段的长度。
2. 遍历字符串，更新 `prev` 和 `curr`。
3. 每当遇到不同的字符时，将 `prev` 和 `curr` 中的较小值加到结果中，并更新 `prev` 为 `curr`，重置 `curr` 为 1。
4. 最后一次更新 `prev` 和 `curr` 后，再进行一次结果累加。

关键点:
- 使用双指针法可以在线性时间内完成遍历。
- 通过记录每段连续字符的长度，可以方便地计算符合条件的子串数量。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是字符串 s 的长度。我们只需要遍历字符串一次。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def count_binary_substrings(s: str) -> int:
    """
    函数式接口 - 计算具有相同数量 0 和 1 的非空（连续）子字符串的数量。
    """
    prev, curr, result = 0, 1, 0
    
    for i in range(1, len(s)):
        if s[i] == s[i - 1]:
            curr += 1
        else:
            result += min(prev, curr)
            prev, curr = curr, 1
    
    result += min(prev, curr)
    
    return result


Solution = create_solution(count_binary_substrings)