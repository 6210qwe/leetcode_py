# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2848
标题: Special Permutations
难度: medium
链接: https://leetcode.cn/problems/special-permutations/
题目类型: 位运算、数组、动态规划、状态压缩
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2741. 特别的排列 - 给你一个下标从 0 开始的整数数组 nums ，它包含 n 个 互不相同 的正整数。如果 nums 的一个排列满足以下条件，我们称它是一个特别的排列： * 对于 0 <= i < n - 1 的下标 i ，要么 nums[i] % nums[i+1] == 0 ，要么 nums[i+1] % nums[i] == 0 。 请你返回特别排列的总数目，由于答案可能很大，请将它对 109 + 7 取余 后返回。 示例 1： 输入：nums = [2,3,6] 输出：2 解释：[3,6,2] 和 [2,6,3] 是 nums 两个特别的排列。 示例 2： 输入：nums = [1,4,3] 输出：2 解释：[3,1,4] 和 [4,1,3] 是 nums 两个特别的排列。 提示： * 2 <= nums.length <= 14 * 1 <= nums[i] <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划和状态压缩来解决这个问题。我们使用一个二维 DP 数组 dp[mask][i] 来表示当前选择的状态为 mask 且最后一个元素是 nums[i] 的特别排列的数量。

算法步骤:
1. 初始化一个二维 DP 数组 dp，其中 dp[0][i] = 1 表示只选择第 i 个元素的初始状态。
2. 遍历所有可能的状态 mask，并对于每个状态，遍历所有可能的最后一个元素 j。
3. 对于每个状态 mask 和最后一个元素 j，遍历所有可能的前一个元素 k，如果 nums[k] 和 nums[j] 满足条件，则更新 dp[mask][j]。
4. 最终结果是所有状态为 (1 << n) - 1 的 dp 值之和。

关键点:
- 使用位掩码来表示状态，减少空间复杂度。
- 动态规划的转移方程需要考虑所有可能的前一个元素。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2 * 2^n)
- n 是 nums 的长度，2^n 是所有可能的状态数，n^2 是状态转移的时间复杂度。

空间复杂度: O(n * 2^n)
- dp 数组的大小为 n * 2^n。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

MOD = 10**9 + 7

def count_special_permutations(nums: List[int]) -> int:
    n = len(nums)
    dp = [[0] * n for _ in range(1 << n)]
    
    # Initialize the DP table
    for i in range(n):
        dp[1 << i][i] = 1
    
    # Fill the DP table
    for mask in range(1, 1 << n):
        for j in range(n):
            if mask & (1 << j) == 0:
                continue
            for k in range(n):
                if mask & (1 << k) and (nums[k] % nums[j] == 0 or nums[j] % nums[k] == 0):
                    dp[mask][j] += dp[mask ^ (1 << j)][k]
                    dp[mask][j] %= MOD
    
    # Sum up all valid permutations
    result = sum(dp[(1 << n) - 1]) % MOD
    return result

Solution = count_special_permutations