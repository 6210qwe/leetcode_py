# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 679
标题: 24 Game
难度: hard
链接: https://leetcode.cn/problems/24-game/
题目类型: 数组、数学、回溯
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
679. 24 点游戏 - 给定一个长度为4的整数数组 cards 。你有 4 张卡片，每张卡片上都包含一个范围在 [1,9] 的数字。您应该使用运算符 ['+', '-', '*', '/'] 和括号 '(' 和 ')' 将这些卡片上的数字排列成数学表达式，以获得值24。 你须遵守以下规则: * 除法运算符 '/' 表示实数除法，而不是整数除法。 * 例如， 4 /(1 - 2 / 3)= 4 /(1 / 3)= 12 。 * 每个运算都在两个数字之间。特别是，不能使用 “-” 作为一元运算符。 * 例如，如果 cards =[1,1,1,1] ，则表达式 “-1 -1 -1 -1” 是 不允许 的。 * 你不能把数字串在一起 * 例如，如果 cards =[1,2,1,2] ，则表达式 “12 + 12” 无效。 如果可以得到这样的表达式，其计算结果为 24 ，则返回 true ，否则返回 false 。 示例 1: 输入: cards = [4, 1, 8, 7] 输出: true 解释: (8-4) * (7-1) = 24 示例 2: 输入: cards = [1, 2, 1, 2] 输出: false 提示: * cards.length == 4 * 1 <= cards[i] <= 9
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 回溯 + 枚举两两运算结果

算法步骤:
1. 将输入的 4 个整数转换为浮点数列表 nums
2. 定义递归函数 dfs(nums):
   - 若 len(nums) == 1，则判断该数与 24 是否足够接近（误差 < 1e-6）
   - 否则，从 nums 中任取两个数 a, b，计算它们的所有可能运算结果:
     a + b, a - b, b - a, a * b, a / b (b != 0), b / a (a != 0)
   - 将运算结果与剩余的数字一起组成新的列表，递归调用 dfs
3. 如果任意一条递归路径返回 True，则整体返回 True，否则返回 False

关键点:
- 使用浮点数并设置误差范围，避免精度问题
- 运算需要考虑顺序：减法和除法是不可交换的
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(1) - 状态空间有限，上界常数（最多 4! * 若干运算组合）
空间复杂度: O(1) - 递归深度和中间列表大小均有常数上界
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def judge_point_24(cards: List[int]) -> bool:
    """
    函数式接口 - 24 点游戏
    """
    nums = [float(x) for x in cards]
    EPS = 1e-6

    def dfs(arr: List[float]) -> bool:
        if len(arr) == 1:
            return abs(arr[0] - 24.0) < EPS

        n = len(arr)
        # 选出两个数做运算
        for i in range(n):
            for j in range(i + 1, n):
                a, b = arr[i], arr[j]
                next_nums: List[float] = []
                # 把没选到的数加入新数组
                for k in range(n):
                    if k != i and k != j:
                        next_nums.append(arr[k])

                # 枚举所有可能的运算结果
                candidates = [
                    a + b,
                    a - b,
                    b - a,
                    a * b,
                ]
                if abs(b) > EPS:
                    candidates.append(a / b)
                if abs(a) > EPS:
                    candidates.append(b / a)

                for val in candidates:
                    next_nums.append(val)
                    if dfs(next_nums):
                        return True
                    next_nums.pop()

        return False

    return dfs(nums)


Solution = create_solution(judge_point_24)
