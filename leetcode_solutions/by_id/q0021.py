# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 21
标题: Merge Two Sorted Lists
难度: easy
链接: https://leetcode.cn/problems/merge-two-sorted-lists/
题目类型: 递归、链表
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
21. 合并两个有序链表 - 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 1： [https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg] 输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4] 示例 2： 输入：l1 = [], l2 = [] 输出：[] 示例 3： 输入：l1 = [], l2 = [0] 输出：[0] 提示： * 两个链表的节点数目范围是 [0, 50] * -100 <= Node.val <= 100 * l1 和 l2 均按 非递减顺序 排列
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 迭代法，使用虚拟头节点，比较两个链表的节点值，将较小的节点连接到结果链表

算法步骤:
1. 创建虚拟头节点dummy和当前指针cur
2. 当两个链表都不为空时：
   - 比较两个链表的当前节点值
   - 将较小的节点连接到cur.next
   - 移动对应的链表指针和cur指针
3. 将剩余的非空链表连接到cur.next
4. 返回dummy.next

关键点:
- 使用虚拟头节点简化代码，避免特殊处理
- 迭代法空间复杂度O(1)，递归法空间复杂度O(m+n)
- 时间复杂度O(m+n)，m和n分别为两个链表的长度
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m + n) - 需要遍历两个链表的所有节点，m和n分别为两个链表的长度
空间复杂度: O(1) - 只使用常数额外空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.solution import create_solution


def merge_two_lists(list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
    """
    函数式接口 - 迭代法实现
    
    实现思路:
    使用虚拟头节点，比较两个链表的节点值，将较小的节点连接到结果链表。
    
    Args:
        list1: 第一个有序链表
        list2: 第二个有序链表
        
    Returns:
        合并后的有序链表
        
    Example:
        >>> l1 = ListNode.from_list([1,2,4])
        >>> l2 = ListNode.from_list([1,3,4])
        >>> result = merge_two_lists(l1, l2)
        >>> result.to_list()
        [1, 1, 2, 3, 4, 4]
    """
    dummy = ListNode(0)
    cur = dummy
    
    while list1 and list2:
        if list1.val <= list2.val:
            cur.next = list1
            list1 = list1.next
        else:
            cur.next = list2
            list2 = list2.next
        cur = cur.next
    
    # 连接剩余部分
    cur.next = list1 if list1 else list2
    
    return dummy.next


# 自动生成Solution类（无需手动编写）
Solution = create_solution(merge_two_lists)
