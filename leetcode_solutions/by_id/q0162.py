# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 162
标题: Find Peak Element
难度: medium
链接: https://leetcode.cn/problems/find-peak-element/
题目类型: 数组、二分查找
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
162. 寻找峰值 - 峰值元素是指其值严格大于左右相邻值的元素。 给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。 你可以假设 nums[-1] = nums[n] = -∞ 。 你必须实现时间复杂度为 O(log n) 的算法来解决此问题。 示例 1： 输入：nums = [1,2,3,1] 输出：2 解释：3 是峰值元素，你的函数应该返回其索引 2。 示例 2： 输入：nums = [1,2,1,3,5,6,4] 输出：1 或 5 解释：你的函数可以返回索引 1，其峰值元素为 2； 或者返回索引 5， 其峰值元素为 6。 提示： * 1 <= nums.length <= 1000 * -231 <= nums[i] <= 231 - 1 * 对于所有有效的 i 都有 nums[i] != nums[i + 1]
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用二分查找，根据趋势判断峰值位置

算法步骤:
1. 使用二分查找，比较nums[mid]和nums[mid+1]
2. 如果nums[mid] < nums[mid+1]，峰值在右半部分
3. 否则峰值在左半部分（包括mid）
4. 当left==right时，找到峰值

关键点:
- 根据相邻元素的大小关系判断峰值方向
- 时间复杂度O(logn)，空间复杂度O(1)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(logn) - 二分查找
空间复杂度: O(1) - 只使用常数额外空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from leetcode_solutions.utils.solution import create_solution


def find_peak_element(nums: List[int]) -> int:
    """
    函数式接口 - 寻找峰值元素
    
    实现思路:
    使用二分查找，根据相邻元素的大小关系判断峰值方向。
    
    Args:
        nums: 整数数组
        
    Returns:
        峰值元素的索引
        
    Example:
        >>> find_peak_element([1, 2, 3, 1])
        2
    """
    left, right = 0, len(nums) - 1
    
    while left < right:
        mid = (left + right) // 2
        
        if nums[mid] < nums[mid + 1]:
            left = mid + 1
        else:
            right = mid
    
    return left


# 自动生成Solution类（无需手动编写）
Solution = create_solution(find_peak_element)
