# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 986
标题: Largest Time for Given Digits
难度: medium
链接: https://leetcode.cn/problems/largest-time-for-given-digits/
题目类型: 数组、字符串、回溯、枚举
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
949. 给定数字能组成的最大时间 - 给定一个由 4 位数字组成的数组，返回可以设置的符合 24 小时制的最大时间。 24 小时格式为 "HH:MM" ，其中 HH 在 00 到 23 之间，MM 在 00 到 59 之间。最小的 24 小时制时间是 00:00 ，而最大的是 23:59 。从 00:00 （午夜）开始算起，过得越久，时间越大。 以长度为 5 的字符串，按 "HH:MM" 格式返回答案。如果不能确定有效时间，则返回空字符串。 示例 1： 输入：arr = [1,2,3,4] 输出："23:41" 解释：有效的 24 小时制时间是 "12:34"，"12:43"，"13:24"，"13:42"，"14:23"，"14:32"，"21:34"，"21:43"，"23:14" 和 "23:41" 。这些时间中，"23:41" 是最大时间。 示例 2： 输入：arr = [5,5,5,5] 输出："" 解释：不存在有效的 24 小时制时间，因为 "55:55" 无效。 示例 3： 输入：arr = [0,0,0,0] 输出："00:00" 示例 4： 输入：arr = [0,0,1,0] 输出："10:00" 提示： * arr.length == 4 * 0 <= arr[i] <= 9
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 枚举所有可能的时间组合，并找到最大的有效时间。

算法步骤:
1. 生成所有可能的 4 个数字的排列。
2. 检查每个排列是否形成有效的时间（小时在 00 到 23 之间，分钟在 00 到 59 之间）。
3. 从所有有效的时间中选择最大的时间。

关键点:
- 使用 itertools.permutations 生成所有排列。
- 通过条件判断检查时间的有效性。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(1)
空间复杂度: O(1)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution
import itertools

def solution_function_name(arr: List[int]) -> str:
    """
    函数式接口 - 返回给定数字能组成的最大时间
    """
    max_time = ""
    
    # 生成所有可能的排列
    for perm in itertools.permutations(arr):
        hours, minutes = perm[:2], perm[2:]
        hour = hours[0] * 10 + hours[1]
        minute = minutes[0] * 10 + minutes[1]
        
        # 检查是否形成有效的时间
        if 0 <= hour < 24 and 0 <= minute < 60:
            time = f"{hour:02d}:{minute:02d}"
            if time > max_time:
                max_time = time
    
    return max_time

Solution = create_solution(solution_function_name)