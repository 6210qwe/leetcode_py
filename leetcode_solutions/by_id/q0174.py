# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 174
标题: Dungeon Game
难度: hard
链接: https://leetcode.cn/problems/dungeon-game/
题目类型: 数组、动态规划、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
174. 地下城游戏 - 恶魔们抓住了公主并将她关在了地下城 dungeon 的 右下角 。地下城是由 m x n 个房间组成的二维网格。我们英勇的骑士最初被安置在 左上角 的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。 骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。 有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。 为了尽快解救公主，骑士决定每次只 向右 或 向下 移动一步。 返回确保骑士能够拯救到公主所需的最低初始健康点数。 注意：任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。 示例 1： [https://assets.leetcode.com/uploads/2021/03/13/dungeon-grid-1.jpg] 输入：dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]] 输出：7 解释：如果骑士遵循最佳路径：右 -> 右 -> 下 -> 下 ，则骑士的初始健康点数至少为 7 。 示例 2： 输入：dungeon = [[0]] 输出：1 提示： * m == dungeon.length * n == dungeon[i].length * 1 <= m, n <= 200 * -1000 <= dungeon[i][j] <= 1000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 从右下角向左上角动态规划，dp[i][j]表示从(i,j)到终点所需的最小初始血量

算法步骤:
1. 从右下角开始，向左上角遍历
2. dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j])
3. 需要保证在任何时刻血量至少为1
4. 返回dp[0][0]

关键点:
- 反向动态规划，从终点到起点
- 时间复杂度O(mn)，空间复杂度O(mn)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(mn) - m和n分别是矩阵的行数和列数
空间复杂度: O(mn) - dp数组空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from leetcode_solutions.utils.solution import create_solution


def dungeon_game(dungeon: List[List[int]]) -> int:
    """
    函数式接口 - 计算地下城游戏所需的最低初始健康点数
    
    实现思路:
    从右下角向左上角动态规划，dp[i][j]表示从(i,j)到终点所需的最小初始血量。
    
    Args:
        dungeon: 地下城矩阵，负数表示损失血量，正数表示增加血量
        
    Returns:
        所需的最低初始健康点数
        
    Example:
        >>> dungeon_game([[-2, -3, 3], [-5, -10, 1], [10, 30, -5]])
        7
    """
    m, n = len(dungeon), len(dungeon[0])
    dp = [[0] * n for _ in range(m)]
    
    # 右下角
    dp[m-1][n-1] = max(1, 1 - dungeon[m-1][n-1])
    
    # 最后一行
    for j in range(n-2, -1, -1):
        dp[m-1][j] = max(1, dp[m-1][j+1] - dungeon[m-1][j])
    
    # 最后一列
    for i in range(m-2, -1, -1):
        dp[i][n-1] = max(1, dp[i+1][n-1] - dungeon[i][n-1])
    
    # 其他位置
    for i in range(m-2, -1, -1):
        for j in range(n-2, -1, -1):
            min_health = min(dp[i+1][j], dp[i][j+1])
            dp[i][j] = max(1, min_health - dungeon[i][j])
    
    return dp[0][0]


# 自动生成Solution类（无需手动编写）
Solution = create_solution(dungeon_game)
