# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 4060
标题: Library Late Fee Calculator
难度: easy
链接: https://leetcode.cn/problems/library-late-fee-calculator/
题目类型: 数组、模拟
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3687. 图书馆逾期罚款计算器 - 备战技术面试？力扣提供海量技术面试资源，帮助你高效提升编程技能,轻松拿下世界 IT 名企 Dream Offer。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过遍历借阅记录数组，计算每本书的逾期天数，并根据逾期天数计算罚款金额。

算法步骤:
1. 初始化总罚款金额为0。
2. 遍历借阅记录数组，对于每条记录：
   - 计算当前日期与应还日期之间的差值，即逾期天数。
   - 根据逾期天数计算罚款金额，并累加到总罚款金额中。
3. 返回总罚款金额。

关键点:
- 罚款金额的计算规则：逾期天数 * 每天罚款金额。
- 注意处理逾期天数为负数的情况（即未逾期）。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是借阅记录数组的长度。需要遍历整个数组一次。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(borrow_records: List[List[int]]) -> int:
    """
    函数式接口 - 计算图书馆逾期罚款总金额
    :param borrow_records: 借阅记录数组，每个记录包含 [借阅日期, 应还日期, 每天罚款金额]
    :return: 总罚款金额
    """
    total_fine = 0
    for record in borrow_records:
        borrow_date, due_date, daily_fine = record
        overdue_days = due_date - borrow_date
        if overdue_days > 0:
            fine = overdue_days * daily_fine
            total_fine += fine
    return total_fine


Solution = create_solution(solution_function_name)