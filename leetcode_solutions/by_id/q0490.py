# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 490
标题: The Maze
难度: medium
链接: https://leetcode.cn/problems/the-maze/
题目类型: 深度优先搜索、广度优先搜索、数组、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
490. 迷宫 - 备战技术面试？力扣提供海量技术面试资源，帮助你高效提升编程技能,轻松拿下世界 IT 名企 Dream Offer。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用广度优先搜索（BFS）来找到从起点到终点的最短路径。

算法步骤:
1. 初始化一个队列，将起点加入队列。
2. 使用一个集合来记录已经访问过的节点，避免重复访问。
3. 当队列不为空时，进行以下操作：
   - 从队列中取出一个节点。
   - 如果该节点是终点，返回True。
   - 否则，向四个方向滚动小球，直到遇到墙壁或边界。
   - 将新的位置加入队列，并标记为已访问。
4. 如果队列为空且未找到终点，返回False。

关键点:
- 使用BFS可以保证找到最短路径。
- 通过滚动小球来处理迷宫中的移动。
- 使用集合来记录已访问的节点，避免重复访问。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m * n) - 其中m和n分别是迷宫的高度和宽度。每个节点最多访问一次。
空间复杂度: O(m * n) - 需要额外的空间来存储队列和已访问的节点。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Tuple
from collections import deque

def the_maze(maze: List[List[int]], start: List[int], destination: List[int]) -> bool:
    """
    函数式接口 - 判断小球是否能从起点滚动到终点。
    
    实现思路:
    使用广度优先搜索（BFS）来找到从起点到终点的最短路径。
    
    Args:
        maze: 二维数组表示的迷宫，0表示空地，1表示墙壁。
        start: 起点坐标 [x, y]。
        destination: 终点坐标 [x, y]。
        
    Returns:
        如果小球能从起点滚动到终点，返回True；否则返回False。
        
    Example:
        >>> the_maze([[0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 1, 0], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0]], [0, 4], [4, 4])
        True
    """
    if not maze or not maze[0]:
        return False
    
    m, n = len(maze), len(maze[0])
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    visited = set()
    queue = deque([tuple(start)])
    visited.add(tuple(start))
    
    while queue:
        x, y = queue.popleft()
        if [x, y] == destination:
            return True
        
        for dx, dy in directions:
            nx, ny = x, y
            # 滚动小球直到遇到墙壁或边界
            while 0 <= nx + dx < m and 0 <= ny + dy < n and maze[nx + dx][ny + dy] == 0:
                nx += dx
                ny += dy
            if (nx, ny) not in visited:
                visited.add((nx, ny))
                queue.append((nx, ny))
    
    return False

# 自动生成Solution类（无需手动编写）
Solution = create_solution(the_maze)