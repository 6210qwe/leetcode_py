# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 807
标题: Custom Sort String
难度: medium
链接: https://leetcode.cn/problems/custom-sort-string/
题目类型: 哈希表、字符串、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
791. 自定义字符串排序 - 给定两个字符串 order 和 s 。order 的所有字母都是 唯一 的，并且预先按照一些自定义的顺序排序。 对 s 的字符进行置换，使其与排序的 order 相匹配。更具体地说，如果在 order 中的字符 x 出现字符 y 之前，那么在排列后的字符串中， x 也应该出现在 y 之前。 返回 满足这个性质的 s 的任意一种排列 。 示例 1： 输入： order = "cba", s = "abcd" 输出： "cbad" 解释： "a"，"b"，"c" 在 order 中出现，所以 "a"，"b"，"c" 的顺序应该是 "c"，"b"，和 "a"。 由于 "d" 没有在 order 中出现，它可以在返回字符串的任意位置。"dcba"，"cdba"，"cbda" 也是合法的输出。 示例 2： 输入： order = "bcafg", s = "abcd" 输出： "bcad" 解释：order 中的字符 "b"、"c" 和 "a" 决定了 s 中字符的顺序。s 中的字符 "d" 没有出现在 order 中，因此其位置是可变的。 按照 order 中的出现顺序，"b"、"c" 和 "a" 应该按 "b"、"c"、"a" 的顺序排列。"d" 可以放在任何位置，因为它不受顺序限制。输出 "bcad" 正确遵循了这一规则。其他排列如 "dbca" 或 "bcda" 也是合法的，只要 "b"、"c"、"a" 的顺序保持不变。 提示: * 1 <= order.length <= 26 * 1 <= s.length <= 200 * order 和 s 由小写英文字母组成 * order 中的所有字符都 不同
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: [TODO]

算法步骤:
1. [TODO]
2. [TODO]

关键点:
- [TODO]
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O([TODO])
空间复杂度: O([TODO])
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(params):
    """
    函数式接口 - [TODO] 实现
    """
    # TODO: 实现最优解法
    pass


Solution = create_solution(solution_function_name)
