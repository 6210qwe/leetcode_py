# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 202
标题: Happy Number
难度: easy
链接: https://leetcode.cn/problems/happy-number/
题目类型: 哈希表、数学、双指针
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
202. 快乐数 - 编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」 定义为： * 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。 * 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。 * 如果这个过程 结果为 1，那么这个数就是快乐数。 如果 n 是 快乐数 就返回 true ；不是，则返回 false 。 示例 1： 输入：n = 19 输出：true 解释： 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 示例 2： 输入：n = 2 输出：false 提示： * 1 <= n <= 231 - 1
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用快慢指针检测循环，如果最终到达1则是快乐数

算法步骤:
1. 定义函数计算数字各位平方和
2. 使用快慢指针：
   - 慢指针每次计算一次
   - 快指针每次计算两次
3. 如果快指针到达1，返回True
4. 如果快慢指针相遇，说明有循环，返回False

关键点:
- 使用快慢指针检测循环，O(1)空间
- 时间复杂度O(logn)，空间复杂度O(1)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(logn) - 计算平方和的次数
空间复杂度: O(1) - 只使用常数额外空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from leetcode_solutions.utils.solution import create_solution


def happy_number(n: int) -> bool:
    """
    函数式接口 - 判断是否为快乐数
    
    实现思路:
    使用快慢指针检测循环，如果最终到达1则是快乐数。
    
    Args:
        n: 正整数
        
    Returns:
        如果是快乐数返回True，否则返回False
        
    Example:
        >>> happy_number(19)
        True
    """
    def get_next(num: int) -> int:
        """计算数字各位平方和"""
        total = 0
        while num > 0:
            num, digit = divmod(num, 10)
            total += digit * digit
        return total
    
    slow = n
    fast = get_next(n)
    
    while fast != 1 and slow != fast:
        slow = get_next(slow)
        fast = get_next(get_next(fast))
    
    return fast == 1


# 自动生成Solution类（无需手动编写）
Solution = create_solution(happy_number)
