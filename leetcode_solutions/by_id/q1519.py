# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1519
标题: Minimum Subsequence in Non-Increasing Order
难度: easy
链接: https://leetcode.cn/problems/minimum-subsequence-in-non-increasing-order/
题目类型: 贪心、数组、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1403. 非递增顺序的最小子序列 - 给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。 如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。 与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。 注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。 示例 1： 输入：nums = [4,3,10,9,8] 输出：[10,9] 解释：子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [10,9] 的元素之和最大。 示例 2： 输入：nums = [4,4,7,6,7] 输出：[7,7,6] 解释：子序列 [7,7] 的和为 14 ，不严格大于剩下的其他元素之和（14 = 4 + 4 + 6）。因此，[7,6,7] 是满足题意的最小子序列。注意，元素按非递增顺序返回。 提示： * 1 <= nums.length <= 500 * 1 <= nums[i] <= 100
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过贪心算法选择最大的元素，直到子序列的和大于剩余元素的和。

算法步骤:
1. 对数组进行降序排序。
2. 初始化两个变量 `subseq_sum` 和 `total_sum`，分别表示子序列的和和整个数组的和。
3. 逐个将排序后的元素加入子序列，并更新 `subseq_sum` 和 `total_sum`。
4. 当 `subseq_sum` 大于 `total_sum - subseq_sum` 时，停止并返回子序列。

关键点:
- 通过降序排序确保每次选择的元素是当前最大的。
- 通过比较子序列的和与剩余元素的和来决定何时停止。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是数组的长度。排序操作的时间复杂度为 O(n log n)。
空间复杂度: O(1)，除了输入和输出外，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def min_subsequence(nums: List[int]) -> List[int]:
    """
    函数式接口 - 返回非递增顺序的最小子序列
    """
    # 对数组进行降序排序
    nums.sort(reverse=True)
    
    subseq_sum = 0
    total_sum = sum(nums)
    subseq = []
    
    for num in nums:
        subseq.append(num)
        subseq_sum += num
        if subseq_sum > total_sum - subseq_sum:
            break
    
    return subseq


Solution = create_solution(min_subsequence)