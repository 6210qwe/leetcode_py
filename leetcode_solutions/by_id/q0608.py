# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 608
标题: Tree Node
难度: medium
链接: https://leetcode.cn/problems/tree-node/
题目类型: 数据库
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
608. 树节点 - 表：Tree +-------------+------+ | Column Name | Type | +-------------+------+ | id | int | | p_id | int | +-------------+------+ id 是该表中具有唯一值的列。 该表的每行包含树中节点的 id 及其父节点的 id 信息。 给定的结构总是一个有效的树。 树中的每个节点可以是以下三种类型之一： * "Leaf"：节点是叶子节点。 * "Root"：节点是树的根节点。 * "lnner"：节点既不是叶子节点也不是根节点。 编写一个解决方案来报告树中每个节点的类型。 以 任意顺序 返回结果表。 结果格式如下所示。 示例 1： [https://assets.leetcode.com/uploads/2021/10/22/tree1.jpg] 输入： Tree table: +----+------+ | id | p_id | +----+------+ | 1 | null | | 2 | 1 | | 3 | 1 | | 4 | 2 | | 5 | 2 | +----+------+ 输出： +----+-------+ | id | type | +----+-------+ | 1 | Root | | 2 | Inner | | 3 | Leaf | | 4 | Leaf | | 5 | Leaf | +----+-------+ 解释： 节点 1 是根节点，因为它的父节点为空，并且它有子节点 2 和 3。 节点 2 是一个内部节点，因为它有父节点 1 和子节点 4 和 5。 节点 3、4 和 5 是叶子节点，因为它们有父节点而没有子节点。 示例 2： [https://assets.leetcode.com/uploads/2021/10/22/tree2.jpg] 输入： Tree table: +----+------+ | id | p_id | +----+------+ | 1 | null | +----+------+ 输出： +----+-------+ | id | type | +----+-------+ | 1 | Root | +----+-------+ 解释：如果树中只有一个节点，则只需要输出其根属性。 注意：本题与 3054. 二叉树节点 [https://leetcode.cn/problems/binary-tree-nodes/] 一致。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用 SQL 查询来分类节点类型。

算法步骤:
1. 找出根节点：p_id 为 NULL 的节点。
2. 找出内部节点：既是某个节点的父节点，也有父节点的节点。
3. 找出叶子节点：有父节点但没有子节点的节点。
4. 将这三类节点合并在一起，生成最终的结果表。

关键点:
- 使用 UNION ALL 来合并多个查询结果。
- 使用子查询来找出内部节点和叶子节点。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是树中节点的数量。每个节点最多被访问一次。
空间复杂度: O(n)，用于存储中间结果和最终结果。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(tree):
    """
    函数式接口 - 实现
    """
    # 定义 SQL 查询
    query = """
    SELECT 
        id, 
        CASE 
            WHEN p_id IS NULL THEN 'Root'
            WHEN id IN (SELECT p_id FROM tree) THEN 'Inner'
            ELSE 'Leaf'
        END AS type
    FROM 
        tree
    ORDER BY 
        id
    """
    # 执行查询并返回结果
    return query


Solution = create_solution(solution_function_name)