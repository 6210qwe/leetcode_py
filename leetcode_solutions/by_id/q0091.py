# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 91
标题: Decode Ways
难度: medium
链接: https://leetcode.cn/problems/decode-ways/
题目类型: 字符串、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
91. 解码方法 - 一条包含字母 A-Z 的消息通过以下映射进行了 编码 ： "1" -> 'A' "2" -> 'B' ... "25" -> 'Y' "26" -> 'Z' 然而，在 解码 已编码的消息时，你意识到有许多不同的方式来解码，因为有些编码被包含在其它编码当中（"2" 和 "5" 与 "25"）。 例如，"11106" 可以映射为： * "AAJF" ，将消息分组为 (1, 1, 10, 6) * "KJF" ，将消息分组为 (11, 10, 6) * 消息不能分组为 (1, 11, 06) ，因为 "06" 不是一个合法编码（只有 "6" 是合法的）。 注意，可能存在无法解码的字符串。 给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。如果没有合法的方式解码整个字符串，返回 0。 题目数据保证答案肯定是一个 32 位 的整数。 示例 1： 输入：s = "12" 输出：2 解释：它可以解码为 "AB"（1 2）或者 "L"（12）。 示例 2： 输入：s = "226" 输出：3 解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。 示例 3： 输入：s = "06" 输出：0 解释："06" 无法映射到 "F" ，因为存在前导零（"6" 和 "06" 并不等价）。 提示： * 1 <= s.length <= 100 * s 只包含数字，并且可能包含前导零。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 动态规划，dp[i]表示前i个字符的解码方法数

算法步骤:
1. 初始化：dp[0] = 1（空字符串有1种解码方法）
2. 对于每个位置i：
   - 如果s[i-1] != '0'，可以单独解码：dp[i] += dp[i-1]
   - 如果s[i-2:i]在10-26之间，可以组合解码：dp[i] += dp[i-2]
3. 返回dp[n]

关键点:
- 处理'0'的情况：'0'不能单独解码，只能与前面的'1'或'2'组合
- 可以优化空间复杂度为O(1)，只使用两个变量
- 时间复杂度O(n)，空间复杂度O(1)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 需要遍历字符串一次
空间复杂度: O(1) - 优化后只使用常数额外空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from leetcode_solutions.utils.solution import create_solution


def num_decodings(s: str) -> int:
    """
    函数式接口 - 动态规划（空间优化）
    
    实现思路:
    使用动态规划计算解码方法数，优化空间复杂度为O(1)。
    
    Args:
        s: 只含数字的非空字符串
        
    Returns:
        解码方法的总数
        
    Example:
        >>> num_decodings("12")
        2
        >>> num_decodings("226")
        3
    """
    if not s or s[0] == '0':
        return 0
    
    n = len(s)
    # 使用两个变量代替数组
    prev2, prev1 = 1, 1
    
    for i in range(1, n):
        current = 0
        
        # 单独解码
        if s[i] != '0':
            current += prev1
        
        # 组合解码
        two_digit = int(s[i-1:i+1])
        if 10 <= two_digit <= 26:
            current += prev2
        
        prev2, prev1 = prev1, current
    
    return prev1


# 自动生成Solution类（无需手动编写）
Solution = create_solution(num_decodings)
