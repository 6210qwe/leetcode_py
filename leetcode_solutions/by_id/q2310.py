# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2310
标题: Minimum Operations to Halve Array Sum
难度: medium
链接: https://leetcode.cn/problems/minimum-operations-to-halve-array-sum/
题目类型: 贪心、数组、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2208. 将数组和减半的最少操作次数 - 给你一个正整数数组 nums 。每一次操作中，你可以从 nums 中选择 任意 一个数并将它减小到 恰好 一半。（注意，在后续操作中你可以对减半过的数继续执行操作） 请你返回将 nums 数组和 至少 减少一半的 最少 操作数。 示例 1： 输入：nums = [5,19,8,1] 输出：3 解释：初始 nums 的和为 5 + 19 + 8 + 1 = 33 。 以下是将数组和减少至少一半的一种方法： 选择数字 19 并减小为 9.5 。 选择数字 9.5 并减小为 4.75 。 选择数字 8 并减小为 4 。 最终数组为 [5, 4.75, 4, 1] ，和为 5 + 4.75 + 4 + 1 = 14.75 。 nums 的和减小了 33 - 14.75 = 18.25 ，减小的部分超过了初始数组和的一半，18.25 >= 33/2 = 16.5 。 我们需要 3 个操作实现题目要求，所以返回 3 。 可以证明，无法通过少于 3 个操作使数组和减少至少一半。 示例 2： 输入：nums = [3,8,20] 输出：3 解释：初始 nums 的和为 3 + 8 + 20 = 31 。 以下是将数组和减少至少一半的一种方法： 选择数字 20 并减小为 10 。 选择数字 10 并减小为 5 。 选择数字 3 并减小为 1.5 。 最终数组为 [1.5, 8, 5] ，和为 1.5 + 8 + 5 = 14.5 。 nums 的和减小了 31 - 14.5 = 16.5 ，减小的部分超过了初始数组和的一半， 16.5 >= 31/2 = 15.5 。 我们需要 3 个操作实现题目要求，所以返回 3 。 可以证明，无法通过少于 3 个操作使数组和减少至少一半。 提示： * 1 <= nums.length <= 105 * 1 <= nums[i] <= 107
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用最大堆（优先队列）来每次选择当前最大的数进行减半操作，直到数组和减少至少一半。

算法步骤:
1. 计算数组的初始和。
2. 将数组中的每个元素加入最大堆。
3. 初始化操作计数器和当前数组和。
4. 进行以下操作直到当前数组和减少至少一半：
   - 从堆中取出当前最大的数。
   - 将该数减半，并将其减半后的值重新加入堆中。
   - 更新当前数组和。
   - 增加操作计数器。
5. 返回操作计数器。

关键点:
- 使用最大堆可以高效地找到并处理当前最大的数。
- 每次操作后更新当前数组和，确保减少至少一半。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是数组的长度。每次操作涉及堆的操作，时间复杂度为 O(log n)。
空间复杂度: O(n)，使用了一个最大堆来存储数组中的元素。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def halve_array(nums: List[int]) -> int:
    """
    函数式接口 - 返回将数组和减半的最少操作次数
    """
    # 计算数组的初始和
    total_sum = sum(nums)
    target_sum = total_sum / 2
    
    # 将数组中的每个元素加入最大堆
    max_heap = [-num for num in nums]
    heapq.heapify(max_heap)
    
    # 初始化操作计数器和当前数组和
    operations = 0
    current_sum = total_sum
    
    # 进行以下操作直到当前数组和减少至少一半
    while current_sum > target_sum:
        # 从堆中取出当前最大的数
        largest = -heapq.heappop(max_heap)
        
        # 将该数减半，并将其减半后的值重新加入堆中
        half_largest = largest / 2
        heapq.heappush(max_heap, -half_largest)
        
        # 更新当前数组和
        current_sum -= half_largest
        
        # 增加操作计数器
        operations += 1
    
    return operations

Solution = create_solution(halve_array)