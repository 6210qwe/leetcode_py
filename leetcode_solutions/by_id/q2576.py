# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2576
标题: Minimum Penalty for a Shop
难度: medium
链接: https://leetcode.cn/problems/minimum-penalty-for-a-shop/
题目类型: 字符串、前缀和
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2483. 商店的最少代价 - 给你一个顾客访问商店的日志，用一个下标从 0 开始且只包含字符 'N' 和 'Y' 的字符串 customers 表示： * 如果第 i 个字符是 'Y' ，它表示第 i 小时有顾客到达。 * 如果第 i 个字符是 'N' ，它表示第 i 小时没有顾客到达。 如果商店在第 j 小时关门（0 <= j <= n），代价按如下方式计算： * 在开门期间，如果某一个小时没有顾客到达，代价增加 1 。 * 在关门期间，如果某一个小时有顾客到达，代价增加 1 。 请你返回在确保代价 最小 的前提下，商店的 最早 关门时间。 注意，商店在第 j 小时关门表示在第 j 小时以及之后商店处于关门状态。 示例 1： 输入：customers = "YYNY" 输出：2 解释： - 第 0 小时关门，总共 1+1+0+1 = 3 代价。 - 第 1 小时关门，总共 0+1+0+1 = 2 代价。 - 第 2 小时关门，总共 0+0+0+1 = 1 代价。 - 第 3 小时关门，总共 0+0+1+1 = 2 代价。 - 第 4 小时关门，总共 0+0+1+0 = 1 代价。 在第 2 或第 4 小时关门代价都最小。由于第 2 小时更早，所以最优关门时间是 2 。 示例 2： 输入：customers = "NNNNN" 输出：0 解释：最优关门时间是 0 ，因为自始至终没有顾客到达。 示例 3： 输入：customers = "YYYY" 输出：4 解释：最优关门时间是 4 ，因为每一小时均有顾客到达。 提示： * 1 <= customers.length <= 105 * customers 只包含字符 'Y' 和 'N' 。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用前缀和来计算每个时间点的代价，并找到最小代价的时间点。

算法步骤:
1. 计算前缀和数组，记录到当前时间为止的 'N' 的数量。
2. 遍历所有可能的关门时间，计算每个时间点的代价。
3. 找到代价最小的时间点。

关键点:
- 使用前缀和数组可以快速计算某个时间段内的 'N' 的数量。
- 通过遍历所有可能的关门时间，可以找到最小代价的时间点。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(customers: str) -> int:
    """
    函数式接口 - 计算商店的最小代价并返回最早关门时间
    """
    n = len(customers)
    prefix_sum = [0] * (n + 1)

    # 计算前缀和数组
    for i in range(1, n + 1):
        prefix_sum[i] = prefix_sum[i - 1] + (customers[i - 1] == 'N')

    min_penalty = float('inf')
    best_hour = 0

    # 遍历所有可能的关门时间
    for j in range(n + 1):
        penalty = prefix_sum[j] + (n - j) - (prefix_sum[n] - prefix_sum[j])
        if penalty < min_penalty:
            min_penalty = penalty
            best_hour = j

    return best_hour


Solution = create_solution(solution_function_name)