# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1637
标题: String Compression II
难度: hard
链接: https://leetcode.cn/problems/string-compression-ii/
题目类型: 字符串、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1531. 压缩字符串 II - 行程长度编码 [https://baike.baidu.com/item/%E8%A1%8C%E7%A8%8B%E9%95%BF%E5%BA%A6%E7%BC%96%E7%A0%81/2931940?fr=aladdin] 是一种常用的字符串压缩方法，它将连续的相同字符（重复 2 次或更多次）替换为字符和表示字符计数的数字（行程长度）。例如，用此方法压缩字符串 "aabccc" ，将 "aa" 替换为 "a2" ，"ccc" 替换为` "c3" 。因此压缩后的字符串变为 "a2bc3" 。 注意，本问题中，压缩时没有在单个字符后附加计数 '1' 。 给你一个字符串 s 和一个整数 k 。你需要从字符串 s 中删除最多 k 个字符，以使 s 的行程长度编码长度最小。 请你返回删除最多 k 个字符后，s 行程长度编码的最小长度 。 示例 1： 输入：s = "aaabcccd", k = 2 输出：4 解释：在不删除任何内容的情况下，压缩后的字符串是 "a3bc3d" ，长度为 6 。最优的方案是删除 'b' 和 'd'，这样一来，压缩后的字符串为 "a3c3" ，长度是 4 。 示例 2： 输入：s = "aabbaa", k = 2 输出：2 解释：如果删去两个 'b' 字符，那么压缩后的字符串是长度为 2 的 "a4" 。 示例 3： 输入：s = "aaaaaaaaaaa", k = 0 输出：3 解释：由于 k 等于 0 ，不能删去任何字符。压缩后的字符串是 "a11" ，长度为 3 。 提示： * 1 <= s.length <= 100 * 0 <= k <= s.length * s 仅包含小写英文字母
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们定义 dp[i][j] 表示从字符串 s 的第 i 个字符开始，删除 j 个字符后的最小压缩长度。

算法步骤:
1. 初始化 dp 数组，dp[i][j] 表示从第 i 个字符开始，删除 j 个字符后的最小压缩长度。
2. 从后向前遍历字符串 s，对于每个字符，考虑删除不同数量的字符，并更新 dp 数组。
3. 对于每个字符，计算其与后续字符的连续长度，并根据不同的长度更新 dp 数组。
4. 最终结果保存在 dp[0][k] 中。

关键点:
- 动态规划的状态转移方程需要考虑字符的连续长度和删除字符的数量。
- 使用一个辅助函数来计算压缩后的长度。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^3)，其中 n 是字符串 s 的长度。三重循环分别遍历字符、删除字符的数量和连续字符的长度。
空间复杂度: O(n^2)，用于存储 dp 数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def get_length(count: int) -> int:
    """计算给定计数的压缩长度"""
    if count == 0:
        return 0
    if count == 1:
        return 1
    if count < 10:
        return 2
    if count < 100:
        return 3
    return 4


def solution_function_name(s: str, k: int) -> int:
    """
    函数式接口 - 返回删除最多 k 个字符后，s 行程长度编码的最小长度
    """
    n = len(s)
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    
    for i in range(n + 1):
        dp[i][0] = n - i  # 不删除任何字符时的长度
    
    for i in range(n - 1, -1, -1):
        for j in range(k + 1):
            count, del_count = 0, 0
            for l in range(i, n):
                if s[l] == s[i]:
                    count += 1
                else:
                    del_count += 1
                
                if del_count > j:
                    break
                
                remaining_deletions = j - del_count
                dp[i][j] = min(dp[i][j], get_length(count) + dp[l + 1][remaining_deletions])
    
    return dp[0][k]


Solution = create_solution(solution_function_name)