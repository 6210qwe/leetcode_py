# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 216
标题: Combination Sum III
难度: medium
链接: https://leetcode.cn/problems/combination-sum-iii/
题目类型: 数组、回溯
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
216. 组合总和 III - 找出所有相加之和为 n 的 k 个数的组合，且满足下列条件： * 只使用数字1到9 * 每个数字 最多使用一次 返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。 示例 1: 输入: k = 3, n = 7 输出: [[1,2,4]] 解释: 1 + 2 + 4 = 7 没有其他符合的组合了。 示例 2: 输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]] 解释: 1 + 2 + 6 = 9 1 + 3 + 5 = 9 2 + 3 + 4 = 9 没有其他符合的组合了。 示例 3: 输入: k = 4, n = 1 输出: [] 解释: 不存在有效的组合。 在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 > 1，没有有效的组合。 提示: * 2 <= k <= 9 * 1 <= n <= 60
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 回溯算法，从1-9中选择k个数，使其和为n

算法步骤:
1. 使用回溯算法，从1开始尝试
2. 每次选择一个数字，递归选择下一个
3. 当选择的数字个数为k且和为n时，加入结果
4. 剪枝：如果当前和已经大于n，或者剩余数字不足以凑够k个，提前返回

关键点:
- 使用回溯算法和剪枝优化
- 时间复杂度O(C(9,k))，空间复杂度O(k)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(C(9,k)) - 组合数
空间复杂度: O(k) - 递归栈深度
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from leetcode_solutions.utils.solution import create_solution


def combination_sum_iii(k: int, n: int) -> List[List[int]]:
    """
    函数式接口 - 组合总和III
    
    实现思路:
    回溯算法，从1-9中选择k个数，使其和为n。
    
    Args:
        k: 需要选择的数字个数
        n: 目标和
        
    Returns:
        所有可能的有效组合列表
        
    Example:
        >>> combination_sum_iii(3, 7)
        [[1, 2, 4]]
    """
    result = []
    
    def backtrack(start, current_sum, path):
        if len(path) == k:
            if current_sum == n:
                result.append(path[:])
            return
        
        for i in range(start, 10):
            if current_sum + i > n:
                break
            path.append(i)
            backtrack(i + 1, current_sum + i, path)
            path.pop()
    
    backtrack(1, 0, [])
    return result


# 自动生成Solution类（无需手动编写）
Solution = create_solution(combination_sum_iii)
