# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1418
标题: Fair Distribution of Cookies
难度: medium
链接: https://leetcode.cn/problems/fair-distribution-of-cookies/
题目类型: 位运算、数组、动态规划、回溯、状态压缩
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2305. 公平分发饼干 - 给你一个整数数组 cookies ，其中 cookies[i] 表示在第 i 个零食包中的饼干数量。另给你一个整数 k 表示等待分发零食包的孩子数量，所有 零食包都需要分发。在同一个零食包中的所有饼干都必须分发给同一个孩子，不能分开。 分发的 不公平程度 定义为单个孩子在分发过程中能够获得饼干的最大总数。 返回所有分发的最小不公平程度。 示例 1： 输入：cookies = [8,15,10,20,8], k = 2 输出：31 解释：一种最优方案是 [8,15,8] 和 [10,20] 。 - 第 1 个孩子分到 [8,15,8] ，总计 8 + 15 + 8 = 31 块饼干。 - 第 2 个孩子分到 [10,20] ，总计 10 + 20 = 30 块饼干。 分发的不公平程度为 max(31,30) = 31 。 可以证明不存在不公平程度小于 31 的分发方案。 示例 2： 输入：cookies = [6,1,3,2,2,4,1,2], k = 3 输出：7 解释：一种最优方案是 [6,1]、[3,2,2] 和 [4,1,2] 。 - 第 1 个孩子分到 [6,1] ，总计 6 + 1 = 7 块饼干。 - 第 2 个孩子分到 [3,2,2] ，总计 3 + 2 + 2 = 7 块饼干。 - 第 3 个孩子分到 [4,1,2] ，总计 4 + 1 + 2 = 7 块饼干。 分发的不公平程度为 max(7,7,7) = 7 。 可以证明不存在不公平程度小于 7 的分发方案。 提示： * 2 <= cookies.length <= 8 * 1 <= cookies[i] <= 105 * 2 <= k <= cookies.length
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用深度优先搜索（DFS）和剪枝来找到最小的不公平程度。

算法步骤:
1. 初始化一个数组 `distribution` 来记录每个孩子的饼干总数。
2. 使用递归函数 `dfs` 来尝试将每个饼干包分配给每个孩子，并更新 `distribution`。
3. 在每次递归中，计算当前分配方案的不公平程度，并更新全局最小值 `min_unfairness`。
4. 使用剪枝技术来减少不必要的递归调用，例如如果当前不公平程度已经大于 `min_unfairness`，则停止递归。

关键点:
- 使用剪枝技术来优化DFS，避免不必要的计算。
- 通过递归和回溯来遍历所有可能的分配方案。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(k^n)，其中 n 是饼干包的数量，k 是孩子的数量。由于使用了剪枝技术，实际运行时间会比最坏情况好很多。
空间复杂度: O(n + k)，递归调用栈的深度为 n，`distribution` 数组的大小为 k。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def distribute_cookies(cookies: List[int], k: int) -> int:
    def dfs(index: int, distribution: List[int]):
        nonlocal min_unfairness
        if index == len(cookies):
            min_unfairness = min(min_unfairness, max(distribution))
            return
        if min_unfairness <= max(distribution):
            return
        for i in range(k):
            distribution[i] += cookies[index]
            dfs(index + 1, distribution)
            distribution[i] -= cookies[index]

    min_unfairness = float('inf')
    dfs(0, [0] * k)
    return min_unfairness

Solution = create_solution(distribute_cookies)