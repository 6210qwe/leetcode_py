# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3211
标题: Find Maximum Non-decreasing Array Length
难度: hard
链接: https://leetcode.cn/problems/find-maximum-non-decreasing-array-length/
题目类型: 栈、队列、数组、二分查找、动态规划、单调队列、单调栈
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2945. 找到最大非递减数组的长度 - 给你一个下标从 0 开始的整数数组 nums 。 你可以执行任意次操作。每次操作中，你需要选择一个 子数组 ，并将这个子数组用它所包含元素的 和 替换。比方说，给定数组是 [1,3,5,6] ，你可以选择子数组 [3,5] ，用子数组的和 8 替换掉子数组，然后数组会变为 [1,8,6] 。 请你返回执行任意次操作以后，可以得到的 最长非递减 数组的长度。 子数组 指的是一个数组中一段连续 非空 的元素序列。 示例 1： 输入：nums = [5,2,2] 输出：1 解释：这个长度为 3 的数组不是非递减的。 我们有 2 种方案使数组长度为 2 。 第一种，选择子数组 [2,2] ，对数组执行操作后得到 [5,4] 。 第二种，选择子数组 [5,2] ，对数组执行操作后得到 [7,2] 。 这两种方案中，数组最后都不是 非递减 的，所以不是可行的答案。 如果我们选择子数组 [5,2,2] ，并将它替换为 [9] ，数组变成非递减的。 所以答案为 1 。 示例 2： 输入：nums = [1,2,3,4] 输出：4 解释：数组已经是非递减的。所以答案为 4 。 示例 3： 输入：nums = [4,3,2,6] 输出：3 解释：将 [3,2] 替换为 [5] ，得到数组 [4,5,6] ，它是非递减的。 最大可能的答案为 3 。 提示： * 1 <= nums.length <= 105 * 1 <= nums[i] <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们定义 dp[i] 表示以 nums[i] 结尾的最长非递减子数组的长度。我们需要维护一个单调递增的栈来帮助我们找到最优解。

算法步骤:
1. 初始化 dp 数组，dp[i] = 1，表示每个元素本身可以作为一个非递减子数组。
2. 使用一个单调递增栈来存储 (num, index) 对，其中 num 是当前元素，index 是其在原数组中的索引。
3. 遍历数组，对于每个元素 nums[i]：
   - 如果栈顶元素小于等于 nums[i]，则直接将 (nums[i], i) 压入栈。
   - 否则，弹出栈顶元素直到栈顶元素小于等于 nums[i]，并更新 dp[i] 为 dp[stack[-1][1]] + 1。
4. 返回 dp 数组中的最大值。

关键点:
- 使用单调递增栈来维护非递减子数组的长度。
- 动态规划数组 dp 用于记录以每个元素结尾的最长非递减子数组的长度。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是 nums 的长度。每个元素最多只会被压入和弹出栈一次。
空间复杂度: O(n)，用于存储 dp 数组和单调递增栈。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def find_max_non_decreasing_length(nums: List[int]) -> int:
    n = len(nums)
    if n == 1:
        return 1

    dp = [1] * n
    stack = []

    for i in range(n):
        while stack and stack[-1][0] > nums[i]:
            stack.pop()
        if stack:
            dp[i] = dp[stack[-1][1]] + 1
        stack.append((nums[i], i))

    return max(dp)

Solution = create_solution(find_max_non_decreasing_length)