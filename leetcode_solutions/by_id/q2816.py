# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2816
标题: Lexicographically Smallest Palindrome
难度: easy
链接: https://leetcode.cn/problems/lexicographically-smallest-palindrome/
题目类型: 贪心、双指针、字符串
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2697. 字典序最小回文串 - 给你一个由 小写英文字母 组成的字符串 s ，你可以对其执行一些操作。在一步操作中，你可以用其他小写英文字母 替换 s 中的一个字符。 请你执行 尽可能少的操作 ，使 s 变成一个 回文串 。如果执行 最少 操作次数的方案不止一种，则只需选取 字典序最小 的方案。 对于两个长度相同的字符串 a 和 b ，在 a 和 b 出现不同的第一个位置，如果该位置上 a 中对应字母比 b 中对应字母在字母表中出现顺序更早，则认为 a 的字典序比 b 的字典序要小。 返回最终的回文字符串。 示例 1： 输入：s = "egcfe" 输出："efcfe" 解释：将 "egcfe" 变成回文字符串的最小操作次数为 1 ，修改 1 次得到的字典序最小回文字符串是 "efcfe"，只需将 'g' 改为 'f' 。 示例 2： 输入：s = "abcd" 输出："abba" 解释：将 "abcd" 变成回文字符串的最小操作次数为 2 ，修改 2 次得到的字典序最小回文字符串是 "abba" 。 示例 3： 输入：s = "seven" 输出："neven" 解释：将 "seven" 变成回文字符串的最小操作次数为 1 ，修改 1 次得到的字典序最小回文字符串是 "neven" 。 提示： * 1 <= s.length <= 1000 * s 仅由小写英文字母组成
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用双指针从两端向中间遍历字符串，确保每对字符相同且字典序最小。

算法步骤:
1. 初始化两个指针 left 和 right，分别指向字符串的开头和结尾。
2. 当 left < right 时，比较 s[left] 和 s[right]：
   - 如果 s[left] != s[right]，则将两者都替换为较小的那个字符。
   - 移动指针 left 向右，right 向左。
3. 最终返回处理后的字符串。

关键点:
- 使用双指针确保每个字符都被检查并替换为字典序最小的字符。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是字符串的长度。每个字符最多被访问一次。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def make_smallest_palindrome(s: str) -> str:
    """
    函数式接口 - 将字符串 s 转换为字典序最小的回文串。
    """
    s = list(s)  # 将字符串转换为列表以便修改
    left, right = 0, len(s) - 1
    
    while left < right:
        if s[left] != s[right]:
            # 将较大的字符替换为较小的字符
            s[left] = s[right] = min(s[left], s[right])
        left += 1
        right -= 1
    
    return ''.join(s)


Solution = create_solution(make_smallest_palindrome)