# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 429
标题: N叉树的层序遍历
难度: 中等
链接: https://leetcode.cn/problems/n-ary-tree-level-order-traversal/
题目类型: 树
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。

树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用广度优先搜索（BFS）进行层序遍历

算法步骤:
1. 初始化一个队列，将根节点加入队列
2. 当队列不为空时，遍历当前层的所有节点，并将它们的子节点加入队列
3. 将当前层的节点值记录到结果列表中
4. 重复步骤2和3，直到队列为空

关键点:
- 使用队列来实现层次遍历
- 每次处理一层节点，确保按层次顺序记录节点值
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 其中 n 是节点的数量，每个节点只访问一次
空间复杂度: O(n) - 最坏情况下，队列中可能包含所有的叶子节点
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.tree import Node
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(root: Optional[Node]) -> List[List[int]]:
    """
    函数式接口 - 实现N叉树的层序遍历
    
    实现思路:
    使用广度优先搜索（BFS）进行层序遍历，逐层记录节点值

    Args:
        root: N叉树的根节点
        
    Returns:
        二维列表，每个子列表表示一层的节点值
        
    Example:
        >>> solution_function_name(Node(1, [Node(3, [Node(5), Node(6)]), Node(2), Node(4)]))
        [[1], [3, 2, 4], [5, 6]]
    """
    if not root:
        return []
    
    result = []
    queue = [root]
    
    while queue:
        level_size = len(queue)
        level_values = []
        
        for _ in range(level_size):
            node = queue.pop(0)
            level_values.append(node.val)
            queue.extend(node.children)
        
        result.append(level_values)
    
    return result


# 自动生成Solution类（无需手动编写）
Solution = create_solution(solution_function_name)