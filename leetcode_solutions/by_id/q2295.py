# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2295
标题: Minimum Time to Finish the Race
难度: hard
链接: https://leetcode.cn/problems/minimum-time-to-finish-the-race/
题目类型: 数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2188. 完成比赛的最少时间 - 给你一个下标从 0 开始的二维整数数组 tires ，其中 tires[i] = [fi, ri] 表示第 i 种轮胎如果连续使用，第 x 圈需要耗时 fi * ri(x-1) 秒。 * 比方说，如果 fi = 3 且 ri = 2 ，且一直使用这种类型的同一条轮胎，那么该轮胎完成第 1 圈赛道耗时 3 秒，完成第 2 圈耗时 3 * 2 = 6 秒，完成第 3 圈耗时 3 * 22 = 12 秒，依次类推。 同时给你一个整数 changeTime 和一个整数 numLaps 。 比赛总共包含 numLaps 圈，你可以选择 任意 一种轮胎开始比赛。每一种轮胎都有 无数条 。每一圈后，你可以选择耗费 changeTime 秒 换成 任意一种轮胎（也可以换成当前种类的新轮胎）。 请你返回完成比赛需要耗费的 最少 时间。 示例 1： 输入：tires = [[2,3],[3,4]], changeTime = 5, numLaps = 4 输出：21 解释： 第 1 圈：使用轮胎 0 ，耗时 2 秒。 第 2 圈：继续使用轮胎 0 ，耗时 2 * 3 = 6 秒。 第 3 圈：耗费 5 秒换一条新的轮胎 0 ，然后耗时 2 秒完成这一圈。 第 4 圈：继续使用轮胎 0 ，耗时 2 * 3 = 6 秒。 总耗时 = 2 + 6 + 5 + 2 + 6 = 21 秒。 完成比赛的最少时间为 21 秒。 示例 2： 输入：tires = [[1,10],[2,2],[3,4]], changeTime = 6, numLaps = 5 输出：25 解释： 第 1 圈：使用轮胎 1 ，耗时 2 秒。 第 2 圈：继续使用轮胎 1 ，耗时 2 * 2 = 4 秒。 第 3 圈：耗时 6 秒换一条新的轮胎 1 ，然后耗时 2 秒完成这一圈。 第 4 圈：继续使用轮胎 1 ，耗时 2 * 2 = 4 秒。 第 5 圈：耗时 6 秒换成轮胎 0 ，然后耗时 1 秒完成这一圈。 总耗时 = 2 + 4 + 6 + 2 + 4 + 6 + 1 = 25 秒。 完成比赛的最少时间为 25 秒。 提示： * 1 <= tires.length <= 105 * tires[i].length == 2 * 1 <= fi, changeTime <= 105 * 2 <= ri <= 105 * 1 <= numLaps <= 1000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来计算每个轮胎在不同圈数下的最小耗时，并结合换胎策略找到最优解。

算法步骤:
1. 计算每个轮胎在连续使用下的最小耗时。
2. 使用动态规划计算每个圈数下的最小耗时。
3. 结合换胎策略，更新每个圈数下的最小耗时。

关键点:
- 计算每个轮胎在连续使用下的最小耗时，避免超出合理范围。
- 动态规划计算每个圈数下的最小耗时，结合换胎策略。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * m)，其中 n 是轮胎数量，m 是圈数。
空间复杂度: O(m)，用于存储每个圈数下的最小耗时。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def minimumFinishTime(tires: List[List[int]], changeTime: int, numLaps: int) -> int:
    # 计算每个轮胎在连续使用下的最小耗时
    max_laps = 17  # 通过实验确定的最大连续使用圈数
    min_time_per_lap = [float('inf')] * (max_laps + 1)
    
    for f, r in tires:
        time = f
        total_time = f
        for lap in range(1, max_laps + 1):
            if total_time < min_time_per_lap[lap]:
                min_time_per_lap[lap] = total_time
            time *= r
            if time >= f + changeTime:
                break
            total_time += time
    
    # 动态规划计算每个圈数下的最小耗时
    dp = [float('inf')] * (numLaps + 1)
    dp[0] = 0
    
    for i in range(1, numLaps + 1):
        for j in range(1, min(i, max_laps) + 1):
            dp[i] = min(dp[i], dp[i - j] + min_time_per_lap[j] + (changeTime if i != j else 0))
    
    return dp[numLaps]

Solution = create_solution(minimumFinishTime)