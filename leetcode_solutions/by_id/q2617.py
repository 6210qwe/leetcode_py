# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2617
标题: Time Taken to Cross the Door
难度: hard
链接: https://leetcode.cn/problems/time-taken-to-cross-the-door/
题目类型: 队列、数组、模拟
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2534. 通过门的时间 - 备战技术面试？力扣提供海量技术面试资源，帮助你高效提升编程技能,轻松拿下世界 IT 名企 Dream Offer。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用优先队列（最小堆）来模拟每个人通过门的过程。

算法步骤:
1. 初始化一个优先队列，将所有人的到达时间和通过时间存入队列。
2. 按照到达时间从小到大处理每个人。
3. 对于每个人，计算其实际通过门的时间，并更新总时间。
4. 返回最后一个人通过门的时间。

关键点:
- 使用优先队列可以高效地按到达时间处理每个人。
- 计算通过门的时间时需要考虑前一个人的通过时间。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是人数。因为我们需要对所有人进行排序，并且每次插入和删除操作的时间复杂度是 O(log n)。
空间复杂度: O(n)，优先队列的空间复杂度是 O(n)。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def solution_function_name(arrival: List[int], state: List[int]) -> int:
    """
    函数式接口 - 计算通过门的时间
    """
    # 将每个人的到达时间和通过时间存入优先队列
    events = []
    for i in range(len(arrival)):
        heapq.heappush(events, (arrival[i], i))
    
    current_time = 0
    last_exit_time = 0
    
    while events:
        arrival_time, index = heapq.heappop(events)
        if arrival_time > current_time:
            current_time = arrival_time
        if state[index] == 1:  # 进门
            current_time += 1
        else:  # 出门
            current_time = max(current_time + 1, last_exit_time + 1)
        last_exit_time = current_time
    
    return last_exit_time

Solution = create_solution(solution_function_name)