# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3495
标题: K-th Nearest Obstacle Queries
难度: medium
链接: https://leetcode.cn/problems/k-th-nearest-obstacle-queries/
题目类型: 数组、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3275. 第 K 近障碍物查询 - 有一个无限大的二维平面。 给你一个正整数 k ，同时给你一个二维数组 queries ，包含一系列查询： * queries[i] = [x, y] ：在平面上坐标 (x, y) 处建一个障碍物，数据保证之前的查询 不会 在这个坐标处建立任何障碍物。 每次查询后，你需要找到离原点第 k 近 障碍物到原点的 距离 。 请你返回一个整数数组 results ，其中 results[i] 表示建立第 i 个障碍物以后，离原地第 k 近障碍物距离原点的距离。如果少于 k 个障碍物，results[i] == -1 。 注意，一开始 没有 任何障碍物。 坐标在 (x, y) 处的点距离原点的距离定义为 |x| + |y| 。 示例 1： 输入：queries = [[1,2],[3,4],[2,3],[-3,0]], k = 2 输出：[-1,7,5,3] 解释： 最初，不存在障碍物。 * queries[0] 之后，少于 2 个障碍物。 * queries[1] 之后， 两个障碍物距离原点的距离分别为 3 和 7 。 * queries[2] 之后，障碍物距离原点的距离分别为 3 ，5 和 7 。 * queries[3] 之后，障碍物距离原点的距离分别为 3，3，5 和 7 。 示例 2： 输入：queries = [[5,5],[4,4],[3,3]], k = 1 输出：[10,8,6] 解释： * queries[0] 之后，只有一个障碍物，距离原点距离为 10 。 * queries[1] 之后，障碍物距离原点距离分别为 8 和 10 。 * queries[2] 之后，障碍物距离原点的距离分别为 6， 8 和10 。 提示： * 1 <= queries.length <= 2 * 105 * 所有 queries[i] 互不相同。 * -109 <= queries[i][0], queries[i][1] <= 109 * 1 <= k <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用最大堆来维护前 k 个最近的障碍物。

算法步骤:
1. 初始化一个最大堆，用于存储前 k 个最近的障碍物。
2. 遍历每个查询，计算当前障碍物到原点的距离。
3. 如果堆的大小小于 k，直接将当前障碍物加入堆中。
4. 如果堆的大小等于 k，比较当前障碍物与堆顶元素的距离：
   - 如果当前障碍物更近，则移除堆顶元素，并将当前障碍物加入堆中。
5. 每次查询后，如果堆的大小小于 k，结果为 -1；否则，结果为堆顶元素的距离。

关键点:
- 使用最大堆来高效地维护前 k 个最近的障碍物。
- 通过比较和替换堆顶元素来保持堆的大小不超过 k。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log k)，其中 n 是 queries 的长度，每次插入和删除操作的时间复杂度为 O(log k)。
空间复杂度: O(k)，堆的最大大小为 k。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def kth_nearest_obstacle_queries(queries: List[List[int]], k: int) -> List[int]:
    """
    返回每次查询后离原点第 k 近障碍物的距离。
    """
    # 初始化最大堆
    max_heap = []
    results = []

    for x, y in queries:
        distance = abs(x) + abs(y)
        
        # 如果堆的大小小于 k，直接将当前障碍物加入堆中
        if len(max_heap) < k:
            heapq.heappush(max_heap, -distance)
        else:
            # 如果当前障碍物比堆顶元素更近，则替换堆顶元素
            if distance < -max_heap[0]:
                heapq.heapreplace(max_heap, -distance)
        
        # 如果堆的大小小于 k，结果为 -1；否则，结果为堆顶元素的距离
        if len(max_heap) < k:
            results.append(-1)
        else:
            results.append(-max_heap[0])
    
    return results

Solution = create_solution(kth_nearest_obstacle_queries)