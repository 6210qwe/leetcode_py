# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2711
标题: Minimum Time to Visit a Cell In a Grid
难度: hard
链接: https://leetcode.cn/problems/minimum-time-to-visit-a-cell-in-a-grid/
题目类型: 广度优先搜索、图、数组、矩阵、最短路、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2577. 在网格图中访问一个格子的最少时间 - 给你一个 m x n 的矩阵 grid ，每个元素都为 非负 整数，其中 grid[row][col] 表示可以访问格子 (row, col) 的 最早 时间。也就是说当你访问格子 (row, col) 时，最少已经经过的时间为 grid[row][col] 。 你从 最左上角 出发，出发时刻为 0 ，你必须一直移动到上下左右相邻四个格子中的 任意 一个格子（即不能停留在格子上）。每次移动都需要花费 1 单位时间。 请你返回 最早 到达右下角格子的时间，如果你无法到达右下角的格子，请你返回 -1 。 示例 1： [https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-8.png] 输入：grid = [[0,1,3,2],[5,1,2,5],[4,3,8,6]] 输出：7 解释：一条可行的路径为： - 时刻 t = 0 ，我们在格子 (0,0) 。 - 时刻 t = 1 ，我们移动到格子 (0,1) ，可以移动的原因是 grid[0][1] <= 1 。 - 时刻 t = 2 ，我们移动到格子 (1,1) ，可以移动的原因是 grid[1][1] <= 2 。 - 时刻 t = 3 ，我们移动到格子 (1,2) ，可以移动的原因是 grid[1][2] <= 3 。 - 时刻 t = 4 ，我们移动到格子 (1,1) ，可以移动的原因是 grid[1][1] <= 4 。 - 时刻 t = 5 ，我们移动到格子 (1,2) ，可以移动的原因是 grid[1][2] <= 5 。 - 时刻 t = 6 ，我们移动到格子 (1,3) ，可以移动的原因是 grid[1][3] <= 6 。 - 时刻 t = 7 ，我们移动到格子 (2,3) ，可以移动的原因是 grid[2][3] <= 7 。 最终到达时刻为 7 。这是最早可以到达的时间。 示例 2： [https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-9.png] 输入：grid = [[0,2,4],[3,2,1],[1,0,4]] 输出：-1 解释：没法从左上角按题目规定走到右下角。 提示： * m == grid.length * n == grid[i].length * 2 <= m, n <= 1000 * 4 <= m * n <= 105 * 0 <= grid[i][j] <= 105 * grid[0][0] == 0
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用Dijkstra算法来找到从起点到终点的最短时间路径。

算法步骤:
1. 初始化一个优先队列（最小堆），将起点(0, 0)和初始时间为0加入队列。
2. 使用一个二维数组dist记录从起点到每个格子的最短时间，初始化为无穷大。
3. 从优先队列中取出当前时间最小的格子，检查其四个方向的邻居格子。
4. 对于每个邻居格子，计算从当前格子到达该邻居格子的时间，并更新dist数组。
5. 如果更新后的到达时间小于dist数组中的值，则将该邻居格子及其时间加入优先队列。
6. 重复上述过程，直到优先队列为空或到达终点。
7. 如果到达终点，返回dist数组中终点的值；否则返回-1。

关键点:
- 使用优先队列来保证每次处理的是当前时间最小的格子。
- 更新邻居格子的时间时，需要考虑格子的访问时间和移动时间。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m * n * log(m * n))，其中m和n分别是网格的行数和列数。优先队列的插入和删除操作的时间复杂度为O(log(m * n))，最多进行m * n次操作。
空间复杂度: O(m * n)，用于存储dist数组和优先队列。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def min_time_to_visit(grid: List[List[int]]) -> int:
    m, n = len(grid), len(grid[0])
    if m == 1 and n == 1:
        return 0
    
    # 方向数组
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
    # 初始化距离数组
    dist = [[float('inf')] * n for _ in range(m)]
    dist[0][0] = 0
    
    # 优先队列
    pq = [(0, 0, 0)]  # (时间, 行, 列)
    
    while pq:
        time, row, col = heapq.heappop(pq)
        
        if row == m - 1 and col == n - 1:
            return time
        
        for dr, dc in directions:
            new_row, new_col = row + dr, col + dc
            
            if 0 <= new_row < m and 0 <= new_col < n:
                wait_time = max(0, grid[new_row][new_col] - (time + 1))
                new_time = time + 1 + wait_time
                
                if new_time < dist[new_row][new_col]:
                    dist[new_row][new_col] = new_time
                    heapq.heappush(pq, (new_time, new_row, new_col))
    
    return -1

Solution = create_solution(min_time_to_visit)