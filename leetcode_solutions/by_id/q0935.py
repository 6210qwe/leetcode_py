# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 935
标题: Orderly Queue
难度: hard
链接: https://leetcode.cn/problems/orderly-queue/
题目类型: 数学、字符串、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
899. 有序队列 - 给定一个字符串 s 和一个整数 k 。你可以从 s 的前 k 个字母中选择一个，并把它加到字符串的末尾。 返回 在应用上述步骤的任意数量的移动后，字典序最小的字符串 。 示例 1： 输入：s = "cba", k = 1 输出："acb" 解释： 在第一步中，我们将第一个字符（“c”）移动到最后，获得字符串 “bac”。 在第二步中，我们将第一个字符（“b”）移动到最后，获得最终结果 “acb”。 示例 2： 输入：s = "baaca", k = 3 输出："aaabc" 解释： 在第一步中，我们将第一个字符（“b”）移动到最后，获得字符串 “aacab”。 在第二步中，我们将第三个字符（“c”）移动到最后，获得最终结果 “aaabc”。 提示： * 1 <= k <= S.length <= 1000 * s 只由小写字母组成。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想:
- 当 k == 1 时，我们只能将第一个字符移到末尾，因此我们需要检查所有可能的循环移位并找到字典序最小的一个。
- 当 k > 1 时，我们可以通过多次操作将字符串中的任意两个字符交换位置，从而可以将字符串重新排列成字典序最小的形式。

算法步骤:
1. 如果 k == 1，生成所有可能的循环移位，并返回其中字典序最小的一个。
2. 如果 k > 1，直接对字符串进行排序并返回结果。

关键点:
- 对于 k > 1 的情况，通过排序可以直接得到字典序最小的字符串。
- 对于 k == 1 的情况，需要遍历所有可能的循环移位。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2) (当 k == 1 时) 或 O(n log n) (当 k > 1 时)
空间复杂度: O(n) (存储所有可能的循环移位)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def orderly_queue(s: str, k: int) -> str:
    """
    函数式接口 - 返回在应用上述步骤的任意数量的移动后，字典序最小的字符串
    """
    if k == 1:
        # 生成所有可能的循环移位
        rotations = [s[i:] + s[:i] for i in range(len(s))]
        # 返回字典序最小的一个
        return min(rotations)
    else:
        # 直接对字符串进行排序
        return ''.join(sorted(s))

Solution = create_solution(orderly_queue)