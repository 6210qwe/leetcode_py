# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1479
标题: Construct Target Array With Multiple Sums
难度: hard
链接: https://leetcode.cn/problems/construct-target-array-with-multiple-sums/
题目类型: 数组、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1354. 多次求和构造目标数组 - 给你一个整数数组 target 。一开始，你有一个数组 A ，它的所有元素均为 1 ，你可以执行以下操作： * 令 x 为你数组里所有元素的和 * 选择满足 0 <= i < target.size 的任意下标 i ，并让 A 数组里下标为 i 处的值为 x 。 * 你可以重复该过程任意次 如果能从 A 开始构造出目标数组 target ，请你返回 True ，否则返回 False 。 示例 1： 输入：target = [9,3,5] 输出：true 解释：从 [1, 1, 1] 开始 [1, 1, 1], 和为 3 ，选择下标 1 [1, 3, 1], 和为 5， 选择下标 2 [1, 3, 5], 和为 9， 选择下标 0 [9, 3, 5] 完成 示例 2： 输入：target = [1,1,1,2] 输出：false 解释：不可能从 [1,1,1,1] 出发构造目标数组。 示例 3： 输入：target = [8,5] 输出：true 提示： * N == target.length * 1 <= target.length <= 5 * 10^4 * 1 <= target[i] <= 10^9
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用最大堆来模拟每次选择最大元素进行更新的过程。

算法步骤:
1. 初始化一个最大堆，并将目标数组中的所有元素加入堆中。
2. 计算初始的总和。
3. 从堆中取出最大元素，假设它是由之前的某个元素加上剩余元素的和得到的。
4. 更新最大元素为 (当前最大元素 - 剩余元素的和) % 剩余元素的和 + 剩余元素的和。
5. 将更新后的最大元素重新加入堆中，并更新总和。
6. 重复上述过程，直到堆中的最大元素为1，或者无法继续更新。

关键点:
- 使用最大堆来高效地获取和更新最大元素。
- 通过模运算和加法来逆向还原数组。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是 target 的长度。每次堆操作的时间复杂度是 O(log n)，最坏情况下需要进行 n 次堆操作。
空间复杂度: O(n)，用于存储堆。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def isPossible(target: List[int]) -> bool:
    if len(target) == 1:
        return target[0] == 1
    
    # 转换为最大堆
    max_heap = [-x for x in target]
    heapq.heapify(max_heap)
    
    total_sum = sum(target)
    
    while -max_heap[0] > 1:
        largest = -heapq.heappop(max_heap)
        rest_sum = total_sum - largest
        
        if rest_sum == 1:
            return True
        if rest_sum >= largest or rest_sum == 0 or largest % rest_sum == 0:
            return False
        
        new_largest = largest % rest_sum
        total_sum = rest_sum + new_largest
        heapq.heappush(max_heap, -new_largest)
    
    return True

Solution = create_solution(isPossible)