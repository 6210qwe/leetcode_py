# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 96
标题: Unique Binary Search Trees
难度: medium
链接: https://leetcode.cn/problems/unique-binary-search-trees/
题目类型: 树、二叉搜索树、数学、动态规划、二叉树
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
96. 不同的二叉搜索树 - 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。 示例 1： [https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg] 输入：n = 3 输出：5 示例 2： 输入：n = 1 输出：1 提示： * 1 <= n <= 19
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 动态规划，dp[i]表示i个节点能组成的不同BST数量（卡塔兰数）

算法步骤:
1. 初始化：dp[0] = 1（空树有1种）
2. 对于i从1到n：
   - 对于每个根节点j（1到i）：
     * 左子树有j-1个节点，右子树有i-j个节点
     * dp[i] += dp[j-1] * dp[i-j]
3. 返回dp[n]

关键点:
- 这是卡塔兰数问题
- 对于n个节点，以j为根节点时，左子树有j-1个节点，右子树有n-j个节点
- 时间复杂度O(n²)，空间复杂度O(n)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n²) - 需要计算n个状态，每个状态需要O(n)时间
空间复杂度: O(n) - 存储DP数组
"""

# ============================================================================
# 代码实现
# ============================================================================

from leetcode_solutions.utils.solution import create_solution


def num_trees(n: int) -> int:
    """
    函数式接口 - 动态规划（卡塔兰数）
    
    实现思路:
    使用动态规划计算n个节点能组成的不同BST数量，这是卡塔兰数问题。
    
    Args:
        n: 节点数量
        
    Returns:
        n个节点组成的不同二叉搜索树的种数
        
    Example:
        >>> num_trees(3)
        5
    """
    dp = [0] * (n + 1)
    dp[0] = 1  # 空树有1种
    
    for i in range(1, n + 1):
        for j in range(1, i + 1):
            # 以j为根节点，左子树有j-1个节点，右子树有i-j个节点
            dp[i] += dp[j - 1] * dp[i - j]
    
    return dp[n]


# 自动生成Solution类（无需手动编写）
Solution = create_solution(num_trees)
