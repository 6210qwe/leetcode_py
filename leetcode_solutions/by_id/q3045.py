# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3045
标题: Minimum Right Shifts to Sort the Array
难度: easy
链接: https://leetcode.cn/problems/minimum-right-shifts-to-sort-the-array/
题目类型: 数组
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2855. 使数组成为递增数组的最少右移次数 - 给你一个长度为 n 下标从 0 开始的数组 nums ，数组中的元素为 互不相同 的正整数。请你返回让 nums 成为递增数组的 最少右移 次数，如果无法得到递增数组，返回 -1 。 一次 右移 指的是同时对所有下标进行操作，将下标为 i 的元素移动到下标 (i + 1) % n 处。 示例 1： 输入：nums = [3,4,5,1,2] 输出：2 解释： 第一次右移后，nums = [2,3,4,5,1] 。 第二次右移后，nums = [1,2,3,4,5] 。 现在 nums 是递增数组了，所以答案为 2 。 示例 2： 输入：nums = [1,3,5] 输出：0 解释：nums 已经是递增数组了，所以答案为 0 。 示例 3： 输入：nums = [2,1,4] 输出：-1 解释：无法将数组变为递增数组。 提示： * 1 <= nums.length <= 100 * 1 <= nums[i] <= 100 * nums 中的整数互不相同。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过找到数组中唯一的一个下降点来确定最小右移次数。如果存在多个下降点，则无法通过右移使其递增。

算法步骤:
1. 遍历数组，找到第一个下降点。
2. 如果没有下降点，说明数组已经是递增的，返回 0。
3. 如果有多个下降点，返回 -1。
4. 计算从下降点开始到数组末尾的距离，即为所需的右移次数。

关键点:
- 找到唯一的下降点。
- 通过计算从下降点到数组末尾的距离来确定右移次数。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(1)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def minimum_right_shifts(nums: List[int]) -> int:
    """
    函数式接口 - 返回使数组成为递增数组的最少右移次数，如果无法得到递增数组，返回 -1。
    """
    n = len(nums)
    shift_point = -1  # 用于记录下降点的位置

    for i in range(n):
        if nums[i] > nums[(i + 1) % n]:
            if shift_point != -1:
                # 如果已经找到了一个下降点，再找到另一个下降点，说明无法通过右移使其递增
                return -1
            shift_point = (i + 1) % n

    if shift_point == -1:
        # 如果没有找到下降点，说明数组已经是递增的
        return 0
    else:
        # 计算从下降点到数组末尾的距离
        return n - shift_point


Solution = create_solution(minimum_right_shifts)