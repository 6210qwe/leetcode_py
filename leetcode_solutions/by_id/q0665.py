# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 665
标题: Non-decreasing Array
难度: medium
链接: https://leetcode.cn/problems/non-decreasing-array/
题目类型: 数组
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
665. 非递减数列 - 给你一个长度为 n 的整数数组 nums ，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。 我们是这样定义一个非递减数列的： 对于数组中任意的 i (0 <= i <= n-2)，总满足 nums[i] <= nums[i + 1]。 示例 1: 输入: nums = [4,2,3] 输出: true 解释: 你可以通过把第一个 4 变成 1 来使得它成为一个非递减数列。 示例 2: 输入: nums = [4,2,1] 输出: false 解释: 你不能在只改变一个元素的情况下将其变为非递减数列。 提示： * n == nums.length * 1 <= n <= 104 * -105 <= nums[i] <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过一次遍历检查数组是否可以最多改变一个元素使其成为非递减数列。

算法步骤:
1. 初始化一个计数器 `modified` 用于记录需要修改的次数。
2. 遍历数组，如果发现 nums[i] > nums[i + 1]，则需要修改：
   - 如果 `modified` 已经大于 0，直接返回 False。
   - 否则，根据情况修改 nums[i] 或 nums[i + 1]，并增加 `modified` 计数。
3. 如果遍历结束且 `modified` 不超过 1，则返回 True。

关键点:
- 通过一次遍历和一个计数器来控制最多修改一个元素。
- 根据具体情况选择修改 nums[i] 还是 nums[i + 1]。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 仅需一次遍历数组。
空间复杂度: O(1) - 只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def check_possibility(nums: List[int]) -> bool:
    """
    检查数组是否可以通过最多改变一个元素使其成为非递减数列。
    """
    modified = 0
    for i in range(len(nums) - 1):
        if nums[i] > nums[i + 1]:
            if modified == 1:
                return False
            if i == 0 or nums[i - 1] <= nums[i + 1]:
                nums[i] = nums[i + 1]
            else:
                nums[i + 1] = nums[i]
            modified += 1
    return True


Solution = create_solution(check_possibility)