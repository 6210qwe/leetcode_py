# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000233
标题: 只出现一次的数字 II
难度: medium
链接: https://leetcode.cn/problems/WGki4K/
题目类型: 位运算、数组
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCR 004. 只出现一次的数字 II - 给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。 示例 1： 输入：nums = [2,2,3,2] 输出：3 示例 2： 输入：nums = [0,1,0,1,0,1,100] 输出：100 提示： * 1 <= nums.length <= 3 * 104 * -231 <= nums[i] <= 231 - 1 * nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 进阶：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 注意：本题与主站 137 题相同：https://leetcode.cn/problems/single-number-ii/ [https://leetcode.cn/problems/single-number-ii/]
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 位运算按位统计，模 3 还原唯一元素

算法步骤:
1. 对于每一位 bit（0..31），统计所有数字在该位上为 1 的次数 count
2. 若 count % 3 != 0，说明唯一元素在该位上为 1
3. 使用一个整数 result，将这些位还原出来
4. 需要正确处理负数：
   - 可以在 32 位有符号整数范围内运算，若最高位为 1，则将 result 视为负数：
     若 result >= 2^31，则 result -= 2^32

关键点:
- 其他元素都出现 3 次，所以在每一位上的 1 的次数对 3 取模后，剩下的就是唯一元素的该位
- 注意 Python 整数无限精度，需要自己限制在 32 位范围内还原符号
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(32 * n) ≈ O(n) - 对每一位遍历所有数字
空间复杂度: O(1)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def single_number(nums: List[int]) -> int:
    """
    函数式接口 - 只出现一次的数字 II
    """
    result = 0
    for bit in range(32):
        count = 0
        for num in nums:
            if (num >> bit) & 1:
                count += 1
        if count % 3 != 0:
            result |= (1 << bit)

    # 处理负数（32 位有符号）
    if result >= 2 ** 31:
        result -= 2 ** 32
    return result


Solution = create_solution(single_number)
