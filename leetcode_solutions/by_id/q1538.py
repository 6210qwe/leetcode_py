# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1538
标题: Maximum Points You Can Obtain from Cards
难度: medium
链接: https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/
题目类型: 数组、前缀和、滑动窗口
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1423. 可获得的最大点数 - 几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。 每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。 你的点数就是你拿到手中的所有卡牌的点数之和。 给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。 示例 1： 输入：cardPoints = [1,2,3,4,5,6,1], k = 3 输出：12 解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。 示例 2： 输入：cardPoints = [2,2,2], k = 2 输出：4 解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。 示例 3： 输入：cardPoints = [9,7,7,9,7,7,9], k = 7 输出：55 解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。 示例 4： 输入：cardPoints = [1,1000,1], k = 1 输出：1 解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。 示例 5： 输入：cardPoints = [1,79,80,1,1,1,200,1], k = 3 输出：202 提示： * 1 <= cardPoints.length <= 10^5 * 1 <= cardPoints[i] <= 10^4 * 1 <= k <= cardPoints.length
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用滑动窗口来找到最大点数

算法步骤:
1. 计算前 k 个元素的总和作为初始值。
2. 使用滑动窗口技术，逐步减少左边的元素并增加右边的元素，更新总和。
3. 在每次更新总和时，记录最大值。

关键点:
- 初始窗口包含前 k 个元素。
- 滑动窗口逐步向右移动，直到窗口包含最后 k 个元素。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(k)
空间复杂度: O(1)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def max_score(card_points: List[int], k: int) -> int:
    """
    函数式接口 - 返回可以获得的最大点数
    """
    n = len(card_points)
    # 初始窗口包含前 k 个元素
    window_sum = sum(card_points[:k])
    max_points = window_sum

    # 滑动窗口逐步向右移动
    for i in range(1, k + 1):
        window_sum += card_points[n - i] - card_points[k - i]
        max_points = max(max_points, window_sum)

    return max_points


Solution = create_solution(max_score)