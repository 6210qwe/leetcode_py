# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1792
标题: Find the Most Competitive Subsequence
难度: medium
链接: https://leetcode.cn/problems/find-the-most-competitive-subsequence/
题目类型: 栈、贪心、数组、单调栈
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1673. 找出最具竞争力的子序列 - 给你一个整数数组 nums 和一个正整数 k ，返回长度为 k 且最具 竞争力 的 nums 子序列。 数组的子序列是从数组中删除一些元素（可能不删除元素）得到的序列。 在子序列 a 和子序列 b 第一个不相同的位置上，如果 a 中的数字小于 b 中对应的数字，那么我们称子序列 a 比子序列 b（相同长度下）更具 竞争力 。 例如，[1,3,4] 比 [1,3,5] 更具竞争力，在第一个不相同的位置，也就是最后一个位置上， 4 小于 5 。 示例 1： 输入：nums = [3,5,2,6], k = 2 输出：[2,6] 解释：在所有可能的子序列集合 {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} 中，[2,6] 最具竞争力。 示例 2： 输入：nums = [2,4,3,3,5,4,9,6], k = 4 输出：[2,3,3,4] 提示： * 1 <= nums.length <= 105 * 0 <= nums[i] <= 109 * 1 <= k <= nums.length
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 单调栈，维护一个长度为k的递增子序列

算法步骤:
1. 使用栈维护当前最优子序列
2. 遍历数组，如果当前元素小于栈顶且剩余元素足够，弹出栈顶
3. 如果栈长度小于k，加入当前元素

关键点:
- 单调栈
- 时间复杂度O(n)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 遍历数组一次
空间复杂度: O(k) - 栈空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def most_competitive(nums: List[int], k: int) -> List[int]:
    """
    函数式接口 - 找出最具竞争力的子序列
    
    实现思路:
    单调栈：维护一个长度为k的递增子序列。
    
    Args:
        nums: 整数数组
        k: 子序列长度
        
    Returns:
        最具竞争力的子序列
        
    Example:
        >>> most_competitive([3,5,2,6], 2)
        [2, 6]
    """
    stack = []
    n = len(nums)
    
    for i, num in enumerate(nums):
        # 如果当前元素小于栈顶且剩余元素足够，弹出栈顶
        while stack and num < stack[-1] and len(stack) + n - i > k:
            stack.pop()
        
        if len(stack) < k:
            stack.append(num)
    
    return stack


Solution = create_solution(most_competitive)
