# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 386
标题: Lexicographical Numbers
难度: medium
链接: https://leetcode.cn/problems/lexicographical-numbers/
题目类型: 深度优先搜索、字典树
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
386. 字典序排数 - 给你一个整数 n ，按字典序返回范围 [1, n] 内所有整数。 你必须设计一个时间复杂度为 O(n) 且使用 O(1) 额外空间的算法。 示例 1： 输入：n = 13 输出：[1,10,11,12,13,2,3,4,5,6,7,8,9] 示例 2： 输入：n = 2 输出：[1,2] 提示： * 1 <= n <= 5 * 104
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 按字典序在整数树上进行类似先序遍历，利用「×10 下钻」和「+1 右移」的规则在 O(1) 额外空间内生成序列

算法步骤:
1. 将 1..n 看作一棵 10 叉树上的节点：每个数字 x 可以扩展出子节点 x0..x9（只要 ≤ n），而字典序遍历就是对这棵树的先序遍历。
2. 用一个变量 cur 表示当前数字，初始 cur = 1，并将其加入结果。
3. 对于每一步，按照如下优先级更新 cur：
   - 若 cur * 10 ≤ n，则优先下潜到下一层：cur *= 10；
   - 否则如果 cur % 10 != 9 且 cur + 1 ≤ n，则横向移动到下一个兄弟：cur += 1；
   - 否则需要回溯到父节点：不断 cur //= 10，直到 cur 的末尾不再是 9 且 cur + 1 ≤ n，然后执行 cur += 1。
4. 重复上述过程直至生成 n 个数字为止。

关键点:
- 整个过程只依赖当前数字，不需要显式构建树结构。
- 「下潜」保证了前缀优先，「横移」与「回溯」保证了在同一前缀下从小到大遍历。
- 注意回溯时可能需要连续去掉多位末尾的 9，直到找到下一个合法前缀。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 每次更新 cur 输出一个数字，总共输出 n 个数字。
空间复杂度: O(1) - 除结果数组外，仅使用常数个变量。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def lexicographical_numbers(n: int) -> List[int]:
    """
    返回 [1, n] 的字典序排列。

    使用数位 DFS/迭代模拟前序遍历。
    """
    res: List[int] = []
    cur = 1
    for _ in range(n):
        res.append(cur)
        if cur * 10 <= n:
            cur *= 10
        else:
            while cur % 10 == 9 or cur + 1 > n:
                cur //= 10
            cur += 1
    return res


# 自动生成Solution类（无需手动编写）
Solution = create_solution(lexicographical_numbers)
