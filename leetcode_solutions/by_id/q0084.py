# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 84
标题: Largest Rectangle in Histogram
难度: hard
链接: https://leetcode.cn/problems/largest-rectangle-in-histogram/
题目类型: 栈、数组、单调栈
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
84. 柱状图中最大的矩形 - 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 示例 1: [https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg] 输入：heights = [2,1,5,6,2,3] 输出：10 解释：最大的矩形为图中红色区域，面积为 10 示例 2： [https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg] 输入： heights = [2,4] 输出： 4 提示： * 1 <= heights.length <=105 * 0 <= heights[i] <= 104
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 单调栈，找到每个柱子左右两边第一个比它矮的柱子

算法步骤:
1. 使用单调递增栈，存储柱子的索引
2. 遍历heights：
   - 如果当前柱子高度小于栈顶柱子高度，弹出栈顶并计算面积
   - 面积 = heights[stack.pop()] * (当前索引 - 新栈顶索引 - 1)
   - 将当前索引入栈
3. 处理栈中剩余的柱子
4. 返回最大面积

关键点:
- 使用单调栈找到每个柱子的左右边界
- 在heights前后添加0，简化边界处理
- 时间复杂度O(n)，空间复杂度O(n)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 每个柱子最多入栈和出栈一次
空间复杂度: O(n) - 栈的大小
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from leetcode_solutions.utils.solution import create_solution


def largest_rectangle_area(heights: List[int]) -> int:
    """
    函数式接口 - 单调栈
    
    实现思路:
    使用单调栈找到每个柱子左右两边第一个比它矮的柱子，计算最大矩形面积。
    
    Args:
        heights: 表示柱子高度的非负整数数组
        
    Returns:
        能够勾勒出来的矩形的最大面积
        
    Example:
        >>> largest_rectangle_area([2,1,5,6,2,3])
        10
    """
    # 在前后添加0，简化边界处理
    heights = [0] + heights + [0]
    stack = []
    max_area = 0
    
    for i in range(len(heights)):
        # 如果当前柱子高度小于栈顶柱子高度，弹出并计算面积
        while stack and heights[i] < heights[stack[-1]]:
            h = heights[stack.pop()]
            width = i - stack[-1] - 1
            max_area = max(max_area, h * width)
        stack.append(i)
    
    return max_area


# 自动生成Solution类（无需手动编写）
Solution = create_solution(largest_rectangle_area)
