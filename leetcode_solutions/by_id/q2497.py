# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2497
标题: Maximum Matching of Players With Trainers
难度: medium
链接: https://leetcode.cn/problems/maximum-matching-of-players-with-trainers/
题目类型: 贪心、数组、双指针、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2410. 运动员和训练师的最大匹配数 - 给你一个下标从 0 开始的整数数组 players ，其中 players[i] 表示第 i 名运动员的 能力 值，同时给你一个下标从 0 开始的整数数组 trainers ，其中 trainers[j] 表示第 j 名训练师的 训练能力值 。 如果第 i 名运动员的能力值 小于等于 第 j 名训练师的能力值，那么第 i 名运动员可以 匹配 第 j 名训练师。除此以外，每名运动员至多可以匹配一位训练师，每位训练师最多可以匹配一位运动员。 请你返回满足上述要求 players 和 trainers 的 最大 匹配数。 示例 1： 输入：players = [4,7,9], trainers = [8,2,5,8] 输出：2 解释： 得到两个匹配的一种方案是： - players[0] 与 trainers[0] 匹配，因为 4 <= 8 。 - players[1] 与 trainers[3] 匹配，因为 7 <= 8 。 可以证明 2 是可以形成的最大匹配数。 示例 2： 输入：players = [1,1,1], trainers = [10] 输出：1 解释： 训练师可以匹配所有 3 个运动员 每个运动员至多只能匹配一个训练师，所以最大答案是 1 。 提示： * 1 <= players.length, trainers.length <= 105 * 1 <= players[i], trainers[j] <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用贪心算法和双指针来最大化匹配数。

算法步骤:
1. 对 players 和 trainers 数组进行排序。
2. 初始化两个指针 i 和 j，分别指向 players 和 trainers 的起始位置。
3. 遍历 players 数组，对于每个运动员，找到第一个能够匹配的训练师。
4. 如果找到匹配的训练师，移动训练师指针 j。
5. 返回匹配的总数。

关键点:
- 排序后使用双指针可以高效地找到匹配的训练师。
- 每次匹配后移动训练师指针，确保每个训练师只被使用一次。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n + m log m)，其中 n 是 players 的长度，m 是 trainers 的长度。排序操作的时间复杂度为 O(n log n) 和 O(m log m)，遍历操作的时间复杂度为 O(n + m)。
空间复杂度: O(1)，除了输入和输出外，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def max_match(players: List[int], trainers: List[int]) -> int:
    """
    函数式接口 - 返回 players 和 trainers 的最大匹配数
    """
    # 对 players 和 trainers 数组进行排序
    players.sort()
    trainers.sort()
    
    # 初始化指针和匹配计数
    i, j, match_count = 0, 0, 0
    
    # 遍历 players 数组
    while i < len(players) and j < len(trainers):
        if players[i] <= trainers[j]:
            # 找到匹配的训练师
            match_count += 1
            i += 1
            j += 1
        else:
            # 当前训练师无法匹配当前运动员，移动训练师指针
            j += 1
    
    return match_count

Solution = create_solution(max_match)