# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2297
标题: Amount of New Area Painted Each Day
难度: hard
链接: https://leetcode.cn/problems/amount-of-new-area-painted-each-day/
题目类型: 线段树、数组、有序集合
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2158. 每天绘制新区域的数量 - 备战技术面试？力扣提供海量技术面试资源，帮助你高效提升编程技能,轻松拿下世界 IT 名企 Dream Offer。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用扫描线算法和有序集合来维护当前的区间，并计算每天新绘制的面积。

算法步骤:
1. 初始化一个有序集合 `events` 来存储所有事件（开始和结束），并初始化一个 `active` 集合来存储当前活跃的区间。
2. 遍历每一天的绘制任务，将每个任务的开始和结束时间加入 `events`。
3. 对 `events` 进行排序，按时间顺序处理每个事件。
4. 使用一个变量 `last` 来记录上一个事件的时间点，用于计算新绘制的面积。
5. 遍历 `events`，对于每个事件：
   - 如果是开始事件，将其加入 `active` 集合。
   - 如果是结束事件，从 `active` 集合中移除。
   - 计算当前活跃区间的总长度，并更新 `last`。
6. 返回每天新绘制的面积。

关键点:
- 使用有序集合来高效地管理和查询当前活跃的区间。
- 通过扫描线算法来处理区间的开始和结束事件。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是绘制任务的数量。排序操作的时间复杂度为 O(n log n)，遍历和插入/删除操作的时间复杂度为 O(log n)。
空间复杂度: O(n)，存储所有事件和活跃区间的空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from sortedcontainers import SortedSet

def amount_painted(paint: List[List[int]]) -> List[int]:
    """
    函数式接口 - 计算每天新绘制的面积
    """
    events = []
    for i, (start, end) in enumerate(paint):
        events.append((start, 'start', i))
        events.append((end, 'end', i))
    
    events.sort()
    active = SortedSet()
    last = 0
    result = [0] * len(paint)
    
    for time, event_type, index in events:
        if active:
            result[index] += (time - last) * len(active)
        
        if event_type == 'start':
            active.add(index)
        else:
            active.remove(index)
        
        last = time
    
    return result

Solution = create_solution(amount_painted)