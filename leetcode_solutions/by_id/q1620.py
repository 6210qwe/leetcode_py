# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1620
标题: Check If Array Pairs Are Divisible by k
难度: medium
链接: https://leetcode.cn/problems/check-if-array-pairs-are-divisible-by-k/
题目类型: 数组、哈希表、计数
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1497. 检查数组对是否可以被 k 整除 - 给你一个整数数组 arr 和一个整数 k ，其中数组长度是偶数，值为 n 。 现在需要把数组恰好分成 n / 2 对，以使每对数字的和都能够被 k 整除。 如果存在这样的分法，请返回 true ；否则，返回 false。 示例 1： 输入：arr = [1,2,3,4,5,10,6,7,8,9], k = 5 输出：true 解释：划分后的数字对为 (1,9),(2,8),(3,7),(4,6) 以及 (5,10) 。 示例 2： 输入：arr = [1,2,3,4,5,6], k = 7 输出：true 解释：划分后的数字对为 (1,6),(2,5) 以及 (3,4) 。 示例 3： 输入：arr = [1,2,3,4,5,6], k = 10 输出：false 解释：无法在将数组中的数字分为三对的同时满足每对数字和能够被 10 整除的条件。 提示： * arr.length == n * 1 <= n <= 105 * n 为偶数 * -109 <= arr[i] <= 109 * 1 <= k <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用哈希表记录每个元素模 k 的余数出现的次数，然后检查是否存在对应的配对。

算法步骤:
1. 初始化一个长度为 k 的数组 count，用于记录每个余数出现的次数。
2. 遍历数组 arr，计算每个元素模 k 的余数，并更新 count 数组。
3. 检查 count 数组中每个余数 i 和 k-i 是否匹配：
   - 如果 i == 0 或 i == k/2，则 count[i] 必须是偶数。
   - 否则，count[i] 必须等于 count[k-i]。

关键点:
- 使用哈希表（数组）来记录余数出现的次数，从而实现 O(n) 时间复杂度。
- 通过检查余数及其补数的配对情况，确保每对数字的和都能被 k 整除。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(k)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def can_arrange_pairs(arr: List[int], k: int) -> bool:
    """
    函数式接口 - 检查数组对是否可以被 k 整除
    """
    # 初始化一个长度为 k 的数组 count，用于记录每个余数出现的次数
    count = [0] * k
    
    # 遍历数组 arr，计算每个元素模 k 的余数，并更新 count 数组
    for num in arr:
        count[num % k] += 1
    
    # 检查 count 数组中每个余数 i 和 k-i 是否匹配
    for i in range(1, k // 2 + 1):
        if count[i] != count[k - i]:
            return False
    
    # 特殊处理余数为 0 和 k/2 的情况
    if count[0] % 2 != 0 or (k % 2 == 0 and count[k // 2] % 2 != 0):
        return False
    
    return True


Solution = create_solution(can_arrange_pairs)