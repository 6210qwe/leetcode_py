# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 354
标题: Russian Doll Envelopes
难度: hard
链接: https://leetcode.cn/problems/russian-doll-envelopes/
题目类型: 数组、二分查找、动态规划、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
354. 俄罗斯套娃信封问题 - 给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。 当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。 请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。 注意：不允许旋转信封。 示例 1： 输入：envelopes = [[5,4],[6,4],[6,7],[2,3]] 输出：3 解释：最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。 示例 2： 输入：envelopes = [[1,1],[1,1],[1,1]] 输出：1 提示： * 1 <= envelopes.length <= 105 * envelopes[i].length == 2 * 1 <= wi, hi <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 排序+最长递增子序列(LIS)

算法步骤:
1. 按宽度升序排序，宽度相同时按高度降序排序
2. 对高度数组求最长递增子序列
3. 使用二分查找优化LIS算法

关键点:
- 宽度相同时按高度降序，避免相同宽度被嵌套
- 使用二分查找优化LIS到O(nlogn)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(nlogn) - 排序O(nlogn) + LIS O(nlogn)
空间复杂度: O(n) - LIS数组
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution
import bisect


def max_envelopes(envelopes: List[List[int]]) -> int:
    """
    函数式接口 - 俄罗斯套娃信封问题
    
    实现思路:
    先按宽度排序，宽度相同时按高度降序，然后对高度求LIS。
    
    Args:
        envelopes: 信封列表，每个信封为[宽度, 高度]
        
    Returns:
        最多能嵌套的信封数量
        
    Example:
        >>> max_envelopes([[5,4],[6,4],[6,7],[2,3]])
        3
    """
    # 按宽度升序，宽度相同时按高度降序
    envelopes.sort(key=lambda x: (x[0], -x[1]))
    
    # 提取高度数组，求LIS
    heights = [h for _, h in envelopes]
    dp = []
    
    for h in heights:
        idx = bisect.bisect_left(dp, h)
        if idx == len(dp):
            dp.append(h)
        else:
            dp[idx] = h
    
    return len(dp)


# 自动生成Solution类（无需手动编写）
Solution = create_solution(max_envelopes)
