# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 67
标题: Add Binary
难度: easy
链接: https://leetcode.cn/problems/add-binary/
题目类型: 位运算、数学、字符串、模拟
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
67. 二进制求和 - 给你两个二进制字符串 a 和 b ，以二进制字符串的形式返回它们的和。 示例 1： 输入:a = "11", b = "1" 输出："100" 示例 2： 输入：a = "1010", b = "1011" 输出："10101" 提示： * 1 <= a.length, b.length <= 104 * a 和 b 仅由字符 '0' 或 '1' 组成 * 字符串如果不是 "0" ，就不含前导零
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 从右向左逐位相加，处理进位

算法步骤:
1. 将两个字符串对齐（从右向左）
2. 逐位相加：sum = int(a[i]) + int(b[j]) + carry
3. 当前位结果：sum % 2
4. 进位：sum // 2
5. 如果最后还有进位，在结果前加1

关键点:
- 从右向左处理，模拟二进制加法
- 使用carry变量记录进位
- 时间复杂度O(max(m,n))，空间复杂度O(max(m,n))
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(max(m,n)) - m和n分别为两个字符串的长度
空间复杂度: O(max(m,n)) - 存储结果字符串
"""

# ============================================================================
# 代码实现
# ============================================================================

from leetcode_solutions.utils.solution import create_solution


def add_binary(a: str, b: str) -> str:
    """
    函数式接口 - 从右向左逐位相加
    
    实现思路:
    从右向左逐位相加两个二进制字符串，处理进位。
    
    Args:
        a: 第一个二进制字符串
        b: 第二个二进制字符串
        
    Returns:
        两个二进制字符串的和
        
    Example:
        >>> add_binary("11", "1")
        '100'
        >>> add_binary("1010", "1011")
        '10101'
    """
    result = []
    carry = 0
    i, j = len(a) - 1, len(b) - 1
    
    while i >= 0 or j >= 0 or carry:
        total = carry
        if i >= 0:
            total += int(a[i])
            i -= 1
        if j >= 0:
            total += int(b[j])
            j -= 1
        
        result.append(str(total % 2))
        carry = total // 2
    
    return ''.join(reversed(result))


# 自动生成Solution类（无需手动编写）
Solution = create_solution(add_binary)
