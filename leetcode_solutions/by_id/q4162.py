# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 4162
标题: Minimum Number of Operations to Have Distinct Elements
难度: medium
链接: https://leetcode.cn/problems/minimum-number-of-operations-to-have-distinct-elements/
题目类型: 数组、哈希表
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3779. 得到互不相同元素的最少操作次数 - 给你一个整数数组 nums。 在一次操作中，你需要移除当前数组的 前三个元素。如果剩余元素少于三个，则移除 所有 剩余元素。 重复此操作，直到数组为空或不包含任何重复元素为止。 返回一个整数，表示所需的操作次数。 示例 1: 输入: nums = [3,8,3,6,5,8] 输出: 1 解释: 在第一次操作中，我们移除前三个元素。剩余的元素 [6, 5, 8] 互不相同，因此停止。仅需要一次操作。 示例 2: 输入: nums = [2,2] 输出: 1 解释: 经过一次操作后，数组变为空，满足停止条件。 示例 3: 输入: nums = [4,3,5,1,2] 输出: 0 解释: 数组中的所有元素都是互不相同的，因此不需要任何操作。 提示: * 1 <= nums.length <= 105 * 1 <= nums[i] <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用哈希表记录每个元素的出现次数，并通过滑动窗口来模拟移除操作。

算法步骤:
1. 初始化一个哈希表 `count` 来记录每个元素的出现次数。
2. 使用一个变量 `ops` 来记录操作次数。
3. 使用一个指针 `i` 从数组的末尾向前遍历。
4. 每次将当前元素的计数减一，如果计数为零则从哈希表中移除该元素。
5. 如果当前哈希表的大小等于剩余元素的数量，则说明剩余元素互不相同，返回操作次数。
6. 否则，增加操作次数并继续遍历。

关键点:
- 使用哈希表记录元素的出现次数，以便快速判断是否还有重复元素。
- 通过从数组末尾向前遍历来模拟移除操作，确保每次操作都移除前三个元素。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def min_operations_to_distinct(nums: List[int]) -> int:
    """
    函数式接口 - 计算得到互不相同元素的最少操作次数
    """
    count = {}
    ops = 0
    n = len(nums)
    
    for i in range(n - 1, -1, -1):
        count[nums[i]] = count.get(nums[i], 0) + 1
        if len(count) == n - 3 * ops:
            return ops
        if (n - i) % 3 == 0:
            ops += 1
            # Remove the first three elements
            for j in range(3):
                if i + j < n:
                    count[nums[i + j]] -= 1
                    if count[nums[i + j]] == 0:
                        del count[nums[i + j]]
    
    return ops

Solution = create_solution(min_operations_to_distinct)