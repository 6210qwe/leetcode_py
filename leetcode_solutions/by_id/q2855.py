# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2855
标题: Maximum Number of Jumps to Reach the Last Index
难度: medium
链接: https://leetcode.cn/problems/maximum-number-of-jumps-to-reach-the-last-index/
题目类型: 数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2770. 达到末尾下标所需的最大跳跃次数 - 给你一个下标从 0 开始、由 n 个整数组成的数组 nums 和一个整数 target 。 你的初始位置在下标 0 。在一步操作中，你可以从下标 i 跳跃到任意满足下述条件的下标 j ： * 0 <= i < j < n * -target <= nums[j] - nums[i] <= target 返回到达下标 n - 1 处所需的 最大跳跃次数 。 如果无法到达下标 n - 1 ，返回 -1 。 示例 1： 输入：nums = [1,3,6,4,1,2], target = 2 输出：3 解释：要想以最大跳跃次数从下标 0 到下标 n - 1 ，可以按下述跳跃序列执行操作： - 从下标 0 跳跃到下标 1 。 - 从下标 1 跳跃到下标 3 。 - 从下标 3 跳跃到下标 5 。 可以证明，从 0 到 n - 1 的所有方案中，不存在比 3 步更长的跳跃序列。因此，答案是 3 。 示例 2： 输入：nums = [1,3,6,4,1,2], target = 3 输出：5 解释：要想以最大跳跃次数从下标 0 到下标 n - 1 ，可以按下述跳跃序列执行操作： - 从下标 0 跳跃到下标 1 。 - 从下标 1 跳跃到下标 2 。 - 从下标 2 跳跃到下标 3 。 - 从下标 3 跳跃到下标 4 。 - 从下标 4 跳跃到下标 5 。 可以证明，从 0 到 n - 1 的所有方案中，不存在比 5 步更长的跳跃序列。因此，答案是 5 。 示例 3： 输入：nums = [1,3,6,4,1,2], target = 0 输出：-1 解释：可以证明不存在从 0 到 n - 1 的跳跃序列。因此，答案是 -1 。 提示： * 2 <= nums.length == n <= 1000 * -109 <= nums[i] <= 109 * 0 <= target <= 2 * 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们定义 dp[i] 表示到达下标 i 所需的最大跳跃次数。对于每个下标 i，我们检查所有可能的前一个下标 j (0 <= j < i)，如果 nums[i] 和 nums[j] 满足跳跃条件，则更新 dp[i]。

算法步骤:
1. 初始化 dp 数组，dp[0] = 0，其他 dp[i] 初始化为 -1。
2. 遍历数组，对于每个下标 i，检查所有可能的前一个下标 j (0 <= j < i)。
3. 如果 nums[i] 和 nums[j] 满足跳跃条件且 dp[j] != -1，则更新 dp[i]。
4. 最后返回 dp[n-1]。

关键点:
- 使用动态规划来记录到达每个下标的最大跳跃次数。
- 通过遍历和条件判断来更新 dp 数组。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def max_jumps_to_reach_last_index(nums: List[int], target: int) -> int:
    n = len(nums)
    if n == 1:
        return 0

    dp = [-1] * n
    dp[0] = 0

    for i in range(1, n):
        for j in range(i):
            if -target <= nums[i] - nums[j] <= target and dp[j] != -1:
                if dp[i] == -1 or dp[i] < dp[j] + 1:
                    dp[i] = dp[j] + 1

    return dp[-1]

Solution = create_solution(max_jumps_to_reach_last_index)