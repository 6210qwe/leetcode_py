# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 503
标题: Next Greater Element II
难度: medium
链接: https://leetcode.cn/problems/next-greater-element-ii/
题目类型: 栈、数组、单调栈
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
503. 下一个更大元素 II - 给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。 数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。 示例 1: 输入: nums = [1,2,1] 输出: [2,-1,2] 解释: 第一个 1 的下一个更大的数是 2； 数字 2 找不到下一个更大的数； 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。 示例 2: 输入: nums = [1,2,3,4,3] 输出: [2,3,4,-1,4] 提示: * 1 <= nums.length <= 104 * -109 <= nums[i] <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用单调栈来解决这个问题。我们可以通过两次遍历数组来模拟循环数组的效果。

算法步骤:
1. 初始化一个栈和一个结果数组。
2. 第一次遍历数组，将每个元素的索引压入栈中，并在找到下一个更大元素时更新结果数组。
3. 第二次遍历数组，重复步骤2，以处理循环数组的情况。
4. 返回结果数组。

关键点:
- 使用单调栈来维护当前未找到下一个更大元素的索引。
- 通过两次遍历数组来模拟循环数组的效果。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是数组的长度。每个元素最多被压入和弹出栈一次。
空间复杂度: O(n)，栈和结果数组的空间复杂度均为 O(n)。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def next_greater_elements(nums: List[int]) -> List[int]:
    """
    函数式接口 - 返回每个元素的下一个更大元素
    """
    n = len(nums)
    result = [-1] * n
    stack = []

    for i in range(2 * n):
        while stack and (nums[stack[-1]] < nums[i % n]):
            result[stack.pop()] = nums[i % n]
        if i < n:
            stack.append(i)

    return result

Solution = create_solution(next_greater_elements)