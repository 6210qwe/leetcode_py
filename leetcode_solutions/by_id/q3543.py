# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3543
标题: Count Substrings That Satisfy K-Constraint I
难度: easy
链接: https://leetcode.cn/problems/count-substrings-that-satisfy-k-constraint-i/
题目类型: 字符串、滑动窗口
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3258. 统计满足 K 约束的子字符串数量 I - 给你一个 二进制 字符串 s 和一个整数 k。 如果一个 二进制字符串 满足以下任一条件，则认为该字符串满足 k 约束： * 字符串中 0 的数量最多为 k。 * 字符串中 1 的数量最多为 k。 返回一个整数，表示 s 的所有满足 k 约束 的子字符串的数量。 示例 1： 输入：s = "10101", k = 1 输出：12 解释： s 的所有子字符串中，除了 "1010"、"10101" 和 "0101" 外，其余子字符串都满足 k 约束。 示例 2： 输入：s = "1010101", k = 2 输出：25 解释： s 的所有子字符串中，除了长度大于 5 的子字符串外，其余子字符串都满足 k 约束。 示例 3： 输入：s = "11111", k = 1 输出：15 解释： s 的所有子字符串都满足 k 约束。 提示： * 1 <= s.length <= 50 * 1 <= k <= s.length * s[i] 是 '0' 或 '1'。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用滑动窗口来统计满足条件的子字符串。

算法步骤:
1. 初始化两个指针 left 和 right，分别表示当前窗口的左右边界。
2. 使用两个计数器 zero_count 和 one_count 分别记录当前窗口内 '0' 和 '1' 的数量。
3. 移动右指针扩展窗口，更新计数器。
4. 当窗口内的 '0' 或 '1' 的数量超过 k 时，移动左指针收缩窗口，直到窗口内的 '0' 和 '1' 的数量都小于等于 k。
5. 在每次移动右指针时，计算当前窗口内的有效子字符串数量，并累加到结果中。

关键点:
- 使用滑动窗口可以高效地统计满足条件的子字符串。
- 通过调整窗口大小，确保窗口内的 '0' 和 '1' 的数量都小于等于 k。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是字符串 s 的长度。每个字符最多被访问两次（一次由右指针，一次由左指针）。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def count_substrings_with_k_constraint(s: str, k: int) -> int:
    """
    函数式接口 - 统计满足 K 约束的子字符串数量
    """
    n = len(s)
    result = 0
    left = 0
    zero_count = 0
    one_count = 0

    for right in range(n):
        if s[right] == '0':
            zero_count += 1
        else:
            one_count += 1

        while zero_count > k or one_count > k:
            if s[left] == '0':
                zero_count -= 1
            else:
                one_count -= 1
            left += 1

        # 计算当前窗口内的有效子字符串数量
        result += right - left + 1

    return result


Solution = create_solution(count_substrings_with_k_constraint)