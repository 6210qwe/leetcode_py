# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1887
标题: Minimum Degree of a Connected Trio in a Graph
难度: hard
链接: https://leetcode.cn/problems/minimum-degree-of-a-connected-trio-in-a-graph/
题目类型: 图、枚举
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1761. 一个图中连通三元组的最小度数 - 给你一个无向图，整数 n 表示图中节点的数目，edges 数组表示图中的边，其中 edges[i] = [ui, vi] ，表示 ui 和 vi 之间有一条无向边。 一个 连通三元组 指的是 三个 节点组成的集合且这三个点之间 两两 有边。 连通三元组的度数 是所有满足此条件的边的数目：一个顶点在这个三元组内，而另一个顶点不在这个三元组内。 请你返回所有连通三元组中度数的 最小值 ，如果图中没有连通三元组，那么返回 -1 。 示例 1： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2021/02/14/trios1.png] 输入：n = 6, edges = [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]] 输出：3 解释：只有一个三元组 [1,2,3] 。构成度数的边在上图中已被加粗。 示例 2： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2021/02/14/trios2.png] 输入：n = 7, edges = [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]] 输出：0 解释：有 3 个三元组： 1) [1,4,3]，度数为 0 。 2) [2,5,6]，度数为 2 。 3) [5,6,7]，度数为 2 。 提示： * 2 <= n <= 400 * edges[i].length == 2 * 1 <= edges.length <= n * (n-1) / 2 * 1 <= ui, vi <= n * ui != vi * 图中没有重复的边。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 枚举所有可能的三元组，并计算每个三元组的度数。

算法步骤:
1. 构建邻接表和节点度数数组。
2. 枚举所有可能的三元组 (u, v, w)，检查它们是否形成连通三元组。
3. 计算每个连通三元组的度数，并记录最小值。

关键点:
- 使用邻接表来快速查找节点之间的连接。
- 通过预处理节点度数来减少计算量。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^3)
空间复杂度: O(n^2)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def min_trio_degree(n: int, edges: List[List[int]]) -> int:
    """
    函数式接口 - 返回所有连通三元组中度数的最小值
    """
    # 构建邻接表
    adj_list = [set() for _ in range(n + 1)]
    degree = [0] * (n + 1)
    
    for u, v in edges:
        adj_list[u].add(v)
        adj_list[v].add(u)
        degree[u] += 1
        degree[v] += 1
    
    min_degree = float('inf')
    
    # 枚举所有可能的三元组
    for u in range(1, n + 1):
        for v in range(u + 1, n + 1):
            if v not in adj_list[u]:
                continue
            for w in range(v + 1, n + 1):
                if w not in adj_list[u] or w not in adj_list[v]:
                    continue
                # 计算三元组的度数
                trio_degree = degree[u] + degree[v] + degree[w] - 6
                min_degree = min(min_degree, trio_degree)
    
    return min_degree if min_degree != float('inf') else -1

Solution = create_solution(min_trio_degree)