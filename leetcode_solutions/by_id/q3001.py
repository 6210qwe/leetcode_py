# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3001
标题: Apply Operations to Maximize Score
难度: hard
链接: https://leetcode.cn/problems/apply-operations-to-maximize-score/
题目类型: 栈、贪心、数组、数学、数论、排序、单调栈
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2818. 操作使得分最大 - 给你一个长度为 n 的正整数数组 nums 和一个整数 k 。 一开始，你的分数为 1 。你可以进行以下操作至多 k 次，目标是使你的分数最大： * 选择一个之前没有选过的 非空 子数组 nums[l, ..., r] 。 * 从 nums[l, ..., r] 里面选择一个 质数分数 最高的元素 x 。如果多个元素质数分数相同且最高，选择下标最小的一个。 * 将你的分数乘以 x 。 nums[l, ..., r] 表示 nums 中起始下标为 l ，结束下标为 r 的子数组，两个端点都包含。 一个整数的 质数分数 等于 x 不同质因子的数目。比方说， 300 的质数分数为 3 ，因为 300 = 2 * 2 * 3 * 5 * 5 。 请你返回进行至多 k 次操作后，可以得到的 最大分数 。 由于答案可能很大，请你将结果对 109 + 7 取余后返回。 示例 1： 输入：nums = [8,3,9,3,8], k = 2 输出：81 解释：进行以下操作可以得到分数 81 ： - 选择子数组 nums[2, ..., 2] 。nums[2] 是子数组中唯一的元素。所以我们将分数乘以 nums[2] ，分数变为 1 * 9 = 9 。 - 选择子数组 nums[2, ..., 3] 。nums[2] 和 nums[3] 质数分数都为 1 ，但是 nums[2] 下标更小。所以我们将分数乘以 nums[2] ，分数变为 9 * 9 = 81 。 81 是可以得到的最高得分。 示例 2： 输入：nums = [19,12,14,6,10,18], k = 3 输出：4788 解释：进行以下操作可以得到分数 4788 ： - 选择子数组 nums[0, ..., 0] 。nums[0] 是子数组中唯一的元素。所以我们将分数乘以 nums[0] ，分数变为 1 * 19 = 19 。 - 选择子数组 nums[5, ..., 5] 。nums[5] 是子数组中唯一的元素。所以我们将分数乘以 nums[5] ，分数变为 19 * 18 = 342 。 - 选择子数组 nums[2, ..., 3] 。nums[2] 和 nums[3] 质数分数都为 2，但是 nums[2] 下标更小。所以我们将分数乘以 nums[2] ，分数变为 342 * 14 = 4788 。 4788 是可以得到的最高的分。 提示： * 1 <= nums.length == n <= 105 * 1 <= nums[i] <= 105 * 1 <= k <= min(n * (n + 1) / 2, 109)
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用贪心算法和堆来最大化分数。

算法步骤:
1. 计算每个数字的质数分数。
2. 使用一个堆来存储每个数字及其索引，按质数分数降序排列。
3. 从堆中取出最大的质数分数的数字，计算其可以被使用的次数，并更新分数。
4. 重复上述步骤直到进行了 k 次操作或堆为空。

关键点:
- 使用堆来高效地获取当前质数分数最高的数字。
- 通过维护一个计数器来记录每个数字已经被使用了多少次。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n + k log n)，其中 n 是 nums 的长度，k 是操作次数。计算质数分数的时间复杂度为 O(n log n)，堆操作的时间复杂度为 O(k log n)。
空间复杂度: O(n)，用于存储质数分数和堆。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq
from collections import Counter

MOD = 10**9 + 7

def prime_score(x):
    score = 0
    if x % 2 == 0:
        score += 1
        while x % 2 == 0:
            x //= 2
    for i in range(3, int(x**0.5) + 1, 2):
        if x % i == 0:
            score += 1
            while x % i == 0:
                x //= i
    if x > 2:
        score += 1
    return score

def max_score(nums: List[int], k: int) -> int:
    n = len(nums)
    scores = [prime_score(num) for num in nums]
    
    # 堆存储 (质数分数, 数字, 索引)
    heap = [(-scores[i], nums[i], i) for i in range(n)]
    heapq.heapify(heap)
    
    count = Counter()
    result = 1
    
    for _ in range(k):
        if not heap:
            break
        _, num, idx = heapq.heappop(heap)
        left = count[idx - 1] if idx > 0 else 0
        right = count[idx + 1] if idx < n - 1 else 0
        available = (idx - left) * (n - idx - right)
        if available > 0:
            result = (result * num) % MOD
            count[idx] += 1
            heapq.heappush(heap, (-scores[idx], num, idx))
    
    return result

Solution = create_solution(max_score)