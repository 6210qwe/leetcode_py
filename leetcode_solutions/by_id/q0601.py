# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 601
标题: Human Traffic of Stadium
难度: hard
链接: https://leetcode.cn/problems/human-traffic-of-stadium/
题目类型: 数据库
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
601. 体育馆的人流量 - 表：Stadium +---------------+---------+ | Column Name | Type | +---------------+---------+ | id | int | | visit_date | date | | people | int | +---------------+---------+ visit_date 是该表中具有唯一值的列。 每日人流量信息被记录在这三列信息中：序号 (id)、日期 (visit_date)、 人流量 (people) 每天只有一行记录，日期随着 id 的增加而增加 编写解决方案找出每行的人数大于或等于 100 且 id 连续的三行或更多行记录。 返回按 visit_date 升序排列 的结果表。 查询结果格式如下所示。 示例 1: 输入： Stadium 表: +------+------------+-----------+ | id | visit_date | people | +------+------------+-----------+ | 1 | 2017-01-01 | 10 | | 2 | 2017-01-02 | 109 | | 3 | 2017-01-03 | 150 | | 4 | 2017-01-04 | 99 | | 5 | 2017-01-05 | 145 | | 6 | 2017-01-06 | 1455 | | 7 | 2017-01-07 | 199 | | 8 | 2017-01-09 | 188 | +------+------------+-----------+ 输出： +------+------------+-----------+ | id | visit_date | people | +------+------------+-----------+ | 5 | 2017-01-05 | 145 | | 6 | 2017-01-06 | 1455 | | 7 | 2017-01-07 | 199 | | 8 | 2017-01-09 | 188 | +------+------------+-----------+ 解释： id 为 5、6、7、8 的四行 id 连续，并且每行都有 >= 100 的人数记录。 请注意，即使第 7 行和第 8 行的 visit_date 不是连续的，输出也应当包含第 8 行，因为我们只需要考虑 id 连续的记录。 不输出 id 为 2 和 3 的行，因为至少需要三条 id 连续的记录。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用窗口函数和条件筛选来找到连续的符合条件的记录。

算法步骤:
1. 选择所有 `people` 大于等于 100 的记录。
2. 使用窗口函数计算每个记录的前一行和后一行的 `id` 差值。
3. 筛选出前一行和后一行的 `id` 差值都为 1 的记录。
4. 选择这些记录的 `id`, `visit_date`, `people` 字段并按 `visit_date` 排序。

关键点:
- 使用窗口函数 `LAG` 和 `LEAD` 来获取前一行和后一行的 `id`。
- 通过条件筛选来找到连续的记录。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是表中的记录数。窗口函数和排序操作的时间复杂度都是线性的。
空间复杂度: O(1)，除了输入和输出外，不需要额外的空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(stadium: List[List[int]]) -> List[List[int]]:
    """
    函数式接口 - 找出每行的人数大于或等于 100 且 id 连续的三行或更多行记录
    """
    if not stadium:
        return []

    # 将输入数据转换为 DataFrame
    import pandas as pd
    df = pd.DataFrame(stadium, columns=['id', 'visit_date', 'people'])

    # 选择所有 `people` 大于等于 100 的记录
    df = df[df['people'] >= 100]

    # 使用窗口函数计算前一行和后一行的 `id` 差值
    df['prev_id_diff'] = df['id'].diff().fillna(1)
    df['next_id_diff'] = df['id'].diff(periods=-1).fillna(1)

    # 筛选出前一行和后一行的 `id` 差值都为 1 的记录
    df = df[(df['prev_id_diff'] == 1) & (df['next_id_diff'] == 1)]

    # 选择这些记录的 `id`, `visit_date`, `people` 字段并按 `visit_date` 排序
    result = df[['id', 'visit_date', 'people']].sort_values(by='visit_date').values.tolist()

    return result


Solution = create_solution(solution_function_name)