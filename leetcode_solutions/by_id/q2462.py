# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2462
标题: Find the K-Sum of an Array
难度: hard
链接: https://leetcode.cn/problems/find-the-k-sum-of-an-array/
题目类型: 数组、排序、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2386. 找出数组的第 K 大和 - 给你一个整数数组 nums 和一个 正 整数 k 。你可以选择数组的任一 子序列 并且对其全部元素求和。 数组的 第 k 大和 定义为：可以获得的第 k 个 最大 子序列和（子序列和允许出现重复） 返回数组的 第 k 大和 。 子序列是一个可以由其他数组删除某些或不删除元素派生而来的数组，且派生过程不改变剩余元素的顺序。 注意：空子序列的和视作 0 。 示例 1： 输入：nums = [2,4,-2], k = 5 输出：2 解释：所有可能获得的子序列和列出如下，按递减顺序排列： 6、4、4、2、2、0、0、-2 数组的第 5 大和是 2 。 示例 2： 输入：nums = [1,-2,3,4,-10,12], k = 16 输出：10 解释：数组的第 16 大和是 10 。 提示： * n == nums.length * 1 <= n <= 105 * -109 <= nums[i] <= 109 * 1 <= k <= min(2000, 2n)
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用最小堆来维护当前最大的 k 个子序列和。

算法步骤:
1. 将所有负数取绝对值，并将所有正数和零加入到一个新的数组中。
2. 对新的数组进行排序。
3. 计算所有正数和零的和，这是最大的子序列和。
4. 使用最小堆来维护当前最大的 k 个子序列和。
5. 从堆中弹出最小的子序列和，并将其与新的数组中的每个元素相加，生成新的子序列和并加入堆中。
6. 重复上述步骤直到找到第 k 大的子序列和。

关键点:
- 使用最小堆来高效地维护当前最大的 k 个子序列和。
- 通过将负数取绝对值并将所有正数和零加入到新的数组中，可以简化问题。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n + k log k)，其中 n 是数组的长度，k 是需要找到的第 k 大和。
空间复杂度: O(n + k)，其中 n 是数组的长度，k 是需要找到的第 k 大和。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def find_k_sum(nums: List[int], k: int) -> int:
    """
    函数式接口 - 找出数组的第 K 大和
    """
    # 将所有负数取绝对值，并将所有正数和零加入到一个新的数组中
    abs_nums = sorted(abs(num) for num in nums)
    pos_nums = [num for num in nums if num >= 0]
    
    # 计算所有正数和零的和
    total_sum = sum(pos_nums)
    
    # 初始化最小堆
    heap = [(total_sum, 0)]
    visited = set()
    visited.add((total_sum, 0))
    
    # 从堆中弹出最小的子序列和，并生成新的子序列和
    for _ in range(k - 1):
        current_sum, idx = heapq.heappop(heap)
        if idx < len(abs_nums):
            new_sum = current_sum - abs_nums[idx]
            if (new_sum, idx + 1) not in visited:
                heapq.heappush(heap, (new_sum, idx + 1))
                visited.add((new_sum, idx + 1))
            if idx > 0 and (current_sum - abs_nums[idx - 1] + abs_nums[idx], idx + 1) not in visited:
                heapq.heappush(heap, (current_sum - abs_nums[idx - 1] + abs_nums[idx], idx + 1))
                visited.add((current_sum - abs_nums[idx - 1] + abs_nums[idx], idx + 1))
    
    return heapq.heappop(heap)[0]

Solution = create_solution(find_k_sum)