# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 459
标题: Repeated Substring Pattern
难度: easy
链接: https://leetcode.cn/problems/repeated-substring-pattern/
题目类型: 字符串、字符串匹配
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
459. 重复的子字符串 - 给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。 示例 1: 输入: s = "abab" 输出: true 解释: 可由子串 "ab" 重复两次构成。 示例 2: 输入: s = "aba" 输出: false 示例 3: 输入: s = "abcabcabcabc" 输出: true 解释: 可由子串 "abc" 重复四次构成。 (或子串 "abcabc" 重复两次构成。) 提示： * 1 <= s.length <= 104 * s 由小写英文字母组成
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 字符串匹配，检查是否由子串重复构成

算法步骤:
1. 尝试所有可能的子串长度（1到n/2）
2. 如果n能被长度整除，检查是否由该子串重复构成
3. 或者使用KMP算法计算next数组，检查n是否能被(n-next[n-1])整除

关键点:
- 枚举子串长度
- 或者使用KMP优化
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2) - 枚举子串长度并检查
空间复杂度: O(1) - 只使用常数额外空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def repeated_substring_pattern(s: str) -> bool:
    """
    函数式接口 - 重复的子字符串
    
    实现思路:
    枚举所有可能的子串长度，检查是否由该子串重复构成。
    
    Args:
        s: 输入字符串
        
    Returns:
        是否可由子串重复构成
        
    Example:
        >>> repeated_substring_pattern("abab")
        True
    """
    n = len(s)
    
    # 尝试所有可能的子串长度
    for length in range(1, n // 2 + 1):
        if n % length != 0:
            continue
        
        pattern = s[:length]
        # 检查是否由pattern重复构成
        if pattern * (n // length) == s:
            return True
    
    return False


# 自动生成Solution类（无需手动编写）
Solution = create_solution(repeated_substring_pattern)
