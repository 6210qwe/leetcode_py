# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 66
标题: Plus One
难度: easy
链接: https://leetcode.cn/problems/plus-one/
题目类型: 数组、数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
66. 加一 - 给定一个表示 大整数 的整数数组 digits，其中 digits[i] 是整数的第 i 位数字。这些数字按从左到右，从最高位到最低位排列。这个大整数不包含任何前导 0。 将大整数加 1，并返回结果的数字数组。 示例 1： 输入：digits = [1,2,3] 输出：[1,2,4] 解释：输入数组表示数字 123。 加 1 后得到 123 + 1 = 124。 因此，结果应该是 [1,2,4]。 示例 2： 输入：digits = [4,3,2,1] 输出：[4,3,2,2] 解释：输入数组表示数字 4321。 加 1 后得到 4321 + 1 = 4322。 因此，结果应该是 [4,3,2,2]。 示例 3： 输入：digits = [9] 输出：[1,0] 解释：输入数组表示数字 9。 加 1 得到了 9 + 1 = 10。 因此，结果应该是 [1,0]。 提示： * 1 <= digits.length <= 100 * 0 <= digits[i] <= 9 * digits 不包含任何前导 0。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 从右向左遍历，处理进位

算法步骤:
1. 从数组末尾开始，将最后一位加1
2. 如果当前位小于10，直接返回
3. 如果当前位等于10，设为0并继续处理前一位
4. 如果所有位都处理完还有进位，在数组开头插入1

关键点:
- 从右向左处理，模拟加法运算
- 如果最后一位加1后小于10，可以直接返回，避免不必要的操作
- 时间复杂度O(n)，空间复杂度O(1)（不包括结果数组）
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 最坏情况需要遍历整个数组
空间复杂度: O(1) - 只使用常数额外空间（不包括结果数组）
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from leetcode_solutions.utils.solution import create_solution


def plus_one(digits: List[int]) -> List[int]:
    """
    函数式接口 - 从右向左处理进位
    
    实现思路:
    从数组末尾开始，将最后一位加1，处理进位。
    
    Args:
        digits: 表示大整数的整数数组
        
    Returns:
        加1后的数字数组
        
    Example:
        >>> plus_one([1, 2, 3])
        [1, 2, 4]
        >>> plus_one([9])
        [1, 0]
    """
    n = len(digits)
    
    # 从右向左遍历
    for i in range(n - 1, -1, -1):
        digits[i] += 1
        if digits[i] < 10:
            return digits
        digits[i] = 0
    
    # 如果所有位都处理完还有进位，在开头插入1
    return [1] + digits


# 自动生成Solution类（无需手动编写）
Solution = create_solution(plus_one)
