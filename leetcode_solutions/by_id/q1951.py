# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1951
标题: Find the Winner of the Circular Game
难度: medium
链接: https://leetcode.cn/problems/find-the-winner-of-the-circular-game/
题目类型: 递归、队列、数组、数学、模拟
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1823. 找出游戏的获胜者 - 共有 n 名小伙伴一起做游戏。小伙伴们围成一圈，按 顺时针顺序 从 1 到 n 编号。确切地说，从第 i 名小伙伴顺时针移动一位会到达第 (i+1) 名小伙伴的位置，其中 1 <= i < n ，从第 n 名小伙伴顺时针移动一位会回到第 1 名小伙伴的位置。 游戏遵循如下规则： 1. 从第 1 名小伙伴所在位置 开始 。 2. 沿着顺时针方向数 k 名小伙伴，计数时需要 包含 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。 3. 你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。 4. 如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 顺时针下一位 小伙伴 开始，回到步骤 2 继续执行。 5. 否则，圈子中最后一名小伙伴赢得游戏。 给你参与游戏的小伙伴总数 n ，和一个整数 k ，返回游戏的获胜者。 示例 1： [https://assets.leetcode.com/uploads/2021/03/25/ic234-q2-ex11.png] 输入：n = 5, k = 2 输出：3 解释：游戏运行步骤如下： 1) 从小伙伴 1 开始。 2) 递归数 2 名小伙伴，也就是小伙伴 1 和 2 。 3) 小伙伴 2 离开圈子。下一次从小伙伴 3 开始。 4) 递归数 2 名小伙伴，也就是小伙伴 3 和 4 。 5) 小伙伴 4 离开圈子。下一次从小伙伴 5 开始。 6) 递归数 2 名小伙伴，也就是小伙伴 5 和 1 。 7) 小伙伴 1 离开圈子。下一次从小伙伴 3 开始。 8) 递归数 2 名小伙伴，也就是小伙伴 3 和 5 。 9) 小伙伴 5 离开圈子。只剩下小伙伴 3 。所以小伙伴 3 是游戏的获胜者。 示例 2： 输入：n = 6, k = 5 输出：1 解释：小伙伴离开圈子的顺序：5、4、6、2、3 。小伙伴 1 是游戏的获胜者。 提示： * 1 <= k <= n <= 500 进阶：你能否使用线性时间复杂度和常数空间复杂度解决此问题？
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用约瑟夫斯问题的递归解法

算法步骤:
1. 定义递归函数 `find_winner`，输入参数为当前剩余人数 `n` 和步长 `k`。
2. 如果 `n` 为 1，直接返回 0（表示唯一剩下的小伙伴）。
3. 递归调用 `find_winner(n - 1, k)`，得到上一轮的赢家在新编号下的位置。
4. 根据约瑟夫斯问题的公式计算当前轮次的赢家位置 `(find_winner(n - 1, k) + k) % n`。

关键点:
- 使用递归方法，通过约瑟夫斯问题的公式来计算赢家位置。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(1)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def find_the_winner(n: int, k: int) -> int:
    """
    函数式接口 - 返回游戏的获胜者
    """
    def find_winner(n: int, k: int) -> int:
        if n == 1:
            return 0
        return (find_winner(n - 1, k) + k) % n

    # 由于编号从 1 开始，所以最终结果需要加 1
    return find_winner(n, k) + 1


Solution = create_solution(find_the_winner)