# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 9
标题: Palindrome Number
难度: easy
链接: https://leetcode.cn/problems/palindrome-number/
题目类型: 数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
9. 回文数 - 给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 * 例如，121 是回文，而 123 不是。 示例 1： 输入：x = 121 输出：true 示例 2： 输入：x = -121 输出：false 解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3： 输入：x = 10 输出：false 解释：从右向左读, 为 01 。因此它不是一个回文数。 提示： * -231 <= x <= 231 - 1 进阶：你能不将整数转为字符串来解决这个问题吗？
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 反转数字的后半部分，与前半部分比较

算法步骤:
1. 特殊情况：负数不是回文数，个位数为0的正数（除了0）不是回文数
2. 反转数字的后半部分：
   - 每次取x的最后一位：digit = x % 10
   - 将digit添加到reversed_num：reversed_num = reversed_num * 10 + digit
   - x去掉最后一位：x //= 10
3. 当x <= reversed_num时，说明已经反转了一半
4. 比较x和reversed_num（或reversed_num // 10，处理奇数长度）

关键点:
- 只反转一半数字，避免溢出问题
- 对于奇数长度的数字，需要去掉reversed_num的最后一位再比较
- 时间复杂度O(log10(n))，空间复杂度O(1)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(log10(n)) - 需要处理的位数，约为log10(n)
空间复杂度: O(1) - 只使用常数额外空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from leetcode_solutions.utils.solution import create_solution


def is_palindrome(x: int) -> bool:
    """
    函数式接口 - 数学方法实现
    
    实现思路:
    反转数字的后半部分，与前半部分比较，判断是否为回文数。
    
    Args:
        x: 输入的整数
        
    Returns:
        如果是回文数返回True，否则返回False
        
    Example:
        >>> is_palindrome(121)
        True
        >>> is_palindrome(-121)
        False
        >>> is_palindrome(10)
        False
    """
    # 负数不是回文数
    if x < 0:
        return False
    
    # 个位数为0的正数（除了0）不是回文数
    if x != 0 and x % 10 == 0:
        return False
    
    reversed_num = 0
    # 只反转一半数字
    while x > reversed_num:
        reversed_num = reversed_num * 10 + x % 10
        x //= 10
    
    # 对于偶数长度：x == reversed_num
    # 对于奇数长度：x == reversed_num // 10（去掉中间位）
    return x == reversed_num or x == reversed_num // 10


# 自动生成Solution类（无需手动编写）
Solution = create_solution(is_palindrome)
