# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 991
标题: Array of Doubled Pairs
难度: medium
链接: https://leetcode.cn/problems/array-of-doubled-pairs/
题目类型: 贪心、数组、哈希表、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
954. 二倍数对数组 - 给定一个长度为偶数的整数数组 arr，只有对 arr 进行重组后可以满足 “对于每个 0 <= i < len(arr) / 2，都有 arr[2 * i + 1] = 2 * arr[2 * i]” 时，返回 true；否则，返回 false。 示例 1： 输入：arr = [3,1,3,6] 输出：false 示例 2： 输入：arr = [2,1,2,6] 输出：false 示例 3： 输入：arr = [4,-2,2,-4] 输出：true 解释：可以用 [-2,-4] 和 [2,4] 这两组组成 [-2,-4,2,4] 或是 [2,4,-2,-4] 提示： * 0 <= arr.length <= 3 * 104 * arr.length 是偶数 * -105 <= arr[i] <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用哈希表记录每个元素的出现次数，并按绝对值从小到大处理每个元素，确保每个元素及其二倍都能配对。

算法步骤:
1. 统计数组中每个元素的出现次数。
2. 按绝对值从小到大对数组进行排序。
3. 遍历排序后的数组，检查每个元素及其二倍是否都在哈希表中有足够的数量。
4. 如果有，则减少哈希表中对应元素的数量；如果没有，则返回 False。
5. 如果所有元素都能成功配对，则返回 True。

关键点:
- 使用哈希表记录每个元素的出现次数，以便快速查找和更新。
- 按绝对值排序以确保先处理较小的元素，避免遗漏负数的情况。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是数组的长度。排序操作的时间复杂度为 O(n log n)，遍历操作为 O(n)。
空间复杂度: O(n)，用于存储哈希表和排序后的数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def can_reorder_doubled(arr: List[int]) -> bool:
    """
    函数式接口 - 判断给定数组是否可以重组为二倍数对数组
    """
    from collections import Counter

    # 统计每个元素的出现次数
    count = Counter(arr)

    # 按绝对值从小到大排序
    for x in sorted(arr, key=abs):
        if count[x] == 0:
            continue
        if count[2 * x] == 0:
            return False
        count[x] -= 1
        count[2 * x] -= 1

    return True


Solution = create_solution(can_reorder_doubled)