# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3834
标题: Minimum Operations to Convert All Elements to Zero
难度: medium
链接: https://leetcode.cn/problems/minimum-operations-to-convert-all-elements-to-zero/
题目类型: 栈、贪心、数组、哈希表、单调栈
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3542. 将所有元素变为 0 的最少操作次数 - 给你一个大小为 n 的 非负 整数数组 nums 。你的任务是对该数组执行若干次（可能为 0 次）操作，使得 所有 元素都变为 0。 在一次操作中，你可以选择一个子数组 [i, j]（其中 0 <= i <= j < n），将该子数组中所有 最小的非负整数 的设为 0。 返回使整个数组变为 0 所需的最少操作次数。 一个 子数组 是数组中的一段连续元素。 示例 1： 输入: nums = [0,2] 输出: 1 解释: * 选择子数组 [1,1]（即 [2]），其中最小的非负整数是 2。将所有 2 设为 0，结果为 [0,0]。 * 因此，所需的最少操作次数为 1。 示例 2： 输入: nums = [3,1,2,1] 输出: 3 解释: * 选择子数组 [1,3]（即 [1,2,1]），最小非负整数是 1。将所有 1 设为 0，结果为 [3,0,2,0]。 * 选择子数组 [2,2]（即 [2]），将 2 设为 0，结果为 [3,0,0,0]。 * 选择子数组 [0,0]（即 [3]），将 3 设为 0，结果为 [0,0,0,0]。 * 因此，最少操作次数为 3。 示例 3： 输入: nums = [1,2,1,2,1,2] 输出: 4 解释: * 选择子数组 [0,5]（即 [1,2,1,2,1,2]），最小非负整数是 1。将所有 1 设为 0，结果为 [0,2,0,2,0,2]。 * 选择子数组 [1,1]（即 [2]），将 2 设为 0，结果为 [0,0,0,2,0,2]。 * 选择子数组 [3,3]（即 [2]），将 2 设为 0，结果为 [0,0,0,0,0,2]。 * 选择子数组 [5,5]（即 [2]），将 2 设为 0，结果为 [0,0,0,0,0,0]。 * 因此，最少操作次数为 4。 提示: * 1 <= n == nums.length <= 105 * 0 <= nums[i] <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用贪心算法，每次选择当前最小的非零元素进行操作，直到所有元素变为 0。

算法步骤:
1. 初始化一个计数器 `operations` 用于记录操作次数。
2. 使用一个集合 `seen` 来存储已经处理过的元素值。
3. 遍历数组 `nums`，找到当前最小的非零元素 `min_val`。
4. 如果 `min_val` 不在 `seen` 中，则将其加入 `seen` 并增加 `operations` 计数。
5. 将数组中所有等于 `min_val` 的元素设为 0。
6. 重复步骤 3-5，直到所有元素都变为 0。

关键点:
- 通过使用集合 `seen` 来避免对同一个值进行多次操作。
- 每次操作后更新数组，确保下次操作时能找到新的最小非零元素。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是数组的长度。每次找到最小非零元素的操作时间复杂度为 O(n)，最多需要进行 n 次操作。
空间复杂度: O(n)，用于存储 `seen` 集合。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def min_operations_to_zero(nums: List[int]) -> int:
    """
    函数式接口 - 实现最优解法
    """
    operations = 0
    seen = set()
    
    while any(num != 0 for num in nums):
        min_val = float('inf')
        
        # 找到当前最小的非零元素
        for num in nums:
            if num > 0 and num < min_val and num not in seen:
                min_val = num
        
        if min_val == float('inf'):
            break
        
        seen.add(min_val)
        operations += 1
        
        # 将所有等于 min_val 的元素设为 0
        for i in range(len(nums)):
            if nums[i] == min_val:
                nums[i] = 0
    
    return operations

Solution = create_solution(min_operations_to_zero)