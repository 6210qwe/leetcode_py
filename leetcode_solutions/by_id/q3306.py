# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3306
标题: Mark Elements on Array by Performing Queries
难度: medium
链接: https://leetcode.cn/problems/mark-elements-on-array-by-performing-queries/
题目类型: 数组、哈希表、排序、模拟、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3080. 执行操作标记数组中的元素 - 给你一个长度为 n 下标从 0 开始的正整数数组 nums 。 同时给你一个长度为 m 的二维操作数组 queries ，其中 queries[i] = [indexi, ki] 。 一开始，数组中的所有元素都 未标记 。 你需要依次对数组执行 m 次操作，第 i 次操作中，你需要执行： * 如果下标 indexi 对应的元素还没标记，那么标记这个元素。 * 然后标记 ki 个数组中还没有标记的 最小 元素。如果有元素的值相等，那么优先标记它们中下标较小的。如果少于 ki 个未标记元素存在，那么将它们全部标记。 请你返回一个长度为 m 的数组 answer ，其中 answer[i]是第 i 次操作后数组中还没标记元素的 和 。 示例 1： 输入：nums = [1,2,2,1,2,3,1], queries = [[1,2],[3,3],[4,2]] 输出：[8,3,0] 解释： 我们依次对数组做以下操作： * 标记下标为 1 的元素，同时标记 2 个未标记的最小元素。标记完后数组为 nums = [1,2,2,1,2,3,1] 。未标记元素的和为 2 + 2 + 3 + 1 = 8 。 * 标记下标为 3 的元素，由于它已经被标记过了，所以我们忽略这次标记，同时标记最靠前的 3 个未标记的最小元素。标记完后数组为 nums = [1,2,2,1,2,3,1] 。未标记元素的和为 3 。 * 标记下标为 4 的元素，由于它已经被标记过了，所以我们忽略这次标记，同时标记最靠前的 2 个未标记的最小元素。标记完后数组为 nums = [1,2,2,1,2,3,1] 。未标记元素的和为 0 。 示例 2： 输入：nums = [1,4,2,3], queries = [[0,1]] 输出：[7] 解释：我们执行一次操作，将下标为 0 处的元素标记，并且标记最靠前的 1 个未标记的最小元素。标记完后数组为 nums = [1,4,2,3] 。未标记元素的和为 4 + 3 = 7 。 提示： * n == nums.length * m == queries.length * 1 <= m <= n <= 105 * 1 <= nums[i] <= 105 * queries[i].length == 2 * 0 <= indexi, ki <= n - 1
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用一个最小堆来维护未标记的元素，并使用一个集合来记录已标记的元素。

算法步骤:
1. 初始化一个最小堆，将所有元素及其索引存入堆中。
2. 初始化一个集合，用于记录已标记的元素。
3. 对于每个查询，首先检查指定的索引是否已经标记，如果没有标记，则将其标记。
4. 然后从堆中取出最小的 k 个未标记元素并标记它们。
5. 计算当前未标记元素的总和，并将其添加到结果列表中。

关键点:
- 使用最小堆来高效地获取最小的未标记元素。
- 使用集合来快速检查和标记元素。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n + m log n)，其中 n 是 nums 的长度，m 是 queries 的长度。初始化堆的时间复杂度为 O(n log n)，每次查询的时间复杂度为 O(log n)。
空间复杂度: O(n)，用于存储最小堆和已标记元素的集合。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def solution_function_name(nums: List[int], queries: List[List[int]]) -> List[int]:
    """
    函数式接口 - 执行操作标记数组中的元素
    """
    n = len(nums)
    min_heap = [(num, i) for i, num in enumerate(nums)]
    heapq.heapify(min_heap)
    
    marked = set()
    result = []
    unmarked_sum = sum(nums)
    
    for index, k in queries:
        if index not in marked:
            marked.add(index)
            unmarked_sum -= nums[index]
        
        while k > 0 and min_heap:
            num, i = heapq.heappop(min_heap)
            if i not in marked:
                marked.add(i)
                unmarked_sum -= num
                k -= 1
        
        result.append(unmarked_sum)
    
    return result

Solution = create_solution(solution_function_name)