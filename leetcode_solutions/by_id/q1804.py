# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1804
标题: Maximum Binary String After Change
难度: medium
链接: https://leetcode.cn/problems/maximum-binary-string-after-change/
题目类型: 贪心、字符串
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1702. 修改后的最大二进制字符串 - 给你一个二进制字符串 binary ，它仅有 0 或者 1 组成。你可以使用下面的操作任意次对它进行修改： * 操作 1 ：如果二进制串包含子字符串 "00" ，你可以用 "10" 将其替换。 * 比方说， "00010" -> "10010" * 操作 2 ：如果二进制串包含子字符串 "10" ，你可以用 "01" 将其替换。 * 比方说， "00010" -> "00001" 请你返回执行上述操作任意次以后能得到的 最大二进制字符串 。如果二进制字符串 x 对应的十进制数字大于二进制字符串 y 对应的十进制数字，那么我们称二进制字符串 x 大于二进制字符串 y 。 示例 1： 输入：binary = "000110" 输出："111011" 解释：一个可行的转换为： "000110" -> "000101" "000101" -> "100101" "100101" -> "110101" "110101" -> "110011" "110011" -> "111011" 示例 2： 输入：binary = "01" 输出："01" 解释："01" 没办法进行任何转换。 提示： * 1 <= binary.length <= 105 * binary 仅包含 '0' 和 '1' 。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 贪心，尽可能将0移到后面，1移到前面

算法步骤:
1. 统计0的个数
2. 找到第一个0的位置
3. 构造结果：前面全是1，中间一个0，后面全是1

关键点:
- 贪心策略
- 字符串构造
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - n为字符串长度
空间复杂度: O(n) - 新字符串空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def maximum_binary_string(binary: str) -> str:
    """
    函数式接口 - 修改后的最大二进制字符串
    
    实现思路:
    贪心：尽可能将0移到后面，1移到前面。
    
    Args:
        binary: 二进制字符串
        
    Returns:
        最大二进制字符串
        
    Example:
        >>> maximum_binary_string("000110")
        '111011'
    """
    n = len(binary)
    zeros = binary.count('0')
    
    if zeros <= 1:
        return binary
    
    # 找到第一个0的位置
    first_zero = binary.find('0')
    
    # 构造结果：前面全是1，中间一个0，后面全是1
    ones_before = first_zero + zeros - 1
    result = '1' * ones_before + '0' + '1' * (n - ones_before - 1)
    
    return result


Solution = create_solution(maximum_binary_string)
