# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1039
标题: Find the Town Judge
难度: easy
链接: https://leetcode.cn/problems/find-the-town-judge/
题目类型: 图、数组、哈希表
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
997. 找到小镇的法官 - 小镇里有 n 个人，按从 1 到 n 的顺序编号。传言称，这些人中有一个暗地里是小镇法官。 如果小镇法官真的存在，那么： 1. 小镇法官不会信任任何人。 2. 每个人（除了小镇法官）都信任这位小镇法官。 3. 只有一个人同时满足属性 1 和属性 2 。 给你一个数组 trust ，其中 trust[i] = [ai, bi] 表示编号为 ai 的人信任编号为 bi 的人。 如果小镇法官存在并且可以确定他的身份，请返回该法官的编号；否则，返回 -1 。 示例 1： 输入：n = 2, trust = [[1,2]] 输出：2 示例 2： 输入：n = 3, trust = [[1,3],[2,3]] 输出：3 示例 3： 输入：n = 3, trust = [[1,3],[2,3],[3,1]] 输出：-1 提示： * 1 <= n <= 1000 * 0 <= trust.length <= 104 * trust[i].length == 2 * trust 中的所有trust[i] = [ai, bi] 互不相同 * ai != bi * 1 <= ai, bi <= n
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用两个计数器分别记录每个人的信任度和被信任度。

算法步骤:
1. 初始化两个计数器：trusted_count 用于记录每个人的被信任次数，trusting_count 用于记录每个人的信任次数。
2. 遍历 trust 数组，更新 trusted_count 和 trusting_count。
3. 遍历 trusted_count 和 trusting_count，找到被信任次数为 n-1 且信任次数为 0 的人，即为小镇法官。
4. 如果没有找到符合条件的人，返回 -1。

关键点:
- 使用两个计数器来记录每个人的信任关系。
- 小镇法官的条件是被信任次数为 n-1 且信任次数为 0。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n + m)，其中 n 是人数，m 是 trust 数组的长度。
空间复杂度: O(n)，需要两个大小为 n+1 的数组来存储信任关系。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def find_judge(n: int, trust: List[List[int]]) -> int:
    """
    函数式接口 - 找到小镇的法官
    """
    if n == 1:
        return 1

    trusted_count = [0] * (n + 1)
    trusting_count = [0] * (n + 1)

    for a, b in trust:
        trusting_count[a] += 1
        trusted_count[b] += 1

    for i in range(1, n + 1):
        if trusted_count[i] == n - 1 and trusting_count[i] == 0:
            return i

    return -1


Solution = create_solution(find_judge)