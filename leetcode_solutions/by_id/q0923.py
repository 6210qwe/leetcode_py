# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 923
标题: Super Egg Drop
难度: hard
链接: https://leetcode.cn/problems/super-egg-drop/
题目类型: 数学、二分查找、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
887. 鸡蛋掉落 - 给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。 已知存在楼层 f ，满足 0 <= f <= n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。 每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 <= x <= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。 请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？ 示例 1： 输入：k = 1, n = 2 输出：2 解释： 鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。 否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。 如果它没碎，那么肯定能得出 f = 2 。 因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。 示例 2： 输入：k = 2, n = 6 输出：3 示例 3： 输入：k = 3, n = 14 输出：4 提示： * 1 <= k <= 100 * 1 <= n <= 104
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划和二分查找来优化解法。

算法步骤:
1. 定义 dp[k][m] 表示使用 k 个鸡蛋在 m 次操作内最多能确定的楼层数。
2. 初始化 dp 数组，dp[0][m] = 0, dp[k][0] = 0。
3. 对于每个 k 和 m，使用二分查找来找到最优的楼层划分点。
4. 更新 dp[k][m] 为 dp[k-1][x-1] + dp[k][m-x] + 1 的最大值。
5. 当 dp[K][m] >= N 时，返回 m。

关键点:
- 使用二分查找来优化楼层划分点的选择。
- 动态规划的状态转移方程为 dp[k][m] = max(dp[k-1][x-1] + dp[k][m-x] + 1)。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(K * logN)
空间复杂度: O(K * N)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def super_egg_drop(k: int, n: int) -> int:
    """
    函数式接口 - 计算确定 f 确切的值的最小操作次数
    """
    # 初始化 dp 数组
    dp = [[0] * (n + 1) for _ in range(k + 1)]
    
    m = 0
    while dp[k][m] < n:
        m += 1
        for i in range(1, k + 1):
            dp[i][m] = dp[i - 1][m - 1] + dp[i][m - 1] + 1
    
    return m


Solution = create_solution(super_egg_drop)