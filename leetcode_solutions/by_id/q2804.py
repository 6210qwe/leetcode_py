# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2804
标题: Compact Object
难度: medium
链接: https://leetcode.cn/problems/compact-object/
题目类型: 其他
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2705. 精简对象 - 现给定一个对象或数组 obj，返回一个 精简对象 。 精简对象 与原始对象相同，只是将包含 假 值的键移除。该操作适用于对象及其嵌套对象。数组被视为索引作为键的对象。当 Boolean(value) 返回 false 时，值被视为 假 值。 你可以假设 obj 是 JSON.parse 的输出结果。换句话说，它是有效的 JSON。 示例 1： 输入：obj = [null, 0, false, 1] 输出：[1] 解释：数组中的所有假值已被移除。 示例 2： 输入：obj = {"a": null, "b": [false, 1]} 输出：{"b": [1]} 解释：obj["a"] 和 obj["b"][0] 包含假值，因此被移除。 示例 3： 输入：obj = [null, 0, 5, [0], [false, 16]] 输出：[5, [], [16]] 解释：obj[0], obj[1], obj[3][0], 和 obj[4][0] 包含假值，因此被移除。 提示： * obj 是一个有效的 JSON 对象 * 2 <= JSON.stringify(obj).length <= 106
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用递归遍历对象或数组，并移除所有假值。

算法步骤:
1. 定义一个递归函数 `compact` 来处理对象或数组。
2. 如果当前元素是字典，创建一个新的字典，并递归处理每个键值对。
3. 如果当前元素是列表，创建一个新的列表，并递归处理每个元素。
4. 如果当前元素是真值，直接保留。
5. 返回处理后的对象或数组。

关键点:
- 使用递归来处理嵌套结构。
- 通过布尔值判断来移除假值。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是对象中所有元素的数量。
空间复杂度: O(n)，最坏情况下需要存储所有真值。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import Any, Dict, List, Union


def compact_object(obj: Union[Dict, List]) -> Union[Dict, List]:
    """
    函数式接口 - 移除对象或数组中的所有假值
    """
    if isinstance(obj, dict):
        return {k: compact_object(v) for k, v in obj.items() if v or isinstance(v, (dict, list))}
    elif isinstance(obj, list):
        return [compact_object(x) for x in obj if x or isinstance(x, (dict, list))]
    else:
        return obj


Solution = create_solution(compact_object)