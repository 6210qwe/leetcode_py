# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1694
标题: Make Sum Divisible by P
难度: medium
链接: https://leetcode.cn/problems/make-sum-divisible-by-p/
题目类型: 数组、哈希表、前缀和
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1590. 使数组和能被 P 整除 - 给你一个正整数数组 nums，请你移除 最短 子数组（可以为 空），使得剩余元素的 和 能被 p 整除。 不允许 将整个数组都移除。 请你返回你需要移除的最短子数组的长度，如果无法满足题目要求，返回 -1 。 子数组 定义为原数组中连续的一组元素。 示例 1： 输入：nums = [3,1,4,2], p = 6 输出：1 解释：nums 中元素和为 10，不能被 p 整除。我们可以移除子数组 [4] ，剩余元素的和为 6 。 示例 2： 输入：nums = [6,3,5,2], p = 9 输出：2 解释：我们无法移除任何一个元素使得和被 9 整除，最优方案是移除子数组 [5,2] ，剩余元素为 [6,3]，和为 9 。 示例 3： 输入：nums = [1,2,3], p = 3 输出：0 解释：和恰好为 6 ，已经能被 3 整除了。所以我们不需要移除任何元素。 示例 4： 输入：nums = [1,2,3], p = 7 输出：-1 解释：没有任何方案使得移除子数组后剩余元素的和被 7 整除。 示例 5： 输入：nums = [1000000000,1000000000,1000000000], p = 3 输出：0 提示： * 1 <= nums.length <= 105 * 1 <= nums[i] <= 109 * 1 <= p <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用前缀和与哈希表来找到最短的子数组，使得剩余元素的和能被 p 整除。

算法步骤:
1. 计算数组的总和，并计算其对 p 的余数。
2. 如果总和已经能被 p 整除，直接返回 0。
3. 使用哈希表记录前缀和对 p 的余数及其对应的索引。
4. 遍历数组，计算当前前缀和对 p 的余数。
5. 检查是否存在一个前缀和，使得当前前缀和减去该前缀和的差值等于目标余数。
6. 更新最短子数组的长度。
7. 如果没有找到合适的子数组，返回 -1。

关键点:
- 使用哈希表记录前缀和对 p 的余数及其对应的索引，以便快速查找。
- 通过前缀和的差值来判断是否可以移除某个子数组。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(p)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def solution_function_name(nums: List[int], p: int) -> int:
    total_sum = sum(nums)
    target_remainder = total_sum % p
    if target_remainder == 0:
        return 0

    prefix_sum = 0
    min_length = float('inf')
    seen = {0: -1}
    
    for i, num in enumerate(nums):
        prefix_sum += num
        current_remainder = prefix_sum % p
        needed_remainder = (current_remainder - target_remainder + p) % p
        
        if needed_remainder in seen:
            min_length = min(min_length, i - seen[needed_remainder])
        
        seen[current_remainder] = i
    
    return min_length if min_length != float('inf') else -1

Solution = create_solution(solution_function_name)