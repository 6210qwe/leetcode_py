# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 366
标题: Find Leaves of Binary Tree
难度: medium
链接: https://leetcode.cn/problems/find-leaves-of-binary-tree/
题目类型: 树、深度优先搜索、二叉树
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
366. 寻找二叉树的叶子节点 - 备战技术面试？力扣提供海量技术面试资源，帮助你高效提升编程技能,轻松拿下世界 IT 名企 Dream Offer。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 将“每轮删除叶子”视为“按节点高度从低到高分组”。

算法步骤:
1. 使用 DFS 递归函数返回每个节点的高度：叶子节点高度为 0，非叶子高度为 `max(左子高度, 右子高度) + 1`。
2. 使用数组 `res`，下标表示高度；在 DFS 中得到当前节点高度 h 后，将节点值加入 `res[h]` 中，如果 `res` 长度不够则先扩容。
3. DFS 完成后，`res[0]` 就是一轮删除的所有叶子节点，`res[1]` 是第二轮删除的所有节点，以此类推。

关键点:
- 高度的定义刚好对应“被删除的轮次”。
- 只需一次 DFS 即可获得所有分组，无需显式模拟每轮删除。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，n 为节点数，每个节点访问一次。
空间复杂度: O(h)，h 为树高，用于递归栈和结果存储。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def find_leaves_of_binary_tree(root: Optional[TreeNode]) -> List[List[int]]:
    """
    分层收集每一轮移除叶子节点的值，等价于按节点高度分组。

    使用 DFS 计算每个节点的高度（叶子高度为 0），把节点值放入对应高度的桶。
    """
    res: List[List[int]] = []

    def dfs(node: Optional[TreeNode]) -> int:
        if not node:
            return -1  # 便于叶子高度为 0
        lh = dfs(node.left)
        rh = dfs(node.right)
        h = max(lh, rh) + 1
        if h == len(res):
            res.append([])
        res[h].append(node.val)
        return h

    dfs(root)
    return res


# 自动生成Solution类（无需手动编写）
Solution = create_solution(find_leaves_of_binary_tree)
