# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000435
标题: 二叉搜索树染色
难度: medium
链接: https://leetcode.cn/problems/QO5KpG/
题目类型: 树、线段树、二叉搜索树、数组、二分查找、二叉树、有序集合
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCP 52. 二叉搜索树染色 - 欢迎各位勇者来到力扣城，本次试炼主题为「二叉搜索树染色」。 每位勇士面前设有一个**二叉搜索树**的模型，模型的根节点为 `root`，树上的各个节点值均不重复。初始时，所有节点均为蓝色。现在按顺序对这棵二叉树进行若干次操作， `ops[i] = [type, x, y]` 表示第 `i` 次操作为： + `type` 等于 0 时，将节点值范围在 `[x, y]` 的节点均染蓝 + `type` 等于 1 时，将节点值范围在 `[x, y]` 的节点均染红 请返回完成所有染色后，该二叉树中红色节点的数量。 **注意：** + 题目保证对于每个操作的 `x`、`y` 值定出现在二叉搜索树节点中 **示例 1：** >输入：`root = [1,null,2,null,3,null,4,null,5], ops = [[1,2,4],[1,1,3],[0,3,5]]` > >输出：`2` > >解释： >第 0 次操作，将值为 2、3、4 的节点染红； >第 1 次操作，将值为 1、2、3 的节点染红； >第 2 次操作，将值为 3、4、5 的节点染蓝； >因此，最终值为 1、2 的节点为红色节点，返回数量 2 ![image.png](https://pic.leetcode.cn/1649833948-arSlXd-image.png){:width=230px} **示例 2：** >输入：`root = [4,2,7,1,null,5,null,null,null,null,6]` >`ops = [[0,2,2],[1,1,5],[0,4,5],[1,5,7]]` > >输出：`5` > >解释： >第 0 次操作，将值为 2 的节点染蓝； >第 1 次操作，将值为 1、2、4、5 的节点染红； >第 2 次操作，将值为 4、5 的节点染蓝； >第 3 次操作，将值为 5、6、7 的节点染红； >因此，最终值为 1、2、5、6、7 的节点为红色节点，返回数量 5 ![image.png](https://pic.leetcode.cn/1649833763-BljEbP-image.png){:width=230px} **提示：** + `1 <= 二叉树节点数量 <= 10^5` + `1 <= ops.length <= 10^5` + `ops[i].length == 3` + `ops[i][0]` 仅为 `0` or `1` + `0 <= ops[i][1] <= ops[i][2] <= 10^9` + `0 <= 节点值 <= 10^9`
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 收集所有节点值，按操作顺序更新颜色状态

算法步骤:
1. 中序遍历BST收集所有节点值
2. 对每个操作，更新对应范围内的节点颜色
3. 最后统计红色节点数量

关键点:
- 中序遍历BST得到有序序列
- 使用集合或数组记录颜色状态
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n + m*k) - n为节点数，m为操作数，k为每次操作的节点数
空间复杂度: O(n) - 存储节点值
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def get_number(root: Optional[TreeNode], ops: List[List[int]]) -> int:
    """
    函数式接口 - 二叉搜索树染色
    
    实现思路:
    收集所有节点值，按操作顺序更新颜色状态。
    
    Args:
        root: BST根节点
        ops: 操作数组
        
    Returns:
        红色节点数量
        
    Example:
        >>> root = TreeNode(1)
        >>> root.right = TreeNode(2)
        >>> get_number(root, [[1,2,4],[1,1,3],[0,3,5]])
        2
    """
    # 中序遍历收集所有节点值
    nodes = []
    
    def inorder(node: Optional[TreeNode]):
        if not node:
            return
        inorder(node.left)
        nodes.append(node.val)
        inorder(node.right)
    
    inorder(root)
    
    # 记录每个节点的颜色：True表示红色，False表示蓝色
    color_map = {val: False for val in nodes}
    
    # 执行所有操作
    for op_type, x, y in ops:
        for val in nodes:
            if x <= val <= y:
                color_map[val] = (op_type == 1)
    
    # 统计红色节点数量
    return sum(1 for val in nodes if color_map[val])


Solution = create_solution(get_number)
