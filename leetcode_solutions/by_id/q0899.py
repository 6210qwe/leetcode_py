# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 899
标题: Binary Gap
难度: easy
链接: https://leetcode.cn/problems/binary-gap/
题目类型: 位运算
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
868. 二进制间距 - 给定一个正整数 n，找到并返回 n 的二进制表示中两个 相邻 1 之间的 最长距离 。如果不存在两个相邻的 1，返回 0 。 如果只有 0 将两个 1 分隔开（可能不存在 0 ），则认为这两个 1 彼此 相邻 。两个 1 之间的距离是它们的二进制表示中位置的绝对差。例如，"1001" 中的两个 1 的距离为 3 。 示例 1： 输入：n = 22 输出：2 解释：22 的二进制是 "10110" 。 在 22 的二进制表示中，有三个 1，组成两对相邻的 1 。 第一对相邻的 1 中，两个 1 之间的距离为 2 。 第二对相邻的 1 中，两个 1 之间的距离为 1 。 答案取两个距离之中最大的，也就是 2 。 示例 2： 输入：n = 8 输出：0 解释：8 的二进制是 "1000" 。 在 8 的二进制表示中没有相邻的两个 1，所以返回 0 。 示例 3： 输入：n = 5 输出：2 解释：5 的二进制是 "101" 。 提示： * 1 <= n <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过位运算找到二进制表示中的所有 1，并计算相邻 1 之间的最大距离。

算法步骤:
1. 初始化变量 `last` 用于记录上一个 1 的位置，`max_gap` 用于记录最大距离。
2. 遍历 n 的每一位，使用位运算找到每一个 1。
3. 计算当前 1 和上一个 1 之间的距离，并更新 `max_gap`。
4. 更新 `last` 为当前 1 的位置。
5. 返回 `max_gap`。

关键点:
- 使用位运算高效地找到每一个 1。
- 通过记录上一个 1 的位置来计算相邻 1 之间的距离。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(log n) - 因为我们在遍历 n 的每一位，最坏情况下需要遍历 log(n) 位。
空间复杂度: O(1) - 只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def binary_gap(n: int) -> int:
    """
    函数式接口 - 找到并返回 n 的二进制表示中两个相邻 1 之间的最长距离。
    """
    last = -1  # 上一个 1 的位置
    max_gap = 0  # 最大距离
    index = 0  # 当前位的位置

    while n > 0:
        if n & 1 == 1:  # 检查当前位是否为 1
            if last != -1:
                max_gap = max(max_gap, index - last)  # 更新最大距离
            last = index  # 更新上一个 1 的位置
        n >>= 1  # 右移一位
        index += 1  # 位置加一

    return max_gap


Solution = create_solution(binary_gap)