# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3705
标题: Find the Largest Almost Missing Integer
难度: easy
链接: https://leetcode.cn/problems/find-the-largest-almost-missing-integer/
题目类型: 数组、哈希表
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3471. 找出最大的几近缺失整数 - 给你一个整数数组 nums 和一个整数 k 。 如果整数 x 恰好仅出现在 nums 中的一个大小为 k 的子数组中，则认为 x 是 nums 中的几近缺失（almost missing）整数。 返回 nums 中 最大的几近缺失 整数，如果不存在这样的整数，返回 -1 。 子数组 是数组中的一个连续元素序列。 示例 1： 输入：nums = [3,9,2,1,7], k = 3 输出：7 解释： * 1 出现在两个大小为 3 的子数组中：[9, 2, 1]、[2, 1, 7] * 2 出现在三个大小为 3 的子数组中：[3, 9, 2]、[9, 2, 1]、[2, 1, 7] * 3 出现在一个大小为 3 的子数组中：[3, 9, 2] * 7 出现在一个大小为 3 的子数组中：[2, 1, 7] * 9 出现在两个大小为 3 的子数组中：[3, 9, 2]、[9, 2, 1] 返回 7 ，因为它满足题意的所有整数中最大的那个。 示例 2： 输入：nums = [3,9,7,2,1,7], k = 4 输出：3 解释： * 1 出现在两个大小为 4 的子数组中：[9, 7, 2, 1]、[7, 2, 1, 7] * 2 出现在三个大小为 4 的子数组中：[3, 9, 7, 2]、[9, 7, 2, 1]、[7, 2, 1, 7] * 3 出现在一个大小为 4 的子数组中：[3, 9, 7, 2] * 7 出现在三个大小为 4 的子数组中：[3, 9, 7, 2]、[9, 7, 2, 1]、[7, 2, 1, 7] * 9 出现在两个大小为 4 的子数组中：[3, 9, 7, 2]、[9, 7, 2, 1] 返回 3 ，因为它满足题意的所有整数中最大的那个。 示例 3： 输入：nums = [0,0], k = 1 输出：-1 解释： 不存在满足题意的整数。 提示： * 1 <= nums.length <= 50 * 0 <= nums[i] <= 50 * 1 <= k <= nums.length
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用滑动窗口和计数器来统计每个元素在所有大小为 k 的子数组中的出现次数。

算法步骤:
1. 初始化一个计数器 `count` 来记录每个元素在当前窗口中的出现次数。
2. 使用滑动窗口遍历数组，维护一个大小为 k 的窗口，并更新计数器。
3. 对于每个窗口，检查计数器中的元素是否只出现一次，并记录这些元素的最大值。
4. 返回最大值，如果没有找到符合条件的元素则返回 -1。

关键点:
- 使用滑动窗口和计数器来高效统计每个元素在所有大小为 k 的子数组中的出现次数。
- 只关注出现次数为 1 的元素，并记录其中的最大值。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是数组的长度。滑动窗口遍历数组的时间复杂度为 O(n)。
空间复杂度: O(k)，其中 k 是窗口的大小。计数器的空间复杂度为 O(k)。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def find_largest_almost_missing_integer(nums: List[int], k: int) -> int:
    """
    函数式接口 - 找出最大的几近缺失整数
    """
    from collections import Counter

    if len(nums) < k:
        return -1

    # 初始化计数器
    count = Counter()
    max_val = -1

    # 初始化第一个窗口
    for i in range(k):
        count[nums[i]] += 1

    # 检查第一个窗口
    for num, freq in count.items():
        if freq == 1:
            max_val = max(max_val, num)

    # 滑动窗口
    for i in range(k, len(nums)):
        # 移除窗口左侧元素
        count[nums[i - k]] -= 1
        if count[nums[i - k]] == 0:
            del count[nums[i - k]]

        # 添加窗口右侧元素
        count[nums[i]] += 1

        # 检查当前窗口
        for num, freq in count.items():
            if freq == 1:
                max_val = max(max_val, num)

    return max_val


Solution = create_solution(find_largest_almost_missing_integer)