# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 100183
标题: Closed Number LCCI
难度: medium
链接: https://leetcode.cn/problems/closed-number-lcci/
题目类型: 位运算
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
面试题 05.04. 下一个数 - 下一个数。给定一个正整数，找出与其二进制表达式中1的个数相同且大小最接近的那两个数（一个略大，一个略小）。 示例 1： 输入：num = 2（或者0b10） 输出：[4, 1] 或者（[0b100, 0b1]） 示例 2： 输入：num = 1 输出：[2, -1] 提示： 1. num 的范围在[1, 2147483647]之间； 2. 如果找不到前一个或者后一个满足条件的正数，那么输出 -1。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过位运算找到与给定数字二进制表示中1的个数相同且大小最接近的两个数。

算法步骤:
1. 找到比给定数字大的下一个数：
   - 从右向左找到第一个1后面跟着0的位置，交换这两个位，并将右侧的所有1移到最右边。
2. 找到比给定数字小的上一个数：
   - 从右向左找到第一个0后面跟着1的位置，交换这两个位，并将右侧的所有1移到最右边。
3. 返回这两个数。

关键点:
- 通过位运算高效地找到需要交换的位。
- 确保交换后的数是合法的32位整数。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(1) - 位运算的时间复杂度是常数级别的。
空间复杂度: O(1) - 只使用了常数级别的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def find_closed_numbers(num: int) -> List[int]:
    """
    找到与给定数字二进制表示中1的个数相同且大小最接近的两个数。
    """
    def get_next(num: int) -> int:
        c = num
        c0 = 0
        c1 = 0
        while (c & 1) == 0 and c != 0:
            c0 += 1
            c >>= 1
        while (c & 1) == 1:
            c1 += 1
            c >>= 1
        if c0 + c1 == 31 or c0 + c1 == 0:
            return -1
        p = c0 + c1
        num |= (1 << p)
        num &= ~((1 << p) - 1)
        num |= (1 << (c1 - 1)) - 1
        return num

    def get_prev(num: int) -> int:
        c = num
        c0 = 0
        c1 = 0
        while (c & 1) == 1:
            c1 += 1
            c >>= 1
        if c == 0:
            return -1
        while (c & 1) == 0 and c != 0:
            c0 += 1
            c >>= 1
        p = c0 + c1
        num &= (~0 << (p + 1))
        mask = (1 << (c1 + 1)) - 1
        num |= mask << (c0 - 1)
        return num

    next_num = get_next(num)
    prev_num = get_prev(num)
    return [next_num, prev_num]


Solution = create_solution(find_closed_numbers)