# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2035
标题: Count Sub Islands
难度: medium
链接: https://leetcode.cn/problems/count-sub-islands/
题目类型: 深度优先搜索、广度优先搜索、并查集、数组、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1905. 统计子岛屿 - 给你两个 m x n 的二进制矩阵 grid1 和 grid2 ，它们只包含 0 （表示水域）和 1 （表示陆地）。一个 岛屿 是由 四个方向 （水平或者竖直）上相邻的 1 组成的区域。任何矩阵以外的区域都视为水域。 如果 grid2 的一个岛屿，被 grid1 的一个岛屿 完全 包含，也就是说 grid2 中该岛屿的每一个格子都被 grid1 中同一个岛屿完全包含，那么我们称 grid2 中的这个岛屿为 子岛屿 。 请你返回 grid2 中 子岛屿 的 数目 。 示例 1： [https://assets.leetcode.com/uploads/2021/06/10/test1.png] 输入：grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]] 输出：3 解释：如上图所示，左边为 grid1 ，右边为 grid2 。 grid2 中标红的 1 区域是子岛屿，总共有 3 个子岛屿。 示例 2： [https://assets.leetcode.com/uploads/2021/06/03/testcasex2.png] 输入：grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]] 输出：2 解释：如上图所示，左边为 grid1 ，右边为 grid2 。 grid2 中标红的 1 区域是子岛屿，总共有 2 个子岛屿。 提示： * m == grid1.length == grid2.length * n == grid1[i].length == grid2[i].length * 1 <= m, n <= 500 * grid1[i][j] 和 grid2[i][j] 都要么是 0 要么是 1 。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用深度优先搜索 (DFS) 来遍历 grid2 中的每个岛屿，并检查这些岛屿是否完全包含在 grid1 中。

算法步骤:
1. 遍历 grid2 中的每个单元格，如果遇到 1，则开始 DFS。
2. 在 DFS 过程中，标记访问过的单元格，并检查这些单元格在 grid1 中是否也是 1。
3. 如果所有访问过的单元格在 grid1 中都是 1，则该岛屿是一个子岛屿。
4. 重复上述步骤直到遍历完 grid2。

关键点:
- 使用 DFS 来遍历岛屿。
- 通过标记访问过的单元格来避免重复访问。
- 检查 grid2 中的岛屿是否完全包含在 grid1 中。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m * n)，其中 m 和 n 分别是 grid1 和 grid2 的行数和列数。每个单元格最多访问一次。
空间复杂度: O(m * n)，递归调用栈的深度最坏情况下为 m * n。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def count_sub_islands(grid1: List[List[int]], grid2: List[List[int]]) -> int:
    def dfs(r: int, c: int) -> bool:
        if r < 0 or r >= len(grid2) or c < 0 or c >= len(grid2[0]) or grid2[r][c] == 0:
            return True
        grid2[r][c] = 0  # Mark as visited
        is_sub_island = grid1[r][c] == 1
        for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
            is_sub_island &= dfs(r + dr, c + dc)
        return is_sub_island

    sub_islands = 0
    for r in range(len(grid2)):
        for c in range(len(grid2[0])):
            if grid2[r][c] == 1 and dfs(r, c):
                sub_islands += 1
    return sub_islands

Solution = create_solution(count_sub_islands)