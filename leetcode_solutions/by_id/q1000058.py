# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000058
标题: 魔术排列
难度: medium
链接: https://leetcode.cn/problems/er94lq/
题目类型: 队列、数组、模拟
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCP 23. 魔术排列 - 秋日市集上，魔术师邀请小扣与他互动。魔术师的道具为分别写有数字 `1~N` 的 `N` 张卡牌，然后请小扣思考一个 `N` 张卡牌的排列 `target`。 魔术师的目标是找到一个数字 k（k >= 1），使得初始排列顺序为 `1~N` 的卡牌经过特殊的洗牌方式最终变成小扣所想的排列 `target`，特殊的洗牌方式为： - 第一步，魔术师将当前位于 **偶数位置** 的卡牌（下标自 1 开始），保持 **当前排列顺序** 放在位于 **奇数位置** 的卡牌之前。例如：将当前排列 [1,2,3,4,5] 位于偶数位置的 [2,4] 置于奇数位置的 [1,3,5] 前，排列变为 [2,4,1,3,5]； - 第二步，若当前卡牌数量小于等于 `k`，则魔术师按排列顺序取走全部卡牌；若当前卡牌数量大于 `k`，则取走前 `k` 张卡牌，剩余卡牌继续重复这两个步骤，直至所有卡牌全部被取走； 卡牌按照魔术师取走顺序构成的新排列为「魔术取数排列」，请返回是否存在这个数字 k 使得「魔术取数排列」恰好就是 `target`，从而让小扣感到大吃一惊。 **示例 1：** >输入：`target = [2,4,3,1,5]` > >输出：`true` > >解释：排列 target 长度为 5，初始排列为：1,2,3,4,5。我们选择 k = 2： >第一次：将当前排列 [1,2,3,4,5] 位于偶数位置的 [2,4] 置于奇数位置的 [1,3,5] 前，排列变为 [2,4,1,3,5]。取走前 2 张卡牌 2,4，剩余 [1,3,5]； >第二次：将当前排列 [1,3,5] 位于偶数位置的 [3] 置于奇数位置的 [1,5] 前，排列变为 [3,1,5]。取走前 2 张 3,1，剩余 [5]； >第三次：当前排列为 [5]，全部取出。 >最后，数字按照取出顺序构成的「魔术取数排列」2,4,3,1,5 恰好为 target。 **示例 2：** >输入：`target = [5,4,3,2,1]` > >输出：`false` > >解释：无法找到一个数字 k 可以使「魔术取数排列」恰好为 target。 **提示：** - `1 <= target.length = N <= 5000` - 题目保证 `target` 是 `1~N` 的一个排列。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过模拟洗牌和取牌过程，检查是否存在一个 k 使得「魔术取数排列」恰好为 target。

算法步骤:
1. 初始化一个从 1 到 N 的排列 cards。
2. 对于每个可能的 k 值 (从 1 到 N)，模拟洗牌和取牌过程。
3. 在每次洗牌后，检查取出的前 k 张卡牌是否与 target 的前 k 张卡牌匹配。
4. 如果匹配，则继续处理剩余的卡牌；否则，尝试下一个 k 值。
5. 如果存在一个 k 使得最终结果与 target 匹配，则返回 True；否则，返回 False。

关键点:
- 模拟洗牌和取牌过程时，需要正确处理偶数位置和奇数位置的卡牌。
- 通过逐步检查每个 k 值，确保找到满足条件的 k。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(N^2)
空间复杂度: O(N)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def is_magic_permutation(target: List[int]) -> bool:
    n = len(target)
    for k in range(1, n + 1):
        cards = list(range(1, n + 1))
        result = []
        while cards:
            # 洗牌
            even_cards = cards[1::2]
            odd_cards = cards[0::2]
            cards = even_cards + odd_cards
            # 取牌
            if len(cards) <= k:
                result.extend(cards)
                break
            else:
                result.extend(cards[:k])
                cards = cards[k:]
        if result == target:
            return True
    return False

Solution = create_solution(is_magic_permutation)