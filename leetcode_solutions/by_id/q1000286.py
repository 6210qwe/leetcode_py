# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000286
标题: 三角形最小路径和
难度: medium
链接: https://leetcode.cn/problems/IlPe0q/
题目类型: 数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCR 100. 三角形最小路径和 - 给定一个三角形 triangle ，找出自顶向下的最小路径和。 每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。 示例 1： 输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]] 输出：11 解释：如下面简图所示： 2 3 4 6 5 7 4 1 8 3 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 示例 2： 输入：triangle = [[-10]] 输出：-10 提示： * 1 <= triangle.length <= 200 * triangle[0].length == 1 * triangle[i].length == triangle[i - 1].length + 1 * -104 <= triangle[i][j] <= 104 进阶： * 你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题吗？ 注意：本题与主站 120 题相同： https://leetcode.cn/problems/triangle/ [https://leetcode.cn/problems/triangle/]
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划，从底向上计算每个位置的最小路径和。

算法步骤:
1. 初始化一个长度为 n 的数组 dp，其中 n 是三角形的行数。
2. 将 dp 数组初始化为三角形最后一行的值。
3. 从倒数第二行开始，逐行向上更新 dp 数组：
   - 对于每个位置 (i, j)，更新 dp[j] 为当前值加上 dp[j] 和 dp[j+1] 中的较小值。
4. 最终 dp[0] 即为自顶向下的最小路径和。

关键点:
- 从底向上计算，避免了重复计算。
- 只使用 O(n) 的额外空间。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2)，其中 n 是三角形的行数。需要遍历整个三角形。
空间复杂度: O(n)，只使用了一个长度为 n 的 dp 数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def minimum_total(triangle: List[List[int]]) -> int:
    """
    函数式接口 - 计算三角形的最小路径和
    """
    n = len(triangle)
    if n == 0:
        return 0

    # 初始化 dp 数组为三角形最后一行的值
    dp = triangle[-1]

    # 从倒数第二行开始，逐行向上更新 dp 数组
    for i in range(n - 2, -1, -1):
        for j in range(i + 1):
            dp[j] = triangle[i][j] + min(dp[j], dp[j + 1])

    # 最终 dp[0] 即为自顶向下的最小路径和
    return dp[0]


Solution = create_solution(minimum_total)