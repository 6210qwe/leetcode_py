# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2610
标题: Closest Prime Numbers in Range
难度: medium
链接: https://leetcode.cn/problems/closest-prime-numbers-in-range/
题目类型: 数学、数论
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2523. 范围内最接近的两个质数 - 给你两个正整数 left 和 right ，请你找到两个整数 num1 和 num2 ，它们满足： * left <= nums1 < nums2 <= right 。 * nums1 和 nums2 都是 质数 。 * nums2 - nums1 是满足上述条件的质数对中的 最小值 。 请你返回正整数数组 ans = [nums1, nums2] 。如果有多个整数对满足上述条件，请你返回 nums1 最小的质数对。如果不存在符合题意的质数对，请你返回 [-1, -1] 。 示例 1： 输入：left = 10, right = 19 输出：[11,13] 解释：10 到 19 之间的质数为 11 ，13 ，17 和 19 。 质数对的最小差值是 2 ，[11,13] 和 [17,19] 都可以得到最小差值。 由于 11 比 17 小，我们返回第一个质数对。 示例 2： 输入：left = 4, right = 6 输出：[-1,-1] 解释：给定范围内只有一个质数，所以题目条件无法被满足。 提示： * 1 <= left <= right <= 106
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用埃拉托斯特尼筛法（Sieve of Eratosthenes）来生成质数列表，然后在该列表中找到最接近的两个质数。

算法步骤:
1. 使用埃拉托斯特尼筛法生成从 2 到 right 的所有质数。
2. 遍历生成的质数列表，找到在 [left, right] 范围内的质数。
3. 在这些质数中找到差值最小的两个质数对。

关键点:
- 使用埃拉托斯特尼筛法高效生成质数列表。
- 通过遍历找到最接近的两个质数。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log log n)，其中 n 是 right 的大小。埃拉托斯特尼筛法的时间复杂度为 O(n log log n)。
空间复杂度: O(n)，需要存储从 2 到 right 的所有质数。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def is_prime(n: int) -> bool:
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def closest_primes(left: int, right: int) -> List[int]:
    primes = []
    for num in range(max(2, left), right + 1):
        if is_prime(num):
            primes.append(num)
    
    if len(primes) < 2:
        return [-1, -1]
    
    min_diff = float('inf')
    result = [-1, -1]
    
    for i in range(len(primes) - 1):
        diff = primes[i + 1] - primes[i]
        if diff < min_diff:
            min_diff = diff
            result = [primes[i], primes[i + 1]]
    
    return result

Solution = create_solution(closest_primes)