# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3826
标题: Maximum Profit from Valid Topological Order in DAG
难度: hard
链接: https://leetcode.cn/problems/maximum-profit-from-valid-topological-order-in-dag/
题目类型: 位运算、图、拓扑排序、数组、动态规划、状态压缩
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3530. 有向无环图中合法拓扑排序的最大利润 - 给你一个由 n 个节点组成的有向无环图（DAG），节点编号从 0 到 n - 1，通过二维数组 edges 表示，其中 edges[i] = [ui, vi] 表示一条从节点 ui 指向节点 vi 的有向边。每个节点都有一个对应的 得分 ，由数组 score 给出，其中 score[i] 表示节点 i 的得分。 你需要以 有效的拓扑排序 顺序处理这些节点。每个节点在处理顺序中被分配一个编号从 1 开始的位置。 将每个节点的得分乘以其在拓扑排序中的位置，然后求和，得到的值称为 利润。 请返回在所有合法拓扑排序中可获得的 最大利润 。 拓扑排序 是一个对 DAG 中所有节点的线性排序，使得每条有向边 u → v 中，节点 u 都出现在 v 之前。 示例 1： 输入： n = 2, edges = [[0,1]], score = [2,3] 输出： 8 解释： [https://pic.leetcode.cn/1745660258-BXXGjv-screenshot-2025-03-11-at-021131.png] 节点 1 依赖于节点 0，因此一个合法顺序是 [0, 1]。 节点 处理顺序 得分 乘数 利润计算 0 第 1 个 2 1 2 × 1 = 2 1 第 2 个 3 2 3 × 2 = 6 所有合法拓扑排序中可获得的最大总利润是 2 + 6 = 8。 示例 2： 输入： n = 3, edges = [[0,1],[0,2]], score = [1,6,3] 输出： 25 解释： [https://pic.leetcode.cn/1745660268-mJrEKY-screenshot-2025-03-11-at-023558.png] 节点 1 和 2 都依赖于节点 0，因此最优的合法顺序是 [0, 2, 1]。 节点 处理顺序 得分 乘数 利润计算 0 第 1 个 1 1 1 × 1 = 1 2 第 2 个 3 2 3 × 2 = 6 1 第 3 个 6 3 6 × 3 = 18 所有合法拓扑排序中可获得的最大总利润是 1 + 6 + 18 = 25。 提示： * 1 <= n == score.length <= 22 * 1 <= score[i] <= 105 * 0 <= edges.length <= n * (n - 1) / 2 * edges[i] == [ui, vi] 表示一条从 ui 到 vi 的有向边。 * 0 <= ui, vi < n * ui != vi * 输入图 保证 是一个 DAG。 * 不存在重复的边。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划和状态压缩来解决这个问题。我们使用一个整数来表示当前的状态，每一位表示一个节点是否已经被处理。对于每个状态，我们尝试处理每一个可以处理的节点，并更新最大利润。

算法步骤:
1. 初始化一个 DP 数组 dp，其中 dp[mask] 表示状态 mask 下的最大利润。
2. 枚举所有可能的状态 mask。
3. 对于每个状态 mask，枚举每一个可以处理的节点 i。
4. 更新 dp[mask] 为 dp[mask ^ (1 << i)] + (score[i] * (popcount(mask) + 1)) 的最大值。
5. 返回 dp[(1 << n) - 1]，即所有节点都被处理后的最大利润。

关键点:
- 使用状态压缩来表示当前的状态。
- 使用 popcount 函数来计算当前状态中已经处理的节点数量。
- 动态规划转移方程为 dp[mask] = max(dp[mask], dp[mask ^ (1 << i)] + (score[i] * (popcount(mask) + 1)))。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(2^n * n)，其中 n 是节点的数量。我们需要枚举所有可能的状态（2^n 个），并且对于每个状态需要枚举所有的节点（n 个）。
空间复杂度: O(2^n)，用于存储 DP 数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import functools

def solution_function_name(n: int, edges: List[List[int]], score: List[int]) -> int:
    """
    函数式接口 - 计算有向无环图中合法拓扑排序的最大利润
    """
    # 构建入度数组
    indegree = [0] * n
    for u, v in edges:
        indegree[v] += 1

    @functools.lru_cache(None)
    def dp(mask: int, k: int) -> int:
        if k == 0:
            return 0
        max_profit = 0
        for i in range(n):
            if (mask & (1 << i)) == 0 and indegree[i] == 0:
                new_mask = mask | (1 << i)
                profit = score[i] * k + dp(new_mask, k - 1)
                max_profit = max(max_profit, profit)
        return max_profit

    all_nodes = (1 << n) - 1
    return dp(all_nodes, n)

Solution = create_solution(solution_function_name)