# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3414
标题: Find Number of Ways to Reach the K-th Stair
难度: hard
链接: https://leetcode.cn/problems/find-number-of-ways-to-reach-the-k-th-stair/
题目类型: 位运算、记忆化搜索、数学、动态规划、组合数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3154. 到达第 K 级台阶的方案数 - 给你有一个 非负 整数 k 。有一个无限长度的台阶，最低 一层编号为 0 。 Alice 有一个整数 jump ，一开始值为 0 。Alice 从台阶 1 开始，可以使用 任意 次操作，目标是到达第 k 级台阶。假设 Alice 位于台阶 i ，一次 操作 中，Alice 可以： * 向下走一级到 i - 1 ，但该操作 不能 连续使用，如果在台阶第 0 级也不能使用。 * 向上走到台阶 i + 2jump 处，然后 jump 变为 jump + 1 。 请你返回 Alice 到达台阶 k 处的总方案数。 注意，Alice 可能到达台阶 k 处后，通过一些操作重新回到台阶 k 处，这视为不同的方案。 示例 1： 输入：k = 0 输出：2 解释： 2 种到达台阶 0 的方案为： * Alice 从台阶 1 开始。 * 执行第一种操作，从台阶 1 向下走到台阶 0 。 * Alice 从台阶 1 开始。 * 执行第一种操作，从台阶 1 向下走到台阶 0 。 * 执行第二种操作，向上走 20 级台阶到台阶 1 。 * 执行第一种操作，从台阶 1 向下走到台阶 0 。 示例 2： 输入：k = 1 输出：4 解释： 4 种到达台阶 1 的方案为： * Alice 从台阶 1 开始，已经到达台阶 1 。 * Alice 从台阶 1 开始。 * 执行第一种操作，从台阶 1 向下走到台阶 0 。 * 执行第二种操作，向上走 20 级台阶到台阶 1 。 * Alice 从台阶 1 开始。 * 执行第二种操作，向上走 20 级台阶到台阶 2 。 * 执行第一种操作，向下走 1 级台阶到台阶 1 。 * Alice 从台阶 1 开始。 * 执行第一种操作，从台阶 1 向下走到台阶 0 。 * 执行第二种操作，向上走 20 级台阶到台阶 1 。 * 执行第一种操作，向下走 1 级台阶到台阶 0 。 * 执行第二种操作，向上走 21 级台阶到台阶 2 。 * 执行第一种操作，向下走 1 级台阶到台阶 1 。 提示： * 0 <= k <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划和记忆化搜索来计算到达第 k 级台阶的方案数。

算法步骤:
1. 定义一个递归函数 `dp(i, j)` 表示从台阶 i 出发，当前跳跃次数为 j 时到达第 k 级台阶的方案数。
2. 如果 i == k，则返回 1，表示找到了一种方案。
3. 如果 i > k 或 i < 0，则返回 0，表示无法到达。
4. 递归计算两种操作的结果：
   - 向下走一级到 i - 1（但不能连续使用）。
   - 向上走到台阶 i + 2^j，并将 j 增加 1。
5. 使用记忆化搜索来避免重复计算。

关键点:
- 使用记忆化搜索来优化递归过程，减少重复计算。
- 递归函数需要考虑边界条件和操作限制。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(k log k)
空间复杂度: O(k log k)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution
from functools import lru_cache

def solution_function_name(k: int) -> int:
    """
    函数式接口 - 计算到达第 k 级台阶的方案数
    """
    @lru_cache(maxsize=None)
    def dp(i: int, j: int) -> int:
        if i == k:
            return 1
        if i > k or i < 0:
            return 0
        # 向下走一级到 i - 1
        down = dp(i - 1, j) if i - 1 >= 0 else 0
        # 向上走到台阶 i + 2^j
        up = dp(i + (1 << j), j + 1)
        return down + up

    return dp(1, 0)

Solution = create_solution(solution_function_name)