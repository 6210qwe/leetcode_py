# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 806
标题: Domino and Tromino Tiling
难度: medium
链接: https://leetcode.cn/problems/domino-and-tromino-tiling/
题目类型: 动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
790. 多米诺和托米诺平铺 - 有两种形状的瓷砖：一种是 2 x 1 的多米诺形，另一种是形如 "L" 的托米诺形。两种形状都可以旋转。 [https://assets.leetcode.com/uploads/2021/07/15/lc-domino.jpg] 给定整数 n ，返回可以平铺 2 x n 的面板的方法的数量。返回对 109 + 7 取模 的值。 平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。 示例 1: [https://assets.leetcode.com/uploads/2021/07/15/lc-domino1.jpg] 输入: n = 3 输出: 5 解释: 五种不同的方法如上所示。 示例 2: 输入: n = 1 输出: 1 提示： * 1 <= n <= 1000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们定义 dp[i][0] 表示 2 x i 的面板完全被平铺的方法数，dp[i][1] 表示 2 x i 的面板顶部有一块未被平铺的方法数，dp[i][2] 表示 2 x i 的面板底部有一块未被平铺的方法数。

算法步骤:
1. 初始化 dp 数组，dp[0][0] = 1，表示空面板有一种平铺方法。
2. 对于每一个 i，从 1 到 n，计算 dp[i][0], dp[i][1], dp[i][2]。
3. dp[i][0] = dp[i-1][0] + dp[i-1][1] + dp[i-1][2] + dp[i-2][0]，表示当前面板完全被平铺的方法数。
4. dp[i][1] = dp[i-2][0] + dp[i-1][2]，表示当前面板顶部有一块未被平铺的方法数。
5. dp[i][2] = dp[i-2][0] + dp[i-1][1]，表示当前面板底部有一块未被平铺的方法数。
6. 返回 dp[n][0] % (10^9 + 7)。

关键点:
- 使用动态规划数组 dp 来存储中间结果，避免重复计算。
- 注意取模操作以防止溢出。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是给定的整数。
空间复杂度: O(n)，使用了长度为 n+1 的 dp 数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def num_tilings(n: int) -> int:
    """
    函数式接口 - 返回可以平铺 2 x n 的面板的方法的数量
    """
    MOD = 10**9 + 7
    if n == 1:
        return 1
    if n == 2:
        return 2
    
    # 初始化 dp 数组
    dp = [[0] * 3 for _ in range(n + 1)]
    dp[0][0] = 1
    dp[1][0] = 1
    dp[1][1] = 0
    dp[1][2] = 0
    dp[2][0] = 2
    dp[2][1] = 1
    dp[2][2] = 1
    
    # 填充 dp 数组
    for i in range(3, n + 1):
        dp[i][0] = (dp[i-1][0] + dp[i-1][1] + dp[i-1][2] + dp[i-2][0]) % MOD
        dp[i][1] = (dp[i-2][0] + dp[i-1][2]) % MOD
        dp[i][2] = (dp[i-2][0] + dp[i-1][1]) % MOD
    
    return dp[n][0]


Solution = create_solution(num_tilings)