# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 410
标题: Split Array Largest Sum
难度: hard
链接: https://leetcode.cn/problems/split-array-largest-sum/
题目类型: 贪心、数组、二分查找、动态规划、前缀和
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
410. 分割数组的最大值 - 给定一个非负整数数组 nums 和一个整数 k ，你需要将这个数组分成 k 个非空的连续子数组，使得这 k 个子数组各自和的最大值 最小。 返回分割后最小的和的最大值。 子数组 是数组中连续的部份。 示例 1： 输入：nums = [7,2,5,10,8], k = 2 输出：18 解释： 一共有四种方法将 nums 分割为 2 个子数组。 其中最好的方式是将其分为 [7,2,5] 和 [10,8] 。 因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。 示例 2： 输入：nums = [1,2,3,4,5], k = 2 输出：9 示例 3： 输入：nums = [1,4,4], k = 3 输出：4 提示： * 1 <= nums.length <= 1000 * 0 <= nums[i] <= 106 * 1 <= k <= min(50, nums.length)
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 二分查找答案，判断能否将数组分成k个子数组，每个子数组和<=mid

算法步骤:
1. 确定二分查找范围：最小值为数组最大值，最大值为数组总和
2. 对于每个mid值，判断能否将数组分成k个子数组，每个子数组和<=mid
3. 如果可以，说明答案<=mid，缩小右边界；否则缩小左边界

关键点:
- 二分查找+贪心验证
- 时间复杂度O(n*log(sum))，空间复杂度O(1)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n*log(sum)) - n为数组长度，sum为数组总和
空间复杂度: O(1) - 只使用常数额外空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from leetcode_solutions.utils.solution import create_solution


def split_array_largest_sum(nums: List[int], k: int) -> int:
    """
    函数式接口 - 分割数组的最大值
    
    实现思路:
    二分查找答案，判断能否将数组分成k个子数组，每个子数组和<=mid。
    
    Args:
        nums: 非负整数数组
        k: 要分割的子数组个数
        
    Returns:
        分割后最小的和的最大值
        
    Example:
        >>> split_array_largest_sum([7, 2, 5, 10, 8], 2)
        18
    """
    def can_split(max_sum):
        """判断能否将数组分成k个子数组，每个子数组和<=max_sum"""
        count = 1
        current_sum = 0
        
        for num in nums:
            if current_sum + num > max_sum:
                count += 1
                current_sum = num
                if count > k:
                    return False
            else:
                current_sum += num
        
        return True
    
    left = max(nums)
    right = sum(nums)
    
    while left < right:
        mid = (left + right) // 2
        if can_split(mid):
            right = mid
        else:
            left = mid + 1
    
    return left


# 自动生成Solution类（无需手动编写）
Solution = create_solution(split_array_largest_sum)
