# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 60
标题: Permutation Sequence
难度: hard
链接: https://leetcode.cn/problems/permutation-sequence/
题目类型: 递归、数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
60. 排列序列 - 给出集合 [1,2,3,...,n]，其所有元素共有 n! 种排列。 按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下： 1. "123" 2. "132" 3. "213" 4. "231" 5. "312" 6. "321" 给定 n 和 k，返回第 k 个排列。 示例 1： 输入：n = 3, k = 3 输出："213" 示例 2： 输入：n = 4, k = 9 输出："2314" 示例 3： 输入：n = 3, k = 1 输出："123" 提示： * 1 <= n <= 9 * 1 <= k <= n!
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 数学方法，根据k值直接计算每一位的数字

算法步骤:
1. 计算阶乘数组fact，fact[i] = i!
2. 创建可用数字列表nums = [1, 2, ..., n]
3. 对于每一位i（从0到n-1）：
   - 计算当前位应该使用哪个数字：index = (k - 1) // fact[n - 1 - i]
   - 将nums[index]添加到结果
   - 从nums中移除该数字
   - 更新k：k = k - index * fact[n - 1 - i]
4. 返回结果字符串

关键点:
- 第k个排列（从1开始）对应索引k-1
- 每一位的选择由剩余数字的排列数决定
- 时间复杂度O(n²)，空间复杂度O(n)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n²) - 需要计算n位，每次移除元素需要O(n)
空间复杂度: O(n) - 存储阶乘数组和可用数字列表
"""

# ============================================================================
# 代码实现
# ============================================================================

from leetcode_solutions.utils.solution import create_solution


def get_permutation(n: int, k: int) -> str:
    """
    函数式接口 - 数学方法
    
    实现思路:
    根据k值直接计算每一位应该使用的数字，避免生成所有排列。
    
    Args:
        n: 集合大小[1,2,...,n]
        k: 第k个排列（从1开始）
        
    Returns:
        第k个排列的字符串表示
        
    Example:
        >>> get_permutation(3, 3)
        '213'
        >>> get_permutation(4, 9)
        '2314'
    """
    # 计算阶乘数组
    fact = [1] * n
    for i in range(1, n):
        fact[i] = fact[i - 1] * i
    
    # 可用数字列表
    nums = list(range(1, n + 1))
    result = []
    k -= 1  # 转换为从0开始的索引
    
    for i in range(n):
        # 计算当前位应该使用哪个数字
        index = k // fact[n - 1 - i]
        result.append(str(nums[index]))
        # 从可用数字中移除
        nums.pop(index)
        # 更新k
        k %= fact[n - 1 - i]
    
    return ''.join(result)


# 自动生成Solution类（无需手动编写）
Solution = create_solution(get_permutation)
