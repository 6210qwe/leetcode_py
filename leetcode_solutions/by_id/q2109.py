# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2109
标题: Find Array Given Subset Sums
难度: hard
链接: https://leetcode.cn/problems/find-array-given-subset-sums/
题目类型: 数组、分治
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1982. 从子集的和还原数组 - 存在一个未知数组需要你进行还原，给你一个整数 n 表示该数组的长度。另给你一个数组 sums ，由未知数组中全部 2n 个 子集的和 组成（子集中的元素没有特定的顺序）。 返回一个长度为 n 的数组 ans 表示还原得到的未知数组。如果存在 多种 答案，只需返回其中 任意一个 。 如果可以由数组 arr 删除部分元素（也可能不删除或全删除）得到数组 sub ，那么数组 sub 就是数组 arr 的一个 子集 。sub 的元素之和就是 arr 的一个 子集的和 。一个空数组的元素之和为 0 。 注意：生成的测试用例将保证至少存在一个正确答案。 示例 1： 输入：n = 3, sums = [-3,-2,-1,0,0,1,2,3] 输出：[1,2,-3] 解释：[1,2,-3] 能够满足给出的子集的和： - []：和是 0 - [1]：和是 1 - [2]：和是 2 - [1,2]：和是 3 - [-3]：和是 -3 - [1,-3]：和是 -2 - [2,-3]：和是 -1 - [1,2,-3]：和是 0 注意，[1,2,-3] 的任何排列和 [-1,-2,3] 的任何排列都会被视作正确答案。 示例 2： 输入：n = 2, sums = [0,0,0,0] 输出：[0,0] 解释：唯一的正确答案是 [0,0] 。 示例 3： 输入：n = 4, sums = [0,0,5,5,4,-1,4,9,9,-1,4,3,4,8,3,8] 输出：[0,-1,4,5] 解释：[0,-1,4,5] 能够满足给出的子集的和。 提示： * 1 <= n <= 15 * sums.length == 2n * -104 <= sums[i] <= 104
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用分治法来解决这个问题。我们可以通过对 sums 进行排序，并利用子集和的性质来逐步恢复原数组。

算法步骤:
1. 对 sums 进行排序。
2. 找到最小的两个元素 diff 和 zero，diff 是原数组中的一个元素，zero 是原数组中的另一个元素。
3. 通过 diff 和 zero 来划分 sums，分别处理两个子集。
4. 递归地处理这两个子集，直到恢复出原数组。

关键点:
- 通过对 sums 进行排序，我们可以利用子集和的性质来逐步恢复原数组。
- 递归地处理子集，确保每个子集都能恢复出原数组的一部分。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(2^n * log(2^n)) = O(n * 2^n)，其中 n 是数组的长度。每次递归的时间复杂度是 O(2^n)，总共需要递归 n 次。
空间复杂度: O(2^n)，用于存储递归调用栈和中间结果。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def recover_array(n: int, sums: List[int]) -> List[int]:
    def helper(sums):
        if len(sums) == 1:
            return [sums[0]]
        
        # 对 sums 进行排序
        sums.sort()
        
        # 找到最小的两个元素 diff 和 zero
        diff = sums[1] - sums[0]
        zero = sums[0]
        
        # 通过 diff 和 zero 来划分 sums
        left, right = [], []
        count = {}
        for s in sums:
            if s not in count:
                count[s] = 0
            count[s] += 1
        
        for s in sums:
            if count[s] > 0:
                left.append(s)
                right.append(s + diff)
                count[s] -= 1
                count[s + diff] -= 1
        
        # 递归地处理这两个子集
        left_result = helper(left)
        right_result = helper(right)
        
        # 合并结果
        result = [diff] + [x for x in left_result if x != zero]
        return result
    
    # 递归处理 sums
    return helper(sums)

Solution = create_solution(recover_array)