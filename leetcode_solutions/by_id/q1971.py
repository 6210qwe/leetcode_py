# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1971
标题: Incremental Memory Leak
难度: medium
链接: https://leetcode.cn/problems/incremental-memory-leak/
题目类型: 数学、模拟
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1860. 增长的内存泄露 - 给你两个整数 memory1 和 memory2 分别表示两个内存条剩余可用内存的位数。现在有一个程序每秒递增的速度消耗着内存。 在第 i 秒（秒数从 1 开始），有 i 位内存被分配到 剩余内存较多 的内存条（如果两者一样多，则分配到第一个内存条）。如果两者剩余内存都不足 i 位，那么程序将 意外退出 。 请你返回一个数组，包含 [crashTime, memory1crash, memory2crash] ，其中 crashTime是程序意外退出的时间（单位为秒）， memory1crash 和 memory2crash 分别是两个内存条最后剩余内存的位数。 示例 1： 输入：memory1 = 2, memory2 = 2 输出：[3,1,0] 解释：内存分配如下： - 第 1 秒，内存条 1 被占用 1 位内存。内存条 1 现在有 1 位剩余可用内存。 - 第 2 秒，内存条 2 被占用 2 位内存。内存条 2 现在有 0 位剩余可用内存。 - 第 3 秒，程序意外退出，两个内存条分别有 1 位和 0 位剩余可用内存。 示例 2： 输入：memory1 = 8, memory2 = 11 输出：[6,0,4] 解释：内存分配如下： - 第 1 秒，内存条 2 被占用 1 位内存，内存条 2 现在有 10 位剩余可用内存。 - 第 2 秒，内存条 2 被占用 2 位内存，内存条 2 现在有 8 位剩余可用内存。 - 第 3 秒，内存条 1 被占用 3 位内存，内存条 1 现在有 5 位剩余可用内存。 - 第 4 秒，内存条 2 被占用 4 位内存，内存条 2 现在有 4 位剩余可用内存。 - 第 5 秒，内存条 1 被占用 5 位内存，内存条 1 现在有 0 位剩余可用内存。 - 第 6 秒，程序意外退出，两个内存条分别有 0 位和 4 位剩余可用内存。 提示： * 0 <= memory1, memory2 <= 231 - 1
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 模拟内存分配过程，直到某个内存条无法满足当前秒数的内存需求。

算法步骤:
1. 初始化秒数 `i` 为 1。
2. 进入循环，直到 `memory1` 和 `memory2` 都不足以分配 `i` 位内存：
   - 如果 `memory1` 大于等于 `memory2`，则从 `memory1` 中减去 `i` 位内存。
   - 否则，从 `memory2` 中减去 `i` 位内存。
   - 将秒数 `i` 增加 1。
3. 返回 `[i, memory1, memory2]`。

关键点:
- 通过比较 `memory1` 和 `memory2` 来决定哪个内存条分配当前秒数的内存。
- 循环直到某个内存条无法满足当前秒数的内存需求。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(sqrt(n))，其中 n 是初始内存的最大值。因为在最坏情况下，内存分配的时间复杂度接近于 sqrt(n)。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(memory1: int, memory2: int) -> List[int]:
    """
    函数式接口 - 实现最优解法
    """
    i = 1
    while memory1 >= i or memory2 >= i:
        if memory1 >= memory2:
            memory1 -= i
        else:
            memory2 -= i
        i += 1
    return [i, memory1, memory2]


Solution = create_solution(solution_function_name)