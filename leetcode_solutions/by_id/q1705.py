# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1705
标题: Count Unhappy Friends
难度: medium
链接: https://leetcode.cn/problems/count-unhappy-friends/
题目类型: 数组、模拟
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1583. 统计不开心的朋友 - 给你一份 n 位朋友的亲近程度列表，其中 n 总是 偶数 。 对每位朋友 i，preferences[i] 包含一份 按亲近程度从高到低排列 的朋友列表。换句话说，排在列表前面的朋友与 i 的亲近程度比排在列表后面的朋友更高。每个列表中的朋友均以 0 到 n-1 之间的整数表示。 所有的朋友被分成几对，配对情况以列表 pairs 给出，其中 pairs[i] = [xi, yi] 表示 xi 与 yi 配对，且 yi 与 xi 配对。 但是，这样的配对情况可能会使其中部分朋友感到不开心。在 x 与 y 配对且 u 与 v 配对的情况下，如果同时满足下述两个条件，x 就会不开心： * x 与 u 的亲近程度胜过 x 与 y，且 * u 与 x 的亲近程度胜过 u 与 v 返回 不开心的朋友的数目 。 示例 1： 输入：n = 4, preferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]], pairs = [[0, 1], [2, 3]] 输出：2 解释： 朋友 1 不开心，因为： - 1 与 0 配对，但 1 与 3 的亲近程度比 1 与 0 高，且 - 3 与 1 的亲近程度比 3 与 2 高。 朋友 3 不开心，因为： - 3 与 2 配对，但 3 与 1 的亲近程度比 3 与 2 高，且 - 1 与 3 的亲近程度比 1 与 0 高。 朋友 0 和 2 都是开心的。 示例 2： 输入：n = 2, preferences = [[1], [0]], pairs = [[1, 0]] 输出：0 解释：朋友 0 和 1 都开心。 示例 3： 输入：n = 4, preferences = [[1, 3, 2], [2, 3, 0], [1, 3, 0], [0, 2, 1]], pairs = [[1, 3], [0, 2]] 输出：4 提示： * 2 <= n <= 500 * n 是偶数 * preferences.length == n * preferences[i].length == n - 1 * 0 <= preferences[i][j] <= n - 1 * preferences[i] 不包含 i * preferences[i] 中的所有值都是独一无二的 * pairs.length == n/2 * pairs[i].length == 2 * xi != yi * 0 <= xi, yi <= n - 1 * 每位朋友都 恰好 被包含在一对中
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用哈希表存储每个朋友的配对情况和偏好顺序，然后检查每个朋友是否不开心。

算法步骤:
1. 构建一个字典 `pair_dict` 存储每个朋友的配对情况。
2. 构建一个字典 `pref_dict` 存储每个朋友的偏好顺序。
3. 遍历每个朋友，检查其是否不开心：
   - 如果当前朋友的配对对象不是其最亲近的朋友，则继续检查。
   - 对于每个更亲近的朋友，检查该朋友是否也更亲近当前朋友。
   - 如果满足条件，则当前朋友不开心。

关键点:
- 使用哈希表高效存储和查找配对情况和偏好顺序。
- 只有当当前朋友的配对对象不是其最亲近的朋友时，才需要进一步检查。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2) - 需要遍历每个朋友及其偏好列表。
空间复杂度: O(n) - 使用了两个哈希表来存储配对情况和偏好顺序。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def count_unhappy_friends(n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:
    pair_dict = {}
    pref_dict = {}

    # 构建配对情况字典
    for x, y in pairs:
        pair_dict[x] = y
        pair_dict[y] = x

    # 构建偏好顺序字典
    for i in range(n):
        pref_dict[i] = {friend: rank for rank, friend in enumerate(preferences[i])}

    unhappy_count = 0

    # 检查每个朋友是否不开心
    for x in range(n):
        y = pair_dict[x]
        if pref_dict[x][y] == 0:
            continue

        for u in preferences[x][:pref_dict[x][y]]:
            v = pair_dict[u]
            if pref_dict[u][x] < pref_dict[u][v]:
                unhappy_count += 1
                break

    return unhappy_count

Solution = create_solution(count_unhappy_friends)