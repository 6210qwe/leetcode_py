# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3435
标题: Block Placement Queries
难度: hard
链接: https://leetcode.cn/problems/block-placement-queries/
题目类型: 树状数组、线段树、数组、二分查找
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3161. 物块放置查询 - 有一条无限长的数轴，原点在 0 处，沿着 x 轴 正 方向无限延伸。 给你一个二维数组 queries ，它包含两种操作： 1. 操作类型 1 ：queries[i] = [1, x] 。在距离原点 x 处建一个障碍物。数据保证当操作执行的时候，位置 x 处 没有 任何障碍物。 2. 操作类型 2 ：queries[i] = [2, x, sz] 。判断在数轴范围 [0, x] 内是否可以放置一个长度为 sz 的物块，这个物块需要 完全 放置在范围 [0, x] 内。如果物块与任何障碍物有重合，那么这个物块 不能 被放置，但物块可以与障碍物刚好接触。注意，你只是进行查询，并 不是 真的放置这个物块。每个查询都是相互独立的。 请你返回一个 boolean 数组results ，如果第 i 个操作类型 2 的操作你可以放置物块，那么 results[i] 为 true ，否则为 false 。 示例 1： 输入：queries = [[1,2],[2,3,3],[2,3,1],[2,2,2]] 输出：[false,true,true] 解释： [https://assets.leetcode.com/uploads/2024/04/22/example0block.png] 查询 0 ，在 x = 2 处放置一个障碍物。在 x = 3 之前任何大小不超过 2 的物块都可以被放置。 示例 2： 输入：queries = [[1,7],[2,7,6],[1,2],[2,7,5],[2,7,6]] 输出：[true,true,false] 解释： [https://assets.leetcode.com/uploads/2024/04/22/example1block.png] * 查询 0 在 x = 7 处放置一个障碍物。在 x = 7 之前任何大小不超过 7 的物块都可以被放置。 * 查询 2 在 x = 2 处放置一个障碍物。现在，在 x = 7 之前任何大小不超过 5 的物块可以被放置，x = 2 之前任何大小不超过 2 的物块可以被放置。 提示： * 1 <= queries.length <= 15 * 104 * 2 <= queries[i].length <= 3 * 1 <= queries[i][0] <= 2 * 1 <= x, sz <= min(5 * 104, 3 * queries.length) * 输入保证操作 1 中，x 处不会有障碍物。 * 输入保证至少有一个操作类型 2 。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用有序集合（SortedList）来维护障碍物的位置，并使用二分查找来快速判断物块是否可以放置。

算法步骤:
1. 初始化一个有序集合 `obstacles` 来存储障碍物的位置。
2. 遍历 `queries` 数组：
   - 如果是操作类型 1，将障碍物的位置加入 `obstacles`。
   - 如果是操作类型 2，使用二分查找来判断在范围 [0, x] 内是否存在一个连续的空位可以放置长度为 `sz` 的物块。

关键点:
- 使用有序集合 `SortedList` 可以高效地插入和查找障碍物位置。
- 通过二分查找快速判断物块是否可以放置。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是 `queries` 的长度。每次插入和查找操作的时间复杂度为 O(log n)。
空间复杂度: O(n)，用于存储障碍物的位置。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from sortedcontainers import SortedList

def block_placement_queries(queries: List[List[int]]) -> List[bool]:
    obstacles = SortedList()
    results = []
    
    for query in queries:
        if query[0] == 1:
            obstacles.add(query[1])
        elif query[0] == 2:
            x, sz = query[1], query[2]
            # 找到第一个大于等于 x - sz + 1 的障碍物位置
            idx = obstacles.bisect_left(x - sz + 1)
            # 判断在 [0, x] 范围内是否有足够的空位放置物块
            if (idx == 0 or obstacles[idx - 1] < x - sz + 1) and (idx == len(obstacles) or obstacles[idx] > x):
                results.append(True)
            else:
                results.append(False)
    
    return results

Solution = create_solution(block_placement_queries)