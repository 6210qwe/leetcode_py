# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 71
标题: Simplify Path
难度: medium
链接: https://leetcode.cn/problems/simplify-path/
题目类型: 栈、字符串
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
71. 简化路径 - 给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 '/' 开头），请你将其转化为 更加简洁的规范路径。 在 Unix 风格的文件系统中规则如下： * 一个点 '.' 表示当前目录本身。 * 此外，两个点 '..' 表示将目录切换到上一级（指向父目录）。 * 任意多个连续的斜杠（即，'//' 或 '///'）都被视为单个斜杠 '/'。 * 任何其他格式的点（例如，'...' 或 '....'）均被视为有效的文件/目录名称。 返回的 简化路径 必须遵循下述格式： * 始终以斜杠 '/' 开头。 * 两个目录名之间必须只有一个斜杠 '/' 。 * 最后一个目录名（如果存在）不能 以 '/' 结尾。 * 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 '.' 或 '..'）。 返回简化后得到的 规范路径 。 示例 1： 输入：path = "/home/" 输出："/home" 解释： 应删除尾随斜杠。 示例 2： 输入：path = "/home//foo/" 输出："/home/foo" 解释： 多个连续的斜杠被单个斜杠替换。 示例 3： 输入：path = "/home/user/Documents/../Pictures" 输出："/home/user/Pictures" 解释： 两个点 ".." 表示上一级目录（父目录）。 示例 4： 输入：path = "/../" 输出："/" 解释： 不可能从根目录上升一级目录。 示例 5： 输入：path = "/.../a/../b/c/../d/./" 输出："/.../b/d" 解释： "..." 在这个问题中是一个合法的目录名。 提示： * 1 <= path.length <= 3000 * path 由英文字母，数字，'.'，'/' 或 '_' 组成。 * path 是一个有效的 Unix 风格绝对路径。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用栈处理路径，遇到'..'弹出栈顶，遇到'.'或''忽略

算法步骤:
1. 按'/'分割路径，得到目录列表
2. 遍历目录列表：
   - 如果是'..'，且栈不为空，弹出栈顶
   - 如果是'.'或''，忽略
   - 否则，加入栈
3. 将栈中的目录用'/'连接，并在前面加上'/'

关键点:
- 使用栈模拟路径的层级关系
- '..'表示返回上一级，需要弹出栈顶
- '.'和''（连续斜杠）需要忽略
- 时间复杂度O(n)，空间复杂度O(n)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 需要遍历路径字符串
空间复杂度: O(n) - 栈存储目录名
"""

# ============================================================================
# 代码实现
# ============================================================================

from leetcode_solutions.utils.solution import create_solution


def simplify_path(path: str) -> str:
    """
    函数式接口 - 栈处理
    
    实现思路:
    使用栈处理路径，遇到'..'弹出栈顶，遇到'.'或''忽略。
    
    Args:
        path: Unix风格的绝对路径
        
    Returns:
        简化后的规范路径
        
    Example:
        >>> simplify_path("/home//foo/")
        '/home/foo'
        >>> simplify_path("/../")
        '/'
    """
    stack = []
    parts = path.split('/')
    
    for part in parts:
        if part == '..':
            # 返回上一级，弹出栈顶
            if stack:
                stack.pop()
        elif part and part != '.':
            # 忽略空字符串和'.'
            stack.append(part)
    
    return '/' + '/'.join(stack)


# 自动生成Solution类（无需手动编写）
Solution = create_solution(simplify_path)
