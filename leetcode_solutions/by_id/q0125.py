# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 125
标题: Valid Palindrome
难度: easy
链接: https://leetcode.cn/problems/valid-palindrome/
题目类型: 双指针、字符串
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
125. 验证回文串 - 如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。 字母和数字都属于字母数字字符。 给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。 示例 1： 输入: s = "A man, a plan, a canal: Panama" 输出：true 解释："amanaplanacanalpanama" 是回文串。 示例 2： 输入：s = "race a car" 输出：false 解释："raceacar" 不是回文串。 示例 3： 输入：s = " " 输出：true 解释：在移除非字母数字字符之后，s 是一个空字符串 "" 。 由于空字符串正着反着读都一样，所以是回文串。 提示： * 1 <= s.length <= 2 * 105 * s 仅由可打印的 ASCII 字符组成
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用双指针从两端向中间比较

算法步骤:
1. 使用左右两个指针
2. 跳过非字母数字字符
3. 比较左右指针指向的字符（转换为小写）
4. 如果不相等返回False，否则继续
5. 直到左右指针相遇

关键点:
- 只比较字母数字字符
- 时间复杂度O(n)，空间复杂度O(1)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 需要遍历字符串一次
空间复杂度: O(1) - 只使用常数额外空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from leetcode_solutions.utils.solution import create_solution


def valid_palindrome(s: str) -> bool:
    """
    函数式接口 - 验证回文串
    
    实现思路:
    使用双指针从两端向中间比较，只比较字母数字字符。
    
    Args:
        s: 待验证的字符串
        
    Returns:
        如果是回文串返回True，否则返回False
        
    Example:
        >>> valid_palindrome("A man, a plan, a canal: Panama")
        True
    """
    left, right = 0, len(s) - 1
    
    while left < right:
        while left < right and not s[left].isalnum():
            left += 1
        while left < right and not s[right].isalnum():
            right -= 1
        
        if s[left].lower() != s[right].lower():
            return False
        
        left += 1
        right -= 1
    
    return True


# 自动生成Solution类（无需手动编写）
Solution = create_solution(valid_palindrome)
