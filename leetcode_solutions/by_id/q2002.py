# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2002
标题: Stone Game VIII
难度: hard
链接: https://leetcode.cn/problems/stone-game-viii/
题目类型: 数组、数学、动态规划、博弈、前缀和
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1872. 石子游戏 VIII - Alice 和 Bob 玩一个游戏，两人轮流操作， Alice 先手 。 总共有 n 个石子排成一行。轮到某个玩家的回合时，如果石子的数目 大于 1 ，他将执行以下操作： 1. 选择一个整数 x > 1 ，并且 移除 最左边的 x 个石子。 2. 将 移除 的石子价值之 和 累加到该玩家的分数中。 3. 将一个 新的石子 放在最左边，且新石子的值为被移除石子值之和。 当只剩下 一个 石子时，游戏结束。 Alice 和 Bob 的 分数之差 为 (Alice 的分数 - Bob 的分数) 。 Alice 的目标是 最大化 分数差，Bob 的目标是 最小化 分数差。 给你一个长度为 n 的整数数组 stones ，其中 stones[i] 是 从左边起 第 i 个石子的价值。请你返回在双方都采用 最优 策略的情况下，Alice 和 Bob 的 分数之差 。 示例 1： 输入：stones = [-1,2,-3,4,-5] 输出：5 解释： - Alice 移除最左边的 4 个石子，得分增加 (-1) + 2 + (-3) + 4 = 2 ，并且将一个价值为 2 的石子放在最左边。stones = [2,-5] 。 - Bob 移除最左边的 2 个石子，得分增加 2 + (-5) = -3 ，并且将一个价值为 -3 的石子放在最左边。stones = [-3] 。 两者分数之差为 2 - (-3) = 5 。 示例 2： 输入：stones = [7,-6,5,10,5,-2,-6] 输出：13 解释： - Alice 移除所有石子，得分增加 7 + (-6) + 5 + 10 + 5 + (-2) + (-6) = 13 ，并且将一个价值为 13 的石子放在最左边。stones = [13] 。 两者分数之差为 13 - 0 = 13 。 示例 3： 输入：stones = [-10,-12] 输出：-22 解释： - Alice 只有一种操作，就是移除所有石子。得分增加 (-10) + (-12) = -22 ，并且将一个价值为 -22 的石子放在最左边。stones = [-22] 。 两者分数之差为 (-22) - 0 = -22 。 提示： * n == stones.length * 2 <= n <= 105 * -104 <= stones[i] <= 104
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。定义 dp[i] 表示从第 i 个位置开始，当前玩家能获得的最大分数差。我们需要从后往前计算 dp 值。

算法步骤:
1. 计算前缀和数组 prefix_sum，prefix_sum[i] 表示从第 0 个到第 i 个石子的总和。
2. 初始化 dp 数组，dp[n-1] = 0，因为只剩一个石子时无法再进行操作。
3. 从 n-2 到 0 逆序遍历，对于每个 i，计算 dp[i] 的值。dp[i] = max(prefix_sum[j] - dp[j])，其中 j 从 i+1 到 n-1。
4. 返回 dp[0]，即从第 0 个位置开始，Alice 能获得的最大分数差。

关键点:
- 使用前缀和数组来快速计算任意区间的和。
- 动态规划的状态转移方程：dp[i] = max(prefix_sum[j] - dp[j])。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2)，其中 n 是 stones 的长度。需要遍历每个位置并计算最大值。
空间复杂度: O(n)，需要存储前缀和数组和 dp 数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def stone_game_viii(stones: List[int]) -> int:
    """
    函数式接口 - 实现最优解法
    """
    n = len(stones)
    if n == 2:
        return sum(stones)

    # 计算前缀和数组
    prefix_sum = [0] * n
    prefix_sum[0] = stones[0]
    for i in range(1, n):
        prefix_sum[i] = prefix_sum[i - 1] + stones[i]

    # 初始化 dp 数组
    dp = [0] * n
    dp[n - 1] = 0

    # 从 n-2 到 0 逆序遍历
    for i in range(n - 2, -1, -1):
        dp[i] = -float('inf')
        for j in range(i + 1, n):
            dp[i] = max(dp[i], prefix_sum[j] - dp[j])

    return dp[0]


Solution = create_solution(stone_game_viii)