# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3777
标题: Maximum Product of Subsequences With an Alternating Sum Equal to K
难度: hard
链接: https://leetcode.cn/problems/maximum-product-of-subsequences-with-an-alternating-sum-equal-to-k/
题目类型: 数组、哈希表、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3509. 最大化交错和为 K 的子序列乘积 - 给你一个整数数组 nums 和两个整数 k 与 limit，你的任务是找到一个非空的 子序列，满足以下条件：
* 它的 交错和 等于 k。
* 在乘积 不超过 limit 的前提下，最大化 其所有数字的乘积。
返回满足条件的子序列的 乘积 。如果不存在这样的子序列，则返回 -1。
子序列 是指可以通过删除原数组中的某些（或不删除）元素并保持剩余元素顺序得到的新数组。
交错和 是指一个 从下标 0 开始 的数组中，偶数下标 的元素之和减去 奇数下标 的元素之和。
示例 1：
输入： nums = [1,2,3], k = 2, limit = 10
输出： 6
解释：
交错和为 2 的子序列有：
* [1, 2, 3]
* 交错和：1 - 2 + 3 = 2
* 乘积：1 * 2 * 3 = 6
* [2]
* 交错和：2
* 乘积：2
在 limit 内的最大乘积是 6。
示例 2：
输入： nums = [0,2,3], k = -5, limit = 12
输出： -1
解释：
不存在交错和恰好为 -5 的子序列。
示例 3：
输入： nums = [2,2,3,3], k = 0, limit = 9
输出： 9
解释：
交错和为 0 的子序列包括：
* [2, 2]
* 交错和：2 - 2 = 0
* 乘积：2 * 2 = 4
* [3, 3]
* 交错和：3 - 3 = 0
* 乘积：3 * 3 = 9
* [2, 2, 3, 3]
* 交错和：2 - 2 + 3 - 3 = 0
* 乘积：2 * 2 * 3 * 3 = 36
子序列 [2, 2, 3, 3] 虽然交错和为 k 且乘积最大，但 36 > 9，超出 limit 。下一个最大且在 limit 范围内的乘积是 9。
提示：
* 1 <= nums.length <= 150
* 0 <= nums[i] <= 12
* -105 <= k <= 105
* 1 <= limit <= 5000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们定义一个二维数组 dp，其中 dp[i][j] 表示前 i 个元素中交错和为 j 的最大乘积。通过遍历每个元素，更新 dp 数组，最终找到交错和为 k 的最大乘积。

算法步骤:
1. 初始化 dp 数组，dp[0][0] = 1，表示空子序列的乘积为 1。
2. 遍历每个元素，更新 dp 数组。
3. 如果当前元素是偶数下标，更新 dp[i+1][j+nums[i]] 和 dp[i+1][j-nums[i]]。
4. 如果当前元素是奇数下标，更新 dp[i+1][j-nums[i]] 和 dp[i+1][j+nums[i]]。
5. 检查 dp[n][k] 是否在 limit 范围内，如果是则返回，否则返回 -1。

关键点:
- 使用动态规划来记录每个状态的最大乘积。
- 通过交错和的正负来更新 dp 数组。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * m)，其中 n 是 nums 的长度，m 是 k 的范围。
空间复杂度: O(n * m)，用于存储 dp 数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def max_product_subsequence(nums: List[int], k: int, limit: int) -> int:
    n = len(nums)
    if n == 0:
        return -1

    # 初始化 dp 数组
    dp = [[-1] * (2 * 100000 + 1) for _ in range(n + 1)]
    dp[0][100000] = 1  # 空子序列的乘积为 1

    for i in range(n):
        for j in range(2 * 100000 + 1):
            if dp[i][j] != -1:
                # 更新 dp 数组
                if (i + 1) % 2 == 0:
                    dp[i + 1][j + nums[i]] = max(dp[i + 1][j + nums[i]], dp[i][j] * nums[i])
                    dp[i + 1][j - nums[i]] = max(dp[i + 1][j - nums[i]], dp[i][j] * nums[i])
                else:
                    dp[i + 1][j - nums[i]] = max(dp[i + 1][j - nums[i]], dp[i][j] * nums[i])
                    dp[i + 1][j + nums[i]] = max(dp[i + 1][j + nums[i]], dp[i][j] * nums[i])

    # 检查 dp[n][k + 100000] 是否在 limit 范围内
    result = dp[n][k + 100000]
    if result == -1 or result > limit:
        return -1
    return result


Solution = create_solution(max_product_subsequence)