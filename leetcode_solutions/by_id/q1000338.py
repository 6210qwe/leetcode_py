# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000338
标题: 合并区间
难度: medium
链接: https://leetcode.cn/problems/SsGoHC/
题目类型: 数组、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCR 074. 合并区间 - 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。 示例 1： 输入：intervals = [[1,3],[2,6],[8,10],[15,18]] 输出：[[1,6],[8,10],[15,18]] 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2： 输入：intervals = [[1,4],[4,5]] 输出：[[1,5]] 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。 提示： * 1 <= intervals.length <= 104 * intervals[i].length == 2 * 0 <= starti <= endi <= 104 注意：本题与主站 56 题相同： https://leetcode.cn/problems/merge-intervals/ [https://leetcode.cn/problems/merge-intervals/]
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 先对区间按起始位置进行排序，然后遍历排序后的区间，合并重叠的区间。

算法步骤:
1. 对区间按起始位置进行排序。
2. 初始化一个结果列表，将第一个区间加入结果列表。
3. 遍历剩余的区间，如果当前区间与结果列表中的最后一个区间重叠，则合并这两个区间；否则，将当前区间加入结果列表。
4. 返回结果列表。

关键点:
- 排序后，只需比较当前区间的起始位置和结果列表中最后一个区间的结束位置来判断是否重叠。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是区间的数量。排序操作的时间复杂度是 O(n log n)，后续的遍历操作是 O(n)。
空间复杂度: O(log n)，排序操作的空间复杂度取决于排序算法的实现，通常是 O(log n)。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def merge_intervals(intervals: List[List[int]]) -> List[List[int]]:
    """
    函数式接口 - 合并区间
    """
    if not intervals:
        return []

    # 按区间的起始位置进行排序
    intervals.sort(key=lambda x: x[0])

    merged = [intervals[0]]
    for interval in intervals[1:]:
        # 如果当前区间的起始位置小于等于结果列表中最后一个区间的结束位置，则合并这两个区间
        if interval[0] <= merged[-1][1]:
            merged[-1][1] = max(merged[-1][1], interval[1])
        else:
            # 否则，将当前区间加入结果列表
            merged.append(interval)

    return merged


Solution = create_solution(merge_intervals)