# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 100177
标题: Legal Binary Search Tree LCCI
难度: medium
链接: https://leetcode.cn/problems/legal-binary-search-tree-lcci/
题目类型: 树、深度优先搜索、二叉搜索树、二叉树
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
面试题 04.05. 合法二叉搜索树 - 实现一个函数，检查一棵二叉树是否为二叉搜索树。 示例 1： 输入： 2 / \ 1 3 输出：true 示例 2： 输入： 5 / \ 1 4 / \ 3 6 输出：false 解释：输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用中序遍历检查二叉树是否为二叉搜索树。中序遍历的结果应该是一个严格递增的序列。

算法步骤:
1. 定义一个辅助函数 `is_valid_bst`，该函数接受当前节点和上下界作为参数。
2. 如果当前节点为空，返回 True。
3. 检查当前节点的值是否在上下界之间。
4. 递归检查左子树和右子树，更新上下界。

关键点:
- 中序遍历的结果应该是严格递增的。
- 使用上下界来确保每个节点的值都在正确的范围内。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是二叉树的节点数。每个节点都被访问一次。
空间复杂度: O(h)，其中 h 是二叉树的高度。递归调用栈的深度最多为树的高度。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import Optional
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def is_valid_bst(root: Optional[TreeNode], low: float = float('-inf'), high: float = float('inf')) -> bool:
    if not root:
        return True
    if not (low < root.val < high):
        return False
    return (is_valid_bst(root.left, low, root.val) and
            is_valid_bst(root.right, root.val, high))


Solution = create_solution(is_valid_bst)