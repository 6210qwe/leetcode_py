# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000324
标题: 前 K 个高频元素
难度: medium
链接: https://leetcode.cn/problems/g5c51o/
题目类型: 数组、哈希表、分治、桶排序、计数、快速选择、排序、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCR 060. 前 K 个高频元素 - 给定一个整数数组 nums 和一个整数 k ，请返回其中出现频率前 k 高的元素。可以按 任意顺序 返回答案。 示例 1： 输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2] 示例 2： 输入: nums = [1], k = 1 输出: [1] 提示： * 1 <= nums.length <= 105 * k 的取值范围是 [1, 数组中不相同的元素的个数] * 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的 进阶：所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。 注意：本题与主站 347 题相同：https://leetcode.cn/problems/top-k-frequent-elements/ [https://leetcode.cn/problems/top-k-frequent-elements/]
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用哈希表统计频率，然后使用最小堆来获取前 K 个高频元素。

算法步骤:
1. 使用哈希表统计每个元素的频率。
2. 使用一个最小堆来存储频率最高的 K 个元素。
3. 遍历哈希表，将频率和元素加入堆中，如果堆的大小超过 K，则弹出堆顶元素。
4. 最后堆中的元素即为前 K 个高频元素。

关键点:
- 使用最小堆来维护前 K 个高频元素，确保时间复杂度优于 O(n log n)。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n + k log k)
空间复杂度: O(n + k)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution
import heapq

def topKFrequent(nums: List[int], k: int) -> List[int]:
    """
    函数式接口 - 返回前 K 个高频元素
    """
    # 统计每个元素的频率
    freq = {}
    for num in nums:
        if num in freq:
            freq[num] += 1
        else:
            freq[num] = 1

    # 使用最小堆来存储频率最高的 K 个元素
    heap = []
    for num, count in freq.items():
        heapq.heappush(heap, (count, num))
        if len(heap) > k:
            heapq.heappop(heap)

    # 从堆中提取前 K 个高频元素
    result = [heapq.heappop(heap)[1] for _ in range(k)]
    return result[::-1]

Solution = create_solution(topKFrequent)