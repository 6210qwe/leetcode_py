# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 402
标题: Remove K Digits
难度: medium
链接: https://leetcode.cn/problems/remove-k-digits/
题目类型: 栈、贪心、字符串、单调栈
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
402. 移掉 K 位数字 - 给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。 示例 1 ： 输入：num = "1432219", k = 3 输出："1219" 解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。 示例 2 ： 输入：num = "10200", k = 1 输出："200" 解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。 示例 3 ： 输入：num = "10", k = 2 输出："0" 解释：从原数字移除所有的数字，剩余为空就是 0 。 提示： * 1 <= k <= num.length <= 105 * num 仅由若干位数字（0 - 9）组成 * 除了 0 本身之外，num 不含任何前导零
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用单调栈，保持栈中元素单调递增，移除k个数字后得到最小数字

算法步骤:
1. 使用栈维护结果，保持栈中元素单调递增
2. 遍历字符串，如果当前数字小于栈顶且还有移除次数，则弹出栈顶
3. 将当前数字入栈
4. 如果还有剩余移除次数，从栈顶移除
5. 移除前导零，返回结果

关键点:
- 使用单调栈贪心策略
- 时间复杂度O(n)，空间复杂度O(n)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 需要遍历字符串一次
空间复杂度: O(n) - 栈的空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from leetcode_solutions.utils.solution import create_solution


def remove_k_digits(num: str, k: int) -> str:
    """
    函数式接口 - 移掉K位数字
    
    实现思路:
    使用单调栈，保持栈中元素单调递增，移除k个数字后得到最小数字。
    
    Args:
        num: 非负整数字符串
        k: 要移除的数字个数
        
    Returns:
        移除k位数字后的最小数字字符串
        
    Example:
        >>> remove_k_digits("1432219", 3)
        '1219'
    """
    stack = []
    remove_count = k
    
    for digit in num:
        while stack and remove_count > 0 and stack[-1] > digit:
            stack.pop()
            remove_count -= 1
        stack.append(digit)
    
    # 如果还有剩余移除次数，从栈顶移除
    while remove_count > 0:
        stack.pop()
        remove_count -= 1
    
    # 移除前导零
    result = ''.join(stack).lstrip('0')
    
    return result if result else '0'


# 自动生成Solution类（无需手动编写）
Solution = create_solution(remove_k_digits)
