# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1002
标题: Maximum Width Ramp
难度: medium
链接: https://leetcode.cn/problems/maximum-width-ramp/
题目类型: 栈、数组、双指针、单调栈
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
962. 最大宽度坡 - 给定一个整数数组 A，坡是元组 (i, j)，其中 i < j 且 A[i] <= A[j]。这样的坡的宽度为 j - i。 找出 A 中的坡的最大宽度，如果不存在，返回 0 。 示例 1： 输入：[6,0,8,2,1,5] 输出：4 解释： 最大宽度的坡为 (i, j) = (1, 5): A[1] = 0 且 A[5] = 5. 示例 2： 输入：[9,8,1,0,1,9,4,0,4,1] 输出：7 解释： 最大宽度的坡为 (i, j) = (2, 9): A[2] = 1 且 A[9] = 1. 提示： 1. 2 <= A.length <= 50000 2. 0 <= A[i] <= 50000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用单调栈来存储递减序列的索引，然后从右向左遍历数组，找到满足条件的最大宽度坡。

算法步骤:
1. 初始化一个空栈 `stack` 用于存储递减序列的索引。
2. 从左到右遍历数组，将递减序列的索引压入栈中。
3. 从右到左遍历数组，对于每个元素，检查栈顶元素是否满足 A[stack[-1]] <= A[j]，如果满足则更新最大宽度，并弹出栈顶元素。
4. 返回最大宽度。

关键点:
- 使用单调栈来存储递减序列的索引，从而在后续遍历时可以快速找到满足条件的坡。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def max_width_ramp(nums: List[int]) -> int:
    """
    函数式接口 - 实现最大宽度坡
    """
    stack = []
    n = len(nums)

    # 从左到右遍历数组，将递减序列的索引压入栈中
    for i in range(n):
        if not stack or nums[stack[-1]] > nums[i]:
            stack.append(i)

    max_width = 0
    # 从右到左遍历数组，找到满足条件的最大宽度坡
    for j in range(n - 1, -1, -1):
        while stack and nums[stack[-1]] <= nums[j]:
            max_width = max(max_width, j - stack.pop())

    return max_width


Solution = create_solution(max_width_ramp)