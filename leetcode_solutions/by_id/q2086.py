# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2086
标题: Count Number of Special Subsequences
难度: hard
链接: https://leetcode.cn/problems/count-number-of-special-subsequences/
题目类型: 数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1955. 统计特殊子序列的数目 - 特殊序列 是由 正整数 个 0 ，紧接着 正整数 个 1 ，最后 正整数 个 2 组成的序列。 * 比方说，[0,1,2] 和 [0,0,1,1,1,2] 是特殊序列。 * 相反，[2,1,0] ，[1] 和 [0,1,2,0] 就不是特殊序列。 给你一个数组 nums （仅 包含整数 0，1 和 2），请你返回 不同特殊子序列的数目 。由于答案可能很大，请你将它对 109 + 7 取余 后返回。 一个数组的 子序列 是从原数组中删除零个或者若干个元素后，剩下元素不改变顺序得到的序列。如果两个子序列的 下标集合 不同，那么这两个子序列是 不同的 。 示例 1： 输入：nums = [0,1,2,2] 输出：3 解释：特殊子序列为 [0,1,2,2]，[0,1,2,2] 和 [0,1,2,2] 。 示例 2： 输入：nums = [2,2,0,0] 输出：0 解释：数组 [2,2,0,0] 中没有特殊子序列。 示例 3： 输入：nums = [0,1,2,0,1,2] 输出：7 解释：特殊子序列包括： - [0,1,2,0,1,2] - [0,1,2,0,1,2] - [0,1,2,0,1,2] - [0,1,2,0,1,2] - [0,1,2,0,1,2] - [0,1,2,0,1,2] - [0,1,2,0,1,2] 提示： * 1 <= nums.length <= 105 * 0 <= nums[i] <= 2
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来计算以 0, 1, 2 结尾的特殊子序列的数量。

算法步骤:
1. 初始化三个变量 end_0, end_1, end_2 分别表示以 0, 1, 2 结尾的特殊子序列的数量。
2. 遍历数组 nums，根据当前数字更新 end_0, end_1, end_2 的值。
3. 最终结果为 end_2。

关键点:
- 动态规划的状态转移方程：
  - end_0 = (end_0 * 2 + count(0)) % MOD
  - end_1 = (end_1 * 2 + end_0) % MOD
  - end_2 = (end_2 * 2 + end_1) % MOD
- 使用模运算防止溢出。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(1)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def count_special_subsequences(nums: List[int]) -> int:
    """
    函数式接口 - 计算特殊子序列的数目
    """
    MOD = 10**9 + 7
    end_0, end_1, end_2 = 0, 0, 0

    for num in nums:
        if num == 0:
            end_0 = (end_0 * 2 + 1) % MOD
        elif num == 1:
            end_1 = (end_1 * 2 + end_0) % MOD
        elif num == 2:
            end_2 = (end_2 * 2 + end_1) % MOD

    return end_2


Solution = create_solution(count_special_subsequences)