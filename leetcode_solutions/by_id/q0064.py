# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 64
标题: Minimum Path Sum
难度: medium
链接: https://leetcode.cn/problems/minimum-path-sum/
题目类型: 数组、动态规划、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
64. 最小路径和 - 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例 1： [https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg] 输入：grid = [[1,3,1],[1,5,1],[4,2,1]] 输出：7 解释：因为路径 1→3→1→1→1 的总和最小。 示例 2： 输入：grid = [[1,2,3],[4,5,6]] 输出：12 提示： * m == grid.length * n == grid[i].length * 1 <= m, n <= 200 * 0 <= grid[i][j] <= 200
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 动态规划，dp[i][j]表示到达(i,j)的最小路径和

算法步骤:
1. 初始化第一行和第一列：累加路径和
2. 状态转移：dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])
3. 返回dp[m-1][n-1]

关键点:
- 可以优化空间复杂度为O(n)，使用一维数组
- 第一行和第一列需要特殊处理（只能从一个方向来）
- 时间复杂度O(m*n)，空间复杂度O(n)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m*n) - 需要遍历整个网格
空间复杂度: O(n) - 优化后只使用一维数组
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from leetcode_solutions.utils.solution import create_solution


def min_path_sum(grid: List[List[int]]) -> int:
    """
    函数式接口 - 动态规划（空间优化）
    
    实现思路:
    使用动态规划计算最小路径和，优化空间复杂度为O(n)。
    
    Args:
        grid: m×n的网格，包含非负整数
        
    Returns:
        从左上角到右下角的最小路径和
        
    Example:
        >>> min_path_sum([[1,3,1],[1,5,1],[4,2,1]])
        7
    """
    m, n = len(grid), len(grid[0])
    
    # 使用一维数组
    dp = [0] * n
    dp[0] = grid[0][0]
    
    # 初始化第一行
    for j in range(1, n):
        dp[j] = dp[j - 1] + grid[0][j]
    
    # 从第二行开始计算
    for i in range(1, m):
        # 更新第一列
        dp[0] += grid[i][0]
        # 更新其他列
        for j in range(1, n):
            dp[j] = grid[i][j] + min(dp[j], dp[j - 1])
    
    return dp[n - 1]


# 自动生成Solution类（无需手动编写）
Solution = create_solution(min_path_sum)
