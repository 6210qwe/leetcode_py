# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1041
标题: Available Captures for Rook
难度: easy
链接: https://leetcode.cn/problems/available-captures-for-rook/
题目类型: 数组、矩阵、模拟
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
999. 可以被一步捕获的棋子数 - 给定一个 8 x 8 的棋盘，只有一个 白色的车，用字符 'R' 表示。棋盘上还可能存在白色的象 'B' 以及黑色的卒 'p'。空方块用字符 '.' 表示。 车可以按水平或竖直方向（上，下，左，右）移动任意个方格直到它遇到另一个棋子或棋盘的边界。如果它能够在一次移动中移动到棋子的方格，则能够 吃掉 棋子。 注意：车不能穿过其它棋子，比如象和卒。这意味着如果有其它棋子挡住了路径，车就不能够吃掉棋子。 返回白车 攻击 范围内 兵的数量。 示例 1： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2019/02/23/1253_example_1_improved.PNG] 输入：[[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","R",".",".",".","p"],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]] 输出：3 解释： 在本例中，车能够吃掉所有的卒。 示例 2： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2019/02/23/1253_example_2_improved.PNG] 输入：[[".",".",".",".",".",".",".","."],[".","p","p","p","p","p",".","."],[".","p","p","B","p","p",".","."],[".","p","B","R","B","p",".","."],[".","p","p","B","p","p",".","."],[".","p","p","p","p","p",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]] 输出：0 解释： 象阻止了车吃掉任何卒。 示例 3： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2019/02/23/1253_example_3_improved.PNG] 输入：[[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","p",".",".",".","."],["p","p",".","R",".","p","B","."],[".",".",".",".",".",".",".","."],[".",".",".","B",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."]] 输出：3 解释： 车可以吃掉位置 b5，d6 和 f5 的卒。 提示： 1. board.length == 8 2. board[i].length == 8 3. board[i][j] 可以是 'R'，'.'，'B' 或 'p' 4. 只有一个格子上存在 board[i][j] == 'R'
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 从车的位置出发，向四个方向（上、下、左、右）进行搜索，直到遇到棋子或边界。

算法步骤:
1. 找到车的位置。
2. 从车的位置开始，分别向四个方向进行搜索。
3. 如果遇到卒 'p'，计数并停止该方向的搜索。
4. 如果遇到象 'B' 或边界，停止该方向的搜索。

关键点:
- 从车的位置出发，向四个方向进行搜索。
- 使用循环控制搜索方向，避免代码重复。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(1) - 因为棋盘大小固定为 8x8，所以搜索的时间复杂度是常数级。
空间复杂度: O(1) - 只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(board: List[List[str]]) -> int:
    """
    函数式接口 - 计算可以被一步捕获的棋子数
    """
    # 找到车的位置
    for i in range(8):
        for j in range(8):
            if board[i][j] == 'R':
                rook_i, rook_j = i, j
                break
    
    # 定义四个方向
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    count = 0
    
    # 从车的位置开始，向四个方向进行搜索
    for di, dj in directions:
        ni, nj = rook_i + di, rook_j + dj
        while 0 <= ni < 8 and 0 <= nj < 8:
            if board[ni][nj] == 'p':
                count += 1
                break
            elif board[ni][nj] == 'B':
                break
            ni, nj = ni + di, nj + dj
    
    return count


Solution = create_solution(solution_function_name)