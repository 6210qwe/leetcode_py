# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3748
标题: Sort Matrix by Diagonals
难度: medium
链接: https://leetcode.cn/problems/sort-matrix-by-diagonals/
题目类型: 数组、矩阵、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3446. 按对角线进行矩阵排序 - 给你一个大小为 n x n 的整数方阵 grid。返回一个经过如下调整的矩阵： * 左下角三角形（包括中间对角线）的对角线按 非递增顺序 排序。 * 右上角三角形 的对角线按 非递减顺序 排序。 示例 1： 输入： grid = [[1,7,3],[9,8,2],[4,5,6]] 输出： [[8,2,3],[9,6,7],[4,5,1]] 解释： [https://assets.leetcode.com/uploads/2024/12/29/4052example1drawio.png] 标有黑色箭头的对角线（左下角三角形）应按非递增顺序排序： * [1, 8, 6] 变为 [8, 6, 1]。 * [9, 5] 和 [4] 保持不变。 标有蓝色箭头的对角线（右上角三角形）应按非递减顺序排序： * [7, 2] 变为 [2, 7]。 * [3] 保持不变。 示例 2： 输入： grid = [[0,1],[1,2]] 输出： [[2,1],[1,0]] 解释： [https://assets.leetcode.com/uploads/2024/12/29/4052example2adrawio.png] 标有黑色箭头的对角线必须按非递增顺序排序，因此 [0, 2] 变为 [2, 0]。其他对角线已经符合要求。 示例 3： 输入： grid = [[1]] 输出： [[1]] 解释： 只有一个元素的对角线已经符合要求，因此无需修改。 提示： * grid.length == grid[i].length == n * 1 <= n <= 10 * -105 <= grid[i][j] <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 对每个对角线分别进行排序，左下角三角形按非递增顺序排序，右上角三角形按非递减顺序排序。

算法步骤:
1. 遍历矩阵，提取每个对角线的元素。
2. 对左下角三角形的对角线按非递增顺序排序。
3. 对右上角三角形的对角线按非递减顺序排序。
4. 将排序后的对角线元素放回原矩阵。

关键点:
- 使用两个字典分别存储左下角和右上角的对角线元素。
- 对每个对角线进行排序后，再将其放回原矩阵。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2 log n)，其中 n 是矩阵的边长。每个对角线的长度最多为 n，排序的时间复杂度为 O(n log n)，总共有 2n-1 个对角线。
空间复杂度: O(n^2)，用于存储对角线的元素。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def sort_matrix_by_diagonals(grid: List[List[int]]) -> List[List[int]]:
    n = len(grid)
    left_diagonals = {}
    right_diagonals = {}

    # 提取每个对角线的元素
    for i in range(n):
        for j in range(n):
            if i >= j:
                if i - j not in left_diagonals:
                    left_diagonals[i - j] = []
                left_diagonals[i - j].append(grid[i][j])
            else:
                if j - i not in right_diagonals:
                    right_diagonals[j - i] = []
                right_diagonals[j - i].append(grid[i][j])

    # 对左下角三角形的对角线按非递增顺序排序
    for key in left_diagonals:
        left_diagonals[key].sort(reverse=True)

    # 对右上角三角形的对角线按非递减顺序排序
    for key in right_diagonals:
        right_diagonals[key].sort()

    # 将排序后的对角线元素放回原矩阵
    for i in range(n):
        for j in range(n):
            if i >= j:
                grid[i][j] = left_diagonals[i - j].pop(0)
            else:
                grid[i][j] = right_diagonals[j - i].pop(0)

    return grid

Solution = create_solution(sort_matrix_by_diagonals)