# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 483
标题: Smallest Good Base
难度: hard
链接: https://leetcode.cn/problems/smallest-good-base/
题目类型: 数学、二分查找
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
483. 最小好进制 - 以字符串的形式给出 n , 以字符串的形式返回 n 的最小 好进制 。 如果 n 的 k(k>=2) 进制数的所有数位全为1，则称 k(k>=2) 是 n 的一个 好进制 。 示例 1： 输入：n = "13" 输出："3" 解释：13 的 3 进制是 111。 示例 2： 输入：n = "4681" 输出："8" 解释：4681 的 8 进制是 11111。 示例 3： 输入：n = "1000000000000000000" 输出："999999999999999999" 解释：1000000000000000000 的 999999999999999999 进制是 11。 提示： * n 的取值范围是 [3, 1018] * n 没有前导 0
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用数学方法和二分查找来找到最小的好进制。

算法步骤:
1. 将 n 转换为整数。
2. 从 m = log2(n) 开始，逐步减少 m，直到找到满足条件的 k。
3. 对于每个 m，使用二分查找来找到可能的 k。
4. 检查 k 是否满足 (k^m - 1) / (k - 1) == n。
5. 如果找到满足条件的 k，则返回 k。

关键点:
- 使用二分查找来优化 k 的查找过程。
- 注意边界条件，确保 k >= 2。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(log n * log n) - 二分查找的时间复杂度为 O(log n)，外层循环的时间复杂度为 O(log n)。
空间复杂度: O(1) - 只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def smallest_good_base(n: str) -> str:
    """
    函数式接口 - 找到 n 的最小好进制
    
    实现思路:
    使用数学方法和二分查找来找到最小的好进制。
    
    Args:
        n: 字符串形式的整数
        
    Returns:
        返回 n 的最小好进制，字符串形式
        
    Example:
        >>> smallest_good_base("13")
        "3"
        >>> smallest_good_base("4681")
        "8"
        >>> smallest_good_base("1000000000000000000")
        "999999999999999999"
    """
    n = int(n)
    max_m = int(n.bit_length())  # 最大可能的 m 值
    for m in range(max_m, 1, -1):
        k_min = 2
        k_max = int(n ** (1 / m)) + 1
        while k_min < k_max:
            k = (k_min + k_max) // 2
            total = (k ** (m + 1) - 1) // (k - 1)
            if total == n:
                return str(k)
            elif total < n:
                k_min = k + 1
            else:
                k_max = k
    return str(n - 1)


# 自动生成Solution类（无需手动编写）
Solution = create_solution(smallest_good_base)