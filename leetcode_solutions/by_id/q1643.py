# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1643
标题: Number of Nodes in the Sub-Tree With the Same Label
难度: medium
链接: https://leetcode.cn/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/
题目类型: 树、深度优先搜索、广度优先搜索、哈希表、计数
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1519. 子树中标签相同的节点数 - 给你一棵树（即，一个连通的无环无向图），这棵树由编号从 0 到 n - 1 的 n 个节点组成，且恰好有 n - 1 条 edges 。树的根节点为节点 0 ，树上的每一个节点都有一个标签，也就是字符串 labels 中的一个小写字符（编号为 i 的 节点的标签就是 labels[i] ） 边数组 edges 以 edges[i] = [ai, bi] 的形式给出，该格式表示节点 ai 和 bi 之间存在一条边。 返回一个大小为 n 的数组，其中 ans[i] 表示第 i 个节点的子树中与节点 i 标签相同的节点数。 树 T 中的子树是由 T 中的某个节点及其所有后代节点组成的树。 示例 1： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/07/19/q3e1.jpg] 输入：n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], labels = "abaedcd" 输出：[2,1,1,1,1,1,1] 解释：节点 0 的标签为 'a' ，以 'a' 为根节点的子树中，节点 2 的标签也是 'a' ，因此答案为 2 。注意树中的每个节点都是这棵子树的一部分。 节点 1 的标签为 'b' ，节点 1 的子树包含节点 1、4 和 5，但是节点 4、5 的标签与节点 1 不同，故而答案为 1（即，该节点本身）。 示例 2： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/07/19/q3e2.jpg] 输入：n = 4, edges = [[0,1],[1,2],[0,3]], labels = "bbbb" 输出：[4,2,1,1] 解释：节点 2 的子树中只有节点 2 ，所以答案为 1 。 节点 3 的子树中只有节点 3 ，所以答案为 1 。 节点 1 的子树中包含节点 1 和 2 ，标签都是 'b' ，因此答案为 2 。 节点 0 的子树中包含节点 0、1、2 和 3，标签都是 'b'，因此答案为 4 。 示例 3： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/07/19/q3e3.jpg] 输入：n = 5, edges = [[0,1],[0,2],[1,3],[0,4]], labels = "aabab" 输出：[3,2,1,1,1] 提示： * 1 <= n <= 10^5 * edges.length == n - 1 * edges[i].length == 2 * 0 <= ai, bi < n * ai != bi * labels.length == n * labels 仅由小写英文字母组成
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用深度优先搜索 (DFS) 遍历树，并在遍历过程中统计每个节点的子树中各个标签的数量。

算法步骤:
1. 构建树的邻接表表示。
2. 初始化结果数组 `ans`，长度为 `n`，用于存储每个节点的答案。
3. 定义 DFS 函数，递归地遍历每个节点，并在回溯时更新子树中各个标签的数量。
4. 在 DFS 函数中，使用一个字典 `count` 来记录当前子树中各个标签的数量。
5. 对于每个节点，更新其子树中对应标签的数量，并将结果存储在 `ans` 数组中。

关键点:
- 使用 DFS 遍历树，并在回溯时更新子树中各个标签的数量。
- 使用字典来记录每个节点子树中各个标签的数量。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是节点的数量。每个节点和每条边只会被访问一次。
空间复杂度: O(n)，递归调用栈的深度最多为 n，同时需要额外的空间来存储每个节点的子树中各个标签的数量。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def countSubTrees(n: int, edges: List[List[int]], labels: str) -> List[int]:
    # 构建树的邻接表表示
    tree = [[] for _ in range(n)]
    for u, v in edges:
        tree[u].append(v)
        tree[v].append(u)

    # 结果数组
    ans = [0] * n

    def dfs(node: int, parent: int):
        # 记录当前子树中各个标签的数量
        count = {labels[node]: 1}
        for child in tree[node]:
            if child != parent:
                child_count = dfs(child, node)
                for label, cnt in child_count.items():
                    count[label] = count.get(label, 0) + cnt
        ans[node] = count[labels[node]]
        return count

    # 从根节点开始进行 DFS
    dfs(0, -1)
    return ans

Solution = create_solution(countSubTrees)