# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1461
标题: Count All Valid Pickup and Delivery Options
难度: hard
链接: https://leetcode.cn/problems/count-all-valid-pickup-and-delivery-options/
题目类型: 数学、动态规划、组合数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1359. 有效的快递序列数目 - 给你 n 笔订单，每笔订单都需要快递服务。 计算所有有效的 取货 / 交付 可能的顺序，使 delivery(i) 总是在 pickup(i) 之后。 由于答案可能很大，请返回答案对 10^9 + 7 取余的结果。 示例 1： 输入：n = 1 输出：1 解释：只有一种序列 (P1, D1)，物品 1 的配送服务（D1）在物品 1 的收件服务（P1）后。 示例 2： 输入：n = 2 输出：6 解释：所有可能的序列包括： (P1,P2,D1,D2)，(P1,P2,D2,D1)，(P1,D1,P2,D2)，(P2,P1,D1,D2)，(P2,P1,D2,D1) 和 (P2,D2,P1,D1)。 (P1,D2,P2,D1) 是一个无效的序列，因为物品 2 的收件服务（P2）不应在物品 2 的配送服务（D2）之后。 示例 3： 输入：n = 3 输出：90 提示： * 1 <= n <= 500
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用组合数学和动态规划来计算所有有效的取货/交付顺序。

算法步骤:
1. 初始化结果为 1。
2. 对于每一个新的订单，计算可以插入的新位置数。
3. 更新结果，并对结果取模。

关键点:
- 使用组合数学中的插空法来计算新订单的插入位置。
- 通过动态规划的思想逐步累乘结果。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(1)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def count_orders(n: int) -> int:
    """
    函数式接口 - 计算所有有效的取货/交付顺序
    """
    MOD = 10**9 + 7
    result = 1
    
    for i in range(1, n + 1):
        # 插入第 i 个订单时，有 (2*i - 1) 个位置可以插入 P_i
        # 之后有 (2*i) 个位置可以插入 D_i
        result = result * i * (2 * i - 1) % MOD
    
    return result


Solution = create_solution(count_orders)