# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 100339
标题: 统计结果概率
难度: medium
链接: https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/
题目类型: 数学、动态规划、概率与统计
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCR 185. 统计结果概率 - 你选择掷出 num 个色子，请返回所有点数总和的概率。 你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 num 个骰子所能掷出的点数集合中第 i 小的那个的概率。 示例 1： 输入：num = 3 输出：[0.00463,0.01389,0.02778,0.04630,0.06944,0.09722,0.11574,0.12500,0.12500,0.11574,0.09722,0.06944,0.04630,0.02778,0.01389,0.00463] 示例 2： 输入：num = 5 输出:[0.00013,0.00064,0.00193,0.00450,0.00900,0.01620,0.02636,0.03922,0.05401,0.06944,0.08372,0.09452,0.10031,0.10031,0.09452,0.08372,0.06944,0.05401,0.03922,0.02636,0.01620,0.00900,0.00450,0.00193,0.00064,0.00013] 提示： * 1 <= num <= 11
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来计算每个点数总和的概率。

算法步骤:
1. 初始化一个二维数组 dp，其中 dp[i][j] 表示前 i 个骰子掷出点数 j 的次数。
2. 初始化第一个骰子的情况，dp[1][j] = 1 (1 <= j <= 6)。
3. 对于每个后续的骰子，更新 dp 数组，使用前一个骰子的结果来计算当前骰子的结果。
4. 计算总的可能性数量，即 6^num。
5. 将 dp 数组中的次数转换为概率，并返回结果。

关键点:
- 使用动态规划来避免重复计算。
- 只保留前一个骰子的结果以节省空间。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * m)，其中 n 是骰子的数量，m 是每个骰子的面数（固定为 6）。
空间复杂度: O(n * (n * m))，简化后为 O(n^2)，因为需要存储每个点数总和的可能性。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def solution_function_name(num: int) -> List[float]:
    """
    函数式接口 - 返回 num 个骰子掷出的所有点数总和的概率
    """
    if num < 1:
        return []

    # 初始化 dp 数组
    dp = [[0] * (num * 6 + 1) for _ in range(2)]
    total_faces = 6
    old, now = 0, 0

    # 初始化第一个骰子的情况
    for i in range(1, total_faces + 1):
        dp[now][i] = 1

    # 动态规划计算每个点数总和的可能性
    for i in range(2, num + 1):
        old = now
        now = 1 - now
        for j in range(i):
            dp[now][j] = 0
        for j in range(i, i * total_faces + 1):
            dp[now][j] = 0
            for k in range(1, min(total_faces, j) + 1):
                dp[now][j] += dp[old][j - k]

    # 计算总的可能性数量
    total = 6 ** num

    # 将 dp 数组中的次数转换为概率
    result = [dp[now][i] / total for i in range(num, num * total_faces + 1)]

    return result

Solution = create_solution(solution_function_name)