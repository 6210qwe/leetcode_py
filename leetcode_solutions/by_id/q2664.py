# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2664
标题: Maximize Greatness of an Array
难度: medium
链接: https://leetcode.cn/problems/maximize-greatness-of-an-array/
题目类型: 贪心、数组、双指针、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2592. 最大化数组的伟大值 - 给你一个下标从 0 开始的整数数组 nums 。你需要将 nums 重新排列成一个新的数组 perm 。 定义 nums 的 伟大值 为满足 0 <= i < nums.length 且 perm[i] > nums[i] 的下标数目。 请你返回重新排列 nums 后的 最大 伟大值。 示例 1： 输入：nums = [1,3,5,2,1,3,1] 输出：4 解释：一个最优安排方案为 perm = [2,5,1,3,3,1,1] 。 在下标为 0, 1, 3 和 4 处，都有 perm[i] > nums[i] 。因此我们返回 4 。 示例 2： 输入：nums = [1,2,3,4] 输出：3 解释：最优排列为 [2,3,4,1] 。 在下标为 0, 1 和 2 处，都有 perm[i] > nums[i] 。因此我们返回 3 。 提示： * 1 <= nums.length <= 105 * 0 <= nums[i] <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过排序和双指针的方法来最大化伟大值。

算法步骤:
1. 对数组进行排序。
2. 使用两个指针 `i` 和 `j`，其中 `i` 指向当前处理的元素，`j` 指向下一个可能的大于 `nums[i]` 的元素。
3. 如果 `nums[j] > nums[i]`，则 `j` 指向的元素可以用于 `perm[i]`，并移动 `i` 和 `j`。
4. 如果 `nums[j] <= nums[i]`，则继续移动 `j` 直到找到一个大于 `nums[i]` 的元素。
5. 重复上述步骤直到遍历完数组。

关键点:
- 通过排序和双指针的方法，确保每次选择的 `perm[i]` 都是尽可能小但大于 `nums[i]` 的元素。
- 这样可以最大化伟大值。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n) - 排序的时间复杂度。
空间复杂度: O(1) - 除了输入和输出外，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(nums: List[int]) -> int:
    """
    函数式接口 - 返回重新排列 nums 后的最大伟大值
    """
    # 对数组进行排序
    nums.sort()
    
    n = len(nums)
    i, j = 0, 0
    greatness = 0
    
    while i < n and j < n:
        if nums[j] > nums[i]:
            # 找到一个大于 nums[i] 的元素
            greatness += 1
            i += 1
            j += 1
        else:
            # 继续寻找大于 nums[i] 的元素
            j += 1
    
    return greatness


Solution = create_solution(solution_function_name)