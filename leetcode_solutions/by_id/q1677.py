# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1677
标题: Matrix Diagonal Sum
难度: easy
链接: https://leetcode.cn/problems/matrix-diagonal-sum/
题目类型: 数组、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1572. 矩阵对角线元素的和 - 给你一个正方形矩阵 mat，请你返回矩阵对角线元素的和。 请你返回在矩阵主对角线上的元素和副对角线上且不在主对角线上元素的和。 示例 1： [https://assets.leetcode.com/uploads/2020/08/14/sample_1911.png] 输入：mat = [[1,2,3], [4,5,6], [7,8,9]] 输出：25 解释：对角线的和为：1 + 5 + 9 + 3 + 7 = 25 请注意，元素 mat[1][1] = 5 只会被计算一次。 示例 2： 输入：mat = [[1,1,1,1], [1,1,1,1], [1,1,1,1], [1,1,1,1]] 输出：8 示例 3： 输入：mat = [[5]] 输出：5 提示： * n == mat.length == mat[i].length * 1 <= n <= 100 * 1 <= mat[i][j] <= 100
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 遍历矩阵，累加主对角线和副对角线上的元素。如果主对角线和副对角线有重叠的元素（即中心元素），只计算一次。

算法步骤:
1. 初始化总和为0。
2. 遍历矩阵的每一行，累加主对角线和副对角线上的元素。
3. 如果当前元素是中心元素，只计算一次。

关键点:
- 主对角线元素的索引为 (i, i)。
- 副对角线元素的索引为 (i, n-i-1)。
- 如果 n 是奇数，中心元素需要只计算一次。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是矩阵的边长。我们只需要遍历一次矩阵。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(mat: List[List[int]]) -> int:
    """
    函数式接口 - 计算矩阵对角线元素的和
    """
    n = len(mat)
    total_sum = 0
    
    for i in range(n):
        # 主对角线元素
        total_sum += mat[i][i]
        # 副对角线元素
        if i != n - i - 1:
            total_sum += mat[i][n - i - 1]
    
    return total_sum


Solution = create_solution(solution_function_name)