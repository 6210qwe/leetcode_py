# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 630
标题: Course Schedule III
难度: hard
链接: https://leetcode.cn/problems/course-schedule-iii/
题目类型: 贪心、数组、排序、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
630. 课程表 III - 这里有 n 门不同的在线课程，按从 1 到 n 编号。给你一个数组 courses ，其中 courses[i] = [durationi, lastDayi] 表示第 i 门课将会 持续 上 durationi 天课，并且必须在不晚于 lastDayi 的时候完成。 你的学期从第 1 天开始。且不能同时修读两门及两门以上的课程。 返回你最多可以修读的课程数目。 示例 1： 输入：courses = [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]] 输出：3 解释： 这里一共有 4 门课程，但是你最多可以修 3 门： 首先，修第 1 门课，耗费 100 天，在第 100 天完成，在第 101 天开始下门课。 第二，修第 3 门课，耗费 1000 天，在第 1100 天完成，在第 1101 天开始下门课程。 第三，修第 2 门课，耗时 200 天，在第 1300 天完成。 第 4 门课现在不能修，因为将会在第 3300 天完成它，这已经超出了关闭日期。 示例 2： 输入：courses = [[1,2]] 输出：1 示例 3： 输入：courses = [[3,2],[4,3]] 输出：0 提示: * 1 <= courses.length <= 104 * 1 <= durationi, lastDayi <= 104
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用贪心算法和最大堆来解决这个问题。首先按课程的结束时间进行排序，然后使用一个最大堆来记录当前已选课程的持续时间。每次选择一个课程时，如果当前时间加上该课程的持续时间不超过其结束时间，则将其加入堆中；否则，检查堆中的最大持续时间课程是否可以被替换以减少总时间。

算法步骤:
1. 按课程的结束时间进行排序。
2. 初始化当前时间和一个最大堆。
3. 遍历排序后的课程列表：
   - 如果当前时间加上该课程的持续时间不超过其结束时间，则将该课程的持续时间加入堆中，并更新当前时间。
   - 否则，检查堆中的最大持续时间课程是否可以被替换以减少总时间。
4. 堆的大小即为最多可以修读的课程数目。

关键点:
- 使用最大堆来记录当前已选课程的持续时间，以便在必要时替换最长的课程。
- 按课程的结束时间进行排序，确保尽早完成课程。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是课程的数量。排序操作的时间复杂度为 O(n log n)，遍历和堆操作的时间复杂度为 O(n log n)。
空间复杂度: O(n)，用于存储最大堆。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def schedule_course(courses: List[List[int]]) -> int:
    """
    函数式接口 - 返回最多可以修读的课程数目
    """
    # 按课程的结束时间进行排序
    courses.sort(key=lambda x: x[1])
    
    current_time = 0
    max_heap = []
    
    for duration, last_day in courses:
        if current_time + duration <= last_day:
            # 如果当前时间加上该课程的持续时间不超过其结束时间，则将该课程的持续时间加入堆中
            current_time += duration
            heapq.heappush(max_heap, -duration)
        elif max_heap and -max_heap[0] > duration:
            # 否则，检查堆中的最大持续时间课程是否可以被替换以减少总时间
            current_time += duration + heapq.heappop(max_heap)
            heapq.heappush(max_heap, -duration)
    
    return len(max_heap)

Solution = create_solution(schedule_course)