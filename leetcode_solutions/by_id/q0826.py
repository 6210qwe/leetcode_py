# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 826
标题: Soup Servings
难度: medium
链接: https://leetcode.cn/problems/soup-servings/
题目类型: 数学、动态规划、概率与统计
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
808. 分汤 - 你有两种汤，A 和 B，每种初始为 n 毫升。在每一轮中，会随机选择以下四种操作中的一种，每种操作的概率为 0.25，且与之前的所有轮次 无关： 1. 从汤 A 取 100 毫升，从汤 B 取 0 毫升 2. 从汤 A 取 75 毫升，从汤 B 取 25 毫升 3. 从汤 A 取 50 毫升，从汤 B 取 50 毫升 4. 从汤 A 取 25 毫升，从汤 B 取 75 毫升 注意： * 不存在从汤 A 取 0 ml 和从汤 B 取 100 ml 的操作。 * 汤 A 和 B 在每次操作中同时被取出。 * 如果一次操作要求你取出比剩余的汤更多的量，请取出该汤剩余的所有部分。 操作过程在任何回合中任一汤被取完后立即停止。 返回汤 A 在 B 前取完的概率，加上两种汤在 同一回合 取完概率的一半。返回值在正确答案 10-5 的范围内将被认为是正确的。 示例 1: 输入：n = 50 输出：0.62500 解释： 如果我们选择前两个操作，A 首先将变为空。 对于第三个操作，A 和 B 会同时变为空。 对于第四个操作，B 首先将变为空。 所以 A 变为空的总概率加上 A 和 B 同时变为空的概率的一半是 0.25 *(1 + 1 + 0.5 + 0)= 0.625。 示例 2: 输入：n = 100 输出：0.71875 解释： 如果我们选择第一个操作，A 首先将变为空。 如果我们选择第二个操作，A 将在执行操作 [1, 2, 3] 时变为空，然后 A 和 B 在执行操作 4 时同时变空。 如果我们选择第三个操作，A 将在执行操作 [1, 2] 时变为空，然后 A 和 B 在执行操作 3 时同时变空。 如果我们选择第四个操作，A 将在执行操作 1 时变为空，然后 A 和 B 在执行操作 2 时同时变空。 所以 A 变为空的总概率加上 A 和 B 同时变为空的概率的一半是 0.71875。 提示: * 0 <= n <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来计算每个状态的概率。

算法步骤:
1. 如果 n 太大（例如大于 4800），直接返回 1，因为概率接近 1。
2. 将 n 转换为单位为 100 的数量，即 N = (n + 24) // 25。
3. 使用一个二维数组 dp 来存储每个状态的概率。
4. 初始化 dp 数组，dp[i][j] 表示 A 还剩 i 单位，B 还剩 j 单位时的概率。
5. 递归地计算每个状态的概率，直到达到基本情况。

关键点:
- 使用记忆化搜索来避免重复计算。
- 递归地计算每个状态的概率，并考虑四种操作。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(N^2)，其中 N = (n + 24) // 25。
空间复杂度: O(N^2)，用于存储 dp 数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def soup_servings(n: int) -> float:
    if n > 4800:
        return 1.0
    
    N = (n + 24) // 25
    memo = {}

    def dp(i: int, j: int) -> float:
        if (i, j) in memo:
            return memo[(i, j)]
        
        if i <= 0 and j <= 0:
            return 0.5
        if i <= 0:
            return 1.0
        if j <= 0:
            return 0.0
        
        memo[(i, j)] = 0.25 * (dp(i - 4, j) + dp(i - 3, j - 1) + dp(i - 2, j - 2) + dp(i - 1, j - 3))
        return memo[(i, j)]
    
    return dp(N, N)


Solution = create_solution(soup_servings)