# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 823
标题: Split Array With Same Average
难度: hard
链接: https://leetcode.cn/problems/split-array-with-same-average/
题目类型: 位运算、数组、数学、动态规划、状态压缩
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
805. 数组的均值分割 - 给定你一个整数数组 nums 我们要将 nums 数组中的每个元素移动到 A 数组 或者 B 数组中，使得 A 数组和 B 数组不为空，并且 average(A) == average(B) 。 如果可以完成则返回true ， 否则返回 false 。 注意：对于数组 arr , average(arr) 是 arr 的所有元素的和除以 arr 长度。 示例 1: 输入: nums = [1,2,3,4,5,6,7,8] 输出: true 解释: 我们可以将数组分割为 [1,4,5,8] 和 [2,3,6,7], 他们的平均值都是4.5。 示例 2: 输入: nums = [3,1] 输出: false 提示: * 1 <= nums.length <= 30 * 0 <= nums[i] <= 104
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划和状态压缩来解决这个问题。我们尝试找到一个子集，使得它的和是总和的一个特定比例。

算法步骤:
1. 计算数组的总和 `total_sum` 和长度 `n`。
2. 如果 `n` 小于等于 1，直接返回 `False`。
3. 使用状态压缩 DP 来记录可能的子集和及其对应的元素数量。
4. 遍历所有可能的子集大小 `k`（从 1 到 `n // 2`），检查是否存在一个子集使得其和为 `total_sum * k / n`。
5. 如果找到这样的子集，返回 `True`；否则，返回 `False`。

关键点:
- 使用状态压缩 DP 来记录可能的子集和及其对应的元素数量。
- 通过遍历所有可能的子集大小来优化搜索空间。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * 2^n)
空间复杂度: O(2^n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def can_split_array(nums: List[int]) -> bool:
    n = len(nums)
    if n <= 1:
        return False
    
    total_sum = sum(nums)
    dp = [set() for _ in range(n + 1)]
    dp[0].add(0)
    
    for num in nums:
        for i in range(n, 0, -1):
            for x in dp[i - 1]:
                dp[i].add(x + num)
    
    for i in range(1, n // 2 + 1):
        if (i * total_sum) % n == 0 and (i * total_sum) // n in dp[i]:
            return True
    
    return False

Solution = create_solution(can_split_array)