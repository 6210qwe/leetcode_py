# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000480
标题: 弹珠游戏
难度: medium
链接: https://leetcode.cn/problems/EXvqDp/
题目类型: 深度优先搜索、广度优先搜索、图、拓扑排序、记忆化搜索、数组、动态规划、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCP 63. 弹珠游戏 - 欢迎各位来到「力扣嘉年华」，接下来将为各位介绍在活动中广受好评的弹珠游戏。 `N*M` 大小的弹珠盘的初始状态信息记录于一维字符串型数组 `plate` 中，数组中的每个元素为仅由 `"O"`、`"W"`、`"E"`、`"."` 组成的字符串。其中： - `"O"` 表示弹珠洞（弹珠到达后会落入洞中，并停止前进）； - `"W"` 表示逆时针转向器（弹珠经过时方向将逆时针旋转 90 度）； - `"E"` 表示顺时针转向器（弹珠经过时方向将顺时针旋转 90 度）； - `"."` 表示空白区域（弹珠可通行）。 游戏规则要求仅能在边缘位置的 **空白区域** 处（弹珠盘的四角除外）沿 **与边缘垂直** 的方向打入弹珠，并且打入后的每颗弹珠最多能 **前进** `num` 步。请返回符合上述要求且可以使弹珠最终入洞的所有打入位置。你可以 **按任意顺序** 返回答案。 **注意：** - 若弹珠已到达弹珠盘边缘并且仍沿着出界方向继续前进，则将直接出界。 **示例 1：** > 输入： >`num = 4` >`plate = ["..E.",".EOW","..W."]` > > 输出：`[[2,1]]` > > 解释： > 在 `[2,1]` 处打入弹珠，弹珠前进 1 步后遇到转向器，前进方向顺时针旋转 90 度，再前进 1 步进入洞中。 ![b054955158a99167b8d51da0e22a54da.gif](https://pic.leetcode.cn/1630392649-BoQncz-b054955158a99167b8d51da0e22a54da.gif){:width="300px"} **示例 2：** > 输入： >`num = 5` >`plate = [".....","..E..",".WO..","....."]` > > 输出：`[[0,1],[1,0],[2,4],[3,2]]` > > 解释： > 在 `[0,1]` 处打入弹珠，弹珠前进 2 步，遇到转向器后前进方向逆时针旋转 90 度，再前进 1 步进入洞中。 > 在 `[1,0]` 处打入弹珠，弹珠前进 2 步，遇到转向器后前进方向顺时针旋转 90 度，再前进 1 步进入洞中。 > 在 `[2,4]` 处打入弹珠，弹珠前进 2 步后进入洞中。 > 在 `[3,2]` 处打入弹珠，弹珠前进 1 步后进入洞中。 ![b44e9963239ae368badf3d00b7563087.gif](https://pic.leetcode.cn/1630392625-rckbdy-b44e9963239ae368badf3d00b7563087.gif){:width="350px"} **示例 3：** > 输入： >`num = 3` >`plate = [".....","....O","....O","....."]` > > 输出：`[]` > > 解释： > 由于弹珠被击中后只能前进 3 步，且不能在弹珠洞和弹珠盘四角打入弹珠，故不存在能让弹珠入洞的打入位置。 **提示：** - `1 <= num <= 10^6` - `1 <= plate.length, plate[i].length <= 1000` - `plate[i][j]` 仅包含 `"O"`、`"W"`、`"E"`、`"."`
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用深度优先搜索 (DFS) 来模拟弹珠的移动过程。

算法步骤:
1. 初始化一个结果列表来存储所有有效的打入位置。
2. 遍历弹珠盘的边缘位置，找到所有可以打入弹珠的位置。
3. 对于每个可以打入弹珠的位置，使用 DFS 模拟弹珠的移动过程，检查是否可以在规定的步数内进入洞中。
4. 如果可以进入洞中，则将该位置加入结果列表。

关键点:
- 使用方向数组来表示弹珠的移动方向。
- 使用递归来实现 DFS。
- 在 DFS 过程中，处理转向器对弹珠方向的影响。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(N * M * num)，其中 N 和 M 分别是弹珠盘的行数和列数，num 是弹珠的最大步数。
空间复杂度: O(N * M)，用于存储访问过的状态。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution

def find_marble_positions(num: int, plate: List[str]) -> List[List[int]]:
    """
    函数式接口 - 找到所有可以使弹珠最终入洞的打入位置
    """
    if not plate or not plate[0]:
        return []

    n, m = len(plate), len(plate[0])
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # 右、下、左、上
    result = []

    def dfs(x, y, direction, steps):
        if steps > num:
            return False
        if x < 0 or x >= n or y < 0 or y >= m:
            return False
        if plate[x][y] == "O":
            return True
        if plate[x][y] == "W":
            direction = (direction + 1) % 4
        elif plate[x][y] == "E":
            direction = (direction - 1) % 4
        dx, dy = directions[direction]
        return dfs(x + dx, y + dy, direction, steps + 1)

    for i in range(n):
        for j in range(m):
            if (i == 0 or i == n - 1 or j == 0 or j == m - 1) and plate[i][j] == ".":
                if (i == 0 and j == 0) or (i == 0 and j == m - 1) or (i == n - 1 and j == 0) or (i == n - 1 and j == m - 1):
                    continue
                if i == 0:
                    if dfs(i, j, 1, 0):
                        result.append([i, j])
                elif i == n - 1:
                    if dfs(i, j, 3, 0):
                        result.append([i, j])
                elif j == 0:
                    if dfs(i, j, 0, 0):
                        result.append([i, j])
                elif j == m - 1:
                    if dfs(i, j, 2, 0):
                        result.append([i, j])

    return result

Solution = create_solution(find_marble_positions)