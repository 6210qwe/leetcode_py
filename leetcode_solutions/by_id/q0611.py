# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 611
标题: Valid Triangle Number
难度: medium
链接: https://leetcode.cn/problems/valid-triangle-number/
题目类型: 贪心、数组、双指针、二分查找、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
611. 有效三角形的个数 - 给定一个包含非负整数的数组 nums ，返回其中可以组成三角形三条边的三元组个数。 示例 1: 输入: nums = [2,2,3,4] 输出: 3 解释:有效的组合是: 2,3,4 (使用第一个 2) 2,3,4 (使用第二个 2) 2,2,3 示例 2: 输入: nums = [4,2,3,4] 输出: 4 提示: * 1 <= nums.length <= 1000 * 0 <= nums[i] <= 1000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用双指针法，先对数组进行排序，然后遍历数组，对于每个元素，使用双指针找到所有满足条件的三元组。

算法步骤:
1. 对数组进行排序。
2. 遍历数组，从最后一个元素开始，设为当前最大边。
3. 使用双指针，左指针指向第一个元素，右指针指向当前最大边前一个元素。
4. 如果左指针和右指针所指的两个元素之和大于当前最大边，则说明从左指针到右指针之间的所有元素与这两个元素都可以组成三角形，计数器加上右指针与左指针的距离。
5. 否则，移动左指针向右。
6. 重复步骤4和5，直到左指针和右指针相遇。
7. 移动最大边指针向前，重复步骤3到6，直到遍历完数组。

关键点:
- 排序后使用双指针可以高效地找到所有满足条件的三元组。
- 通过计算左右指针之间的距离来快速统计满足条件的三元组数量。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2)，其中 n 是数组的长度。排序的时间复杂度为 O(n log n)，双指针遍历的时间复杂度为 O(n^2)。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(nums: List[int]) -> int:
    """
    函数式接口 - 返回可以组成三角形的三元组个数
    """
    nums.sort()  # 先对数组进行排序
    n = len(nums)
    count = 0

    for i in range(n - 1, 1, -1):
        left, right = 0, i - 1
        while left < right:
            if nums[left] + nums[right] > nums[i]:
                count += right - left
                right -= 1
            else:
                left += 1

    return count


Solution = create_solution(solution_function_name)