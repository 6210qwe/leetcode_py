# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3314
标题: Most Frequent Prime
难度: medium
链接: https://leetcode.cn/problems/most-frequent-prime/
题目类型: 数组、哈希表、数学、计数、枚举、矩阵、数论
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3044. 出现频率最高的质数 - 给你一个大小为 m x n 、下标从 0 开始的二维矩阵 mat 。在每个单元格，你可以按以下方式生成数字： * 最多有 8 条路径可以选择：东，东南，南，西南，西，西北，北，东北。 * 选择其中一条路径，沿着这个方向移动，并且将路径上的数字添加到正在形成的数字后面。 * 注意，每一步都会生成数字，例如，如果路径上的数字是 1, 9, 1，那么在这个方向上会生成三个数字：1, 19, 191 。 返回在遍历矩阵所创建的所有数字中，出现频率最高的、大于 10的质数；如果不存在这样的质数，则返回 -1 。如果存在多个出现频率最高的质数，那么返回其中最大的那个。 注意：移动过程中不允许改变方向。 示例 1： [https://assets.leetcode.com/uploads/2024/02/15/south] 输入：mat = [[1,1],[9,9],[1,1]] 输出：19 解释： 从单元格 (0,0) 出发，有 3 个可能的方向，这些方向上可以生成的大于 10 的数字有： 东方向: [11], 东南方向: [19], 南方向: [19,191] 。 从单元格 (0,1) 出发，所有可能方向上生成的大于 10 的数字有：[19,191,19,11] 。 从单元格 (1,0) 出发，所有可能方向上生成的大于 10 的数字有：[99,91,91,91,91] 。 从单元格 (1,1) 出发，所有可能方向上生成的大于 10 的数字有：[91,91,99,91,91] 。 从单元格 (2,0) 出发，所有可能方向上生成的大于 10 的数字有：[11,19,191,19] 。 从单元格 (2,1) 出发，所有可能方向上生成的大于 10 的数字有：[11,19,19,191] 。 在所有生成的数字中，出现频率最高的质数是 19 。 示例 2： 输入：mat = [[7]] 输出：-1 解释：唯一可以生成的数字是 7 。它是一个质数，但不大于 10 ，所以返回 -1 。 示例 3： 输入：mat = [[9,7,8],[4,6,5],[2,8,6]] 输出：97 解释： 从单元格 (0,0) 出发，所有可能方向上生成的大于 10 的数字有: [97,978,96,966,94,942] 。 从单元格 (0,1) 出发，所有可能方向上生成的大于 10 的数字有: [78,75,76,768,74,79] 。 从单元格 (0,2) 出发，所有可能方向上生成的大于 10 的数字有: [85,856,86,862,87,879] 。 从单元格 (1,0) 出发，所有可能方向上生成的大于 10 的数字有: [46,465,48,42,49,47] 。 从单元格 (1,1) 出发，所有可能方向上生成的大于 10 的数字有: [65,66,68,62,64,69,67,68] 。 从单元格 (1,2) 出发，所有可能方向上生成的大于 10 的数字有: [56,58,56,564,57,58] 。 从单元格 (2,0) 出发，所有可能方向上生成的大于 10 的数字有: [28,286,24,249,26,268] 。 从单元格 (2,1) 出发，所有可能方向上生成的大于 10 的数字有: [86,82,84,86,867,85] 。 从单元格 (2,2) 出发，所有可能方向上生成的大于 10 的数字有: [68,682,66,669,65,658] 。 在所有生成的数字中，出现频率最高的质数是 97 。 提示： * m == mat.length * n == mat[i].length * 1 <= m, n <= 6 * 1 <= mat[i][j] <= 9
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想:
1. 从每个单元格出发，沿8个方向生成所有可能的数字。
2. 检查生成的数字是否为质数且大于10。
3. 统计每个质数的出现频率。
4. 返回出现频率最高的质数，如果有多个则返回最大的那个。

算法步骤:
1. 定义一个函数来检查一个数是否为质数。
2. 使用一个字典来记录每个质数的出现频率。
3. 遍历矩阵中的每个单元格，沿8个方向生成所有可能的数字。
4. 如果生成的数字是质数且大于10，则更新字典中的频率。
5. 找出出现频率最高的质数，如果有多个则返回最大的那个。

关键点:
- 生成所有可能的数字时，需要考虑路径上的数字组合。
- 质数检查函数需要高效。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m * n * 8 * max(m, n))，其中m和n是矩阵的行数和列数。每个单元格最多有8个方向，每个方向最多有max(m, n)个数字。
空间复杂度: O(m * n * 8 * max(m, n))，用于存储生成的数字及其频率。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution

def is_prime(num: int) -> bool:
    if num <= 1:
        return False
    if num <= 3:
        return True
    if num % 2 == 0 or num % 3 == 0:
        return False
    i = 5
    while i * i <= num:
        if num % i == 0 or num % (i + 2) == 0:
            return False
        i += 6
    return True

def solution_function_name(mat: List[List[int]]) -> int:
    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]
    m, n = len(mat), len(mat[0])
    prime_count = {}
    
    for i in range(m):
        for j in range(n):
            for dx, dy in directions:
                x, y = i, j
                num = 0
                while 0 <= x < m and 0 <= y < n:
                    num = num * 10 + mat[x][y]
                    if num > 10 and is_prime(num):
                        prime_count[num] = prime_count.get(num, 0) + 1
                    x += dx
                    y += dy
    
    if not prime_count:
        return -1
    
    max_freq = max(prime_count.values())
    return max(num for num, freq in prime_count.items() if freq == max_freq)

Solution = create_solution(solution_function_name)