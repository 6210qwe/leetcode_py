# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2687
标题: Lexicographically Smallest Beautiful String
难度: hard
链接: https://leetcode.cn/problems/lexicographically-smallest-beautiful-string/
题目类型: 贪心、字符串
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2663. 字典序最小的美丽字符串 - 如果一个字符串满足以下条件，则称其为 美丽字符串 ： * 它由英语小写字母表的前 k 个字母组成。 * 它不包含任何长度为 2 或更长的回文子字符串。 给你一个长度为 n 的美丽字符串 s 和一个正整数 k 。 请你找出并返回一个长度为 n 的美丽字符串，该字符串还满足：在字典序大于 s 的所有美丽字符串中字典序最小。如果不存在这样的字符串，则返回一个空字符串。 对于长度相同的两个字符串 a 和 b ，如果字符串 a 在与字符串 b 不同的第一个位置上的字符字典序更大，则字符串 a 的字典序大于字符串 b 。 * 例如，"abcd" 的字典序比 "abcc" 更大，因为在不同的第一个位置（第四个字符）上 d 的字典序大于 c 。 示例 1： 输入：s = "abcz", k = 26 输出："abda" 解释：字符串 "abda" 既是美丽字符串，又满足字典序大于 "abcz" 。 可以证明不存在字符串同时满足字典序大于 "abcz"、美丽字符串、字典序小于 "abda" 这三个条件。 示例 2： 输入：s = "dc", k = 4 输出："" 解释：可以证明，不存在既是美丽字符串，又字典序大于 "dc" 的字符串。 提示： * 1 <= n == s.length <= 105 * 4 <= k <= 26 * s 是一个美丽字符串
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用贪心算法，从后向前遍历字符串，找到第一个可以修改的位置，并确保修改后的字符串仍然是美丽字符串。

算法步骤:
1. 从后向前遍历字符串，找到第一个可以修改的位置。
2. 修改该位置的字符，使其成为下一个合法字符。
3. 从该位置向后重新构造字符串，确保新字符串是美丽字符串且字典序最小。

关键点:
- 从后向前遍历，确保修改后的字符串字典序最小。
- 通过检查前一个和后一个字符来避免回文子字符串。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(1)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(s: str, k: int) -> str:
    """
    函数式接口 - 返回字典序最小的美丽字符串
    """
    def is_beautiful(ch, prev, next_ch):
        return ch != prev and (next_ch is None or ch != next_ch)

    n = len(s)
    s = list(s)
    
    for i in range(n - 1, -1, -1):
        for j in range(ord(s[i]) + 1, ord('a') + k):
            ch = chr(j)
            if is_beautiful(ch, s[i - 1] if i > 0 else None, s[i + 1] if i < n - 1 else None):
                s[i] = ch
                for j in range(i + 1, n):
                    for k in range(ord('a'), ord('a') + k):
                        ch = chr(k)
                        if is_beautiful(ch, s[j - 1], s[j + 1] if j < n - 1 else None):
                            s[j] = ch
                            break
                    else:
                        return ""
                return "".join(s)
    
    return ""


Solution = create_solution(solution_function_name)