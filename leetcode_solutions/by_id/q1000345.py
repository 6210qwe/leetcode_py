# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000345
标题: 不同路径
难度: medium
链接: https://leetcode.cn/problems/2AoeFn/
题目类型: 数学、动态规划、组合数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCR 098. 不同路径 - 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？ 示例 1： [https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png] 输入：m = 3, n = 7 输出：28 示例 2： 输入：m = 3, n = 2 输出：3 解释： 从左上角开始，总共有 3 条路径可以到达右下角。 1. 向右 -> 向下 -> 向下 2. 向下 -> 向下 -> 向右 3. 向下 -> 向右 -> 向下 示例 3： 输入：m = 7, n = 3 输出：28 示例 4： 输入：m = 3, n = 3 输出：6 提示： * 1 <= m, n <= 100 * 题目数据保证答案小于等于 2 * 109 注意：本题与主站 62 题相同： https://leetcode.cn/problems/unique-paths/ [https://leetcode.cn/problems/unique-paths/]
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 动态规划，dp[i][j]表示到达(i,j)的路径数

算法步骤:
1. dp[i][j] = dp[i-1][j] + dp[i][j-1]
2. 第一行和第一列都是1
3. 也可以使用组合数学：C(m+n-2, m-1)

关键点:
- 动态规划或组合数学
- 时间复杂度O(m*n)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m*n) - 遍历网格
空间复杂度: O(n) - 可以优化到O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def unique_paths(m: int, n: int) -> int:
    """
    函数式接口 - 不同路径
    
    实现思路:
    动态规划：dp[i][j]表示到达(i,j)的路径数。
    
    Args:
        m: 行数
        n: 列数
        
    Returns:
        不同路径的数量
        
    Example:
        >>> unique_paths(3, 7)
        28
    """
    # 优化空间：只使用一维数组
    dp = [1] * n
    
    for i in range(1, m):
        for j in range(1, n):
            dp[j] += dp[j - 1]
    
    return dp[n - 1]


Solution = create_solution(unique_paths)
