# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 372
标题: Super Pow
难度: medium
链接: https://leetcode.cn/problems/super-pow/
题目类型: 数学、分治
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
372. 超级次方 - 你的任务是计算 ab 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。 示例 1： 输入：a = 2, b = [3] 输出：8 示例 2： 输入：a = 2, b = [1,0] 输出：1024 示例 3： 输入：a = 1, b = [4,3,3,8,5,2] 输出：1 示例 4： 输入：a = 2147483647, b = [2,0,0] 输出：1198 提示： * 1 <= a <= 231 - 1 * 1 <= b.length <= 2000 * 0 <= b[i] <= 9 * b 不含前导 0
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 利用模运算性质将大指数拆位，结合快速幂与欧拉定理/循环节，递归地处理数组形式的大整数指数

算法步骤:
1. 记模数 M = 1337，注意 b 以数组形式给出，比如 b=[1,0] 表示 10，可视作十进制展开：
   \[a^b \equiv a^{\sum b_i 10^{m-i}} \pmod{M}\]
2. 使用递归或从低位到高位迭代地处理指数：
   - 若将 b 写成「前缀」和「最后一位」的形式：b = 10 * prefix + last，则
     \[a^b \equiv (a^{prefix})^{10} \cdot a^{last} \pmod{M}\]
3. 定义函数 superPow(a, b[0..k])：
   - 若 b 为空数组则返回 1；
   - 取出最后一位 last = b[-1]，对前缀递归求值 part = superPow(a, b[0..k-1])；
   - 返回 (powMod(part, 10, M) * powMod(a, last, M)) % M，其中 powMod 使用快速幂实现。
4. 对底数 a 先对 M 取模，确保在递归和快速幂过程中乘法不会溢出。

关键点:
- 关键转化公式 a^{10·x + y} ≡ (a^x)^{10}·a^y (mod M)。 
- 快速幂 powMod 采用二分递归或迭代位运算实现，时间复杂度 O(log exp)。
- 递归处理指数数组时要注意终止条件（b 为空时返回 1）。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(len(b) * log 10) ≈ O(len(b)) - 每一位调用一次快速幂，指数最大为 10。
空间复杂度: O(len(b)) - 递归深度与数组 b 长度同阶，可改写为迭代以降为 O(1)。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution

MOD = 1337


def _pow_mod(a: int, exp: int) -> int:
    """快速幂计算 a^exp mod MOD。"""
    a %= MOD
    res = 1
    while exp:
        if exp & 1:
            res = (res * a) % MOD
        a = (a * a) % MOD
        exp >>= 1
    return res


def super_pow(a: int, b: List[int]) -> int:
    """
    计算 a^b mod 1337，其中 b 以数字数组形式给出。

    使用公式 a^{10·x + y} ≡ (a^x)^{10} · a^y (mod 1337)，
    从高位到低位迭代处理指数数组。
    """
    a %= MOD
    res = 1
    for digit in b:
        # 之前的结果整体提升 10 次幂
        res = _pow_mod(res, 10) * _pow_mod(a, digit) % MOD
    return res


# 自动生成Solution类（无需手动编写）
Solution = create_solution(super_pow)
