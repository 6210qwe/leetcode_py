# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2476
标题: Check Distances Between Same Letters
难度: easy
链接: https://leetcode.cn/problems/check-distances-between-same-letters/
题目类型: 数组、哈希表、字符串
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2399. 检查相同字母间的距离 - 给你一个下标从 0 开始的字符串 s ，该字符串仅由小写英文字母组成，s 中的每个字母都 恰好 出现 两次 。另给你一个下标从 0 开始、长度为 26 的的整数数组 distance 。 字母表中的每个字母按从 0 到 25 依次编号（即，'a' -> 0, 'b' -> 1, 'c' -> 2, ... , 'z' -> 25）。 在一个 匀整 字符串中，第 i 个字母的两次出现之间的字母数量是 distance[i] 。如果第 i 个字母没有在 s 中出现，那么 distance[i] 可以 忽略 。 如果 s 是一个 匀整 字符串，返回 true ；否则，返回 false 。 示例 1： 输入：s = "abaccb", distance = [1,3,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] 输出：true 解释： - 'a' 在下标 0 和下标 2 处出现，所以满足 distance[0] = 1 。 - 'b' 在下标 1 和下标 5 处出现，所以满足 distance[1] = 3 。 - 'c' 在下标 3 和下标 4 处出现，所以满足 distance[2] = 0 。 注意 distance[3] = 5 ，但是由于 'd' 没有在 s 中出现，可以忽略。 因为 s 是一个匀整字符串，返回 true 。 示例 2： 输入：s = "aa", distance = [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] 输出：false 解释： - 'a' 在下标 0 和 1 处出现，所以两次出现之间的字母数量为 0 。 但是 distance[0] = 1 ，s 不是一个匀整字符串。 提示： * 2 <= s.length <= 52 * s 仅由小写英文字母组成 * s 中的每个字母恰好出现两次 * distance.length == 26 * 0 <= distance[i] <= 50
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用一个字典来记录每个字母第一次出现的位置，然后在第二次遇到该字母时，计算两次出现之间的距离，并与 distance 数组中的值进行比较。

算法步骤:
1. 初始化一个字典 first_occurrence 来记录每个字母第一次出现的位置。
2. 遍历字符串 s，对于每个字母：
   - 如果该字母第一次出现，则记录其位置。
   - 如果该字母第二次出现，则计算两次出现之间的距离，并与 distance 数组中的值进行比较。
3. 如果所有字母的距离都符合要求，则返回 True，否则返回 False。

关键点:
- 使用字典来记录每个字母第一次出现的位置。
- 计算两次出现之间的距离时，需要减去 1，因为距离是指中间的字符数量。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是字符串 s 的长度。我们只需要遍历字符串一次。
空间复杂度: O(1)，虽然使用了字典，但字典的大小最多为 26（字母表的大小），因此可以视为常数空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def check_distances(s: str, distance: List[int]) -> bool:
    """
    检查字符串 s 是否是一个匀整字符串。
    :param s: 字符串 s
    :param distance: 距离数组
    :return: 如果 s 是一个匀整字符串，返回 True；否则返回 False。
    """
    first_occurrence = {}  # 记录每个字母第一次出现的位置
    
    for i, char in enumerate(s):
        if char in first_occurrence:
            # 计算两次出现之间的距离
            expected_distance = i - first_occurrence[char] - 1
            if expected_distance != distance[ord(char) - ord('a')]:
                return False
        else:
            first_occurrence[char] = i
    
    return True


Solution = create_solution(check_distances)