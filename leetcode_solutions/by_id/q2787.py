# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2787
标题: Movement of Robots
难度: medium
链接: https://leetcode.cn/problems/movement-of-robots/
题目类型: 脑筋急转弯、数组、前缀和、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2731. 移动机器人 - 有一些机器人分布在一条无限长的数轴上，他们初始坐标用一个下标从 0 开始的整数数组 nums 表示。当你给机器人下达命令时，它们以每秒钟一单位的速度开始移动。 给你一个字符串 s ，每个字符按顺序分别表示每个机器人移动的方向。'L' 表示机器人往左或者数轴的负方向移动，'R' 表示机器人往右或者数轴的正方向移动。 当两个机器人相撞时，它们开始沿着原本相反的方向移动。 请你返回指令重复执行 d 秒后，所有机器人之间两两距离之和。由于答案可能很大，请你将答案对 109 + 7 取余后返回。 注意： * 对于坐标在 i 和 j 的两个机器人，(i,j) 和 (j,i) 视为相同的坐标对。也就是说，机器人视为无差别的。 * 当机器人相撞时，它们 立即改变 它们的前进方向，这个过程不消耗任何时间。 * 当两个机器人在同一时刻占据相同的位置时，就会相撞。 * 例如，如果一个机器人位于位置 0 并往右移动，另一个机器人位于位置 2 并往左移动，下一秒，它们都将占据位置 1，并改变方向。再下一秒钟后，第一个机器人位于位置 0 并往左移动，而另一个机器人位于位置 2 并往右移动。 * 例如，如果一个机器人位于位置 0 并往右移动，另一个机器人位于位置 1 并往左移动，下一秒，第一个机器人位于位置 0 并往左行驶，而另一个机器人位于位置 1 并往右移动。 示例 1： 输入：nums = [-2,0,2], s = "RLL", d = 3 输出：8 解释： 1 秒后，机器人的位置为 [-1,-1,1] 。现在下标为 0 的机器人开始往左移动，下标为 1 的机器人开始往右移动。 2 秒后，机器人的位置为 [-2,0,0] 。现在下标为 1 的机器人开始往左移动，下标为 2 的机器人开始往右移动。 3 秒后，机器人的位置为 [-3,-1,1] 。 下标为 0 和 1 的机器人之间距离为 abs(-3 - (-1)) = 2 。 下标为 0 和 2 的机器人之间的距离为 abs(-3 - 1) = 4 。 下标为 1 和 2 的机器人之间的距离为 abs(-1 - 1) = 2 。 所有机器人对之间的总距离为 2 + 4 + 2 = 8 。 示例 2： 输入：nums = [1,0], s = "RL", d = 2 输出：5 解释： 1 秒后，机器人的位置为 [2,-1] 。 2 秒后，机器人的位置为 [3,-2] 。 两个机器人的距离为 abs(-2 - 3) = 5 。 提示： * 2 <= nums.length <= 105 * -2 * 109 <= nums[i] <= 2 * 109 * 0 <= d <= 109 * nums.length == s.length * s 只包含 'L' 和 'R' 。 * nums[i] 互不相同。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过计算每个机器人在 d 秒后的最终位置，然后使用排序和前缀和来计算所有机器人之间的两两距离之和。

算法步骤:
1. 根据每个机器人的初始位置和移动方向，计算 d 秒后的最终位置。
2. 将这些最终位置进行排序。
3. 使用前缀和计算所有机器人之间的两两距离之和。
4. 返回结果并对 10^9 + 7 取余。

关键点:
- 机器人相撞后会立即改变方向，但最终位置可以通过直接计算得出。
- 通过排序和前缀和可以高效地计算所有机器人之间的两两距离之和。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是机器人的数量。排序操作的时间复杂度是 O(n log n)，计算前缀和的时间复杂度是 O(n)。
空间复杂度: O(n)，用于存储最终位置和前缀和。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution

def sum_of_distances(nums: List[int], s: str, d: int) -> int:
    MOD = 10**9 + 7
    n = len(nums)
    
    # 计算 d 秒后的最终位置
    final_positions = []
    for i in range(n):
        if s[i] == 'L':
            final_positions.append(nums[i] - d)
        else:
            final_positions.append(nums[i] + d)
    
    # 对最终位置进行排序
    final_positions.sort()
    
    # 计算前缀和
    prefix_sum = [0] * (n + 1)
    for i in range(n):
        prefix_sum[i + 1] = (prefix_sum[i] + final_positions[i]) % MOD
    
    # 计算所有机器人之间的两两距离之和
    total_distance = 0
    for i in range(n):
        total_distance = (total_distance + (final_positions[i] * (2 * i + 1 - n)) % MOD - (prefix_sum[i] - prefix_sum[n - i - 1]) % MOD) % MOD
    
    return total_distance

Solution = create_solution(sum_of_distances)