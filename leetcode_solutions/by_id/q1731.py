# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1731
标题: Even Odd Tree
难度: medium
链接: https://leetcode.cn/problems/even-odd-tree/
题目类型: 树、广度优先搜索、二叉树
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1609. 奇偶树 - 如果一棵二叉树满足下述几个条件，则可以称为 奇偶树 ： * 二叉树根节点所在层下标为 0 ，根的子节点所在层下标为 1 ，根的孙节点所在层下标为 2 ，依此类推。 * 偶数下标 层上的所有节点的值都是 奇 整数，从左到右按顺序 严格递增 * 奇数下标 层上的所有节点的值都是 偶 整数，从左到右按顺序 严格递减 给你二叉树的根节点，如果二叉树为 奇偶树 ，则返回 true ，否则返回 false 。 示例 1： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/10/04/sample_1_1966.png] 输入：root = [1,10,4,3,null,7,9,12,8,6,null,null,2] 输出：true 解释：每一层的节点值分别是： 0 层：[1] 1 层：[10,4] 2 层：[3,7,9] 3 层：[12,8,6,2] 由于 0 层和 2 层上的节点值都是奇数且严格递增，而 1 层和 3 层上的节点值都是偶数且严格递减，因此这是一棵奇偶树。 示例 2： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/10/04/sample_2_1966.png] 输入：root = [5,4,2,3,3,7] 输出：false 解释：每一层的节点值分别是： 0 层：[5] 1 层：[4,2] 2 层：[3,3,7] 2 层上的节点值不满足严格递增的条件，所以这不是一棵奇偶树。 示例 3： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/10/04/sample_1_333_1966.png] 输入：root = [5,9,1,3,5,7] 输出：false 解释：1 层上的节点值应为偶数。 示例 4： 输入：root = [1] 输出：true 示例 5： 输入：root = [11,8,6,1,3,9,11,30,20,18,16,12,10,4,2,17] 输出：true 提示： * 树中节点数在范围 [1, 105] 内 * 1 <= Node.val <= 106
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用广度优先搜索（BFS）遍历二叉树，并检查每一层是否满足奇偶树的条件。

算法步骤:
1. 初始化一个队列，将根节点加入队列。
2. 使用一个变量 `level` 记录当前层数，初始值为 0。
3. 开始层次遍历：
   - 对于每一层，记录前一个节点的值 `prev_val`，初始化为负无穷或正无穷，取决于当前层是偶数还是奇数。
   - 遍历当前层的所有节点：
     - 检查当前节点的值是否满足奇偶树的条件。
     - 将当前节点的子节点加入队列。
     - 更新 `prev_val` 为当前节点的值。
4. 如果遍历过程中发现任何不满足条件的情况，返回 `False`。
5. 如果遍历完整棵树均未发现不满足条件的情况，返回 `True`。

关键点:
- 使用 BFS 进行层次遍历。
- 通过 `level` 变量判断当前层是偶数层还是奇数层。
- 使用 `prev_val` 来检查当前层的节点值是否严格递增或递减。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是树中节点的数量。每个节点只会被访问一次。
空间复杂度: O(w)，其中 w 是树的最大宽度。队列中最多会存储一层的节点。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import Optional
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def is_even_odd_tree(root: Optional[TreeNode]) -> bool:
    if not root:
        return False

    queue = [root]
    level = 0

    while queue:
        size = len(queue)
        prev_val = float('-inf') if level % 2 == 0 else float('inf')

        for _ in range(size):
            node = queue.pop(0)

            if (level % 2 == 0 and (node.val % 2 == 0 or node.val <= prev_val)) or \
               (level % 2 != 0 and (node.val % 2 != 0 or node.val >= prev_val)):
                return False

            prev_val = node.val

            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

        level += 1

    return True


Solution = create_solution(is_even_odd_tree)