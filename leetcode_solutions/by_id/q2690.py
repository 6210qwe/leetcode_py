# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2690
标题: House Robber IV
难度: medium
链接: https://leetcode.cn/problems/house-robber-iv/
题目类型: 贪心、数组、二分查找、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2560. 打家劫舍 IV - 沿街有一排连续的房屋。每间房屋内都藏有一定的现金。现在有一位小偷计划从这些房屋中窃取现金。 由于相邻的房屋装有相互连通的防盗系统，所以小偷 不会窃取相邻的房屋 。 小偷的 窃取能力 定义为他在窃取过程中能从单间房屋中窃取的 最大金额 。 给你一个整数数组 nums 表示每间房屋存放的现金金额。形式上，从左起第 i 间房屋中放有 nums[i] 美元。 另给你一个整数 k ，表示窃贼将会窃取的 最少 房屋数。小偷总能窃取至少 k 间房屋。 返回小偷的 最小 窃取能力。 示例 1： 输入：nums = [2,3,5,9], k = 2 输出：5 解释： 小偷窃取至少 2 间房屋，共有 3 种方式： - 窃取下标 0 和 2 处的房屋，窃取能力为 max(nums[0], nums[2]) = 5 。 - 窃取下标 0 和 3 处的房屋，窃取能力为 max(nums[0], nums[3]) = 9 。 - 窃取下标 1 和 3 处的房屋，窃取能力为 max(nums[1], nums[3]) = 9 。 因此，返回 min(5, 9, 9) = 5 。 示例 2： 输入：nums = [2,7,9,3,1], k = 2 输出：2 解释：共有 7 种窃取方式。窃取能力最小的情况所对应的方式是窃取下标 0 和 4 处的房屋。返回 max(nums[0], nums[4]) = 2 。 提示： * 1 <= nums.length <= 105 * 1 <= nums[i] <= 109 * 1 <= k <= (nums.length + 1)/2
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用二分查找和贪心算法来确定最小的窃取能力。

算法步骤:
1. 初始化二分查找的左右边界，left 为 1，right 为 max(nums)。
2. 在二分查找的过程中，计算中间值 mid，并检查是否可以使用 mid 作为窃取能力窃取至少 k 间房屋。
3. 如果可以，则缩小右边界；否则，扩大左边界。
4. 最终返回 left 作为最小的窃取能力。

关键点:
- 使用二分查找来确定最小的窃取能力。
- 使用贪心算法来检查当前窃取能力是否可行。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log(max(nums)))，其中 n 是 nums 的长度，log(max(nums)) 是二分查找的时间复杂度。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def can_rob_houses(nums: List[int], k: int, max_amount: int) -> bool:
    """
    检查是否可以使用 max_amount 作为窃取能力窃取至少 k 间房屋。
    """
    count, prev = 0, -2
    for i in range(len(nums)):
        if nums[i] <= max_amount and i > prev + 1:
            count += 1
            prev = i
    return count >= k


def min_capability(nums: List[int], k: int) -> int:
    """
    返回小偷的最小窃取能力。
    """
    left, right = 1, max(nums)
    while left < right:
        mid = (left + right) // 2
        if can_rob_houses(nums, k, mid):
            right = mid
        else:
            left = mid + 1
    return left


Solution = create_solution(min_capability)