# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 120
标题: Triangle
难度: medium
链接: https://leetcode.cn/problems/triangle/
题目类型: 数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
120. 三角形最小路径和 - 给定一个三角形 triangle ，找出自顶向下的最小路径和。 每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。 示例 1： 输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]] 输出：11 解释：如下面简图所示： 2 3 4 6 5 7 4 1 8 3 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 示例 2： 输入：triangle = [[-10]] 输出：-10 提示： * 1 <= triangle.length <= 200 * triangle[0].length == 1 * triangle[i].length == triangle[i - 1].length + 1 * -104 <= triangle[i][j] <= 104 进阶： * 你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题吗？
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 自底向上动态规划，使用滚动数组优化空间

算法步骤:
1. 从倒数第二行开始，自底向上计算
2. 对于每个位置，选择下一行相邻两个位置的最小值加上当前位置的值
3. 使用滚动数组优化空间复杂度

关键点:
- 自底向上避免边界处理
- 时间复杂度O(n^2)，空间复杂度O(n)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2) - n为三角形的行数
空间复杂度: O(n) - 使用滚动数组
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from leetcode_solutions.utils.solution import create_solution


def triangle(triangle: List[List[int]]) -> int:
    """
    函数式接口 - 计算三角形最小路径和
    
    实现思路:
    自底向上动态规划，使用滚动数组优化空间复杂度。
    
    Args:
        triangle: 三角形数组
        
    Returns:
        自顶向下的最小路径和
        
    Example:
        >>> triangle([[2], [3, 4], [6, 5, 7], [4, 1, 8, 3]])
        11
    """
    n = len(triangle)
    dp = triangle[n - 1][:]
    
    for i in range(n - 2, -1, -1):
        for j in range(len(triangle[i])):
            dp[j] = min(dp[j], dp[j + 1]) + triangle[i][j]
    
    return dp[0]


# 自动生成Solution类（无需手动编写）
Solution = create_solution(triangle)
