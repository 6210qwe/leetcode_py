# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 100180
标题: Insert Into Bits LCCI
难度: easy
链接: https://leetcode.cn/problems/insert-into-bits-lcci/
题目类型: 位运算
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
面试题 05.01. 插入 - 给定两个整型数字 N 与 M，以及表示比特位置的 i 与 j（i <= j，且从 0 位开始计算）。 编写一种方法，使 M 对应的二进制数字插入 N 对应的二进制数字的第 i ~ j 位区域，不足之处用 0 补齐。具体插入过程如图所示。 [https://pic.leetcode.cn/1610104070-NuLVQi-05.01.gif] 题目保证从 i 位到 j 位足以容纳 M， 例如： M = 10011，则 i～j 区域至少可容纳 5 位。 示例 1： 输入：N = 1024(10000000000), M = 19(10011), i = 2, j = 6 输出：N = 1100(10001001100) 示例 2： 输入：N = 0, M = 31(11111), i = 0, j = 4 输出：N = 31(11111)
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用掩码和位操作来实现插入操作。

算法步骤:
1. 创建一个掩码，将 N 的第 i 到 j 位清零。
2. 将 M 左移 i 位。
3. 将处理后的 M 和 N 进行按位或操作，得到最终结果。

关键点:
- 使用掩码清除 N 的第 i 到 j 位。
- 将 M 左移到正确的位置。
- 使用按位或操作将 M 插入到 N 中。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(1)
空间复杂度: O(1)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def insert_bits(N: int, M: int, i: int, j: int) -> int:
    """
    函数式接口 - 将 M 对应的二进制数字插入 N 对应的二进制数字的第 i ~ j 位区域
    """
    # 创建一个掩码，将 N 的第 i 到 j 位清零
    all_ones = ~0
    left = all_ones << (j + 1)
    right = (1 << i) - 1
    mask = left | right

    # 清除 N 的第 i 到 j 位
    N_cleared = N & mask

    # 将 M 左移 i 位
    M_shifted = M << i

    # 将处理后的 M 和 N 进行按位或操作
    result = N_cleared | M_shifted
    return result


Solution = create_solution(insert_bits)