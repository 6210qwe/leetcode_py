# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2725
标题: Mice and Cheese
难度: medium
链接: https://leetcode.cn/problems/mice-and-cheese/
题目类型: 贪心、数组、排序、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2611. 老鼠和奶酪 - 有两只老鼠和 n 块不同类型的奶酪，每块奶酪都只能被其中一只老鼠吃掉。 下标为 i 处的奶酪被吃掉的得分为： * 如果第一只老鼠吃掉，则得分为 reward1[i] 。 * 如果第二只老鼠吃掉，则得分为 reward2[i] 。 给你一个正整数数组 reward1 ，一个正整数数组 reward2 ，和一个非负整数 k 。 请你返回第一只老鼠恰好吃掉 k 块奶酪的情况下，最大 得分为多少。 示例 1： 输入：reward1 = [1,1,3,4], reward2 = [4,4,1,1], k = 2 输出：15 解释：这个例子中，第一只老鼠吃掉第 2 和 3 块奶酪（下标从 0 开始），第二只老鼠吃掉第 0 和 1 块奶酪。 总得分为 4 + 4 + 3 + 4 = 15 。 15 是最高得分。 示例 2： 输入：reward1 = [1,1], reward2 = [1,1], k = 2 输出：2 解释：这个例子中，第一只老鼠吃掉第 0 和 1 块奶酪（下标从 0 开始），第二只老鼠不吃任何奶酪。 总得分为 1 + 1 = 2 。 2 是最高得分。 提示： * 1 <= n == reward1.length == reward2.length <= 105 * 1 <= reward1[i], reward2[i] <= 1000 * 0 <= k <= n
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过贪心算法选择最优解。首先计算每块奶酪由第一只老鼠吃掉比第二只老鼠吃掉多出来的得分差值，然后选择差值最大的前 k 块奶酪给第一只老鼠吃。

算法步骤:
1. 计算每块奶酪的得分差值。
2. 将这些差值按降序排序。
3. 选择前 k 个差值对应的奶酪给第一只老鼠吃，其余给第二只老鼠吃。
4. 计算总得分。

关键点:
- 通过差值排序来确定哪些奶酪应该由第一只老鼠吃掉。
- 使用贪心算法确保总得分最大化。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是奶酪的数量。排序操作的时间复杂度为 O(n log n)。
空间复杂度: O(n)，存储差值和排序结果需要 O(n) 的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def mice_and_cheese(reward1: List[int], reward2: List[int], k: int) -> int:
    """
    函数式接口 - 返回第一只老鼠恰好吃掉 k 块奶酪的情况下，最大得分为多少。
    """
    n = len(reward1)
    # 计算每块奶酪的得分差值
    diff = [reward1[i] - reward2[i] for i in range(n)]
    # 按差值降序排序，并获取前 k 个差值的索引
    top_k_indices = sorted(range(n), key=lambda i: diff[i], reverse=True)[:k]
    
    # 计算总得分
    total_score = sum(reward1[i] if i in top_k_indices else reward2[i] for i in range(n))
    
    return total_score

Solution = create_solution(mice_and_cheese)