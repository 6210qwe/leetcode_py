# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000051
标题: Sparse Similarity LCCI
难度: hard
链接: https://leetcode.cn/problems/sparse-similarity-lcci/
题目类型: 数组、哈希表、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
面试题 17.26. 稀疏相似度 - 两个(具有不同单词的)文档的交集(intersection)中元素的个数除以并集(union)中元素的个数，就是这两个文档的相似度。例如，{1, 5, 3} 和 {1, 7, 2, 3} 的相似度是 0.4，其中，交集的元素有 2 个，并集的元素有 5 个。给定一系列的长篇文档，每个文档元素各不相同，并与一个 ID 相关联。它们的相似度非常“稀疏”，也就是说任选 2 个文档，相似度都很接近 0。请设计一个算法返回每对文档的 ID 及其相似度。只需输出相似度大于 0 的组合。请忽略空文档。为简单起见，可以假定每个文档由一个含有不同整数的数组表示。 输入为一个二维数组 docs，docs[i] 表示 id 为 i 的文档。返回一个数组，其中每个元素是一个字符串，代表每对相似度大于 0 的文档，其格式为 {id1},{id2}: {similarity}，其中 id1 为两个文档中较小的 id，similarity 为相似度，精确到小数点后 4 位。以任意顺序返回数组均可。 示例: 输入: [ [14, 15, 100, 9, 3], [32, 1, 9, 3, 5], [15, 29, 2, 6, 8, 7], [7, 10] ] 输出: [ "0,1: 0.2500", "0,2: 0.1000", "2,3: 0.1429" ] 提示： * docs.length <= 500 * docs[i].length <= 500
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用倒排索引和集合操作来计算相似度。

算法步骤:
1. 构建倒排索引，记录每个单词出现在哪些文档中。
2. 遍历每个文档，使用集合操作计算与其他文档的相似度。
3. 将相似度大于 0 的结果存储在结果列表中。

关键点:
- 使用倒排索引来快速查找包含相同单词的文档。
- 使用集合操作来高效计算交集和并集。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(N * M + N^2)，其中 N 是文档数量，M 是每个文档的平均长度。
空间复杂度: O(N * M)，用于存储倒排索引。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def solution_function_name(docs: List[List[int]]) -> List[str]:
    """
    函数式接口 - 计算文档间的稀疏相似度
    """
    # 构建倒排索引
    inverted_index = {}
    for doc_id, doc in enumerate(docs):
        for word in doc:
            if word not in inverted_index:
                inverted_index[word] = set()
            inverted_index[word].add(doc_id)
    
    n = len(docs)
    result = []
    
    # 计算相似度
    for i in range(n):
        for j in range(i + 1, n):
            doc_i_set = set(docs[i])
            doc_j_set = set(docs[j])
            
            intersection = doc_i_set & doc_j_set
            union = doc_i_set | doc_j_set
            
            if intersection:
                similarity = len(intersection) / len(union)
                result.append(f"{i},{j}: {similarity:.4f}")
    
    return result

Solution = create_solution(solution_function_name)