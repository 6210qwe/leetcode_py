# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 605
标题: Can Place Flowers
难度: easy
链接: https://leetcode.cn/problems/can-place-flowers/
题目类型: 贪心、数组
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
605. 种花问题 - 假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。 给你一个整数数组 flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false 。 示例 1： 输入：flowerbed = [1,0,0,0,1], n = 1 输出：true 示例 2： 输入：flowerbed = [1,0,0,0,1], n = 2 输出：false 提示： * 1 <= flowerbed.length <= 2 * 104 * flowerbed[i] 为 0 或 1 * flowerbed 中不存在相邻的两朵花 * 0 <= n <= flowerbed.length
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用贪心算法，从左到右遍历花坛数组，找到可以种花的位置并种下花。

算法步骤:
1. 在花坛数组的开头和结尾添加虚拟的 0，以简化边界条件处理。
2. 遍历花坛数组，检查当前位置及其左右是否都为 0，如果是，则可以种花，并将该位置标记为 1。
3. 每次种花后，减少需要种花的数量 n。
4. 如果 n 减少到 0 或以下，返回 True；否则，返回 False。

关键点:
- 在花坛数组的开头和结尾添加虚拟的 0，以简化边界条件处理。
- 使用贪心算法，从左到右遍历花坛数组，找到可以种花的位置并种下花。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是 flowerbed 的长度。我们只需要遍历一次 flowerbed 数组。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def can_place_flowers(flowerbed: List[int], n: int) -> bool:
    """
    判断是否可以在不打破种植规则的情况下种入 n 朵花。
    
    :param flowerbed: 花坛数组
    :param n: 需要种花的数量
    :return: 是否可以种入 n 朵花
    """
    # 在花坛数组的开头和结尾添加虚拟的 0
    extended_flowerbed = [0] + flowerbed + [0]
    
    for i in range(1, len(extended_flowerbed) - 1):
        if extended_flowerbed[i - 1] == 0 and extended_flowerbed[i] == 0 and extended_flowerbed[i + 1] == 0:
            extended_flowerbed[i] = 1
            n -= 1
            if n <= 0:
                return True
    
    return n <= 0


Solution = create_solution(can_place_flowers)