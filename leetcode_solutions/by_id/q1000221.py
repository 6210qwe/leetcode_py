# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000221
标题: 蓄水
难度: easy
链接: https://leetcode.cn/problems/o8SXZn/
题目类型: 贪心、数组、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCP 33. 蓄水 - 给定 N 个无限容量且初始均空的水缸，每个水缸配有一个水桶用来打水，第 `i` 个水缸配备的水桶容量记作 `bucket[i]`。小扣有以下两种操作： - 升级水桶：选择任意一个水桶，使其容量增加为 `bucket[i]+1` - 蓄水：将全部水桶接满水，倒入各自对应的水缸 每个水缸对应最低蓄水量记作 `vat[i]`，返回小扣至少需要多少次操作可以完成所有水缸蓄水要求。 注意：实际蓄水量 **达到或超过** 最低蓄水量，即完成蓄水要求。 **示例 1：** >输入：`bucket = [1,3], vat = [6,8]` > >输出：`4` > >解释： >第 1 次操作升级 bucket[0]； >第 2 ~ 4 次操作均选择蓄水，即可完成蓄水要求。 ![vat1.gif](https://pic.leetcode.cn/1616122992-RkDxoL-vat1.gif) **示例 2：** >输入：`bucket = [9,0,1], vat = [0,2,2]` > >输出：`3` > >解释： >第 1 次操作均选择升级 bucket[1] >第 2~3 次操作选择蓄水，即可完成蓄水要求。 **提示：** - `1 <= bucket.length == vat.length <= 100` - `0 <= bucket[i], vat[i] <= 10^4`
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用贪心算法和优先队列来最小化操作次数。

算法步骤:
1. 初始化一个优先队列，存储每个水缸的 (所需倒水次数, 当前水桶容量, 对应水缸索引)。
2. 计算每个水缸的初始倒水次数，并将其加入优先队列。
3. 从优先队列中取出当前倒水次数最多的水缸，计算升级一次水桶后的倒水次数，并更新优先队列。
4. 重复步骤3，直到所有水缸的倒水次数都小于等于当前最优解的操作次数。

关键点:
- 使用优先队列来动态维护每个水缸的倒水次数。
- 通过贪心策略，每次选择倒水次数最多的水缸进行升级，以最小化总操作次数。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是水缸的数量。每次插入和删除优先队列的时间复杂度是 O(log n)，最坏情况下需要对每个水缸进行多次操作。
空间复杂度: O(n)，优先队列的空间复杂度。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def min_operations_to_fill_vats(bucket: List[int], vat: List[int]) -> int:
    """
    函数式接口 - 计算最少操作次数来完成所有水缸的蓄水要求
    """
    n = len(bucket)
    if n != len(vat):
        raise ValueError("bucket and vat must be of the same length")

    # 初始化优先队列
    pq = []
    for i in range(n):
        if vat[i] == 0:
            continue
        if bucket[i] == 0:
            return -1
        heapq.heappush(pq, (-((vat[i] + bucket[i] - 1) // bucket[i]), bucket[i], i))

    operations = 0
    while pq:
        max_pours, current_bucket, index = heapq.heappop(pq)
        max_pours = -max_pours
        if max_pours * (operations + 1) < operations:
            break
        operations += 1
        new_bucket = current_bucket + 1
        new_pours = (vat[index] + new_bucket - 1) // new_bucket
        heapq.heappush(pq, (-new_pours, new_bucket, index))

    return operations

Solution = create_solution(min_operations_to_fill_vats)