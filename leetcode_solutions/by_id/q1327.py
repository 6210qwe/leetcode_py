# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1327
标题: Last Person to Fit in the Bus
难度: medium
链接: https://leetcode.cn/problems/last-person-to-fit-in-the-bus/
题目类型: 数据库
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1204. 最后一个能进入巴士的人 - 表: Queue +-------------+---------+ | Column Name | Type | +-------------+---------+ | person_id | int | | person_name | varchar | | weight | int | | turn | int | +-------------+---------+ person_id 是这个表具有唯一值的列。 该表展示了所有候车乘客的信息。 表中 person_id 和 turn 列将包含从 1 到 n 的所有数字，其中 n 是表中的行数。 turn 决定了候车乘客上巴士的顺序，其中 turn=1 表示第一个上巴士，turn=n 表示最后一个上巴士。 weight 表示候车乘客的体重，以千克为单位。 有一队乘客在等着上巴士。然而，巴士有1000 千克 的重量限制，所以其中一部分乘客可能无法上巴士。 编写解决方案找出 最后一个 上巴士且不超过重量限制的乘客，并报告 person_name 。题目测试用例确保顺位第一的人可以上巴士且不会超重。 返回结果格式如下所示。 示例 1： 输入： Queue 表 +-----------+-------------+--------+------+ | person_id | person_name | weight | turn | +-----------+-------------+--------+------+ | 5 | Alice | 250 | 1 | | 4 | Bob | 175 | 5 | | 3 | Alex | 350 | 2 | | 6 | John Cena | 400 | 3 | | 1 | Winston | 500 | 6 | | 2 | Marie | 200 | 4 | +-----------+-------------+--------+------+ 输出： +-------------+ | person_name | +-------------+ | John Cena | +-------------+ 解释： 为了简化，Queue 表按 turn 列由小到大排序。 +------+----+-----------+--------+--------------+ | Turn | ID | Name | Weight | Total Weight | +------+----+-----------+--------+--------------+ | 1 | 5 | Alice | 250 | 250 | | 2 | 3 | Alex | 350 | 600 | | 3 | 6 | John Cena | 400 | 1000 | (最后一个上巴士) | 4 | 2 | Marie | 200 | 1200 | (无法上巴士) | 5 | 4 | Bob | 175 | ___ | | 6 | 1 | Winston | 500 | ___ | +------+----+-----------+--------+--------------+
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用累计权重来确定最后一个能进入巴士的乘客。

算法步骤:
1. 按照 turn 列对 Queue 表进行排序。
2. 初始化总重量为 0。
3. 遍历排序后的 Queue 表，累加每个乘客的体重。
4. 如果累加后的总重量超过 1000 千克，则返回上一个乘客的名字。
5. 如果遍历结束仍未超过 1000 千克，则返回最后一个乘客的名字。

关键点:
- 使用累计权重来判断是否超过重量限制。
- 通过遍历一次 Queue 表来找到最后一个能进入巴士的乘客。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是 Queue 表的长度，因为需要对表进行排序。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(queue: List[dict]) -> str:
    """
    函数式接口 - 找到最后一个能进入巴士的乘客
    """
    # 按 turn 列对 Queue 表进行排序
    queue.sort(key=lambda x: x['turn'])
    
    total_weight = 0
    last_person_name = ""
    
    for person in queue:
        if total_weight + person['weight'] <= 1000:
            total_weight += person['weight']
            last_person_name = person['person_name']
        else:
            break
    
    return last_person_name


Solution = create_solution(solution_function_name)