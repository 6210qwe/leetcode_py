# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 100292
标题: 位 1 的个数
难度: easy
链接: https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/
题目类型: 位运算
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCR 133. 位 1 的个数 - 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为 汉明重量 [http://en.wikipedia.org/wiki/Hamming_weight].）。 提示： * 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无签名的，其内部的二进制表示形式都是相同的。 * 在 Java 中，编译器使用 二进制补码 [https://baike.baidu.com/item/二进制补码/5295284] 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。 示例 1： 输入：n = 11 (控制台输入 00000000000000000000000000001011) 输出：3 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。 示例 2： 输入：n = 128 (控制台输入 00000000000000000000000010000000) 输出：1 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。 示例 3： 输入：n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3） 输出：31 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。 提示： * 输入必须是长度为 32 的 二进制串 。 注意：本题与主站 191 题相同：https://leetcode.cn/problems/number-of-1-bits/ [https://leetcode.cn/problems/number-of-1-bits/]
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用 Brian Kernighan 算法，每次将 n 和 n-1 进行按位与操作，直到 n 变为 0。

算法步骤:
1. 初始化计数器 count 为 0。
2. 当 n 不为 0 时，执行以下操作：
   a. 将 n 和 n-1 进行按位与操作，结果赋值给 n。
   b. 计数器 count 加 1。
3. 返回计数器 count。

关键点:
- Brian Kernighan 算法通过每次消除 n 的最低位的 1 来减少循环次数。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(k)，其中 k 是 n 的二进制表示中 1 的个数。
空间复杂度: O(1)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(n: int) -> int:
    """
    函数式接口 - 计算二进制表示中 1 的个数
    """
    count = 0
    while n:
        n &= n - 1  # 消除 n 的最低位的 1
        count += 1
    return count


Solution = create_solution(solution_function_name)