# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1706
标题: Min Cost to Connect All Points
难度: medium
链接: https://leetcode.cn/problems/min-cost-to-connect-all-points/
题目类型: 并查集、图、数组、最小生成树
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1584. 连接所有点的最小费用 - 给你一个points 数组，表示 2D 平面上的一些点，其中 points[i] = [xi, yi] 。 连接点 [xi, yi] 和点 [xj, yj] 的费用为它们之间的 曼哈顿距离 ：|xi - xj| + |yi - yj| ，其中 |val| 表示 val 的绝对值。 请你返回将所有点连接的最小总费用。只有任意两点之间 有且仅有 一条简单路径时，才认为所有点都已连接。 示例 1： [https://assets.leetcode.com/uploads/2020/08/26/d.png] 输入：points = [[0,0],[2,2],[3,10],[5,2],[7,0]] 输出：20 解释： [https://assets.leetcode.com/uploads/2020/08/26/c.png] 我们可以按照上图所示连接所有点得到最小总费用，总费用为 20 。 注意到任意两个点之间只有唯一一条路径互相到达。 示例 2： 输入：points = [[3,12],[-2,5],[-4,1]] 输出：18 示例 3： 输入：points = [[0,0],[1,1],[1,0],[-1,1]] 输出：4 示例 4： 输入：points = [[-1000000,-1000000],[1000000,1000000]] 输出：4000000 示例 5： 输入：points = [[0,0]] 输出：0 提示： * 1 <= points.length <= 1000 * -106 <= xi, yi <= 106 * 所有点 (xi, yi) 两两不同。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用 Prim 算法来找到最小生成树。

算法步骤:
1. 初始化一个优先队列（最小堆），并将第一个点加入队列。
2. 使用一个集合来记录已经访问过的点。
3. 从优先队列中取出当前最小边，并将其对应的点加入已访问集合。
4. 对于每个未访问的相邻点，计算其与当前点的曼哈顿距离，并将该距离和点加入优先队列。
5. 重复步骤 3 和 4，直到所有点都被访问。

关键点:
- 使用优先队列来高效地找到当前最小边。
- 使用集合来记录已访问的点，避免重复访问。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2 log n)，其中 n 是点的数量。因为每次从优先队列中取出元素的时间复杂度是 O(log n)，而最多需要进行 n 次这样的操作。
空间复杂度: O(n^2)，因为我们需要存储所有的边及其权重。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def minCostConnectPoints(points: List[List[int]]) -> int:
    def manhattan_distance(p1, p2):
        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])
    
    n = len(points)
    if n == 1:
        return 0
    
    # 优先队列
    pq = [(0, 0)]  # (cost, point_index)
    visited = set()
    total_cost = 0
    
    while len(visited) < n:
        cost, i = heapq.heappop(pq)
        if i in visited:
            continue
        visited.add(i)
        total_cost += cost
        
        for j in range(n):
            if j not in visited:
                heapq.heappush(pq, (manhattan_distance(points[i], points[j]), j))
    
    return total_cost

Solution = create_solution(minCostConnectPoints)