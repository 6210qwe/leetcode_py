# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 428
标题: 串联所有单词的子串
难度: 困难
链接: https://leetcode.cn/problems/serialize-and-deserialize-bst/
题目类型: 字符串
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。

注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词的顺序。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用滑动窗口和哈希表

算法步骤:
1. 初始化一个哈希表来记录 words 中每个单词的出现次数。
2. 使用滑动窗口遍历字符串 s，窗口大小为所有单词的总长度。
3. 在每个窗口内，将窗口内的子串分割成单词，并检查这些单词是否与哈希表中的单词匹配。
4. 如果匹配成功，记录当前窗口的起始位置。

关键点:
- 使用哈希表记录单词出现次数，方便快速查找和更新。
- 滑动窗口每次移动一个单词的长度，减少重复计算。
- 注意边界条件和特殊情况的处理。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * m) - n 是字符串 s 的长度，m 是单个单词的长度
空间复杂度: O(k) - k 是 words 中不同单词的数量
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from collections import Counter

def find_substring(s: str, words: List[str]) -> List[int]:
    """
    函数式接口 - 找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置
    
    实现思路:
    使用滑动窗口和哈希表来匹配子串。
    
    Args:
        s: 输入字符串
        words: 单词列表
        
    Returns:
        匹配成功的子串起始位置列表
        
    Example:
        >>> find_substring("barfoothefoobarman", ["foo", "bar"])
        [0, 9]
    """
    if not s or not words:
        return []
    
    word_len = len(words[0])
    total_len = word_len * len(words)
    word_count = Counter(words)
    result = []
    
    for i in range(len(s) - total_len + 1):
        seen = Counter()
        for j in range(i, i + total_len, word_len):
            word = s[j:j + word_len]
            if word in word_count:
                seen[word] += 1
                if seen[word] > word_count[word]:
                    break
            else:
                break
        if seen == word_count:
            result.append(i)
    
    return result


# 自动生成Solution类（无需手动编写）
Solution = create_solution(find_substring)