# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2094
标题: Remove Stones to Minimize the Total
难度: medium
链接: https://leetcode.cn/problems/remove-stones-to-minimize-the-total/
题目类型: 贪心、数组、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1962. 移除石子使总数最小 - 给你一个整数数组 piles ，数组 下标从 0 开始 ，其中 piles[i] 表示第 i 堆石子中的石子数量。另给你一个整数 k ，请你执行下述操作 恰好 k 次： * 选出任一石子堆 piles[i] ，并从中 移除 floor(piles[i] / 2) 颗石子。 注意：你可以对 同一堆 石子多次执行此操作。 返回执行 k 次操作后，剩下石子的 最小 总数。 floor(x) 为 小于 或 等于 x 的 最大 整数。（即，对 x 向下取整）。 示例 1： 输入：piles = [5,4,9], k = 2 输出：12 解释：可能的执行情景如下： - 对第 2 堆石子执行移除操作，石子分布情况变成 [5,4,5] 。 - 对第 0 堆石子执行移除操作，石子分布情况变成 [3,4,5] 。 剩下石子的总数为 12 。 示例 2： 输入：piles = [4,3,6,7], k = 3 输出：12 解释：可能的执行情景如下： - 对第 2 堆石子执行移除操作，石子分布情况变成 [4,3,3,7] 。 - 对第 3 堆石子执行移除操作，石子分布情况变成 [4,3,3,4] 。 - 对第 0 堆石子执行移除操作，石子分布情况变成 [2,3,3,4] 。 剩下石子的总数为 12 。 提示： * 1 <= piles.length <= 105 * 1 <= piles[i] <= 104 * 1 <= k <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用最大堆来存储石子堆的数量，每次取出堆顶元素（即当前最大的石子堆），移除一半的石子后重新放回堆中。这样可以保证每次操作都是对当前最大的石子堆进行操作，从而使得剩余石子的总数最小。

算法步骤:
1. 初始化一个最大堆，并将所有石子堆的数量加入堆中。
2. 执行 k 次操作，每次从堆中取出最大的石子堆，移除一半的石子后重新放回堆中。
3. 计算并返回堆中所有石子堆的总数。

关键点:
- 使用 Python 的 heapq 模块来实现最大堆，通过将每个元素取负数来模拟最大堆。
- 每次操作后，需要更新堆顶元素。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(k log n)，其中 n 是石子堆的数量，k 是操作次数。每次操作涉及堆的插入和删除操作，时间复杂度为 O(log n)。
空间复杂度: O(n)，需要额外的空间来存储堆。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def remove_stones_to_minimize_total(piles: List[int], k: int) -> int:
    """
    函数式接口 - 移除石子使总数最小
    """
    # 将每个元素取负数以模拟最大堆
    max_heap = [-pile for pile in piles]
    heapq.heapify(max_heap)
    
    for _ in range(k):
        # 取出堆顶元素（即当前最大的石子堆）
        largest_pile = -heapq.heappop(max_heap)
        # 移除一半的石子
        removed_stones = largest_pile // 2
        new_pile = largest_pile - removed_stones
        # 将新的石子堆数量放回堆中
        heapq.heappush(max_heap, -new_pile)
    
    # 计算并返回堆中所有石子堆的总数
    return -sum(max_heap)

Solution = create_solution(remove_stones_to_minimize_total)