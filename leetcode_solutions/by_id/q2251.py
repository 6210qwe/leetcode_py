# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2251
标题: Number of Ways to Divide a Long Corridor
难度: hard
链接: https://leetcode.cn/problems/number-of-ways-to-divide-a-long-corridor/
题目类型: 数学、字符串、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2147. 分隔长廊的方案数 - 在一个图书馆的长廊里，有一些座位和装饰植物排成一列。给你一个下标从 0 开始，长度为 n 的字符串 corridor ，它包含字母 'S' 和 'P' ，其中每个 'S' 表示一个座位，每个 'P' 表示一株植物。 在下标 0 的左边和下标 n - 1 的右边 已经 分别各放了一个屏风。你还需要额外放置一些屏风。每一个位置 i - 1 和 i 之间（1 <= i <= n - 1），至多能放一个屏风。 请你将走廊用屏风划分为若干段，且每一段内都 恰好有两个座位 ，而每一段内植物的数目没有要求。可能有多种划分方案，如果两个方案中有任何一个屏风的位置不同，那么它们被视为 不同 方案。 请你返回划分走廊的方案数。由于答案可能很大，请你返回它对 109 + 7 取余 的结果。如果没有任何方案，请返回 0 。 示例 1： [https://assets.leetcode.com/uploads/2021/12/04/1.png] 输入：corridor = "SSPPSPS" 输出：3 解释：总共有 3 种不同分隔走廊的方案。 上图中黑色的竖线表示已经放置好的屏风。 上图每种方案中，每一段都恰好有 两个 座位。 示例 2： [https://assets.leetcode.com/uploads/2021/12/04/2.png] 输入：corridor = "PPSPSP" 输出：1 解释：只有 1 种分隔走廊的方案，就是不放置任何屏风。 放置任何的屏风都会导致有一段无法恰好有 2 个座位。 示例 3： [https://assets.leetcode.com/uploads/2021/12/12/3.png] 输入：corridor = "S" 输出：0 解释：没有任何方案，因为总是有一段无法恰好有 2 个座位。 提示： * n == corridor.length * 1 <= n <= 105 * corridor[i] 要么是 'S' ，要么是 'P' 。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想:
- 通过遍历字符串找到所有座位的位置，并将其分成若干段，每段恰好有两个座位。
- 计算每段之间的植物数量，然后计算这些段之间的组合数。

算法步骤:
1. 遍历字符串，记录所有座位的位置。
2. 检查座位总数是否为偶数，如果不是则返回 0。
3. 将座位分成若干段，每段恰好有两个座位。
4. 计算每段之间的植物数量，并累乘这些数量得到最终的方案数。

关键点:
- 确保每段恰好有两个座位。
- 使用模运算防止结果溢出。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(1)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(corridor: str) -> int:
    """
    函数式接口 - 返回划分走廊的方案数
    """
    mod = 10**9 + 7
    seats = [i for i, c in enumerate(corridor) if c == 'S']
    
    # 如果座位总数不是偶数，则无法划分
    if len(seats) % 2 != 0 or len(seats) < 2:
        return 0
    
    ways = 1
    for i in range(2, len(seats), 2):
        ways = (ways * (seats[i] - seats[i - 1])) % mod
    
    return ways


Solution = create_solution(solution_function_name)