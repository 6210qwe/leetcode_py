# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 719
标题: Find K-th Smallest Pair Distance
难度: hard
链接: https://leetcode.cn/problems/find-k-th-smallest-pair-distance/
题目类型: 数组、双指针、二分查找、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
719. 找出第 K 小的数对距离 - 数对 (a,b) 由整数 a 和 b 组成，其数对距离定义为 a 和 b 的绝对差值。 给你一个整数数组 nums 和一个整数 k ，数对由 nums[i] 和 nums[j] 组成且满足 0 <= i < j < nums.length 。返回 所有数对距离中 第 k 小的数对距离。 示例 1： 输入：nums = [1,3,1], k = 1 输出：0 解释：数对和对应的距离如下： (1,3) -> 2 (1,1) -> 0 (3,1) -> 2 距离第 1 小的数对是 (1,1) ，距离为 0 。 示例 2： 输入：nums = [1,1,1], k = 2 输出：0 示例 3： 输入：nums = [1,6,1], k = 3 输出：5 提示： * n == nums.length * 2 <= n <= 104 * 0 <= nums[i] <= 106 * 1 <= k <= n * (n - 1) / 2
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用二分查找来找到第 k 小的数对距离。

算法步骤:
1. 对数组进行排序。
2. 使用二分查找来确定最小的距离 d，使得数组中存在至少 k 个数对的距离小于等于 d。
3. 在每次二分查找的过程中，使用滑动窗口来计算当前距离 d 下的数对数量。

关键点:
- 排序后的数组可以方便地使用滑动窗口来计算数对数量。
- 二分查找的时间复杂度较低，适合处理大规模数据。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n + n log d)，其中 n 是数组长度，d 是数组中的最大值减去最小值。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def solution_function_name(nums: List[int], k: int) -> int:
    """
    函数式接口 - 找出第 K 小的数对距离
    """
    def count_pairs(nums, mid):
        count = 0
        left = 0
        for right in range(len(nums)):
            while nums[right] - nums[left] > mid:
                left += 1
            count += right - left
        return count

    nums.sort()
    low, high = 0, nums[-1] - nums[0]
    
    while low < high:
        mid = (low + high) // 2
        if count_pairs(nums, mid) < k:
            low = mid + 1
        else:
            high = mid
    return low

Solution = create_solution(solution_function_name)