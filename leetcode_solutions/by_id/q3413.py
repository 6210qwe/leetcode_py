# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3413
标题: Find The First Player to win K Games in a Row
难度: medium
链接: https://leetcode.cn/problems/find-the-first-player-to-win-k-games-in-a-row/
题目类型: 数组、模拟
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3175. 找到连续赢 K 场比赛的第一位玩家 - 有 n 位玩家在进行比赛，玩家编号依次为 0 到 n - 1 。 给你一个长度为 n 的整数数组 skills 和一个 正 整数 k ，其中 skills[i] 是第 i 位玩家的技能等级。skills 中所有整数 互不相同 。 所有玩家从编号 0 到 n - 1 排成一列。 比赛进行方式如下： * 队列中最前面两名玩家进行一场比赛，技能等级 更高 的玩家胜出。 * 比赛后，获胜者保持在队列的开头，而失败者排到队列的末尾。 这个比赛的赢家是 第一位连续 赢下 k 场比赛的玩家。 请你返回这个比赛的赢家编号。 示例 1： 输入：skills = [4,2,6,3,9], k = 2 输出：2 解释： 一开始，队列里的玩家为 [0,1,2,3,4] 。比赛过程如下： * 玩家 0 和 1 进行一场比赛，玩家 0 的技能等级高于玩家 1 ，玩家 0 胜出，队列变为 [0,2,3,4,1] 。 * 玩家 0 和 2 进行一场比赛，玩家 2 的技能等级高于玩家 0 ，玩家 2 胜出，队列变为 [2,3,4,1,0] 。 * 玩家 2 和 3 进行一场比赛，玩家 2 的技能等级高于玩家 3 ，玩家 2 胜出，队列变为 [2,4,1,0,3] 。 玩家 2 连续赢了 k = 2 场比赛，所以赢家是玩家 2 。 示例 2： 输入：skills = [2,5,4], k = 3 输出：1 解释： 一开始，队列里的玩家为 [0,1,2] 。比赛过程如下： * 玩家 0 和 1 进行一场比赛，玩家 1 的技能等级高于玩家 0 ，玩家 1 胜出，队列变为 [1,2,0] 。 * 玩家 1 和 2 进行一场比赛，玩家 1 的技能等级高于玩家 2 ，玩家 1 胜出，队列变为 [1,0,2] 。 * 玩家 1 和 0 进行一场比赛，玩家 1 的技能等级高于玩家 0 ，玩家 1 胜出，队列变为 [1,2,0] 。 玩家 1 连续赢了 k = 3 场比赛，所以赢家是玩家 1 。 提示： * n == skills.length * 2 <= n <= 105 * 1 <= k <= 109 * 1 <= skills[i] <= 106 * skills 中的整数互不相同。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用双端队列来模拟比赛过程，并记录每个玩家的胜利次数。

算法步骤:
1. 初始化一个双端队列 `queue`，将所有玩家编号加入队列。
2. 初始化一个字典 `win_counts` 来记录每个玩家的胜利次数。
3. 使用一个变量 `current_winner` 来记录当前连胜的玩家编号。
4. 循环直到某个玩家连胜 `k` 场：
   - 从队列中取出前两个玩家进行比赛。
   - 技能等级高的玩家胜出，更新 `win_counts` 和 `current_winner`。
   - 如果当前连胜的玩家连胜次数达到 `k`，返回该玩家编号。
   - 将胜者放回队列头部，败者放回队列尾部。
5. 返回最终的赢家编号。

关键点:
- 使用双端队列高效地模拟比赛过程。
- 使用字典记录每个玩家的胜利次数。
- 通过变量 `current_winner` 记录当前连胜的玩家。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n + k)，其中 n 是玩家数量，k 是连胜次数。最坏情况下需要进行 n + k 次比赛。
空间复杂度: O(n)，使用双端队列和字典存储玩家信息。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from collections import deque

def find_first_player_to_win_k_games(skills: List[int], k: int) -> int:
    n = len(skills)
    queue = deque(range(n))
    win_counts = {i: 0 for i in range(n)}
    current_winner = None
    
    while True:
        player1 = queue.popleft()
        player2 = queue.popleft()
        
        if skills[player1] > skills[player2]:
            winner, loser = player1, player2
        else:
            winner, loser = player2, player1
        
        if winner == current_winner:
            win_counts[winner] += 1
        else:
            win_counts[winner] = 1
            current_winner = winner
        
        if win_counts[current_winner] == k:
            return current_winner
        
        queue.appendleft(winner)
        queue.append(loser)

Solution = create_solution(find_first_player_to_win_k_games)