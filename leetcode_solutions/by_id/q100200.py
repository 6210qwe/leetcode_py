# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 100200
标题: Bracket LCCI
难度: medium
链接: https://leetcode.cn/problems/bracket-lcci/
题目类型: 字符串、动态规划、回溯
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
面试题 08.09. 括号 - 括号。设计一种算法，打印n对括号的所有合法的（例如，开闭一一对应）组合。 说明：解集不能包含重复的子集。 示例： 输入：n = 3 输出： [ "((()))", "(()())", "(())()", "()(())", "()()()" ]
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用回溯法生成所有可能的括号组合，并在过程中进行剪枝以确保合法性。

算法步骤:
1. 定义一个递归函数 `backtrack`，参数包括当前字符串 `path`，左括号数量 `left` 和右括号数量 `right`。
2. 如果 `left` 和 `right` 都为 0，则将当前字符串 `path` 加入结果列表。
3. 如果 `left` 大于 0，则可以添加一个左括号，并递归调用 `backtrack`。
4. 如果 `right` 大于 `left`，则可以添加一个右括号，并递归调用 `backtrack`。

关键点:
- 通过控制左右括号的数量来确保生成的括号组合是合法的。
- 使用回溯法避免生成非法的括号组合。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(4^n / sqrt(n))，其中 n 是括号对数。这是卡特兰数的时间复杂度。
空间复杂度: O(n)，递归调用栈的深度最多为 2n。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def generate_parenthesis(n: int) -> List[str]:
    """
    生成 n 对括号的所有合法组合。
    """
    def backtrack(path: str, left: int, right: int):
        if len(path) == 2 * n:
            result.append(path)
            return
        if left < n:
            backtrack(path + '(', left + 1, right)
        if right < left:
            backtrack(path + ')', left, right + 1)

    result = []
    backtrack("", 0, 0)
    return result


Solution = create_solution(generate_parenthesis)