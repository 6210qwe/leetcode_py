# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2591
标题: Frog Jump II
难度: medium
链接: https://leetcode.cn/problems/frog-jump-ii/
题目类型: 贪心、数组、二分查找
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2498. 青蛙过河 II - 给你一个下标从 0 开始的整数数组 stones ，数组中的元素 严格递增 ，表示一条河中石头的位置。 一只青蛙一开始在第一块石头上，它想到达最后一块石头，然后回到第一块石头。同时每块石头 至多 到达 一次。 一次跳跃的 长度 是青蛙跳跃前和跳跃后所在两块石头之间的距离。 * 更正式的，如果青蛙从 stones[i] 跳到 stones[j] ，跳跃的长度为 |stones[i] - stones[j]| 。 一条路径的 代价 是这条路径里的 最大跳跃长度 。 请你返回这只青蛙的 最小代价 。 示例 1： [https://assets.leetcode.com/uploads/2022/11/14/example-1.png] 输入：stones = [0,2,5,6,7] 输出：5 解释：上图展示了一条最优路径。 这条路径的代价是 5 ，是这条路径中的最大跳跃长度。 无法得到一条代价小于 5 的路径，我们返回 5 。 示例 2： [https://assets.leetcode.com/uploads/2022/11/14/example-2.png] 输入：stones = [0,3,9] 输出：9 解释： 青蛙可以直接跳到最后一块石头，然后跳回第一块石头。 在这条路径中，每次跳跃长度都是 9 。所以路径代价是 max(9, 9) = 9 。 这是可行路径中的最小代价。 提示： * 2 <= stones.length <= 105 * 0 <= stones[i] <= 109 * stones[0] == 0 * stones 中的元素严格递增。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用贪心算法，通过跳跃间隔来最小化最大跳跃长度。

算法步骤:
1. 初始化一个变量 `max_jump` 为 0，用于记录当前的最大跳跃长度。
2. 遍历数组 `stones`，计算相邻两个石头之间的跳跃长度，并更新 `max_jump`。
3. 返回 `max_jump` 作为结果。

关键点:
- 通过跳跃间隔来最小化最大跳跃长度。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是数组 `stones` 的长度。我们需要遍历整个数组一次。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def min_frog_jump(stones: List[int]) -> int:
    """
    函数式接口 - 计算青蛙过河的最小代价
    """
    if len(stones) < 2:
        return 0

    max_jump = 0
    for i in range(1, len(stones)):
        max_jump = max(max_jump, stones[i] - stones[i - 1])

    return max_jump


Solution = create_solution(min_frog_jump)