# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2685
标题: First Completely Painted Row or Column
难度: medium
链接: https://leetcode.cn/problems/first-completely-painted-row-or-column/
题目类型: 数组、哈希表、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2661. 找出叠涂元素 - 给你一个下标从 0 开始的整数数组 arr 和一个 m x n 的整数 矩阵 mat 。arr 和 mat 都包含范围 [1，m * n] 内的 所有 整数。 从下标 0 开始遍历 arr 中的每个下标 i ，并将包含整数 arr[i] 的 mat 单元格涂色。 请你找出 arr 中第一个使得 mat 的某一行或某一列都被涂色的元素，并返回其下标 i 。 示例 1： image explanation for example 1 [https://assets.leetcode.com/uploads/2023/01/18/grid1.jpg] 输入：arr = [1,3,4,2], mat = [[1,4],[2,3]] 输出：2 解释：遍历如上图所示，arr[2] 在矩阵中的第一行或第二列上都被涂色。 示例 2： image explanation for example 2 [https://assets.leetcode.com/uploads/2023/01/18/grid2.jpg] 输入：arr = [2,8,7,4,1,3,5,6,9], mat = [[3,2,5],[1,4,6],[8,7,9]] 输出：3 解释：遍历如上图所示，arr[3] 在矩阵中的第二列上都被涂色。 提示： * m == mat.length * n = mat[i].length * arr.length == m * n * 1 <= m, n <= 105 * 1 <= m * n <= 105 * 1 <= arr[i], mat[r][c] <= m * n * arr 中的所有整数 互不相同 * mat 中的所有整数 互不相同
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用哈希表记录每个元素在矩阵中的位置，然后遍历 arr 数组，更新每行和每列的涂色计数，直到某一行或某一列被完全涂色。

算法步骤:
1. 构建一个哈希表 `pos_map`，记录每个元素在矩阵中的位置 (r, c)。
2. 初始化两个数组 `row_count` 和 `col_count`，分别记录每行和每列的涂色计数。
3. 遍历 arr 数组，对于每个元素，获取其在矩阵中的位置 (r, c)，并更新 `row_count[r]` 和 `col_count[c]`。
4. 检查 `row_count[r]` 或 `col_count[c]` 是否等于矩阵的列数或行数，如果是，则返回当前元素的下标。
5. 如果遍历完 arr 数组后没有找到符合条件的元素，返回 -1。

关键点:
- 使用哈希表快速查找元素的位置。
- 使用两个数组分别记录每行和每列的涂色计数。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m * n)，其中 m 和 n 分别是矩阵的行数和列数。构建哈希表和遍历 arr 数组的时间复杂度都是 O(m * n)。
空间复杂度: O(m * n)，哈希表 `pos_map` 和两个计数数组 `row_count` 和 `col_count` 需要 O(m * n) 的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def firstCompleteIndex(arr: List[int], mat: List[List[int]]) -> int:
    """
    找出第一个使得矩阵的某一行或某一列都被涂色的元素的下标。
    """
    m, n = len(mat), len(mat[0])
    pos_map = {}
    
    # 构建哈希表，记录每个元素在矩阵中的位置
    for r in range(m):
        for c in range(n):
            pos_map[mat[r][c]] = (r, c)
    
    # 初始化行和列的涂色计数
    row_count = [0] * m
    col_count = [0] * n
    
    # 遍历 arr 数组
    for i, num in enumerate(arr):
        r, c = pos_map[num]
        row_count[r] += 1
        col_count[c] += 1
        
        # 检查当前行或列是否被完全涂色
        if row_count[r] == n or col_count[c] == m:
            return i
    
    return -1

Solution = create_solution(firstCompleteIndex)