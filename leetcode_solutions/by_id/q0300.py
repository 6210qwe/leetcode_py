# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 300
标题: Longest Increasing Subsequence
难度: medium
链接: https://leetcode.cn/problems/longest-increasing-subsequence/
题目类型: 数组、二分查找、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
300. 最长递增子序列 - 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 示例 1： 输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 示例 2： 输入：nums = [0,1,0,3,2,3] 输出：4 示例 3： 输入：nums = [7,7,7,7,7,7,7] 输出：1 提示： * 1 <= nums.length <= 2500 * -104 <= nums[i] <= 104 进阶： * 你能将算法的时间复杂度降低到 O(n log(n)) 吗?
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用二分查找维护一个递增序列，tails[i]表示长度为i+1的递增子序列的最小末尾元素

算法步骤:
1. 维护一个数组tails，tails[i]表示长度为i+1的递增子序列的最小末尾元素
2. 遍历数组，对于每个元素，使用二分查找找到它在tails中的位置
3. 如果元素大于所有tails中的元素，扩展序列；否则替换对应位置

关键点:
- 使用二分查找优化到O(nlogn)
- 时间复杂度O(nlogn)，空间复杂度O(n)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(nlogn) - 遍历数组O(n)，每个元素二分查找O(logn)
空间复杂度: O(n) - tails数组空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import bisect
from leetcode_solutions.utils.solution import create_solution


def longest_increasing_subsequence(nums: List[int]) -> int:
    """
    函数式接口 - 最长递增子序列
    
    实现思路:
    使用二分查找维护一个递增序列，tails[i]表示长度为i+1的递增子序列的最小末尾元素。
    
    Args:
        nums: 整数数组
        
    Returns:
        最长严格递增子序列的长度
        
    Example:
        >>> longest_increasing_subsequence([10,9,2,5,3,7,101,18])
        4
    """
    if not nums:
        return 0
    
    tails = []
    
    for num in nums:
        # 使用二分查找找到插入位置
        pos = bisect.bisect_left(tails, num)
        
        if pos == len(tails):
            # 如果num大于所有元素，扩展序列
            tails.append(num)
        else:
            # 否则替换对应位置，保持最小末尾元素
            tails[pos] = num
    
    return len(tails)


# 自动生成Solution类（无需手动编写）
Solution = create_solution(longest_increasing_subsequence)
