# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 63
标题: Unique Paths II
难度: medium
链接: https://leetcode.cn/problems/unique-paths-ii/
题目类型: 数组、动态规划、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
63. 不同路径 II - 给定一个 m x n 的整数数组 grid。一个机器人初始位于 左上角（即 grid[0][0]）。机器人尝试移动到 右下角（即 grid[m - 1][n - 1]）。机器人每次只能向下或者向右移动一步。 网格中的障碍物和空位置分别用 1 和 0 来表示。机器人的移动路径中不能包含 任何 有障碍物的方格。 返回机器人能够到达右下角的不同路径数量。 测试用例保证答案小于等于 2 * 109。 示例 1： [https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg] 输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]] 输出：2 解释：3x3 网格的正中间有一个障碍物。 从左上角到右下角一共有 2 条不同的路径： 1. 向右 -> 向右 -> 向下 -> 向下 2. 向下 -> 向下 -> 向右 -> 向右 示例 2： [https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg] 输入：obstacleGrid = [[0,1],[0,0]] 输出：1 提示： * m == obstacleGrid.length * n == obstacleGrid[i].length * 1 <= m, n <= 100 * obstacleGrid[i][j] 为 0 或 1
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 动态规划，遇到障碍物时路径数为0

算法步骤:
1. 如果起点或终点有障碍物，返回0
2. 初始化第一行和第一列：
   - 如果遇到障碍物，后续位置路径数都为0
   - 否则路径数为1
3. 状态转移：如果当前位置有障碍物，dp[i][j] = 0
   否则，dp[i][j] = dp[i-1][j] + dp[i][j-1]
4. 返回dp[m-1][n-1]

关键点:
- 可以优化空间复杂度为O(n)，使用一维数组
- 遇到障碍物时，该位置的路径数直接设为0
- 注意边界条件的处理
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m*n) - 需要遍历整个网格
空间复杂度: O(n) - 优化后只使用一维数组
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from leetcode_solutions.utils.solution import create_solution


def unique_paths_with_obstacles(obstacle_grid: List[List[int]]) -> int:
    """
    函数式接口 - 动态规划（空间优化）
    
    实现思路:
    使用动态规划，遇到障碍物时路径数为0，优化空间复杂度为O(n)。
    
    Args:
        obstacle_grid: m×n的网格，1表示障碍物，0表示空位置
        
    Returns:
        从左上角到右下角的不同路径数量
        
    Example:
        >>> unique_paths_with_obstacles([[0,0,0],[0,1,0],[0,0,0]])
        2
    """
    m, n = len(obstacle_grid), len(obstacle_grid[0])
    
    # 如果起点或终点有障碍物，返回0
    if obstacle_grid[0][0] == 1 or obstacle_grid[m - 1][n - 1] == 1:
        return 0
    
    # 使用一维数组
    dp = [0] * n
    dp[0] = 1
    
    # 初始化第一行
    for j in range(1, n):
        if obstacle_grid[0][j] == 1:
            dp[j] = 0
        else:
            dp[j] = dp[j - 1]
    
    # 从第二行开始计算
    for i in range(1, m):
        # 更新第一列
        if obstacle_grid[i][0] == 1:
            dp[0] = 0
        # 更新其他列
        for j in range(1, n):
            if obstacle_grid[i][j] == 1:
                dp[j] = 0
            else:
                dp[j] += dp[j - 1]
    
    return dp[n - 1]


# 自动生成Solution类（无需手动编写）
Solution = create_solution(unique_paths_with_obstacles)
