# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 312
标题: Burst Balloons
难度: hard
链接: https://leetcode.cn/problems/burst-balloons/
题目类型: 数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
312. 戳气球 - 有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。 现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。 求所能获得硬币的最大数量。 示例 1： 输入：nums = [3,1,5,8] 输出：167 解释： nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 示例 2： 输入：nums = [1,5] 输出：10 提示： * n == nums.length * 1 <= n <= 300 * 0 <= nums[i] <= 100
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 区间动态规划，dp[i][j]表示戳破(i,j)区间内所有气球能获得的最大硬币数

算法步骤:
1. 在数组两端添加1，方便处理边界
2. dp[i][j] = max(dp[i][k] + dp[k][j] + nums[i]*nums[k]*nums[j])，k为最后戳破的气球
3. 枚举区间长度和区间起点，计算dp值

关键点:
- 区间DP，枚举最后戳破的气球
- 时间复杂度O(n^3)，空间复杂度O(n^2)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^3) - n为气球数量
空间复杂度: O(n^2) - dp数组空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from leetcode_solutions.utils.solution import create_solution


def burst_balloons(nums: List[int]) -> int:
    """
    函数式接口 - 戳气球
    
    实现思路:
    区间动态规划，dp[i][j]表示戳破(i,j)区间内所有气球能获得的最大硬币数。
    
    Args:
        nums: 气球上的数字数组
        
    Returns:
        能获得硬币的最大数量
        
    Example:
        >>> burst_balloons([3, 1, 5, 8])
        167
    """
    n = len(nums)
    # 在两端添加1
    balloons = [1] + nums + [1]
    m = len(balloons)
    
    # dp[i][j]表示戳破(i,j)区间内所有气球能获得的最大硬币数
    dp = [[0] * m for _ in range(m)]
    
    # 枚举区间长度
    for length in range(3, m + 1):
        for i in range(m - length + 1):
            j = i + length - 1
            # 枚举最后戳破的气球k
            for k in range(i + 1, j):
                dp[i][j] = max(
                    dp[i][j],
                    dp[i][k] + dp[k][j] + balloons[i] * balloons[k] * balloons[j]
                )
    
    return dp[0][m - 1]


# 自动生成Solution类（无需手动编写）
Solution = create_solution(burst_balloons)
