# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1940
标题: Maximum XOR for Each Query
难度: medium
链接: https://leetcode.cn/problems/maximum-xor-for-each-query/
题目类型: 位运算、数组、前缀和
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1829. 每个查询的最大异或值 - 给你一个 有序 数组 nums ，它由 n 个非负整数组成，同时给你一个整数 maximumBit 。你需要执行以下查询 n 次： 1. 找到一个非负整数 k < 2maximumBit ，使得 nums[0] XOR nums[1] XOR ... XOR nums[nums.length-1] XOR k 的结果 最大化 。k 是第 i 个查询的答案。 2. 从当前数组 nums 删除 最后 一个元素。 请你返回一个数组 answer ，其中 answer[i]是第 i 个查询的结果。 示例 1： 输入：nums = [0,1,1,3], maximumBit = 2 输出：[0,3,2,3] 解释：查询的答案如下： 第一个查询：nums = [0,1,1,3]，k = 0，因为 0 XOR 1 XOR 1 XOR 3 XOR 0 = 3 。 第二个查询：nums = [0,1,1]，k = 3，因为 0 XOR 1 XOR 1 XOR 3 = 3 。 第三个查询：nums = [0,1]，k = 2，因为 0 XOR 1 XOR 2 = 3 。 第四个查询：nums = [0]，k = 3，因为 0 XOR 3 = 3 。 示例 2： 输入：nums = [2,3,4,7], maximumBit = 3 输出：[5,2,6,5] 解释：查询的答案如下： 第一个查询：nums = [2,3,4,7]，k = 5，因为 2 XOR 3 XOR 4 XOR 7 XOR 5 = 7。 第二个查询：nums = [2,3,4]，k = 2，因为 2 XOR 3 XOR 4 XOR 2 = 7 。 第三个查询：nums = [2,3]，k = 6，因为 2 XOR 3 XOR 6 = 7 。 第四个查询：nums = [2]，k = 5，因为 2 XOR 5 = 7 。 示例 3： 输入：nums = [0,1,2,2,5,7], maximumBit = 3 输出：[4,3,6,4,6,7] 提示： * nums.length == n * 1 <= n <= 105 * 1 <= maximumBit <= 20 * 0 <= nums[i] < 2maximumBit * nums 中的数字已经按 升序 排好序。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过前缀异或和来快速计算每个查询的结果。

算法步骤:
1. 计算前缀异或和数组 prefix_xor。
2. 对于每个查询，计算当前前缀异或和与最大可能值 (2^maximumBit - 1) 的异或结果。
3. 将结果存储在答案数组中。

关键点:
- 使用前缀异或和可以快速计算任意子数组的异或和。
- 最大可能值为 (2^maximumBit - 1)，与当前前缀异或和的异或结果即为最大化的 k。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def get_maximum_xor(nums: List[int], maximum_bit: int) -> List[int]:
    n = len(nums)
    prefix_xor = [0] * (n + 1)
    
    # 计算前缀异或和
    for i in range(n):
        prefix_xor[i + 1] = prefix_xor[i] ^ nums[i]
    
    max_value = (1 << maximum_bit) - 1
    result = []
    
    # 计算每个查询的结果
    for i in range(n):
        k = prefix_xor[n - i] ^ max_value
        result.append(k)
    
    return result

Solution = create_solution(get_maximum_xor)