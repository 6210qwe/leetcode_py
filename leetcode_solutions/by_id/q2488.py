# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2488
标题: Divide Intervals Into Minimum Number of Groups
难度: medium
链接: https://leetcode.cn/problems/divide-intervals-into-minimum-number-of-groups/
题目类型: 贪心、数组、双指针、前缀和、排序、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2406. 将区间分为最少组数 - 给你一个二维整数数组 intervals ，其中 intervals[i] = [lefti, righti] 表示 闭 区间 [lefti, righti] 。 你需要将 intervals 划分为一个或者多个区间 组 ，每个区间 只 属于一个组，且同一个组中任意两个区间 不相交 。 请你返回 最少 需要划分成多少个组。 如果两个区间覆盖的范围有重叠（即至少有一个公共数字），那么我们称这两个区间是 相交 的。比方说区间 [1, 5] 和 [5, 8] 相交。 示例 1： 输入：intervals = [[5,10],[6,8],[1,5],[2,3],[1,10]] 输出：3 解释：我们可以将区间划分为如下的区间组： - 第 1 组：[1, 5] ，[6, 8] 。 - 第 2 组：[2, 3] ，[5, 10] 。 - 第 3 组：[1, 10] 。 可以证明无法将区间划分为少于 3 个组。 示例 2： 输入：intervals = [[1,3],[5,6],[8,10],[11,13]] 输出：1 解释：所有区间互不相交，所以我们可以把它们全部放在一个组内。 提示： * 1 <= intervals.length <= 105 * intervals[i].length == 2 * 1 <= lefti <= righti <= 106
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用贪心算法和最小堆来解决这个问题。首先将所有区间的左端点和右端点分别存储，并按时间顺序排序。然后使用一个最小堆来跟踪当前活动的区间组。每次遇到一个新的左端点时，检查是否有可以合并的区间组；如果没有，则创建一个新的区间组。

算法步骤:
1. 将所有区间的左端点和右端点分别存储在两个列表中。
2. 按时间顺序对这些端点进行排序。
3. 使用一个最小堆来跟踪当前活动的区间组。
4. 遍历排序后的端点列表，对于每个左端点：
   - 如果堆为空或堆顶元素大于当前左端点，说明需要一个新的区间组。
   - 否则，从堆中弹出一个元素，表示该区间组可以继续使用。
5. 对于每个右端点，将其加入堆中。
6. 最终堆的大小即为所需的最少区间组数。

关键点:
- 使用最小堆来高效地管理当前活动的区间组。
- 按时间顺序处理端点，确保正确处理区间的重叠情况。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是 intervals 的长度。主要的时间开销在于排序操作。
空间复杂度: O(n)，用于存储端点和最小堆。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def min_groups(intervals: List[List[int]]) -> int:
    """
    函数式接口 - 返回将区间分为最少组数
    """
    # 将所有区间的左端点和右端点分别存储
    events = []
    for start, end in intervals:
        events.append((start, 1))  # 左端点
        events.append((end + 1, -1))  # 右端点

    # 按时间顺序对这些端点进行排序
    events.sort()

    # 使用一个最小堆来跟踪当前活动的区间组
    active_groups = 0
    max_groups = 0
    for _, event_type in events:
        active_groups += event_type
        max_groups = max(max_groups, active_groups)

    return max_groups

Solution = create_solution(min_groups)