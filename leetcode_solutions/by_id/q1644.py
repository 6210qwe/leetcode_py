# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1644
标题: Maximum Number of Non-Overlapping Substrings
难度: hard
链接: https://leetcode.cn/problems/maximum-number-of-non-overlapping-substrings/
题目类型: 贪心、字符串
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1520. 最多的不重叠子字符串 - 给你一个只包含小写字母的字符串 s ，你需要找到 s 中最多数目的非空子字符串，满足如下条件： 1. 这些字符串之间互不重叠，也就是说对于任意两个子字符串 s[i..j] 和 s[x..y] ，要么 j < x 要么 i > y 。 2. 如果一个子字符串包含字符 char ，那么 s 中所有 char 字符都应该在这个子字符串中。 请你找到满足上述条件的最多子字符串数目。如果有多个解法有相同的子字符串数目，请返回这些子字符串总长度最小的一个解。可以证明最小总长度解是唯一的。 请注意，你可以以 任意 顺序返回最优解的子字符串。 示例 1： 输入：s = "adefaddaccc" 输出：["e","f","ccc"] 解释：下面为所有满足第二个条件的子字符串： [ "adefaddaccc" "adefadda", "ef", "e", "f", "ccc", ] 如果我们选择第一个字符串，那么我们无法再选择其他任何字符串，所以答案为 1 。如果我们选择 "adefadda" ，剩下子字符串中我们只可以选择 "ccc" ，它是唯一不重叠的子字符串，所以答案为 2 。同时我们可以发现，选择 "ef" 不是最优的，因为它可以被拆分成 2 个子字符串。所以最优解是选择 ["e","f","ccc"] ，答案为 3 。不存在别的相同数目子字符串解。 示例 2： 输入：s = "abbaccd" 输出：["d","bb","cc"] 解释：注意到解 ["d","abba","cc"] 答案也为 3 ，但它不是最优解，因为它的总长度更长。 提示： * 1 <= s.length <= 10^5 * s 只包含小写英文字母。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用贪心算法，通过记录每个字符的最左和最右出现位置，构建区间，然后合并区间，最终得到不重叠的子字符串。

算法步骤:
1. 记录每个字符在字符串中的最左和最右出现位置。
2. 构建区间，并尝试合并区间，确保每个区间内的字符都在该区间内出现。
3. 选择不重叠的区间，使得子字符串数量最多且总长度最小。

关键点:
- 通过记录字符的最左和最右位置来构建区间。
- 合并区间时，确保每个区间内的字符都在该区间内出现。
- 选择不重叠的区间，使得子字符串数量最多且总长度最小。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是字符串 s 的长度。我们需要遍历字符串两次，一次记录字符的位置，一次构建和合并区间。
空间复杂度: O(1)，虽然我们使用了额外的空间来记录字符的位置，但空间复杂度是常数级别的，因为字符集大小是固定的（26个小写字母）。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def max_num_of_non_overlapping_substrings(s: str) -> List[str]:
    """
    函数式接口 - 实现最多不重叠子字符串
    """
    # 记录每个字符的最左和最右出现位置
    left, right = {}, {}
    for i, char in enumerate(s):
        if char not in left:
            left[char] = i
        right[char] = i
    
    # 构建区间
    intervals = []
    for char in set(s):
        intervals.append((left[char], right[char]))
    
    # 按区间的左端点排序
    intervals.sort()
    
    # 合并区间
    merged_intervals = []
    for l, r in intervals:
        if not merged_intervals or merged_intervals[-1][1] < l:
            merged_intervals.append([l, r])
        else:
            merged_intervals[-1][1] = max(merged_intervals[-1][1], r)
    
    # 选择不重叠的区间
    result = []
    end = -1
    for l, r in merged_intervals:
        if l > end:
            result.append(s[l:r+1])
            end = r
    
    return result

Solution = create_solution(max_num_of_non_overlapping_substrings)