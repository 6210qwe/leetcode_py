# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 815
标题: Champagne Tower
难度: medium
链接: https://leetcode.cn/problems/champagne-tower/
题目类型: 动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
799. 香槟塔 - 我们把玻璃杯摆成金字塔的形状，其中 第一层 有 1 个玻璃杯， 第二层 有 2 个，依次类推到第 100 层，每个玻璃杯将盛有香槟。 从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上） 例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，如下图所示。 [https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/09/tower.png] 现在当倾倒了非负整数杯香槟后，返回第 i 行 j 个玻璃杯所盛放的香槟占玻璃杯容积的比例（ i 和 j 都从0开始）。 示例 1: 输入: poured(倾倒香槟总杯数) = 1, query_glass(杯子的位置数) = 1, query_row(行数) = 1 输出: 0.00000 解释: 我们在顶层（下标是（0，0））倒了一杯香槟后，没有溢出，因此所有在顶层以下的玻璃杯都是空的。 示例 2: 输入: poured(倾倒香槟总杯数) = 2, query_glass(杯子的位置数) = 1, query_row(行数) = 1 输出: 0.50000 解释: 我们在顶层（下标是（0，0）倒了两杯香槟后，有一杯量的香槟将从顶层溢出，位于（1，0）的玻璃杯和（1，1）的玻璃杯平分了这一杯香槟，所以每个玻璃杯有一半的香槟。 示例 3: 输入: poured = 100000009, query_row = 33, query_glass = 17 输出: 1.00000 提示: * 0 <= poured <= 109 * 0 <= query_glass <= query_row < 100
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来模拟香槟流动的过程。我们用一个二维数组 dp 来表示每一层每个玻璃杯中的香槟量。

算法步骤:
1. 初始化一个二维数组 dp，dp[i][j] 表示第 i 行第 j 个玻璃杯中的香槟量。
2. 将倒入的香槟量全部加到 dp[0][0] 中。
3. 从第一层开始，逐层计算每个玻璃杯中的香槟量。如果当前玻璃杯中的香槟量超过 1，则将其超出的部分平均分配给下一层的两个玻璃杯。
4. 最后返回 dp[query_row][query_glass] 的值，如果该值大于 1，则返回 1，否则返回该值。

关键点:
- 使用动态规划来模拟香槟流动的过程。
- 只需要计算到 query_row 这一行，不需要计算整个金字塔。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(query_row^2)
空间复杂度: O(query_row^2)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def champagne_tower(poured: int, query_row: int, query_glass: int) -> float:
    """
    函数式接口 - 计算第 query_row 行第 query_glass 个玻璃杯中的香槟量
    """
    # 初始化 dp 数组
    dp = [[0.0] * (r + 1) for r in range(query_row + 1)]
    
    # 将倒入的香槟量全部加到 dp[0][0] 中
    dp[0][0] = poured
    
    # 逐层计算每个玻璃杯中的香槟量
    for r in range(query_row):
        for c in range(r + 1):
            excess = (dp[r][c] - 1.0) / 2.0
            if excess > 0:
                dp[r + 1][c] += excess
                dp[r + 1][c + 1] += excess
    
    # 返回 dp[query_row][query_glass] 的值
    return min(1.0, dp[query_row][query_glass])


Solution = create_solution(champagne_tower)