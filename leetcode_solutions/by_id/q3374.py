# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3374
标题: Count Alternating Subarrays
难度: medium
链接: https://leetcode.cn/problems/count-alternating-subarrays/
题目类型: 数组、数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3101. 交替子数组计数 - 给你一个二进制数组 nums 。 如果一个子数组中 不存在 两个 相邻 元素的值 相同 的情况，我们称这样的子数组为 交替子数组 。 返回数组 nums 中交替子数组的数量。 示例 1： 输入： nums = [0,1,1,1] 输出： 5 解释： 以下子数组是交替子数组：[0] 、[1] 、[1] 、[1] 以及 [0,1] 。 示例 2： 输入： nums = [1,0,1,0] 输出： 10 解释： 数组的每个子数组都是交替子数组。可以统计在内的子数组共有 10 个。 提示： * 1 <= nums.length <= 105 * nums[i] 不是 0 就是 1 。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用双指针方法来遍历数组，并计算所有交替子数组的数量。

算法步骤:
1. 初始化两个指针 `left` 和 `right`，都指向数组的第一个元素。
2. 使用 `right` 指针遍历数组，如果当前元素与前一个元素不同，则继续移动 `right` 指针。
3. 当 `right` 指针遇到相邻元素相同的情况时，计算以 `left` 为起点的所有交替子数组的数量，并更新 `left` 指针到 `right` 的位置。
4. 重复步骤 2 和 3，直到遍历完整个数组。
5. 最后，处理从最后一个 `left` 到数组末尾的所有交替子数组。

关键点:
- 使用双指针方法可以高效地找到所有交替子数组。
- 通过计算子数组的长度，可以快速得到所有交替子数组的数量。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是数组的长度。每个元素最多被访问两次。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def count_alternating_subarrays(nums: List[int]) -> int:
    """
    计算二进制数组 nums 中交替子数组的数量。
    """
    n = len(nums)
    if n == 0:
        return 0
    
    left = 0
    right = 0
    count = 0
    
    while right < n:
        # 移动 right 指针，直到遇到相邻元素相同的情况
        while right + 1 < n and nums[right] != nums[right + 1]:
            right += 1
        
        # 计算以 left 为起点的所有交替子数组的数量
        length = right - left + 1
        count += (length * (length + 1)) // 2
        
        # 更新 left 指针
        left = right + 1
        right = left
    
    return count

Solution = create_solution(count_alternating_subarrays)