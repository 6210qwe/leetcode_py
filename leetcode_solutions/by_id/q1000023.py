# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000023
标题: The Masseuse LCCI
难度: easy
链接: https://leetcode.cn/problems/the-masseuse-lcci/
题目类型: 数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
面试题 17.16. 按摩师 - 一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。 注意：本题相对原题稍作改动 示例 1： 输入： [1,2,3,1] 输出： 4 解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。 示例 2： 输入： [2,7,9,3,1] 输出： 12 解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。 示例 3： 输入： [2,1,4,5,3,1,1,3] 输出： 12 解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们定义 dp[i] 表示前 i 个预约的最大总时长。状态转移方程为：
dp[i] = max(dp[i-1], dp[i-2] + nums[i-1])

算法步骤:
1. 初始化 dp 数组，长度为 n+1，其中 n 是预约请求的长度。
2. 设置初始条件：dp[0] = 0, dp[1] = nums[0]。
3. 遍历预约请求，更新 dp 数组。
4. 返回 dp[n] 作为结果。

关键点:
- 使用 dp 数组来存储中间结果，避免重复计算。
- 状态转移方程确保了不接受相邻的预约。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是预约请求的长度。我们只需要遍历一次预约请求。
空间复杂度: O(n)，我们需要一个长度为 n+1 的 dp 数组来存储中间结果。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(nums: List[int]) -> int:
    """
    函数式接口 - 实现最优解法
    """
    if not nums:
        return 0

    n = len(nums)
    if n == 1:
        return nums[0]

    dp = [0] * (n + 1)
    dp[1] = nums[0]

    for i in range(2, n + 1):
        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i - 1])

    return dp[n]


Solution = create_solution(solution_function_name)