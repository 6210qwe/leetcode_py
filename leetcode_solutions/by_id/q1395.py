# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1395
标题: Minimum Time Visiting All Points
难度: easy
链接: https://leetcode.cn/problems/minimum-time-visiting-all-points/
题目类型: 几何、数组、数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1266. 访问所有点的最小时间 - 平面上有 n 个点，点的位置用整数坐标表示 points[i] = [xi, yi] 。请你计算访问所有这些点需要的 最小时间（以秒为单位）。 你需要按照下面的规则在平面上移动： * 每一秒内，你可以： * 沿水平方向移动一个单位长度，或者 * 沿竖直方向移动一个单位长度，或者 * 跨过对角线移动 sqrt(2) 个单位长度（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。 * 必须按照数组中出现的顺序来访问这些点。 * 在访问某个点时，可以经过该点后面出现的点，但经过的那些点不算作有效访问。 示例 1： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2019/11/24/1626_example_1.png] 输入：points = [[1,1],[3,4],[-1,0]] 输出：7 解释：一条最佳的访问路径是： [1,1] -> [2,2] -> [3,3] -> [3,4] -> [2,3] -> [1,2] -> [0,1] -> [-1,0] 从 [1,1] 到 [3,4] 需要 3 秒 从 [3,4] 到 [-1,0] 需要 4 秒 一共需要 7 秒 示例 2： 输入：points = [[3,2],[-2,2]] 输出：5 提示： * points.length == n * 1 <= n <= 100 * points[i].length == 2 * -1000 <= points[i][0], points[i][1] <= 1000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过计算每两个相邻点之间的曼哈顿距离来确定最小时间。

算法步骤:
1. 初始化总时间为 0。
2. 遍历所有相邻点对，计算它们之间的曼哈顿距离，并将其加到总时间中。
3. 返回总时间。

关键点:
- 曼哈顿距离可以同时考虑水平和垂直方向的移动，以及对角线移动。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是点的数量。我们需要遍历所有相邻点对。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def min_time_to_visit_all_points(points: List[List[int]]) -> int:
    """
    计算访问所有点的最小时间。
    """
    total_time = 0
    for i in range(1, len(points)):
        dx = abs(points[i][0] - points[i - 1][0])
        dy = abs(points[i][1] - points[i - 1][1])
        total_time += max(dx, dy)
    return total_time


Solution = create_solution(min_time_to_visit_all_points)