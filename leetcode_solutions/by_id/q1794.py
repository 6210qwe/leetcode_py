# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1794
标题: Minimize Deviation in Array
难度: hard
链接: https://leetcode.cn/problems/minimize-deviation-in-array/
题目类型: 贪心、数组、有序集合、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1675. 数组的最小偏移量 - 给你一个由 n 个正整数组成的数组 nums 。 你可以对数组的任意元素执行任意次数的两类操作： * 如果元素是 偶数 ，除以 2 * 例如，如果数组是 [1,2,3,4] ，那么你可以对最后一个元素执行此操作，使其变成 [1,2,3,2] * 如果元素是 奇数 ，乘上 2 * 例如，如果数组是 [1,2,3,4] ，那么你可以对第一个元素执行此操作，使其变成 [2,2,3,4] 数组的 偏移量 是数组中任意两个元素之间的 最大差值 。 返回数组在执行某些操作之后可以拥有的 最小偏移量 。 示例 1： 输入：nums = [1,2,3,4] 输出：1 解释：你可以将数组转换为 [1,2,3,2]，然后转换成 [2,2,3,2]，偏移量是 3 - 2 = 1 示例 2： 输入：nums = [4,1,5,20,3] 输出：3 解释：两次操作后，你可以将数组转换为 [4,2,5,5,3]，偏移量是 5 - 2 = 3 示例 3： 输入：nums = [2,10,8] 输出：3 提示： * n == nums.length * 2 <= n <= 5 * 104 * 1 <= nums[i] <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用最大堆，将所有奇数乘以2，然后不断减小最大值

算法步骤:
1. 将所有奇数乘以2，统一为偶数
2. 使用最大堆维护数组
3. 不断减小最大值，直到最大值是奇数
4. 计算最小偏移量

关键点:
- 最大堆
- 贪心策略
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n*log(n)*log(max)) - n为数组长度
空间复杂度: O(n) - 堆空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
import heapq
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def minimum_deviation(nums: List[int]) -> int:
    """
    函数式接口 - 数组的最小偏移量
    
    实现思路:
    使用最大堆，将所有奇数乘以2，然后不断减小最大值。
    
    Args:
        nums: 正整数数组
        
    Returns:
        最小偏移量
        
    Example:
        >>> minimum_deviation([1,2,3,4])
        1
    """
    # 将所有奇数乘以2，统一为偶数
    heap = []
    min_val = float('inf')
    
    for num in nums:
        if num % 2 == 1:
            num *= 2
        heapq.heappush(heap, -num)  # 最大堆用负数
        min_val = min(min_val, num)
    
    result = float('inf')
    
    while True:
        max_val = -heapq.heappop(heap)
        result = min(result, max_val - min_val)
        
        # 如果最大值是奇数，不能再减小
        if max_val % 2 == 1:
            break
        
        # 将最大值除以2
        new_val = max_val // 2
        min_val = min(min_val, new_val)
        heapq.heappush(heap, -new_val)
    
    return result


Solution = create_solution(minimum_deviation)
