# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 241
标题: Different Ways to Add Parentheses
难度: medium
链接: https://leetcode.cn/problems/different-ways-to-add-parentheses/
题目类型: 递归、记忆化搜索、数学、字符串、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
241. 为运算表达式设计优先级 - 给你一个由数字和运算符组成的字符串 expression ，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。你可以 按任意顺序 返回答案。 生成的测试用例满足其对应输出值符合 32 位整数范围，不同结果的数量不超过 104 。 示例 1： 输入：expression = "2-1-1" 输出：[0,2] 解释： ((2-1)-1) = 0 (2-(1-1)) = 2 示例 2： 输入：expression = "2*3-4*5" 输出：[-34,-14,-10,-10,10] 解释： (2*(3-(4*5))) = -34 ((2*3)-(4*5)) = -14 ((2*(3-4))*5) = -10 (2*((3-4)*5)) = -10 (((2*3)-4)*5) = 10 提示： * 1 <= expression.length <= 20 * expression 由数字和算符 '+'、'-' 和 '*' 组成。 * 输入表达式中的所有整数值在范围 [0, 99] * 输入表达式中的所有整数都没有前导 '-' 或 '+' 表示符号。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 分治+记忆化，对于每个运算符，递归计算左右两边的所有可能结果，然后组合

算法步骤:
1. 如果表达式是纯数字，返回该数字
2. 遍历表达式，找到每个运算符
3. 对于每个运算符，递归计算左右两边的所有可能结果
4. 将左右结果组合，根据运算符计算
5. 使用记忆化优化重复计算

关键点:
- 分治+记忆化搜索
- 时间复杂度O(Catalan数)，空间复杂度O(n)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(Catalan数) - 括号组合的数量
空间复杂度: O(n) - 递归栈和记忆化空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from functools import lru_cache
from leetcode_solutions.utils.solution import create_solution


def different_ways_to_add_parentheses(expression: str) -> List[int]:
    """
    函数式接口 - 为运算表达式设计优先级
    
    实现思路:
    分治+记忆化，对于每个运算符，递归计算左右两边的所有可能结果，然后组合。
    
    Args:
        expression: 由数字和运算符组成的字符串
        
    Returns:
        所有可能组合的结果列表
        
    Example:
        >>> different_ways_to_add_parentheses("2-1-1")
        [0, 2]
    """
    @lru_cache(maxsize=None)
    def dfs(expr: str) -> List[int]:
        """递归计算表达式的所有可能结果"""
        if expr.isdigit():
            return [int(expr)]
        
        result = []
        for i, char in enumerate(expr):
            if char in '+-*':
                left = dfs(expr[:i])
                right = dfs(expr[i+1:])
                
                for l in left:
                    for r in right:
                        if char == '+':
                            result.append(l + r)
                        elif char == '-':
                            result.append(l - r)
                        else:
                            result.append(l * r)
        
        return result
    
    return dfs(expression)


# 自动生成Solution类（无需手动编写）
Solution = create_solution(different_ways_to_add_parentheses)
