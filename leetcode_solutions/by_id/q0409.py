# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 409
标题: Longest Palindrome
难度: easy
链接: https://leetcode.cn/problems/longest-palindrome/
题目类型: 贪心、哈希表、字符串
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
409. 最长回文串 - 给定一个包含大写字母和小写字母的字符串 s ，返回 通过这些字母构造成的 最长的 回文串 的长度。 在构造过程中，请注意 区分大小写 。比如 "Aa" 不能当做一个回文字符串。 示例 1: 输入:s = "abccccdd" 输出:7 解释: 我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。 示例 2: 输入:s = "a" 输出:1 解释：可以构造的最长回文串是"a"，它的长度是 1。 提示: * 1 <= s.length <= 2000 * s 只由小写 和/或 大写英文字母组成
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 统计每个字符出现次数，偶数次字符全部使用，奇数次字符使用次数-1，最后可以加一个中心字符

算法步骤:
1. 统计每个字符的出现次数
2. 累加所有偶数次字符和奇数次字符-1
3. 如果存在奇数次字符，可以加1作为中心

关键点:
- 贪心策略：尽可能使用所有字符
- 时间复杂度O(n)，空间复杂度O(1)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 需要遍历字符串一次
空间复杂度: O(1) - 字符集大小固定
"""

# ============================================================================
# 代码实现
# ============================================================================

from collections import Counter
from leetcode_solutions.utils.solution import create_solution


def longest_palindrome(s: str) -> int:
    """
    函数式接口 - 最长回文串
    
    实现思路:
    统计每个字符出现次数，偶数次字符全部使用，奇数次字符使用次数-1，最后可以加一个中心字符。
    
    Args:
        s: 字符串
        
    Returns:
        可以构造的最长回文串长度
        
    Example:
        >>> longest_palindrome("abccccdd")
        7
    """
    char_count = Counter(s)
    length = 0
    has_odd = False
    
    for count in char_count.values():
        if count % 2 == 0:
            length += count
        else:
            length += count - 1
            has_odd = True
    
    # 如果有奇数次字符，可以加1作为中心
    if has_odd:
        length += 1
    
    return length


# 自动生成Solution类（无需手动编写）
Solution = create_solution(longest_palindrome)
