# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000015
标题: Hanota LCCI
难度: easy
链接: https://leetcode.cn/problems/hanota-lcci/
题目类型: 递归、数组
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
面试题 08.06. 汉诺塔问题 - 在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制: (1) 每次只能移动一个盘子; (2) 盘子只能从柱子顶端滑出移到下一根柱子; (3) 盘子只能叠在比它大的盘子上。 请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。 你需要原地修改栈。 示例 1： 输入：A = [2, 1, 0], B = [], C = [] 输出：C = [2, 1, 0] 示例 2： 输入：A = [1, 0], B = [], C = [] 输出：C = [1, 0] 提示： 1. A 中盘子的数目不大于 14 个。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用递归方法解决汉诺塔问题。

算法步骤:
1. 将 n-1 个盘子从 A 移动到 B，使用 C 作为辅助柱子。
2. 将第 n 个盘子从 A 移动到 C。
3. 将 n-1 个盘子从 B 移动到 C，使用 A 作为辅助柱子。

关键点:
- 递归调用自身来解决子问题。
- 确保每次移动都是合法的。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(2^n) - 递归调用的次数是指数级的。
空间复杂度: O(n) - 递归调用栈的深度。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def hanota(A: List[int], B: List[int], C: List[int]) -> None:
    """
    将所有盘子从 A 移动到 C，使用 B 作为辅助柱子。
    """
    def move_disks(n: int, source: List[int], target: List[int], auxiliary: List[int]) -> None:
        if n == 1:
            # 只有一个盘子时，直接移动
            target.append(source.pop())
        else:
            # 将 n-1 个盘子从 source 移动到 auxiliary
            move_disks(n - 1, source, auxiliary, target)
            # 将第 n 个盘子从 source 移动到 target
            target.append(source.pop())
            # 将 n-1 个盘子从 auxiliary 移动到 target
            move_disks(n - 1, auxiliary, target, source)

    # 调用递归函数
    move_disks(len(A), A, C, B)


Solution = create_solution(hanota)