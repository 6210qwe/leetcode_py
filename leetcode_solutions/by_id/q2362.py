# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2362
标题: Minimum Rounds to Complete All Tasks
难度: medium
链接: https://leetcode.cn/problems/minimum-rounds-to-complete-all-tasks/
题目类型: 贪心、数组、哈希表、计数
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2244. 完成所有任务需要的最少轮数 - 给你一个下标从 0 开始的整数数组 tasks ，其中 tasks[i] 表示任务的难度级别。在每一轮中，你可以完成 2 个或者 3 个 相同难度级别 的任务。 返回完成所有任务需要的 最少 轮数，如果无法完成所有任务，返回 -1 。 示例 1： 输入：tasks = [2,2,3,3,2,4,4,4,4,4] 输出：4 解释：要想完成所有任务，一个可能的计划是： - 第一轮，完成难度级别为 2 的 3 个任务。 - 第二轮，完成难度级别为 3 的 2 个任务。 - 第三轮，完成难度级别为 4 的 3 个任务。 - 第四轮，完成难度级别为 4 的 2 个任务。 可以证明，无法在少于 4 轮的情况下完成所有任务，所以答案为 4 。 示例 2： 输入：tasks = [2,3,3] 输出：-1 解释：难度级别为 2 的任务只有 1 个，但每一轮执行中，只能选择完成 2 个或者 3 个相同难度级别的任务。因此，无法完成所有任务，答案为 -1 。 提示： * 1 <= tasks.length <= 105 * 1 <= tasks[i] <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用哈希表统计每个任务的出现次数，然后根据任务数量计算最少轮数。

算法步骤:
1. 使用 Counter 统计每个任务的出现次数。
2. 遍历每个任务的数量，计算完成该任务所需的最少轮数。
   - 如果任务数量为 1，直接返回 -1。
   - 如果任务数量为 2 或 3，分别需要 1 轮。
   - 如果任务数量大于 3，优先使用 3 个一组的任务，剩余部分再考虑 2 个一组的任务。

关键点:
- 优先使用 3 个一组的任务可以最小化轮数。
- 对于不能被 3 整除的任务数量，通过调整组合方式来最小化轮数。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是 tasks 的长度。我们需要遍历 tasks 数组并进行计数。
空间复杂度: O(n)，哈希表存储任务的计数。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from collections import Counter
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def minimum_rounds(tasks: List[int]) -> int:
    """
    函数式接口 - 计算完成所有任务需要的最少轮数
    """
    # 统计每个任务的出现次数
    task_count = Counter(tasks)
    
    rounds = 0
    for count in task_count.values():
        if count == 1:
            return -1
        elif count % 3 == 0:
            rounds += count // 3
        else:
            rounds += count // 3 + 1
    
    return rounds


Solution = create_solution(minimum_rounds)