# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1492
标题: Time Needed to Inform All Employees
难度: medium
链接: https://leetcode.cn/problems/time-needed-to-inform-all-employees/
题目类型: 树、深度优先搜索、广度优先搜索
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1376. 通知所有员工所需的时间 - 公司里有 n 名员工，每个员工的 ID 都是独一无二的，编号从 0 到 n - 1。公司的总负责人通过 headID 进行标识。 在 manager 数组中，每个员工都有一个直属负责人，其中 manager[i] 是第 i 名员工的直属负责人。对于总负责人，manager[headID] = -1。题目保证从属关系可以用树结构显示。 公司总负责人想要向公司所有员工通告一条紧急消息。他将会首先通知他的直属下属们，然后由这些下属通知他们的下属，直到所有的员工都得知这条紧急消息。 第 i 名员工需要 informTime[i] 分钟来通知它的所有直属下属（也就是说在 informTime[i] 分钟后，他的所有直属下属都可以开始传播这一消息）。 返回通知所有员工这一紧急消息所需要的 分钟数 。 示例 1： 输入：n = 1, headID = 0, manager = [-1], informTime = [0] 输出：0 解释：公司总负责人是该公司的唯一一名员工。 示例 2： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/03/08/graph.png] 输入：n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0] 输出：1 解释：id = 2 的员工是公司的总负责人，也是其他所有员工的直属负责人，他需要 1 分钟来通知所有员工。 上图显示了公司员工的树结构。 提示： * 1 <= n <= 10^5 * 0 <= headID < n * manager.length == n * 0 <= manager[i] < n * manager[headID] == -1 * informTime.length == n * 0 <= informTime[i] <= 1000 * 如果员工 i 没有下属，informTime[i] == 0 。 * 题目 保证 所有员工都可以收到通知。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用深度优先搜索 (DFS) 来遍历树结构，并计算从根节点到每个叶子节点的最大时间。

算法步骤:
1. 构建一个字典，表示每个经理的直接下属。
2. 使用 DFS 从根节点 (headID) 开始遍历，递归地计算每个节点的最大通知时间。
3. 返回最大通知时间。

关键点:
- 使用 DFS 递归遍历树结构。
- 计算从根节点到每个叶子节点的最大时间。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是员工数量。每个员工只被访问一次。
空间复杂度: O(n)，用于存储子节点关系和递归调用栈。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def numOfMinutes(n: int, headID: int, manager: List[int], informTime: List[int]) -> int:
    # 构建一个字典，表示每个经理的直接下属
    subordinates = {i: [] for i in range(n)}
    for i, m in enumerate(manager):
        if m != -1:
            subordinates[m].append(i)
    
    def dfs(employee: int) -> int:
        # 递归计算从当前员工到所有下属的最大通知时间
        max_time = 0
        for subordinate in subordinates[employee]:
            max_time = max(max_time, dfs(subordinate))
        return informTime[employee] + max_time
    
    # 从根节点 (headID) 开始计算最大通知时间
    return dfs(headID)

Solution = create_solution(numOfMinutes)