# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3892
标题: Best Time to Buy and Sell Stock V
难度: medium
链接: https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-v/
题目类型: 数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3573. 买卖股票的最佳时机 V - 给你一个整数数组 prices，其中 prices[i] 是第 i 天股票的价格（美元），以及一个整数 k。 你最多可以进行 k 笔交易，每笔交易可以是以下任一类型： * 普通交易：在第 i 天买入，然后在之后的第 j 天卖出，其中 i < j。你的利润是 prices[j] - prices[i]。 * 做空交易：在第 i 天卖出，然后在之后的第 j 天买回，其中 i < j。你的利润是 prices[i] - prices[j]。 注意：你必须在开始下一笔交易之前完成当前交易。此外，你不能在已经进行买入或卖出操作的同一天再次进行买入或卖出操作。 通过进行 最多 k 笔交易，返回你可以获得的最大总利润。 示例 1: 输入: prices = [1,7,9,8,2], k = 2 输出: 14 解释: 我们可以通过 2 笔交易获得 14 美元的利润： * 一笔普通交易：第 0 天以 1 美元买入，第 2 天以 9 美元卖出。 * 一笔做空交易：第 3 天以 8 美元卖出，第 4 天以 2 美元买回。 示例 2: 输入: prices = [12,16,19,19,8,1,19,13,9], k = 3 输出: 36 解释: 我们可以通过 3 笔交易获得 36 美元的利润： * 一笔普通交易：第 0 天以 12 美元买入，第 2 天以 19 美元卖出。 * 一笔做空交易：第 3 天以 19 美元卖出，第 4 天以 8 美元买回。 * 一笔普通交易：第 5 天以 1 美元买入，第 6 天以 19 美元卖出。 提示: * 2 <= prices.length <= 103 * 1 <= prices[i] <= 109 * 1 <= k <= prices.length / 2
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们使用两个二维数组 dp_buy 和 dp_sell 来记录在第 i 天进行第 j 次买入和卖出时的最大利润。

算法步骤:
1. 初始化两个二维数组 dp_buy 和 dp_sell，分别表示第 i 天进行第 j 次买入和卖出时的最大利润。
2. 遍历每一天，更新 dp_buy 和 dp_sell 的值。
3. 返回 dp_sell 的最大值。

关键点:
- dp_buy[i][j] 表示第 i 天进行第 j 次买入时的最大利润。
- dp_sell[i][j] 表示第 i 天进行第 j 次卖出时的最大利润。
- 初始条件：dp_buy[0][j] = -prices[0]，dp_sell[0][j] = 0。
- 状态转移方程：
  - dp_buy[i][j] = max(dp_buy[i-1][j], dp_sell[i-1][j-1] - prices[i])
  - dp_sell[i][j] = max(dp_sell[i-1][j], dp_buy[i-1][j] + prices[i])
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * k)，其中 n 是 prices 的长度，k 是交易次数。
空间复杂度: O(n * k)，使用了两个二维数组 dp_buy 和 dp_sell。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def best_time_to_buy_and_sell_stock_v(prices: List[int], k: int) -> int:
    """
    函数式接口 - 通过动态规划解决最多进行 k 笔交易的最大利润问题
    """
    n = len(prices)
    if n == 0 or k == 0:
        return 0

    # 初始化 dp 数组
    dp_buy = [[-float('inf')] * (k + 1) for _ in range(n)]
    dp_sell = [[0] * (k + 1) for _ in range(n)]

    # 初始条件
    dp_buy[0][1] = -prices[0]

    # 动态规划
    for i in range(1, n):
        for j in range(1, k + 1):
            dp_buy[i][j] = max(dp_buy[i-1][j], dp_sell[i-1][j-1] - prices[i])
            dp_sell[i][j] = max(dp_sell[i-1][j], dp_buy[i-1][j] + prices[i])

    # 返回最大利润
    return max(dp_sell[n-1])

Solution = create_solution(best_time_to_buy_and_sell_stock_v)