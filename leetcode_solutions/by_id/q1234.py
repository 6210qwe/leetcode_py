# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1234
标题: Number of Paths with Max Score
难度: hard
链接: https://leetcode.cn/problems/number-of-paths-with-max-score/
题目类型: 数组、动态规划、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1301. 最大得分的路径数目 - 给你一个正方形字符数组 board ，你从数组最右下方的字符 'S' 出发。 你的目标是到达数组最左上角的字符 'E' ，数组剩余的部分为数字字符 1, 2, ..., 9 或者障碍 'X'。在每一步移动中，你可以向上、向左或者左上方移动，可以移动的前提是到达的格子没有障碍。 一条路径的 「得分」 定义为：路径上所有数字的和。 请你返回一个列表，包含两个整数：第一个整数是 「得分」 的最大值，第二个整数是得到最大得分的方案数，请把结果对 10^9 + 7 取余。 如果没有任何路径可以到达终点，请返回 [0, 0] 。 示例 1： 输入：board = ["E23","2X2","12S"] 输出：[7,1] 示例 2： 输入：board = ["E12","1X1","21S"] 输出：[4,2] 示例 3： 输入：board = ["E11","XXX","11S"] 输出：[0,0] 提示： * 2 <= board.length == board[i].length <= 100
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们定义两个二维数组 dp 和 count，其中 dp[i][j] 表示从 (i, j) 到达终点的最大得分，count[i][j] 表示从 (i, j) 到达终点的最大得分的路径数。

算法步骤:
1. 初始化 dp 和 count 数组。
2. 从右下角开始逆向遍历，更新 dp 和 count 数组。
3. 返回 dp[0][0] 和 count[0][0]。

关键点:
- 使用动态规划来记录每个位置的最大得分和路径数。
- 从右下角开始逆向遍历，确保每个位置的值都是基于已经计算好的值。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2)，其中 n 是 board 的边长。
空间复杂度: O(n^2)，我们需要两个 n x n 的二维数组来存储 dp 和 count。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def paths_with_max_score(board: List[str]) -> List[int]:
    n = len(board)
    MOD = 10**9 + 7
    dp = [[0] * n for _ in range(n)]
    count = [[0] * n for _ in range(n)]
    count[n-1][n-1] = 1  # 起点

    for i in range(n-1, -1, -1):
        for j in range(n-1, -1, -1):
            if board[i][j] == 'X':
                continue
            for di, dj in [(-1, 0), (0, -1), (-1, -1)]:
                ni, nj = i + di, j + dj
                if 0 <= ni < n and 0 <= nj < n:
                    if dp[ni][nj] > dp[i][j]:
                        dp[i][j] = dp[ni][nj]
                        count[i][j] = count[ni][nj]
                    elif dp[ni][nj] == dp[i][j]:
                        count[i][j] += count[ni][nj]
            if board[i][j] != 'S' and board[i][j] != 'E':
                dp[i][j] += int(board[i][j])

    return [dp[0][0], count[0][0] % MOD]

Solution = create_solution(paths_with_max_score)