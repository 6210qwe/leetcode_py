# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2022
标题: Maximum Alternating Subsequence Sum
难度: medium
链接: https://leetcode.cn/problems/maximum-alternating-subsequence-sum/
题目类型: 数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1911. 最大交替子序列和 - 一个下标从 0 开始的数组的 交替和 定义为 偶数 下标处元素之 和 减去 奇数 下标处元素之 和 。 * 比方说，数组 [4,2,5,3] 的交替和为 (4 + 5) - (2 + 3) = 4 。 给你一个数组 nums ，请你返回 nums 中任意子序列的 最大交替和 （子序列的下标 重新 从 0 开始编号）。 一个数组的 子序列 是从原数组中删除一些元素后（也可能一个也不删除）剩余元素不改变顺序组成的数组。比方说，[2,7,4] 是 [4,2,3,7,2,1,4] 的一个子序列（加粗元素），但是 [2,4,2] 不是。 示例 1： 输入：nums = [4,2,5,3] 输出：7 解释：最优子序列为 [4,2,5] ，交替和为 (4 + 5) - 2 = 7 。 示例 2： 输入：nums = [5,6,7,8] 输出：8 解释：最优子序列为 [8] ，交替和为 8 。 示例 3： 输入：nums = [6,2,1,2,4,5] 输出：10 解释：最优子序列为 [6,1,5] ，交替和为 (6 + 5) - 1 = 10 。 提示： * 1 <= nums.length <= 105 * 1 <= nums[i] <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们定义两个状态变量：
- even_sum: 当前以偶数下标结尾的最大交替和
- odd_sum: 当前以奇数下标结尾的最大交替和

算法步骤:
1. 初始化 even_sum 为第一个元素，odd_sum 为 0。
2. 遍历数组，从第二个元素开始，更新 even_sum 和 odd_sum。
3. 返回 even_sum 和 odd_sum 中的最大值。

关键点:
- 通过维护两个状态变量，我们可以在线性时间内找到最大交替和。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是数组的长度。我们只需要遍历数组一次。
空间复杂度: O(1)，我们只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def max_alternating_subsequence_sum(nums: List[int]) -> int:
    """
    函数式接口 - 计算数组的最大交替子序列和
    """
    if not nums:
        return 0

    even_sum = nums[0]
    odd_sum = 0

    for i in range(1, len(nums)):
        new_even_sum = max(even_sum, odd_sum + nums[i])
        new_odd_sum = max(odd_sum, even_sum - nums[i])
        even_sum, odd_sum = new_even_sum, new_odd_sum

    return max(even_sum, odd_sum)


Solution = create_solution(max_alternating_subsequence_sum)