# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2879
标题: Minimum Changes to Make K Semi-palindromes
难度: hard
链接: https://leetcode.cn/problems/minimum-changes-to-make-k-semi-palindromes/
题目类型: 双指针、字符串、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2911. 得到 K 个半回文串的最少修改次数 - 给你一个字符串 s 和一个整数 k ，请你将 s 分成 k 个 子字符串 ，使得每个 子字符串 变成 半回文串 需要修改的字符数目最少。 请你返回一个整数，表示需要修改的 最少 字符数目。 注意： * 如果一个字符串从左往右和从右往左读是一样的，那么它是一个 回文串 。 * 如果长度为 len 的字符串存在一个满足 1 <= d < len 的正整数 d ，len % d == 0 成立且所有对 d 做除法余数相同的下标对应的字符连起来得到的字符串都是 回文串 ，那么我们说这个字符串是 半回文串 。比方说 "aa" ，"aba" ，"adbgad" 和 "abab" 都是 半回文串 ，而 "a" ，"ab" 和 "abca" 不是。 * 子字符串 指的是一个字符串中一段连续的字符序列。 示例 1： 输入：s = "abcac", k = 2 输出：1 解释：我们可以将 s 分成子字符串 "ab" 和 "cac" 。子字符串 "cac" 已经是半回文串。如果我们将 "ab" 变成 "aa" ，它也会变成一个 d = 1 的半回文串。 该方案是将 s 分成 2 个子字符串的前提下，得到 2 个半回文子字符串需要的最少修改次数。所以答案为 1 。 示例 2: 输入：s = "abcdef", k = 2 输出：2 解释：我们可以将 s 分成子字符串 "abc" 和 "def" 。子字符串 "abc" 和 "def" 都需要修改一个字符得到半回文串，所以我们总共需要 2 次字符修改使所有子字符串变成半回文串。 该方案是将 s 分成 2 个子字符串的前提下，得到 2 个半回文子字符串需要的最少修改次数。所以答案为 2 。 示例 3： 输入：s = "aabbaa", k = 3 输出：0 解释：我们可以将 s 分成子字符串 "aa" ，"bb" 和 "aa" 。 字符串 "aa" 和 "bb" 都已经是半回文串了。所以答案为 0 。 提示： * 2 <= s.length <= 200 * 1 <= k <= s.length / 2 * s 只包含小写英文字母。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们定义 `dp[i][j]` 表示将前 `i` 个字符分成 `j` 个子字符串的最小修改次数。我们需要计算每个子字符串变成半回文串所需的最小修改次数，并更新 `dp` 数组。

算法步骤:
1. 初始化 `dp` 数组，`dp[i][j]` 表示将前 `i` 个字符分成 `j` 个子字符串的最小修改次数。
2. 计算每个子字符串变成半回文串所需的最小修改次数。
3. 使用动态规划更新 `dp` 数组。
4. 返回 `dp[n][k]`，即最终结果。

关键点:
- 使用动态规划来优化子问题的解。
- 计算每个子字符串变成半回文串所需的最小修改次数。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^3 * k)，其中 n 是字符串的长度，k 是子字符串的数量。
空间复杂度: O(n * k)，用于存储 `dp` 数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def min_changes_to_make_k_semi_palindromes(s: str, k: int) -> int:
    n = len(s)
    
    def min_changes_to_semi_palindrome(sub: str) -> int:
        m = len(sub)
        changes = float('inf')
        for d in range(1, m):
            if m % d == 0:
                is_semi_palindrome = True
                for i in range(d):
                    if sub[i::d] != sub[i::d][::-1]:
                        is_semi_palindrome = False
                        break
                if is_semi_palindrome:
                    return 0
        # 如果没有找到合适的 d，则计算将其变成回文串所需的最小修改次数
        return sum(a != b for a, b in zip(sub, sub[::-1])) // 2
    
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 0
    
    for i in range(1, n + 1):
        for j in range(1, min(i, k) + 1):
            for l in range(j - 1, i):
                dp[i][j] = min(dp[i][j], dp[l][j - 1] + min_changes_to_semi_palindrome(s[l:i]))
    
    return dp[n][k]


Solution = create_solution(min_changes_to_make_k_semi_palindromes)