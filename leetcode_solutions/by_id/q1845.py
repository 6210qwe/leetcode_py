# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1845
标题: Largest Submatrix With Rearrangements
难度: medium
链接: https://leetcode.cn/problems/largest-submatrix-with-rearrangements/
题目类型: 贪心、数组、矩阵、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1727. 重新排列后的最大子矩阵 - 给你一个二进制矩阵 matrix ，它的大小为 m x n ，你可以将 matrix 中的 列 按任意顺序重新排列。 请你返回最优方案下将 matrix 重新排列后，全是 1 的子矩阵面积。 示例 1： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2021/01/17/screenshot-2020-12-30-at-40536-pm.png] 输入：matrix = [[0,0,1],[1,1,1],[1,0,1]] 输出：4 解释：你可以按照上图方式重新排列矩阵的每一列。 最大的全 1 子矩阵是上图中加粗的部分，面积为 4 。 示例 2： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2021/01/17/screenshot-2020-12-30-at-40852-pm.png] 输入：matrix = [[1,0,1,0,1]] 输出：3 解释：你可以按照上图方式重新排列矩阵的每一列。 最大的全 1 子矩阵是上图中加粗的部分，面积为 3 。 示例 3： 输入：matrix = [[1,1,0],[1,0,1]] 输出：2 解释：由于你只能整列整列重新排布，所以没有比面积为 2 更大的全 1 子矩形。 示例 4： 输入：matrix = [[0,0],[0,0]] 输出：0 解释：由于矩阵中没有 1 ，没有任何全 1 的子矩阵，所以面积为 0 。 提示： * m == matrix.length * n == matrix[i].length * 1 <= m * n <= 105 * matrix[i][j] 要么是 0 ，要么是 1 。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想:
- 计算每列的高度，然后对高度进行排序，找到最大的全 1 子矩阵。

算法步骤:
1. 初始化一个高度数组 `heights`，记录每一列的高度。
2. 对于每一行，更新 `heights` 数组，并将其排序。
3. 计算当前行的最大全 1 子矩阵面积。
4. 更新全局最大面积。

关键点:
- 使用动态规划计算每列的高度。
- 通过排序找到可能的最大子矩阵。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m * n * log n)，其中 m 是矩阵的行数，n 是矩阵的列数。每次排序的时间复杂度是 O(n * log n)。
空间复杂度: O(n)，用于存储高度数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def largest_submatrix(matrix: List[List[int]]) -> int:
    if not matrix or not matrix[0]:
        return 0

    m, n = len(matrix), len(matrix[0])
    heights = [0] * n
    max_area = 0

    for i in range(m):
        for j in range(n):
            if matrix[i][j] == 1:
                heights[j] += 1
            else:
                heights[j] = 0

        sorted_heights = sorted(heights, reverse=True)
        for k in range(n):
            max_area = max(max_area, sorted_heights[k] * (k + 1))

    return max_area

Solution = create_solution(largest_submatrix)