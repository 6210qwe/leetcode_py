# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 233
标题: Number of Digit One
难度: hard
链接: https://leetcode.cn/problems/number-of-digit-one/
题目类型: 递归、数学、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
233. 数字 1 的个数 - 给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。 示例 1： 输入：n = 13 输出：6 示例 2： 输入：n = 0 输出：0 提示： * 0 <= n <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 按位统计，对于每一位，计算该位上1出现的次数

算法步骤:
1. 对于每一位（个位、十位、百位等），计算该位上1出现的次数
2. 设当前位为第k位（从右往左，从0开始），高位为high，当前位为cur，低位为low
3. 如果cur == 0，该位1的个数为 high * base
4. 如果cur == 1，该位1的个数为 high * base + low + 1
5. 如果cur > 1，该位1的个数为 (high + 1) * base

关键点:
- 按位统计，数学方法
- 时间复杂度O(log10(n))，空间复杂度O(1)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(log10(n)) - 需要遍历每一位
空间复杂度: O(1) - 只使用常数额外空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from leetcode_solutions.utils.solution import create_solution


def number_of_digit_one(n: int) -> int:
    """
    函数式接口 - 数字1的个数
    
    实现思路:
    按位统计，对于每一位，计算该位上1出现的次数。
    
    Args:
        n: 整数
        
    Returns:
        所有小于等于n的非负整数中数字1出现的个数
        
    Example:
        >>> number_of_digit_one(13)
        6
    """
    if n <= 0:
        return 0
    
    count = 0
    base = 1
    
    while base <= n:
        high = n // (base * 10)
        cur = (n // base) % 10
        low = n % base
        
        if cur == 0:
            count += high * base
        elif cur == 1:
            count += high * base + low + 1
        else:
            count += (high + 1) * base
        
        base *= 10
    
    return count


# 自动生成Solution类（无需手动编写）
Solution = create_solution(number_of_digit_one)
