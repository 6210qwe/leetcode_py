# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 714
标题: Best Time to Buy and Sell Stock with Transaction Fee
难度: medium
链接: https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/
题目类型: 贪心、数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
714. 买卖股票的最佳时机含手续费 - 给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。 注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。 示例 1： 输入：prices = [1, 3, 2, 8, 4, 9], fee = 2 输出：8 解释：能够达到的最大利润: 在此处买入 prices[0] = 1 在此处卖出 prices[3] = 8 在此处买入 prices[4] = 4 在此处卖出 prices[5] = 9 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8 示例 2： 输入：prices = [1,3,7,5,10,3], fee = 3 输出：6 提示： * 1 <= prices.length <= 5 * 104 * 1 <= prices[i] < 5 * 104 * 0 <= fee < 5 * 104
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们定义两个状态变量：
- hold: 表示当前持有股票时的最大利润
- not_hold: 表示当前不持有股票时的最大利润

算法步骤:
1. 初始化 hold 和 not_hold，hold 初始化为 -prices[0]，not_hold 初始化为 0。
2. 遍历价格数组，更新 hold 和 not_hold 的值。
3. 最后返回 not_hold 的值作为最大利润。

关键点:
- 持有股票时的最大利润可以通过前一天不持有股票时的最大利润减去当天的价格和手续费得到。
- 不持有股票时的最大利润可以通过前一天持有股票时的最大利润加上当天的价格得到。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是价格数组的长度。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def max_profit_with_fee(prices: List[int], fee: int) -> int:
    """
    函数式接口 - 计算在给定价格数组和手续费的情况下，可以获得的最大利润。
    """
    if not prices:
        return 0

    # 初始化持有和不持有股票时的最大利润
    hold = -prices[0]
    not_hold = 0

    for price in prices[1:]:
        # 更新持有股票时的最大利润
        hold = max(hold, not_hold - price)
        # 更新不持有股票时的最大利润
        not_hold = max(not_hold, hold + price - fee)

    return not_hold


Solution = create_solution(max_profit_with_fee)