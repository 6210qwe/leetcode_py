# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 100241
标题: Permutation I LCCI
难度: medium
链接: https://leetcode.cn/problems/permutation-i-lcci/
题目类型: 字符串、回溯
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
面试题 08.07. 无重复字符串的排列组合 - 无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同。 示例 1： 输入：S = "qwe" 输出：["qwe", "qew", "wqe", "weq", "ewq", "eqw"] 示例 2： 输入：S = "ab" 输出：["ab", "ba"] 提示： 1. 字符都是英文字母。 2. 字符串长度在[1, 9]之间。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用回溯法生成所有可能的排列组合。

算法步骤:
1. 定义一个递归函数 `backtrack`，用于生成排列。
2. 初始化结果列表 `res` 和当前路径 `path`。
3. 在递归函数中，如果当前路径长度等于字符串长度，则将当前路径加入结果列表。
4. 否则，遍历字符串中的每个字符，如果该字符未被使用，则将其加入当前路径，并标记为已使用。
5. 递归调用 `backtrack` 生成下一个字符的排列。
6. 回溯时，移除当前路径中的最后一个字符，并标记为未使用。

关键点:
- 使用一个布尔数组 `used` 来记录字符是否被使用。
- 通过递归和回溯来生成所有可能的排列。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n!)
- 其中 n 是字符串的长度，因为我们需要生成所有可能的排列。

空间复杂度: O(n)
- 递归调用栈的深度最多为 n，同时需要一个长度为 n 的布尔数组 `used`。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def permutation(s: str) -> List[str]:
    """
    函数式接口 - 生成字符串 s 的所有排列组合
    """
    def backtrack(path, used):
        if len(path) == len(s):
            res.append(''.join(path))
            return
        for i in range(len(s)):
            if not used[i]:
                path.append(s[i])
                used[i] = True
                backtrack(path, used)
                path.pop()
                used[i] = False

    res = []
    used = [False] * len(s)
    backtrack([], used)
    return res


Solution = create_solution(permutation)