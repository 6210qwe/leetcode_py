# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2780
标题: Make Costs of Paths Equal in a Binary Tree
难度: medium
链接: https://leetcode.cn/problems/make-costs-of-paths-equal-in-a-binary-tree/
题目类型: 贪心、树、数组、动态规划、二叉树
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2673. 使二叉树所有路径值相等的最小代价 - 给你一个整数 n 表示一棵 满二叉树 里面节点的数目，节点编号从 1 到 n 。根节点编号为 1 ，树中每个非叶子节点 i 都有两个孩子，分别是左孩子 2 * i 和右孩子 2 * i + 1 。 树中每个节点都有一个值，用下标从 0 开始、长度为 n 的整数数组 cost 表示，其中 cost[i] 是第 i + 1 个节点的值。每次操作，你可以将树中 任意 节点的值 增加 1 。你可以执行操作 任意 次。 你的目标是让根到每一个 叶子结点 的路径值相等。请你返回 最少 需要执行增加操作多少次。 注意： * 满二叉树 指的是一棵树，它满足树中除了叶子节点外每个节点都恰好有 2 个子节点，且所有叶子节点距离根节点距离相同。 * 路径值 指的是路径上所有节点的值之和。 示例 1： [https://assets.leetcode.com/uploads/2023/04/04/binaryytreeedrawio-4.png] 输入：n = 7, cost = [1,5,2,2,3,3,1] 输出：6 解释：我们执行以下的增加操作： - 将节点 4 的值增加一次。 - 将节点 3 的值增加三次。 - 将节点 7 的值增加两次。 从根到叶子的每一条路径值都为 9 。 总共增加次数为 1 + 3 + 2 = 6 。 这是最小的答案。 示例 2： [https://assets.leetcode.com/uploads/2023/04/04/binaryytreee2drawio.png] 输入：n = 3, cost = [5,3,3] 输出：0 解释：两条路径已经有相等的路径值，所以不需要执行任何增加操作。 提示： * 3 <= n <= 105 * n + 1 是 2 的幂 * cost.length == n * 1 <= cost[i] <= 104
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用贪心算法，从叶子节点向上调整，使得每一对兄弟节点的路径值相等。

算法步骤:
1. 从最后一个非叶子节点开始，逐层向上调整。
2. 对于每个非叶子节点，计算其左右子节点的路径值差，并将较小的路径值增加到较大的路径值。
3. 累加所有需要的增加操作次数。

关键点:
- 从叶子节点向上调整，确保每一对兄弟节点的路径值相等。
- 使用贪心策略，每次只调整当前节点的子节点，确保总的操作次数最少。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(1)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def min_increments_to_equal_paths(n: int, cost: List[int]) -> int:
    """
    函数式接口 - 计算使二叉树所有路径值相等的最小代价
    """
    total_operations = 0
    for i in range(n // 2 - 1, -1, -1):
        left_child = 2 * i + 1
        right_child = 2 * i + 2
        max_cost = max(cost[left_child], cost[right_child])
        total_operations += 2 * max_cost - (cost[left_child] + cost[right_child])
        cost[i] += max_cost
    return total_operations

Solution = create_solution(min_increments_to_equal_paths)