# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1250
标题: Longest Common Subsequence
难度: medium
链接: https://leetcode.cn/problems/longest-common-subsequence/
题目类型: 字符串、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1143. 最长公共子序列 - 给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。 * 例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。 示例 1： 输入：text1 = "abcde", text2 = "ace" 输出：3 解释：最长公共子序列是 "ace" ，它的长度为 3 。 示例 2： 输入：text1 = "abc", text2 = "abc" 输出：3 解释：最长公共子序列是 "abc" ，它的长度为 3 。 示例 3： 输入：text1 = "abc", text2 = "def" 输出：0 解释：两个字符串没有公共子序列，返回 0 。 提示： * 1 <= text1.length, text2.length <= 1000 * text1 和 text2 仅由小写英文字符组成。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决最长公共子序列问题。

算法步骤:
1. 初始化一个二维数组 dp，其中 dp[i][j] 表示 text1 前 i 个字符和 text2 前 j 个字符的最长公共子序列长度。
2. 如果 text1[i-1] == text2[j-1]，则 dp[i][j] = dp[i-1][j-1] + 1。
3. 否则，dp[i][j] = max(dp[i-1][j], dp[i][j-1])。
4. 返回 dp[m][n]，其中 m 和 n 分别是 text1 和 text2 的长度。

关键点:
- 动态规划的状态转移方程
- 初始化 dp 数组
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m * n)，其中 m 和 n 分别是 text1 和 text2 的长度。
空间复杂度: O(m * n)，用于存储 dp 数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def longest_common_subsequence(text1: str, text2: str) -> int:
    """
    函数式接口 - 计算两个字符串的最长公共子序列长度
    """
    m, n = len(text1), len(text2)
    # 初始化 dp 数组
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # 填充 dp 数组
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    
    return dp[m][n]


Solution = create_solution(longest_common_subsequence)