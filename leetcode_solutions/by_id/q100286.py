# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 100286
标题: 训练计划 IV
难度: easy
链接: https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/
题目类型: 递归、链表
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCR 142. 训练计划 IV - 给定两个以 有序链表 形式记录的训练计划 l1、l2，分别记录了两套核心肌群训练项目编号，请合并这两个训练计划，按训练项目编号 升序 记录于链表并返回。 注意：新链表是通过拼接给定的两个链表的所有节点组成的。 示例 1： 输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4] 示例 2： 输入：l1 = [], l2 = [] 输出：[] 示例 3： 输入：l1 = [], l2 = [0] 输出：[0] 提示： 0 <= 链表长度 <= 1000 注意：本题与主站 21 题相同：https://leetcode.cn/problems/merge-two-sorted-lists/ [https://leetcode.cn/problems/merge-two-sorted-lists/]
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用双指针法合并两个有序链表。

算法步骤:
1. 创建一个虚拟头节点 `dummy` 和一个指针 `current` 指向它。
2. 使用双指针 `p1` 和 `p2` 分别指向 `l1` 和 `l2` 的头节点。
3. 比较 `p1` 和 `p2` 所指向的节点值，将较小的节点连接到 `current` 后面，并移动相应的指针。
4. 重复步骤 3 直到其中一个链表为空。
5. 将剩余的非空链表连接到 `current` 后面。
6. 返回 `dummy.next` 作为合并后的链表头节点。

关键点:
- 使用虚拟头节点简化边界条件处理。
- 双指针法确保合并过程的时间复杂度为 O(n + m)。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n + m)，其中 n 和 m 分别是两个链表的长度。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.solution import create_solution


def merge_two_lists(l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
    """
    合并两个有序链表。
    :param l1: 第一个有序链表的头节点
    :param l2: 第二个有序链表的头节点
    :return: 合并后的有序链表的头节点
    """
    # 创建虚拟头节点
    dummy = ListNode(0)
    current = dummy

    # 使用双指针合并链表
    p1, p2 = l1, l2
    while p1 and p2:
        if p1.val < p2.val:
            current.next = p1
            p1 = p1.next
        else:
            current.next = p2
            p2 = p2.next
        current = current.next

    # 连接剩余的非空链表
    if p1:
        current.next = p1
    elif p2:
        current.next = p2

    return dummy.next


Solution = create_solution(merge_two_lists)