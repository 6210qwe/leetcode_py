# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1631
标题: Number of Sub-arrays With Odd Sum
难度: medium
链接: https://leetcode.cn/problems/number-of-sub-arrays-with-odd-sum/
题目类型: 数组、数学、动态规划、前缀和
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1524. 和为奇数的子数组数目 - 给你一个整数数组 arr 。请你返回和为 奇数 的子数组数目。 由于答案可能会很大，请你将结果对 10^9 + 7 取余后返回。 示例 1： 输入：arr = [1,3,5] 输出：4 解释：所有的子数组为 [[1],[1,3],[1,3,5],[3],[3,5],[5]] 。 所有子数组的和为 [1,4,9,3,8,5]. 奇数和包括 [1,9,3,5] ，所以答案为 4 。 示例 2 ： 输入：arr = [2,4,6] 输出：0 解释：所有子数组为 [[2],[2,4],[2,4,6],[4],[4,6],[6]] 。 所有子数组和为 [2,6,12,4,10,6] 。 所有子数组和都是偶数，所以答案为 0 。 示例 3： 输入：arr = [1,2,3,4,5,6,7] 输出：16 示例 4： 输入：arr = [100,100,99,99] 输出：4 示例 5： 输入：arr = [7] 输出：1 提示： * 1 <= arr.length <= 10^5 * 1 <= arr[i] <= 100
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用前缀和与计数的方法来计算和为奇数的子数组数目。

算法步骤:
1. 初始化两个计数器 `even_count` 和 `odd_count`，分别记录当前前缀和为偶数和奇数的子数组数量。
2. 遍历数组，更新前缀和，并根据前缀和的奇偶性更新计数器。
3. 根据前缀和的奇偶性计算当前子数组的贡献。

关键点:
- 使用前缀和的奇偶性来判断子数组的和是否为奇数。
- 通过维护两个计数器来避免重复计算。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是数组的长度，因为我们需要遍历数组一次。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(arr: List[int]) -> int:
    """
    函数式接口 - 返回和为奇数的子数组数目
    """
    MOD = 10**9 + 7
    even_count, odd_count = 1, 0  # 初始时，前缀和为0，是偶数
    prefix_sum, result = 0, 0

    for num in arr:
        prefix_sum += num
        if prefix_sum % 2 == 0:
            # 当前前缀和为偶数，之前的奇数前缀和可以构成奇数和的子数组
            result += odd_count
            even_count += 1
        else:
            # 当前前缀和为奇数，之前的偶数前缀和可以构成奇数和的子数组
            result += even_count
            odd_count += 1

    return result % MOD


Solution = create_solution(solution_function_name)