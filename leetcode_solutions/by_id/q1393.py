# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1393
标题: Maximum Value of K Coins From Piles
难度: hard
链接: https://leetcode.cn/problems/maximum-value-of-k-coins-from-piles/
题目类型: 数组、动态规划、前缀和
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2218. 从栈中取出 K 个硬币的最大面值和 - 一张桌子上总共有 n 个硬币 栈 。每个栈有 正整数 个带面值的硬币。 每一次操作中，你可以从任意一个栈的 顶部 取出 1 个硬币，从栈中移除它，并放入你的钱包里。 给你一个列表 piles ，其中 piles[i] 是一个整数数组，分别表示第 i 个栈里 从顶到底 的硬币面值。同时给你一个正整数 k ，请你返回在 恰好 进行 k 次操作的前提下，你钱包里硬币面值之和 最大为多少 。 示例 1： [https://assets.leetcode.com/uploads/2019/11/09/e1.png] 输入：piles = [[1,100,3],[7,8,9]], k = 2 输出：101 解释： 上图展示了几种选择 k 个硬币的不同方法。 我们可以得到的最大面值为 101 。 示例 2： 输入：piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7 输出：706 解释： 如果我们所有硬币都从最后一个栈中取，可以得到最大面值和。 提示： * n == piles.length * 1 <= n <= 1000 * 1 <= piles[i][j] <= 105 * 1 <= k <= sum(piles[i].length) <= 2000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。定义 dp[i][j] 表示从前 i 个栈中取出 j 个硬币的最大价值。

算法步骤:
1. 初始化 dp 数组，dp[0][0] = 0，其他 dp[0][j] 为 0。
2. 遍历每个栈，对于每个栈，计算其前缀和。
3. 更新 dp 数组，对于每个栈中的每个硬币，更新 dp[i][j] 的值。

关键点:
- 使用前缀和来快速计算从某个栈中取出一定数量硬币的价值。
- 动态规划的状态转移方程为 dp[i][j] = max(dp[i-1][j], dp[i-1][j-t] + prefix_sum[t])，其中 t 是从当前栈中取出的硬币数量。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * k^2)，其中 n 是栈的数量，k 是需要取出的硬币数量。
空间复杂度: O(n * k)，用于存储 dp 数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(piles: List[List[int]], k: int) -> int:
    """
    函数式接口 - 从栈中取出 K 个硬币的最大面值和
    """
    n = len(piles)
    dp = [[0] * (k + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        prefix_sum = [0]
        for coin in piles[i - 1]:
            prefix_sum.append(prefix_sum[-1] + coin)
        
        for j in range(k + 1):
            dp[i][j] = dp[i - 1][j]
            for t in range(1, min(len(piles[i - 1]), j) + 1):
                if j - t >= 0:
                    dp[i][j] = max(dp[i][j], dp[i - 1][j - t] + prefix_sum[t])
    
    return dp[n][k]


Solution = create_solution(solution_function_name)