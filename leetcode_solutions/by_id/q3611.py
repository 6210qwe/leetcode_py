# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3611
标题: Construct the Minimum Bitwise Array II
难度: medium
链接: https://leetcode.cn/problems/construct-the-minimum-bitwise-array-ii/
题目类型: 位运算、数组
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3315. 构造最小位运算数组 II - 给你一个长度为 n 的 质数 数组 nums 。你的任务是返回一个长度为 n 的数组 ans ，对于每个下标 i ，以下 条件 均成立： * ans[i] OR (ans[i] + 1) == nums[i] 除此以外，你需要 最小化 结果数组里每一个 ans[i] 。 如果没法找到符合 条件 的 ans[i] ，那么 ans[i] = -1 。 质数 指的是一个大于 1 的自然数，且它只有 1 和自己两个因数。 示例 1： 输入：nums = [2,3,5,7] 输出：[-1,1,4,3] 解释： * 对于 i = 0 ，不存在 ans[0] 满足 ans[0] OR (ans[0] + 1) = 2 ，所以 ans[0] = -1 。 * 对于 i = 1 ，满足 ans[1] OR (ans[1] + 1) = 3 的最小 ans[1] 为 1 ，因为 1 OR (1 + 1) = 3 。 * 对于 i = 2 ，满足 ans[2] OR (ans[2] + 1) = 5 的最小 ans[2] 为 4 ，因为 4 OR (4 + 1) = 5 。 * 对于 i = 3 ，满足 ans[3] OR (ans[3] + 1) = 7 的最小 ans[3] 为 3 ，因为 3 OR (3 + 1) = 7 。 示例 2： 输入：nums = [11,13,31] 输出：[9,12,15] 解释： * 对于 i = 0 ，满足 ans[0] OR (ans[0] + 1) = 11 的最小 ans[0] 为 9 ，因为 9 OR (9 + 1) = 11 。 * 对于 i = 1 ，满足 ans[1] OR (ans[1] + 1) = 13 的最小 ans[1] 为 12 ，因为 12 OR (12 + 1) = 13 。 * 对于 i = 2 ，满足 ans[2] OR (ans[2] + 1) = 31 的最小 ans[2] 为 15 ，因为 15 OR (15 + 1) = 31 。 提示： * 1 <= nums.length <= 100 * 2 <= nums[i] <= 109 * nums[i] 是一个质数。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过位运算找到满足条件的最小值。

算法步骤:
1. 对于每个质数 num，从 0 开始遍历，找到第一个满足 `x | (x + 1) == num` 的 x。
2. 如果找不到这样的 x，则将结果设为 -1。

关键点:
- 使用位运算来判断和构造满足条件的值。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * log(num))，其中 n 是 nums 的长度，num 是 nums 中的最大值。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def construct_min_bitwise_array(nums: List[int]) -> List[int]:
    """
    返回一个长度为 n 的数组 ans，对于每个下标 i，满足 ans[i] OR (ans[i] + 1) == nums[i]，
    并且 ans[i] 是最小的。如果找不到这样的 ans[i]，则 ans[i] = -1。
    """
    def find_min_x(num: int) -> int:
        for x in range(num):
            if x | (x + 1) == num:
                return x
        return -1

    return [find_min_x(num) for num in nums]


Solution = create_solution(construct_min_bitwise_array)