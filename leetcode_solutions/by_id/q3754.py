# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3754
标题: Maximum Manhattan Distance After K Changes
难度: medium
链接: https://leetcode.cn/problems/maximum-manhattan-distance-after-k-changes/
题目类型: 哈希表、数学、字符串、计数
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3443. K 次修改后的最大曼哈顿距离 - 给你一个由字符 'N'、'S'、'E' 和 'W' 组成的字符串 s，其中 s[i] 表示在无限网格中的移动操作： * 'N'：向北移动 1 个单位。 * 'S'：向南移动 1 个单位。 * 'E'：向东移动 1 个单位。 * 'W'：向西移动 1 个单位。 初始时，你位于原点 (0, 0)。你 最多 可以修改 k 个字符为任意四个方向之一。 请找出在 按顺序 执行所有移动操作过程中的 任意时刻 ，所能达到的离原点的 最大曼哈顿距离 。 曼哈顿距离 定义为两个坐标点 (xi, yi) 和 (xj, yj) 的横向距离绝对值与纵向距离绝对值之和，即 |xi - xj| + |yi - yj|。 示例 1： 输入：s = "NWSE", k = 1 输出：3 解释： 将 s[2] 从 'S' 改为 'N' ，字符串 s 变为 "NWNE" 。 移动操作 位置 (x, y) 曼哈顿距离 最大值 s[0] == 'N' (0, 1) 0 + 1 = 1 1 s[1] == 'W' (-1, 1) 1 + 1 = 2 2 s[2] == 'N' (-1, 2) 1 + 2 = 3 3 s[3] == 'E' (0, 2) 0 + 2 = 2 3 执行移动操作过程中，距离原点的最大曼哈顿距离是 3 。 示例 2： 输入：s = "NSWWEW", k = 3 输出：6 解释： 将 s[1] 从 'S' 改为 'N' ，将 s[4] 从 'E' 改为 'W' 。字符串 s 变为 "NNWWWW" 。 执行移动操作过程中，距离原点的最大曼哈顿距离是 6 。 提示： * 1 <= s.length <= 105 * 0 <= k <= s.length * s 仅由 'N'、'S'、'E' 和 'W' 。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用滑动窗口来维护当前可以修改的 k 个字符，并计算最大曼哈顿距离。

算法步骤:
1. 初始化方向字典，记录每个方向的移动量。
2. 遍历字符串，计算前缀和，记录当前位置的 x 和 y 坐标。
3. 使用滑动窗口来维护当前可以修改的 k 个字符，并计算最大曼哈顿距离。
4. 返回最大曼哈顿距离。

关键点:
- 使用前缀和来快速计算当前位置。
- 使用滑动窗口来优化 k 个字符的修改。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(1)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def max_manhattan_distance_after_k_changes(s: str, k: int) -> int:
    """
    函数式接口 - 计算 k 次修改后的最大曼哈顿距离
    """
    # 方向字典
    directions = {'N': (0, 1), 'S': (0, -1), 'E': (1, 0), 'W': (-1, 0)}
    
    # 前缀和
    prefix_x, prefix_y = [0], [0]
    for move in s:
        dx, dy = directions[move]
        prefix_x.append(prefix_x[-1] + dx)
        prefix_y.append(prefix_y[-1] + dy)
    
    # 滑动窗口
    max_distance = 0
    left = 0
    for right in range(len(s) + 1):
        while (prefix_x[right] - prefix_x[left]) + (prefix_y[right] - prefix_y[left]) > k:
            left += 1
        max_distance = max(max_distance, abs(prefix_x[right]) + abs(prefix_y[right]))
    
    return max_distance


Solution = create_solution(max_manhattan_distance_after_k_changes)