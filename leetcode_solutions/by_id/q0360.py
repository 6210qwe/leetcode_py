# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 360
标题: Sort Transformed Array
难度: medium
链接: https://leetcode.cn/problems/sort-transformed-array/
题目类型: 数组、数学、双指针、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
360. 有序转化数组 - 备战技术面试？力扣提供海量技术面试资源，帮助你高效提升编程技能,轻松拿下世界 IT 名企 Dream Offer。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 二次函数在有序数组上的单调性 + 双指针。

算法步骤:
1. 对有序数组中的每个元素 x 应用函数 f(x)=ax^2+bx+c。
2. 当 a>=0 时，抛物线开口向上，f(x) 在两端较大，在中间较小；用两个指针从两端向内移动，每次取 f(nums[i]) 和 f(nums[j]) 中较大的，从结果数组末尾向前填充。
3. 当 a<0 时，开口向下，f(x) 在两端较小，在中间较大；同样双指针从两端向内，每次取较小的值，从结果数组开头向后填充。
4. 直到两个指针交错，结果数组即为有序。

关键点:
- 充分利用原数组有序性，避免对变换后的数组再排序。
- 根据 a 的符号决定结果数组的填充方向。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，n 为数组长度，只需一次双指针线性扫描。
空间复杂度: O(1) 额外空间，除了返回结果数组外不依赖额外结构。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def sort_transformed_array(nums: List[int], a: int, b: int, c: int) -> List[int]:
    """
    对有序数组 nums 中每个元素应用二次函数 f(x)=ax^2+bx+c，并返回有序结果。

    利用原数组有序性和二次函数的开口方向，双指针从两端向中间填充结果。
    """

    def f(x: int) -> int:
        return a * x * x + b * x + c

    n = len(nums)
    res = [0] * n
    i, j = 0, n - 1

    if a >= 0:
        # 开口向上，最大值在两端，倒序填充
        k = n - 1
        while i <= j:
            v_i, v_j = f(nums[i]), f(nums[j])
            if v_i > v_j:
                res[k] = v_i
                i += 1
            else:
                res[k] = v_j
                j -= 1
            k -= 1
    else:
        # 开口向下，最小值在两端，正序填充
        k = 0
        while i <= j:
            v_i, v_j = f(nums[i]), f(nums[j])
            if v_i < v_j:
                res[k] = v_i
                i += 1
            else:
                res[k] = v_j
                j -= 1
            k += 1

    return res


# 自动生成Solution类（无需手动编写）
Solution = create_solution(sort_transformed_array)
