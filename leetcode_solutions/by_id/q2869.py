# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2869
标题: Longest Non-decreasing Subarray From Two Arrays
难度: medium
链接: https://leetcode.cn/problems/longest-non-decreasing-subarray-from-two-arrays/
题目类型: 数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2771. 构造最长非递减子数组 - 给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，长度均为 n 。 让我们定义另一个下标从 0 开始、长度为 n 的整数数组，nums3 。对于范围 [0, n - 1] 的每个下标 i ，你可以将 nums1[i] 或 nums2[i] 的值赋给 nums3[i] 。 你的任务是使用最优策略为 nums3 赋值，以最大化 nums3 中 最长非递减子数组 的长度。 以整数形式表示并返回 nums3 中 最长非递减 子数组的长度。 注意：子数组 是数组中的一个连续非空元素序列。 示例 1： 输入：nums1 = [2,3,1], nums2 = [1,2,1] 输出：2 解释：构造 nums3 的方法之一是： nums3 = [nums1[0], nums2[1], nums2[2]] => [2,2,1] 从下标 0 开始到下标 1 结束，形成了一个长度为 2 的非递减子数组 [2,2] 。 可以证明 2 是可达到的最大长度。 示例 2： 输入：nums1 = [1,3,2,1], nums2 = [2,2,3,4] 输出：4 解释：构造 nums3 的方法之一是： nums3 = [nums1[0], nums2[1], nums2[2], nums2[3]] => [1,2,3,4] 整个数组形成了一个长度为 4 的非递减子数组，并且是可达到的最大长度。 示例 3： 输入：nums1 = [1,1], nums2 = [2,2] 输出：2 解释：构造 nums3 的方法之一是： nums3 = [nums1[0], nums1[1]] => [1,1] 整个数组形成了一个长度为 2 的非递减子数组，并且是可达到的最大长度。 提示： * 1 <= nums1.length == nums2.length == n <= 105 * 1 <= nums1[i], nums2[i] <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们维护两个数组 dp1 和 dp2，分别表示以 nums1[i] 和 nums2[i] 结尾的最长非递减子数组的长度。

算法步骤:
1. 初始化两个数组 dp1 和 dp2，长度为 n，初始值为 1。
2. 遍历数组，对于每个位置 i，更新 dp1[i] 和 dp2[i]。
3. 如果 nums1[i] >= nums1[i-1]，则 dp1[i] = dp1[i-1] + 1；如果 nums1[i] >= nums2[i-1]，则 dp1[i] = max(dp1[i], dp2[i-1] + 1)。
4. 同理更新 dp2[i]。
5. 最后返回 dp1 和 dp2 中的最大值。

关键点:
- 动态规划的状态转移方程
- 保持 dp1 和 dp2 的更新逻辑一致
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def longest_non_decreasing_subarray(nums1: List[int], nums2: List[int]) -> int:
    n = len(nums1)
    dp1 = [1] * n
    dp2 = [1] * n
    
    for i in range(1, n):
        if nums1[i] >= nums1[i - 1]:
            dp1[i] = dp1[i - 1] + 1
        if nums1[i] >= nums2[i - 1]:
            dp1[i] = max(dp1[i], dp2[i - 1] + 1)
        
        if nums2[i] >= nums2[i - 1]:
            dp2[i] = dp2[i - 1] + 1
        if nums2[i] >= nums1[i - 1]:
            dp2[i] = max(dp2[i], dp1[i - 1] + 1)
    
    return max(max(dp1), max(dp2))

Solution = create_solution(longest_non_decreasing_subarray)