# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 552
标题: Student Attendance Record II
难度: hard
链接: https://leetcode.cn/problems/student-attendance-record-ii/
题目类型: 动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
552. 学生出勤记录 II - 可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符： * 'A'：Absent，缺勤 * 'L'：Late，迟到 * 'P'：Present，到场 如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励： * 按 总出勤 计，学生缺勤（'A'）严格 少于两天。 * 学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（'L'）记录。 给你一个整数 n ，表示出勤记录的长度（次数）。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 数量 。答案可能很大，所以返回对 109 + 7 取余 的结果。 示例 1： 输入：n = 2 输出：8 解释： 有 8 种长度为 2 的记录将被视为可奖励： "PP" , "AP", "PA", "LP", "PL", "AL", "LA", "LL" 只有"AA"不会被视为可奖励，因为缺勤次数为 2 次（需要少于 2 次）。 示例 2： 输入：n = 1 输出：3 示例 3： 输入：n = 10101 输出：183236316 提示： * 1 <= n <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。定义状态 dp[i][j][k] 表示长度为 i 的记录中，包含 j 个 'A' 和 k 个连续 'L' 的有效记录数量。

算法步骤:
1. 初始化 dp 数组，dp[0][0][0] = 1，表示空记录是一种有效记录。
2. 通过递推公式更新 dp 数组：
   - 添加 'P'：dp[i][j][0] += sum(dp[i-1][j][k]) for k in range(3)
   - 添加 'A'：dp[i][1][0] += sum(dp[i-1][0][k]) for k in range(3) （如果 j == 0）
   - 添加 'L'：dp[i][j][k+1] = dp[i-1][j][k] （如果 k < 2）
3. 最终结果是 dp[n][0][0] + dp[n][1][0]。

关键点:
- 使用三维数组 dp 来存储不同状态的有效记录数量。
- 通过递推公式更新 dp 数组，确保不违反题目条件。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是记录的长度。
空间复杂度: O(n)，使用了三维数组 dp，但可以通过滚动数组优化到 O(1)。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution

MOD = 10**9 + 7

def solution_function_name(n: int) -> int:
    """
    函数式接口 - 返回长度为 n 的出勤记录中，可能获得出勤奖励的记录情况数量。
    """
    if n == 0:
        return 0

    # dp[i][j][k] 表示长度为 i 的记录中，包含 j 个 'A' 和 k 个连续 'L' 的有效记录数量
    dp = [[[0 for _ in range(3)] for _ in range(2)] for _ in range(n + 1)]
    dp[0][0][0] = 1

    for i in range(1, n + 1):
        for j in range(2):
            for k in range(3):
                # 添加 'P'
                dp[i][j][0] = (dp[i][j][0] + sum(dp[i-1][j][kk] for kk in range(3))) % MOD
                # 添加 'A'
                if j > 0:
                    dp[i][j][0] = (dp[i][j][0] + sum(dp[i-1][j-1][kk] for kk in range(3))) % MOD
                # 添加 'L'
                if k > 0:
                    dp[i][j][k] = dp[i-1][j][k-1]

    return (dp[n][0][0] + dp[n][1][0]) % MOD

Solution = create_solution(solution_function_name)