# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000043
标题: Shortest Supersequence LCCI
难度: medium
链接: https://leetcode.cn/problems/shortest-supersequence-lcci/
题目类型: 数组、哈希表、滑动窗口
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
面试题 17.18. 最短超串 - 假设你有两个数组，一个长一个短，短的元素均不相同。找到长数组中包含短数组所有的元素的最短子数组，其出现顺序无关紧要。 返回最短子数组的左端点和右端点，如有多个满足条件的子数组，返回左端点最小的一个。若不存在，返回空数组。 示例 1： 输入： big = [7,5,9,0,2,1,3,5,7,9,1,1,5,8,8,9,7] small = [1,5,9] 输出：[7,10] 示例 2： 输入： big = [1,2,3] small = [4] 输出：[] 提示： * big.length <= 100000 * 1 <= small.length <= 100000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用滑动窗口技术来找到包含所有 small 元素的最短子数组。

算法步骤:
1. 初始化两个指针 left 和 right，分别表示当前窗口的左右边界。
2. 使用一个计数器 need 来记录 small 中每个元素的需要数量。
3. 使用一个计数器 window 来记录当前窗口中每个元素的数量。
4. 移动右指针扩展窗口，直到窗口包含了 small 中的所有元素。
5. 移动左指针收缩窗口，直到窗口不再包含 small 中的所有元素。
6. 在每次窗口满足条件时，更新最短子数组的长度和起始位置。
7. 返回最短子数组的起始和结束位置。

关键点:
- 使用滑动窗口技术可以在 O(n) 时间复杂度内解决问题。
- 计数器 need 和 window 用于跟踪所需元素和当前窗口中的元素。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是 big 的长度。每个元素最多被访问两次（一次由右指针，一次由左指针）。
空间复杂度: O(m)，其中 m 是 small 的长度。需要存储 small 中的元素及其计数。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def shortest_supersequence(big: List[int], small: List[int]) -> List[int]:
    if not small or not big:
        return []

    need, window = {}, {}
    for num in small:
        need[num] = need.get(num, 0) + 1

    left, right = 0, 0
    valid = 0
    start, length = 0, float('inf')

    while right < len(big):
        c = big[right]
        right += 1
        if c in need:
            window[c] = window.get(c, 0) + 1
            if window[c] == need[c]:
                valid += 1

        while valid == len(need):
            if right - left < length:
                start = left
                length = right - left
            d = big[left]
            left += 1
            if d in need:
                if window[d] == need[d]:
                    valid -= 1
                window[d] -= 1

    return [start, start + length - 1] if length != float('inf') else []

Solution = create_solution(shortest_supersequence)