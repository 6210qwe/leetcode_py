# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 44
标题: Wildcard Matching
难度: hard
链接: https://leetcode.cn/problems/wildcard-matching/
题目类型: 贪心、递归、字符串、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
44. 通配符匹配 - 给你一个输入字符串 (s) 和一个字符模式 (p) ，请你实现一个支持 '?' 和 '*' 匹配规则的通配符匹配： * '?' 可以匹配任何单个字符。 * '*' 可以匹配任意字符序列（包括空字符序列）。 判定匹配成功的充要条件是：字符模式必须能够 完全匹配 输入字符串（而不是部分匹配）。 示例 1： 输入：s = "aa", p = "a" 输出：false 解释："a" 无法匹配 "aa" 整个字符串。 示例 2： 输入：s = "aa", p = "*" 输出：true 解释：'*' 可以匹配任意字符串。 示例 3： 输入：s = "cb", p = "?a" 输出：false 解释：'?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。 提示： * 0 <= s.length, p.length <= 2000 * s 仅由小写英文字母组成 * p 仅由小写英文字母、'?' 或 '*' 组成
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 动态规划，dp[i][j]表示s的前i个字符和p的前j个字符是否匹配

算法步骤:
1. 初始化dp[0][0]=True，dp[0][j]只有当p前j个都是*时为True
2. 如果p[j-1]=='*'，可以匹配0个或多个字符
3. 如果p[j-1]=='?'或p[j-1]==s[i-1]，匹配一个字符

关键点:
- 动态规划，处理*的特殊情况
- 时间复杂度O(m*n)，空间复杂度O(m*n)，可优化到O(n)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m*n) - m和n为两个字符串的长度
空间复杂度: O(m*n) - DP数组空间，可优化到O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from leetcode_solutions.utils.solution import create_solution


def wildcard_matching(s: str, p: str) -> bool:
    """
    函数式接口 - 通配符匹配
    
    实现思路:
    动态规划，dp[i][j]表示s的前i个字符和p的前j个字符是否匹配。
    
    Args:
        s: 输入字符串
        p: 字符模式
        
    Returns:
        是否匹配
        
    Example:
        >>> wildcard_matching("aa", "*")
        True
    """
    m, n = len(s), len(p)
    dp = [[False] * (n + 1) for _ in range(m + 1)]
    
    # 空字符串匹配空模式
    dp[0][0] = True
    
    # 处理p前j个都是*的情况
    for j in range(1, n + 1):
        if p[j - 1] == '*':
            dp[0][j] = dp[0][j - 1]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if p[j - 1] == '*':
                # *可以匹配0个或多个字符
                dp[i][j] = dp[i][j - 1] or dp[i - 1][j]
            elif p[j - 1] == '?' or p[j - 1] == s[i - 1]:
                # ?匹配任意单个字符，或字符匹配
                dp[i][j] = dp[i - 1][j - 1]
    
    return dp[m][n]


# 自动生成Solution类（无需手动编写）
Solution = create_solution(wildcard_matching)
