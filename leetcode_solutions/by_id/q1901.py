# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1901
标题: Equal Sum Arrays With Minimum Number of Operations
难度: medium
链接: https://leetcode.cn/problems/equal-sum-arrays-with-minimum-number-of-operations/
题目类型: 贪心、数组、哈希表、计数
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1775. 通过最少操作次数使数组的和相等 - 给你两个长度可能不等的整数数组 nums1 和 nums2 。两个数组中的所有值都在 1 到 6 之间（包含 1 和 6）。 每次操作中，你可以选择 任意 数组中的任意一个整数，将它变成 1 到 6 之间 任意 的值（包含 1 和 6）。 请你返回使 nums1 中所有数的和与 nums2 中所有数的和相等的最少操作次数。如果无法使两个数组的和相等，请返回 -1 。 示例 1： 输入：nums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2] 输出：3 解释：你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。 - 将 nums2[0] 变为 6 。 nums1 = [1,2,3,4,5,6], nums2 = [6,1,2,2,2,2] 。 - 将 nums1[5] 变为 1 。 nums1 = [1,2,3,4,5,1], nums2 = [6,1,2,2,2,2] 。 - 将 nums1[2] 变为 2 。 nums1 = [1,2,2,4,5,1], nums2 = [6,1,2,2,2,2] 。 示例 2： 输入：nums1 = [1,1,1,1,1,1,1], nums2 = [6] 输出：-1 解释：没有办法减少 nums1 的和或者增加 nums2 的和使二者相等。 示例 3： 输入：nums1 = [6,6], nums2 = [1] 输出：3 解释：你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。 - 将 nums1[0] 变为 2 。 nums1 = [2,6], nums2 = [1] 。 - 将 nums1[1] 变为 2 。 nums1 = [2,2], nums2 = [1] 。 - 将 nums2[0] 变为 4 。 nums1 = [2,2], nums2 = [4] 。 提示： * 1 <= nums1.length, nums2.length <= 105 * 1 <= nums1[i], nums2[i] <= 6
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过贪心算法，优先选择能够带来最大收益的操作，即每次选择能最大化减少或增加差值的操作。

算法步骤:
1. 计算两个数组的和，并确定哪个数组的和更大。
2. 使用计数器统计每个数组中每个数字的出现次数。
3. 优先选择能够带来最大收益的操作，即每次选择能最大化减少或增加差值的操作。
4. 逐步减少差值，直到差值为0或无法再减少为止。

关键点:
- 优先选择能够带来最大收益的操作。
- 使用计数器统计每个数组中每个数字的出现次数。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n + m)，其中 n 和 m 分别是 nums1 和 nums2 的长度。
空间复杂度: O(1)，因为计数器的大小固定为 6。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def min_operations(nums1: List[int], nums2: List[int]) -> int:
    sum1, sum2 = sum(nums1), sum(nums2)
    if sum1 == sum2:
        return 0
    if sum1 > sum2:
        nums1, nums2 = nums2, nums1
        sum1, sum2 = sum2, sum1
    
    count1, count2 = [0] * 7, [0] * 7
    for num in nums1:
        count1[num] += 1
    for num in nums2:
        count2[num] += 1
    
    diff = abs(sum1 - sum2)
    operations = 0
    for i in range(5, 0, -1):
        max_change = min(count1[6 - i], count2[i + 1])
        while max_change > 0 and diff > 0:
            diff -= (6 - i) + (i + 1) - 6
            max_change -= 1
            operations += 1
        if diff <= 0:
            break
    
    if diff > 0:
        for i in range(1, 6):
            while count1[i] > 0 and diff > 0:
                diff -= 6 - i
                count1[i] -= 1
                operations += 1
            if diff <= 0:
                break
            while count2[6 - i] > 0 and diff > 0:
                diff -= i - 1
                count2[6 - i] -= 1
                operations += 1
            if diff <= 0:
                break
    
    return operations if diff <= 0 else -1

Solution = create_solution(min_operations)