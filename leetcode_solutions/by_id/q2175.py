# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2175
标题: Count Nodes With the Highest Score
难度: medium
链接: https://leetcode.cn/problems/count-nodes-with-the-highest-score/
题目类型: 树、深度优先搜索、数组、二叉树
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2049. 统计最高分的节点数目 - 给你一棵根节点为 0 的 二叉树 ，它总共有 n 个节点，节点编号为 0 到 n - 1 。同时给你一个下标从 0 开始的整数数组 parents 表示这棵树，其中 parents[i] 是节点 i 的父节点。由于节点 0 是根，所以 parents[0] == -1 。 一个子树的 大小 为这个子树内节点的数目。每个节点都有一个与之关联的 分数 。求出某个节点分数的方法是，将这个节点和与它相连的边全部 删除 ，剩余部分是若干个 非空 子树，这个节点的 分数 为所有这些子树 大小的乘积 。 请你返回有 最高得分 节点的 数目 。 示例 1: example-1 [https://assets.leetcode.com/uploads/2021/10/03/example-1.png] 输入：parents = [-1,2,0,2,0] 输出：3 解释： - 节点 0 的分数为：3 * 1 = 3 - 节点 1 的分数为：4 = 4 - 节点 2 的分数为：1 * 1 * 2 = 2 - 节点 3 的分数为：4 = 4 - 节点 4 的分数为：4 = 4 最高得分为 4 ，有三个节点得分为 4 （分别是节点 1，3 和 4 ）。 示例 2： example-2 [https://assets.leetcode.com/uploads/2021/10/03/example-2.png] 输入：parents = [-1,2,0] 输出：2 解释： - 节点 0 的分数为：2 = 2 - 节点 1 的分数为：2 = 2 - 节点 2 的分数为：1 * 1 = 1 最高分数为 2 ，有两个节点分数为 2 （分别为节点 0 和 1 ）。 提示： * n == parents.length * 2 <= n <= 105 * parents[0] == -1 * 对于 i != 0 ，有 0 <= parents[i] <= n - 1 * parents 表示一棵二叉树。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用深度优先搜索 (DFS) 来计算每个节点的子树大小，并在遍历过程中计算每个节点的分数。

算法步骤:
1. 构建树的邻接表表示。
2. 使用 DFS 计算每个节点的子树大小。
3. 在 DFS 过程中，计算每个节点的分数，并记录最高分数及其对应的节点数目。

关键点:
- 使用 DFS 递归地计算子树大小。
- 在计算分数时，考虑删除当前节点后形成的子树大小。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是节点数目。每个节点只被访问一次。
空间复杂度: O(n)，用于存储树的邻接表和递归调用栈。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def count_highest_score_nodes(parents: List[int]) -> int:
    n = len(parents)
    tree = [[] for _ in range(n)]
    
    # 构建树的邻接表
    for i in range(1, n):
        tree[parents[i]].append(i)
    
    max_score = 0
    count = 0
    
    def dfs(node: int) -> int:
        nonlocal max_score, count
        size = 1
        score = 1
        
        # 计算子树大小
        for child in tree[node]:
            child_size = dfs(child)
            size += child_size
            score *= child_size
        
        # 计算剩余部分的大小
        if node != 0:
            score *= (n - size)
        
        # 更新最高分数及其对应的节点数目
        if score > max_score:
            max_score = score
            count = 1
        elif score == max_score:
            count += 1
        
        return size
    
    dfs(0)
    return count

Solution = create_solution(count_highest_score_nodes)