# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2
标题: 两数相加
难度: medium
链接: https://leetcode.cn/problems/add-two-numbers/
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例1:
输入: l1 = [2,4,3], l2 = [5,6,4]
输出: [7,0,8]
解释: 342 + 465 = 807

示例2:
输入: l1 = [0], l2 = [0]
输出: [0]

示例3:
输入: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出: [8,9,9,9,0,0,0,1]

约束条件:
- 每个链表中的节点数在范围 [1, 100] 内
- 0 <= Node.val <= 9
- 题目数据保证列表表示的数字不含前导零
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 模拟手工加法，逐位相加并处理进位

算法步骤:
1. 创建虚拟头节点dummy，用于简化边界处理
2. 使用carry变量记录进位值（初始为0）
3. 同时遍历两个链表，直到两个链表都遍历完且没有进位:
   - 获取当前位的值（如果节点存在则取val，否则为0）
   - 计算当前位的和：val1 + val2 + carry
   - 更新进位：carry = total // 10
   - 创建新节点存储当前位的值：total % 10
   - 移动指针到下一个节点
4. 返回dummy.next（真正的头节点）

关键点:
- 使用虚拟头节点可以简化代码，避免特殊处理
- 需要处理两个链表长度不同的情况
- 最后可能还有进位，需要额外创建一个节点
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(max(m, n)) - 需要遍历两个链表中较长的那个，m和n分别为两个链表的长度
空间复杂度: O(max(m, n)) - 新链表的长度最多为max(m, n) + 1（可能有进位）
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.solution import create_solution


def add_two_numbers(l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
    """
    函数式接口 - 模拟加法实现
    
    实现思路:
    模拟手工加法过程，逐位相加并处理进位，使用虚拟头节点简化代码。
    
    Args:
        l1: 第一个链表（逆序存储的数字）
        l2: 第二个链表（逆序存储的数字）
        
    Returns:
        表示和的链表（逆序存储）
        
    Example:
        >>> l1 = ListNode.from_list([2, 4, 3])
        >>> l2 = ListNode.from_list([5, 6, 4])
        >>> result = add_two_numbers(l1, l2)
        >>> result.to_list()
        [7, 0, 8]
    """
    dummy = ListNode()  # 虚拟头节点
    cur = dummy
    carry = 0  # 进位值
    
    while l1 or l2 or carry:
        val1 = l1.val if l1 else 0
        val2 = l2.val if l2 else 0
        
        total = val1 + val2 + carry
        carry = total // 10
        cur.next = ListNode(total % 10)
        
        cur = cur.next
        l1 = l1.next if l1 else None
        l2 = l2.next if l2 else None
    
    return dummy.next


# 自动生成Solution类（无需手动编写）
Solution = create_solution(add_two_numbers)

