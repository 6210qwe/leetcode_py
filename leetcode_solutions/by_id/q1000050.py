# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000050
标题: Langtons Ant LCCI
难度: medium
链接: https://leetcode.cn/problems/langtons-ant-lcci/
题目类型: 数组、哈希表、字符串、矩阵、模拟
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
面试题 16.22. 兰顿蚂蚁 - 一只蚂蚁坐在由白色和黑色方格构成的无限网格上。开始时，网格全白，蚂蚁面向右侧。每行走一步，蚂蚁执行以下操作。 (1) 如果在白色方格上，则翻转方格的颜色，向右(顺时针)转 90 度，并向前移动一个单位。 (2) 如果在黑色方格上，则翻转方格的颜色，向左(逆时针方向)转 90 度，并向前移动一个单位。 编写程序来模拟蚂蚁执行的前 K 个动作，并返回最终的网格。 网格由数组表示，每个元素是一个字符串，代表网格中的一行，黑色方格由 'X' 表示，白色方格由 '_' 表示，蚂蚁所在的位置由 'L', 'U', 'R', 'D' 表示，分别表示蚂蚁 左、上、右、下 的朝向。只需要返回能够包含蚂蚁走过的所有方格的最小矩形。 示例 1： 输入：0 输出：["R"] 示例 2： 输入：2 输出： [ "_X", "LX" ] 示例 3： 输入：5 输出： [ "_U", "X_", "XX" ] 说明： * K <= 100000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用字典记录蚂蚁走过的路径，并动态扩展网格。

算法步骤:
1. 初始化网格为全白，蚂蚁位置为 (0, 0)，方向为右。
2. 使用字典记录每个位置的颜色（默认为白色）。
3. 模拟蚂蚁的 K 步操作：
   - 根据当前颜色决定转向方向。
   - 翻转当前格子的颜色。
   - 更新蚂蚁的位置。
4. 计算蚂蚁走过的最小矩形范围，并构建最终的网格。

关键点:
- 使用字典记录颜色可以避免预先分配大量空间。
- 动态扩展网格以适应蚂蚁的移动。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(K)
空间复杂度: O(K)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def langtons_ant(k: int) -> List[str]:
    """
    模拟兰顿蚂蚁的前 K 个动作，并返回最终的网格。
    """
    # 方向向量
    directions = [(0, 1), (-1, 0), (0, -1), (1, 0)]
    # 蚂蚁初始位置和方向
    x, y = 0, 0
    direction = 0  # 0: 右, 1: 上, 2: 左, 3: 下
    # 记录颜色的字典
    grid = {}
    
    for _ in range(k):
        # 获取当前格子的颜色
        color = grid.get((x, y), '_')
        # 根据颜色决定转向
        if color == '_':
            direction = (direction + 1) % 4
        else:
            direction = (direction - 1) % 4
        # 翻转颜色
        grid[(x, y)] = 'X' if color == '_' else '_'
        # 更新位置
        dx, dy = directions[direction]
        x, y = x + dx, y + dy
    
    # 找到蚂蚁走过的最小矩形范围
    min_x = min(x for x, y in grid.keys())
    max_x = max(x for x, y in grid.keys())
    min_y = min(y for x, y in grid.keys())
    max_y = max(y for x, y in grid.keys())
    
    # 构建最终的网格
    result = []
    for i in range(min_x, max_x + 1):
        row = []
        for j in range(min_y, max_y + 1):
            if (i, j) == (x, y):
                row.append('LRUD'[direction])
            else:
                row.append(grid.get((i, j), '_'))
        result.append(''.join(row))
    
    return result


Solution = create_solution(langtons_ant)