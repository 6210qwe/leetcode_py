# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3231
标题: Minimum Number of Coins to be Added
难度: medium
链接: https://leetcode.cn/problems/minimum-number-of-coins-to-be-added/
题目类型: 贪心、数组、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2952. 需要添加的硬币的最小数量 - 给你一个下标从 0 开始的整数数组 coins，表示可用的硬币的面值，以及一个整数 target 。 如果存在某个 coins 的子序列总和为 x，那么整数 x 就是一个 可取得的金额 。 返回需要添加到数组中的 任意面值 硬币的 最小数量 ，使范围 [1, target] 内的每个整数都属于 可取得的金额 。 数组的 子序列 是通过删除原始数组的一些（可能不删除）元素而形成的新的 非空 数组，删除过程不会改变剩余元素的相对位置。 示例 1： 输入：coins = [1,4,10], target = 19 输出：2 解释：需要添加面值为 2 和 8 的硬币各一枚，得到硬币数组 [1,2,4,8,10] 。 可以证明从 1 到 19 的所有整数都可由数组中的硬币组合得到，且需要添加到数组中的硬币数目最小为 2 。 示例 2： 输入：coins = [1,4,10,5,7,19], target = 19 输出：1 解释：只需要添加一枚面值为 2 的硬币，得到硬币数组 [1,2,4,5,7,10,19] 。 可以证明从 1 到 19 的所有整数都可由数组中的硬币组合得到，且需要添加到数组中的硬币数目最小为 1 。 示例 3： 输入：coins = [1,1,1], target = 20 输出：3 解释： 需要添加面值为 4 、8 和 16 的硬币各一枚，得到硬币数组 [1,1,1,4,8,16] 。 可以证明从 1 到 20 的所有整数都可由数组中的硬币组合得到，且需要添加到数组中的硬币数目最小为 3 。 提示： * 1 <= target <= 105 * 1 <= coins.length <= 105 * 1 <= coins[i] <= target
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用贪心算法，逐步增加硬币面值，确保当前能覆盖的金额范围逐渐扩大，直到覆盖 [1, target]。

算法步骤:
1. 初始化 `current` 为 0，表示当前能覆盖的最大金额。
2. 初始化 `added_coins` 为 0，表示需要添加的硬币数量。
3. 对硬币面值进行排序。
4. 遍历硬币面值：
   - 如果当前硬币面值大于 `current + 1`，则需要添加一个面值为 `current + 1` 的硬币，并更新 `current`。
   - 否则，更新 `current` 为 `current + 当前硬币面值`。
5. 如果遍历完所有硬币后仍未覆盖到 `target`，继续添加硬币直到覆盖 `target`。

关键点:
- 使用贪心策略，每次添加的硬币面值是当前能覆盖的最大金额加一。
- 通过排序确保每次添加的硬币面值是最优的。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是 coins 的长度，因为排序操作的时间复杂度是 O(n log n)。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def min_coins_to_add(coins: List[int], target: int) -> int:
    """
    函数式接口 - 计算需要添加的硬币的最小数量
    """
    # 对硬币面值进行排序
    coins.sort()
    
    current = 0  # 当前能覆盖的最大金额
    added_coins = 0  # 需要添加的硬币数量
    
    for coin in coins:
        # 如果当前硬币面值大于 current + 1，则需要添加一个面值为 current + 1 的硬币
        while coin > current + 1 and current < target:
            added_coins += 1
            current += current + 1
        # 更新 current
        current += coin
        if current >= target:
            break
    
    # 如果遍历完所有硬币后仍未覆盖到 target，继续添加硬币直到覆盖 target
    while current < target:
        added_coins += 1
        current += current + 1
    
    return added_coins


Solution = create_solution(min_coins_to_add)