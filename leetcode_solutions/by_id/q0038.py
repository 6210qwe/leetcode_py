# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 38
标题: Count and Say
难度: medium
链接: https://leetcode.cn/problems/count-and-say/
题目类型: 字符串
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
38. 外观数列 - 「外观数列」是一个数位字符串序列，由递归公式定义： * countAndSay(1) = "1" * countAndSay(n) 是 countAndSay(n-1) 的行程长度编码。 行程长度编码 [https://baike.baidu.com/item/%E8%A1%8C%E7%A8%8B%E9%95%BF%E5%BA%A6%E7%BC%96%E7%A0%81/2931940]（RLE）是一种字符串压缩方法，其工作原理是通过将连续相同字符（重复两次或更多次）替换为字符重复次数（运行长度）和字符的串联。例如，要压缩字符串 "3322251" ，我们将 "33" 用 "23" 替换，将 "222" 用 "32" 替换，将 "5" 用 "15" 替换并将 "1" 用 "11" 替换。因此压缩后字符串变为 "23321511"。 给定一个整数 n ，返回 外观数列 的第 n 个元素。 示例 1： 输入：n = 4 输出："1211" 解释： countAndSay(1) = "1" countAndSay(2) = "1" 的行程长度编码 = "11" countAndSay(3) = "11" 的行程长度编码 = "21" countAndSay(4) = "21" 的行程长度编码 = "1211" 示例 2： 输入：n = 1 输出："1" 解释： 这是基本情况。 提示： * 1 <= n <= 30 进阶：你能迭代解决该问题吗？
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 迭代生成，从"1"开始，每次对前一个字符串进行行程长度编码

算法步骤:
1. 从"1"开始
2. 对于每个n，对前一个字符串进行行程长度编码
3. 行程长度编码：统计连续相同字符的个数，然后拼接

关键点:
- 迭代生成，每次编码前一个字符串
- 时间复杂度O(2^n)，空间复杂度O(2^n)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(2^n) - 字符串长度指数增长
空间复杂度: O(2^n) - 字符串长度指数增长
"""

# ============================================================================
# 代码实现
# ============================================================================

from leetcode_solutions.utils.solution import create_solution


def count_and_say(n: int) -> str:
    """
    函数式接口 - 外观数列
    
    实现思路:
    迭代生成，从"1"开始，每次对前一个字符串进行行程长度编码。
    
    Args:
        n: 要生成的第n个外观数列
        
    Returns:
        外观数列的第n个元素
        
    Example:
        >>> count_and_say(4)
        '1211'
    """
    if n == 1:
        return "1"
    
    prev = "1"
    for _ in range(2, n + 1):
        curr = []
        i = 0
        while i < len(prev):
            count = 1
            while i + count < len(prev) and prev[i + count] == prev[i]:
                count += 1
            curr.append(str(count))
            curr.append(prev[i])
            i += count
        prev = ''.join(curr)
    
    return prev


# 自动生成Solution类（无需手动编写）
Solution = create_solution(count_and_say)
