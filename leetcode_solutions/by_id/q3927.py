# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3927
标题: Minimum Cost Path with Alternating Directions II
难度: medium
链接: https://leetcode.cn/problems/minimum-cost-path-with-alternating-directions-ii/
题目类型: 数组、动态规划、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3603. 交替方向的最小路径代价 II - 给你两个整数 m 和 n，分别表示网格的行数和列数。 进入单元格 (i, j) 的成本定义为 (i + 1) * (j + 1)。 另外给你一个二维整数数组 waitCost，其中 waitCost[i][j] 定义了在该单元格 等待 的成本。 路径始终从第 1 步进入单元格 (0, 0) 并支付入场花费开始。 每一步，你都遵循交替模式： * 在 奇数秒 ，你必须向 右 或向 下 移动到 相邻 的单元格，并支付其进入成本。 * 在 偶数秒 ，你必须原地 等待恰好 1 秒并在 1 秒期间支付 waitCost[i][j]。 返回到达 (m - 1, n - 1) 所需的 最小 总成本。 示例 1： 输入：m = 1, n = 2, waitCost = [[1,2]] 输出：3 解释： 最佳路径为： * 从第 1 秒开始在单元格 (0, 0)，进入成本为 (0 + 1) * (0 + 1) = 1。 * 第 1 秒：向右移动到单元格 (0, 1)，进入成本为 (0 + 1) * (1 + 1) = 2。 因此，总成本为 1 + 2 = 3。 示例 2： 输入：m = 2, n = 2, waitCost = [[3,5],[2,4]] 输出：9 解释： 最佳路径为： * 从第 1 秒开始在单元格 (0, 0)，进入成本为 (0 + 1) * (0 + 1) = 1。 * 第 1 秒：向下移动到单元格 (1, 0)，进入成本为 (1 + 1) * (0 + 1) = 2。 * 第 2 秒：在单元格 (1, 0) 等待，支付 waitCost[1][0] = 2。 * 第 3 秒：向右移动到单元格 (1, 1)，进入成本为 (1 + 1) * (1 + 1) = 4。 因此，总成本为 1 + 2 + 2 + 4 = 9。 示例 3： 输入：m = 2, n = 3, waitCost = [[6,1,4],[3,2,5]] 输出：16 解释： 最佳路径为： * 从第 1 秒开始在单元格 (0, 0)，进入成本为 (0 + 1) * (0 + 1) = 1。 * 第 1 秒：向右移动到单元格 (0, 1)，进入成本为 (0 + 1) * (1 + 1) = 2。 * 第 2 秒：在单元格 (0, 1) 等待，支付 waitCost[0][1] = 1。 * 第 3 秒：向下移动到单元格 (1, 1)，进入成本为 (1 + 1) * (1 + 1) = 4。 * 第 4 秒：在单元格 (1, 1) 等待，支付 waitCost[1][1] = 2。 * 第 5 秒：向右移动到单元格 (1, 2)，进入成本为 (1 + 1) * (2 + 1) = 6。 因此，总成本为 1 + 2 + 1 + 4 + 2 + 6 = 16。 提示： * 1 <= m, n <= 105 * 2 <= m * n <= 105 * waitCost.length == m * waitCost[0].length == n * 0 <= waitCost[i][j] <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们维护一个三维数组 dp，其中 dp[i][j][k] 表示到达 (i, j) 位置时，最后一步是 k（0 表示等待，1 表示向右或向下移动）的最小成本。

算法步骤:
1. 初始化 dp 数组，dp[0][0][1] = 1，因为从 (0, 0) 开始，第一步是进入。
2. 遍历每个单元格 (i, j)，更新 dp 数组：
   - 如果当前步是等待，则 dp[i][j][0] = min(dp[i][j-1][1], dp[i-1][j][1]) + waitCost[i][j]。
   - 如果当前步是移动，则 dp[i][j][1] = min(dp[i][j-1][0], dp[i-1][j][0]) + (i + 1) * (j + 1)。
3. 返回 dp[m-1][n-1][1]，即到达 (m-1, n-1) 且最后一步是移动的最小成本。

关键点:
- 动态规划的状态转移方程。
- 边界条件的处理。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m * n)
空间复杂度: O(m * n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def minimum_cost_path(m: int, n: int, waitCost: List[List[int]]) -> int:
    # 初始化 dp 数组
    dp = [[[float('inf')] * 2 for _ in range(n)] for _ in range(m)]
    dp[0][0][1] = 1  # 从 (0, 0) 开始，第一步是进入
    
    # 遍历每个单元格
    for i in range(m):
        for j in range(n):
            if i > 0:
                dp[i][j][0] = min(dp[i][j][0], dp[i-1][j][1] + waitCost[i][j])
                dp[i][j][1] = min(dp[i][j][1], dp[i-1][j][0] + (i + 1) * (j + 1))
            if j > 0:
                dp[i][j][0] = min(dp[i][j][0], dp[i][j-1][1] + waitCost[i][j])
                dp[i][j][1] = min(dp[i][j][1], dp[i][j-1][0] + (i + 1) * (j + 1))
    
    return dp[m-1][n-1][1]

Solution = create_solution(minimum_cost_path)