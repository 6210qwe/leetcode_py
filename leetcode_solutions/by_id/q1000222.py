# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000222
标题: 最多牌组数
难度: hard
链接: https://leetcode.cn/problems/Up5XYM/
题目类型: 数组、动态规划、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCP 36. 最多牌组数 - 麻将的游戏规则中，共有两种方式凑成「一组牌」： - 顺子：三张牌面数字连续的麻将，例如 [4,5,6] - 刻子：三张牌面数字相同的麻将，例如 [10,10,10] 给定若干数字作为麻将牌的数值（记作一维数组 `tiles`），请返回所给 `tiles` 最多可组成的牌组数。 注意：凑成牌组时，每张牌仅能使用一次。 **示例 1：** >输入：`tiles = [2,2,2,3,4]` > >输出：`1` > >解释：最多可以组合出 [2,2,2] 或者 [2,3,4] 其中一组牌。 **示例 2：** >输入：`tiles = [2,2,2,3,4,1,3]` > >输出：`2` > >解释：最多可以组合出 [1,2,3] 与 [2,3,4] 两组牌。 **提示：** - `1 <= tiles.length <= 10^5` - `1 <= tiles[i] <= 10^9`
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。首先对数组进行排序，然后使用一个计数器来记录每个数字的出现次数。接下来，我们使用一个二维动态规划数组 dp，其中 dp[i][j] 表示前 i 个数字中，剩余 j 个数字时的最大牌组数。

算法步骤:
1. 对数组进行排序。
2. 使用 Counter 记录每个数字的出现次数。
3. 初始化动态规划数组 dp，其中 dp[i][j] 表示前 i 个数字中，剩余 j 个数字时的最大牌组数。
4. 遍历每个数字，更新 dp 数组。
5. 返回 dp 数组的最终结果。

关键点:
- 动态规划的状态转移方程。
- 处理顺子和刻子的情况。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是 tiles 的长度，排序操作的时间复杂度为 O(n log n)。
空间复杂度: O(n)，用于存储计数器和动态规划数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from collections import Counter

def maxGroupNumber(tiles: List[int]) -> int:
    """
    函数式接口 - 返回所给 tiles 最多可组成的牌组数
    """
    # 对数组进行排序
    tiles.sort()
    
    # 使用 Counter 记录每个数字的出现次数
    count = Counter(tiles)
    
    # 初始化动态规划数组 dp
    dp = [0] * (len(tiles) + 1)
    
    # 遍历每个数字，更新 dp 数组
    for num in count:
        new_dp = [0] * (len(tiles) + 1)
        for j in range(len(tiles) + 1):
            if j < count[num]:
                new_dp[j] = dp[j]
            else:
                # 更新 dp 数组
                new_dp[j] = max(dp[j], 
                                dp[j - count[num]] + (count[num] // 3),  # 刻子
                                dp[j - count[num] - 1] + (count[num] - 1) // 3 if num + 1 in count and count[num + 1] >= 1 else 0,  # 顺子
                                dp[j - count[num] - 2] + (count[num] - 2) // 3 if num + 1 in count and count[num + 1] >= 1 and num + 2 in count and count[num + 2] >= 1 else 0)  # 顺子
        dp = new_dp
    
    return dp[len(tiles)]

Solution = create_solution(maxGroupNumber)