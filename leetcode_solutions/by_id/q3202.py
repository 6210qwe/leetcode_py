# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3202
标题: High-Access Employees
难度: medium
链接: https://leetcode.cn/problems/high-access-employees/
题目类型: 数组、哈希表、字符串、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2933. 高访问员工 - 给你一个长度为 n 、下标从 0 开始的二维字符串数组 access_times 。对于每个 i（0 <= i <= n - 1 ），access_times[i][0] 表示某位员工的姓名，access_times[i][1] 表示该员工的访问时间。access_times 中的所有条目都发生在同一天内。 访问时间用 四位 数字表示， 符合 24 小时制 ，例如 "0800" 或 "2250" 。 如果员工在 同一小时内 访问系统 三次或更多 ，则称其为 高访问 员工。 时间间隔正好相差一小时的时间 不 被视为同一小时内。例如，"0815" 和 "0915" 不属于同一小时内。 一天开始和结束时的访问时间不被计算为同一小时内。例如，"0005" 和 "2350" 不属于同一小时内。 以列表形式，按任意顺序，返回所有 高访问 员工的姓名。 示例 1： 输入：access_times = [["a","0549"],["b","0457"],["a","0532"],["a","0621"],["b","0540"]] 输出：["a"] 解释："a" 在时间段 [05:32, 06:31] 内有三条访问记录，时间分别为 05:32 、05:49 和 06:21 。 但是 "b" 的访问记录只有两条。 因此，答案是 ["a"] 。 示例 2： 输入：access_times = [["d","0002"],["c","0808"],["c","0829"],["e","0215"],["d","1508"],["d","1444"],["d","1410"],["c","0809"]] 输出：["c","d"] 解释："c" 在时间段 [08:08, 09:07] 内有三条访问记录，时间分别为 08:08 、08:09 和 08:29 。 "d" 在时间段 [14:10, 15:09] 内有三条访问记录，时间分别为 14:10 、14:44 和 15:08 。 然而，"e" 只有一条访问记录，因此不能包含在答案中，最终答案是 ["c","d"] 。 示例 3： 输入：access_times = [["cd","1025"],["ab","1025"],["cd","1046"],["cd","1055"],["ab","1124"],["ab","1120"]] 输出：["ab","cd"] 解释："ab"在时间段 [10:25, 11:24] 内有三条访问记录，时间分别为 10:25 、11:20 和 11:24 。 "cd" 在时间段 [10:25, 11:24] 内有三条访问记录，时间分别为 10:25 、10:46 和 10:55 。 因此，答案是 ["ab","cd"] 。 提示： * 1 <= access_times.length <= 100 * access_times[i].length == 2 * 1 <= access_times[i][0].length <= 10 * access_times[i][0] 仅由小写英文字母组成。 * access_times[i][1].length == 4 * access_times[i][1] 采用24小时制表示时间。 * access_times[i][1] 仅由数字 '0' 到 '9' 组成。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用哈希表存储每个员工的访问时间，并对每个员工的访问时间进行排序，然后检查是否有三个访问时间在同一个小时内。

算法步骤:
1. 使用一个字典 `time_dict` 来存储每个员工的访问时间列表。
2. 对每个员工的访问时间列表进行排序。
3. 遍历每个员工的访问时间列表，检查是否有三个访问时间在同一个小时内。
4. 如果有，则将该员工添加到结果列表中。

关键点:
- 使用哈希表存储每个员工的访问时间。
- 对访问时间进行排序，以便于后续的检查。
- 检查相邻的三个访问时间是否在同一个小时内。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是 access_times 的长度。排序操作的时间复杂度为 O(n log n)。
空间复杂度: O(n)，存储每个员工的访问时间列表。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def find_high_access_employees(access_times: List[List[str]]) -> List[str]:
    """
    返回所有高访问员工的姓名。
    """
    # 使用字典存储每个员工的访问时间
    time_dict = {}
    for name, time in access_times:
        if name not in time_dict:
            time_dict[name] = []
        time_dict[name].append(int(time))

    high_access_employees = []

    # 检查每个员工的访问时间
    for name, times in time_dict.items():
        times.sort()
        for i in range(len(times) - 2):
            if times[i + 2] - times[i] < 100:
                high_access_employees.append(name)
                break

    return high_access_employees

Solution = create_solution(find_high_access_employees)