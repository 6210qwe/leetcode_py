# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000011
标题: Robot in a Grid LCCI
难度: medium
链接: https://leetcode.cn/problems/robot-in-a-grid-lcci/
题目类型: 数组、动态规划、回溯、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
面试题 08.02. 迷路的机器人 - 设想有个机器人坐在一个网格的左上角，网格 r 行 c 列。机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。设计一种算法，寻找机器人从左上角移动到右下角的路径。 [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png] 网格中的障碍物和空位置分别用 1 和 0 来表示。 返回一条可行的路径，路径由经过的网格的行号和列号组成。左上角为 0 行 0 列。如果没有可行的路径，返回空数组。 示例 1： 输入：[[0,0,0],[0,1,0],[0,0,0]] 输出：[[0,0],[0,1],[0,2],[1,2],[2,2]] 解释： 输入中标粗的位置即为输出表示的路径，即 0 行 0 列（左上角） -> 0 行 1 列 -> 0 行 2 列 -> 1 行 2 列 -> 2 行 2 列（右下角） 说明：r 和 c 的值均不超过 100。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用深度优先搜索（DFS）结合回溯来找到从起点到终点的路径。

算法步骤:
1. 定义一个递归函数 `dfs` 来进行深度优先搜索。
2. 从起点 (0, 0) 开始，尝试向右或向下移动。
3. 如果到达终点 (m-1, n-1)，记录路径并返回。
4. 如果当前单元格是障碍物或已经访问过，则跳过。
5. 标记当前单元格为已访问，并继续搜索。
6. 如果没有找到路径，回溯并取消标记。

关键点:
- 使用一个二维数组 `visited` 来记录已经访问过的单元格，避免重复访问。
- 使用一个列表 `path` 来记录当前路径。
- 使用回溯来找到所有可能的路径。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(2^(m+n))，在最坏情况下，每个单元格都可能被访问两次（一次向下，一次向右）。
空间复杂度: O(m*n)，用于存储 `visited` 数组和递归调用栈。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional

def find_path(grid: List[List[int]]) -> List[List[int]]:
    def dfs(x: int, y: int, path: List[List[int]], visited: List[List[bool]]) -> bool:
        if x == m - 1 and y == n - 1:
            path.append([x, y])
            return True
        if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == 1 or visited[x][y]:
            return False
        
        visited[x][y] = True
        path.append([x, y])
        
        if dfs(x + 1, y, path, visited) or dfs(x, y + 1, path, visited):
            return True
        
        path.pop()
        return False
    
    m, n = len(grid), len(grid[0])
    visited = [[False] * n for _ in range(m)]
    path = []
    
    if dfs(0, 0, path, visited):
        return path
    else:
        return []

Solution = create_solution(find_path)