# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1619
标题: Path Crossing
难度: easy
链接: https://leetcode.cn/problems/path-crossing/
题目类型: 哈希表、字符串
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1496. 判断路径是否相交 - 给你一个字符串 path，其中 path[i] 的值可以是 'N'、'S'、'E' 或者 'W'，分别表示向北、向南、向东、向西移动一个单位。 你从二维平面上的原点 (0, 0) 处开始出发，按 path 所指示的路径行走。 如果路径在任何位置上与自身相交，也就是走到之前已经走过的位置，请返回 true ；否则，返回 false 。 示例 1： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/06/28/screen-shot-2020-06-10-at-123929-pm.png] 输入：path = "NES" 输出：false 解释：该路径没有在任何位置相交。 示例 2： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/06/28/screen-shot-2020-06-10-at-123843-pm.png] 输入：path = "NESWW" 输出：true 解释：该路径经过原点两次。 提示： * 1 <= path.length <= 104 * path[i] 为 'N'、'S'、'E' 或 'W'
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用哈希集合记录已经访问过的位置。如果在遍历过程中发现某个位置已经被访问过，则说明路径相交。

算法步骤:
1. 初始化当前位置 (x, y) 为 (0, 0)，并将其加入哈希集合。
2. 遍历路径字符串 path：
   - 根据当前字符更新 (x, y) 的值。
   - 检查更新后的 (x, y) 是否已经在哈希集合中，如果是则返回 True。
   - 将更新后的 (x, y) 加入哈希集合。
3. 如果遍历结束后没有发现重复位置，则返回 False。

关键点:
- 使用哈希集合来记录已经访问过的位置，以 O(1) 时间复杂度检查和插入。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是路径字符串的长度。
空间复杂度: O(n)，最坏情况下需要存储所有位置。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import Set


def is_path_crossing(path: str) -> bool:
    """
    判断路径是否相交
    """
    # 初始化当前位置 (x, y) 为 (0, 0)，并将其加入哈希集合
    x, y = 0, 0
    visited: Set[tuple[int, int]] = {(x, y)}

    # 遍历路径字符串 path
    for direction in path:
        if direction == 'N':
            y += 1
        elif direction == 'S':
            y -= 1
        elif direction == 'E':
            x += 1
        elif direction == 'W':
            x -= 1

        # 检查更新后的 (x, y) 是否已经在哈希集合中
        if (x, y) in visited:
            return True

        # 将更新后的 (x, y) 加入哈希集合
        visited.add((x, y))

    # 如果遍历结束后没有发现重复位置，则返回 False
    return False


Solution = create_solution(is_path_crossing)