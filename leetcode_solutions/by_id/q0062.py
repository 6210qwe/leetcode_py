# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 62
标题: Unique Paths
难度: medium
链接: https://leetcode.cn/problems/unique-paths/
题目类型: 数学、动态规划、组合数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
62. 不同路径 - 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？ 示例 1： [https://pic.leetcode.cn/1697422740-adxmsI-image.png] 输入：m = 3, n = 7 输出：28 示例 2： 输入：m = 3, n = 2 输出：3 解释： 从左上角开始，总共有 3 条路径可以到达右下角。 1. 向右 -> 向下 -> 向下 2. 向下 -> 向下 -> 向右 3. 向下 -> 向右 -> 向下 示例 3： 输入：m = 7, n = 3 输出：28 示例 4： 输入：m = 3, n = 3 输出：6 提示： * 1 <= m, n <= 100 * 题目数据保证答案小于等于 2 * 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 动态规划，dp[i][j]表示到达(i,j)的不同路径数

算法步骤:
1. 初始化：第一行和第一列的所有位置都只有1条路径
2. 状态转移：dp[i][j] = dp[i-1][j] + dp[i][j-1]
3. 返回dp[m-1][n-1]

关键点:
- 可以优化空间复杂度为O(n)，只使用一维数组
- 也可以使用组合数学：C(m+n-2, m-1)，但可能溢出
- 动态规划方法更稳定
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m*n) - 需要填充m×n的DP表
空间复杂度: O(n) - 优化后只使用一维数组
"""

# ============================================================================
# 代码实现
# ============================================================================

from leetcode_solutions.utils.solution import create_solution


def unique_paths(m: int, n: int) -> int:
    """
    函数式接口 - 动态规划（空间优化）
    
    实现思路:
    使用动态规划，优化空间复杂度为O(n)，只使用一维数组。
    
    Args:
        m: 网格的行数
        n: 网格的列数
        
    Returns:
        从左上角到右下角的不同路径数量
        
    Example:
        >>> unique_paths(3, 7)
        28
    """
    # 使用一维数组，初始化为1（第一行的所有位置都只有1条路径）
    dp = [1] * n
    
    # 从第二行开始计算
    for i in range(1, m):
        for j in range(1, n):
            # dp[j] = dp[j]（上一行的值）+ dp[j-1]（当前行左边的值）
            dp[j] += dp[j - 1]
    
    return dp[n - 1]


# 自动生成Solution类（无需手动编写）
Solution = create_solution(unique_paths)
