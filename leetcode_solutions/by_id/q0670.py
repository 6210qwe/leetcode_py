# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 670
标题: Maximum Swap
难度: medium
链接: https://leetcode.cn/problems/maximum-swap/
题目类型: 贪心、数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
670. 最大交换 - 给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。 示例 1 : 输入: 2736 输出: 7236 解释: 交换数字2和数字7。 示例 2 : 输入: 9973 输出: 9973 解释: 不需要交换。 注意: 1. 给定数字的范围是 [0, 108]
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 贪心 + 记录每个数字最后一次出现的位置

算法步骤:
1. 将数字转换为字符数组 digits
2. 从右往左遍历 digits，记录每个数字(0-9)最后一次出现的下标 last_pos
3. 从左到右遍历 digits，对当前位置 i 的数字 d：
   - 从 9 到 d+1 依次检查是否存在更大的数字，且它在 i 的右侧（last_pos[x] > i）
   - 如果存在，则与该位置进行一次交换并返回结果
4. 如果遍历结束都没有交换，说明已经是最大值，直接返回原数字

关键点:
- 只允许交换一次，所以找到最左边可以提升的位，与其右侧最靠右的更大数字交换
- 使用 last_pos 数组可以在 O(1) 时间内找到某个数字最后出现的位置
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(d) - d 为数字的位数（最多 10 位）
空间复杂度: O(1) - 只使用常数级额外空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def maximum_swap(num: int) -> int:
    """
    函数式接口 - 最大交换

    实现思路:
    记录每个数字最后出现的位置，从左到右尝试与右侧更大的数字交换一次。

    Args:
        num: 非负整数

    Returns:
        通过至多一次交换得到的最大整数

    Example:
        >>> maximum_swap(2736)
        7236
    """
    digits = list(str(num))
    n = len(digits)

    # 记录每个数字最后一次出现的位置
    last_pos = [-1] * 10
    for i, ch in enumerate(digits):
        last_pos[int(ch)] = i

    # 从左到右寻找可以交换的位置
    for i, ch in enumerate(digits):
        cur = int(ch)
        # 尝试用右侧更大的数字来替换当前位
        for d in range(9, cur, -1):
            if last_pos[d] > i:
                # 交换并返回结果
                j = last_pos[d]
                digits[i], digits[j] = digits[j], digits[i]
                return int("".join(digits))

    # 已经是最大数字
    return num


Solution = create_solution(maximum_swap)
