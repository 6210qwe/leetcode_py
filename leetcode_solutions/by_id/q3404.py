# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3404
标题: Minimum Number of Operations to Satisfy Conditions
难度: medium
链接: https://leetcode.cn/problems/minimum-number-of-operations-to-satisfy-conditions/
题目类型: 数组、动态规划、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3122. 使矩阵满足条件的最少操作次数 - 给你一个大小为 m x n 的二维矩形 grid 。每次 操作 中，你可以将 任一 格子的值修改为 任意 非负整数。完成所有操作后，你需要确保每个格子 grid[i][j] 的值满足： * 如果下面相邻格子存在的话，它们的值相等，也就是 grid[i][j] == grid[i + 1][j]（如果存在）。 * 如果右边相邻格子存在的话，它们的值不相等，也就是 grid[i][j] != grid[i][j + 1]（如果存在）。 请你返回需要的 最少 操作数目。 示例 1： 输入：grid = [[1,0,2],[1,0,2]] 输出：0 解释： [https://assets.leetcode.com/uploads/2024/04/15/examplechanged.png] 矩阵中所有格子已经满足要求。 示例 2： 输入：grid = [[1,1,1],[0,0,0]] 输出：3 解释： [https://assets.leetcode.com/uploads/2024/03/27/example21.png] 将矩阵变成 [[1,0,1],[1,0,1]] ，它满足所有要求，需要 3 次操作： * 将 grid[1][0] 变为 1 。 * 将 grid[0][1] 变为 0 。 * 将 grid[1][2] 变为 1 。 示例 3： 输入：grid = [[1],[2],[3]] 输出：2 解释： [https://assets.leetcode.com/uploads/2024/03/31/changed.png] 这个矩阵只有一列，我们可以通过 2 次操作将所有格子里的值变为 1 。 提示： * 1 <= n, m <= 1000 * 0 <= grid[i][j] <= 9
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们需要维护两个状态：当前行的最小操作数和前一行的最小操作数。

算法步骤:
1. 初始化 DP 表，dp[i][j] 表示将第 i 行的所有元素变为 j 所需的最小操作数。
2. 遍历每一行，更新 DP 表。
3. 对于每一行，计算将当前行的所有元素变为某个值所需的最小操作数，并更新 DP 表。
4. 返回最后一行的最小操作数。

关键点:
- 动态规划的状态转移方程：dp[i][j] = min(dp[i][j], dp[i-1][k] + cost) 其中 k != j。
- 使用滚动数组优化空间复杂度。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m * n * 10) - 其中 m 是行数，n 是列数，10 是可能的值的数量。
空间复杂度: O(n * 10) - 使用滚动数组优化后的空间复杂度。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def min_operations_to_satisfy_conditions(grid: List[List[int]]) -> int:
    if not grid or not grid[0]:
        return 0

    m, n = len(grid), len(grid[0])
    prev_row = [0] * 10
    cur_row = [0] * 10

    for i in range(m):
        for j in range(10):
            cur_row[j] = float('inf')
            for k in range(10):
                if j != k:
                    cur_row[j] = min(cur_row[j], prev_row[k] + sum(1 for cell in grid[i] if cell != j))
        
        prev_row, cur_row = cur_row, prev_row

    return min(prev_row)

Solution = create_solution(min_operations_to_satisfy_conditions)