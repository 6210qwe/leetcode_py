# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1679
标题: Shortest Subarray to be Removed to Make Array Sorted
难度: medium
链接: https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/
题目类型: 栈、数组、双指针、二分查找、单调栈
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1574. 删除最短的子数组使剩余数组有序 - 给你一个整数数组 arr ，请你删除一个子数组（可以为空），使得 arr 中剩下的元素是 非递减 的。 一个子数组指的是原数组中连续的一个子序列。 请你返回满足题目要求的最短子数组的长度。 示例 1： 输入：arr = [1,2,3,10,4,2,3,5] 输出：3 解释：我们需要删除的最短子数组是 [10,4,2] ，长度为 3 。剩余元素形成非递减数组 [1,2,3,3,5] 。 另一个正确的解为删除子数组 [3,10,4] 。 示例 2： 输入：arr = [5,4,3,2,1] 输出：4 解释：由于数组是严格递减的，我们只能保留一个元素。所以我们需要删除长度为 4 的子数组，要么删除 [5,4,3,2]，要么删除 [4,3,2,1]。 示例 3： 输入：arr = [1,2,3] 输出：0 解释：数组已经是非递减的了，我们不需要删除任何元素。 示例 4： 输入：arr = [1] 输出：0 提示： * 1 <= arr.length <= 10^5 * 0 <= arr[i] <= 10^9
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用双指针和二分查找来找到最短的子数组。

算法步骤:
1. 找到数组的左边界，使得从该位置开始数组是非递减的。
2. 找到数组的右边界，使得到该位置为止数组是非递减的。
3. 使用二分查找在左右边界之间找到最短的子数组，使得删除该子数组后数组是非递减的。

关键点:
- 通过双指针和二分查找来优化时间复杂度。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)
空间复杂度: O(1)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(arr: List[int]) -> int:
    """
    函数式接口 - 找到最短的子数组，使得删除该子数组后数组是非递减的。
    """
    n = len(arr)
    left, right = 0, n - 1
    
    # 找到左边界
    while left < n - 1 and arr[left] <= arr[left + 1]:
        left += 1
    if left == n - 1:
        return 0  # 数组已经是非递减的
    
    # 找到右边界
    while right > 0 and arr[right - 1] <= arr[right]:
        right -= 1
    if right == 0:
        return n - 1  # 数组是严格递减的
    
    # 初始化结果
    result = min(n - left - 1, right)
    
    # 使用二分查找找到最短的子数组
    for i in range(left + 1):
        j = right
        while j < n and arr[j] < arr[i]:
            j += 1
        result = min(result, j - i - 1)
    
    return result


Solution = create_solution(solution_function_name)