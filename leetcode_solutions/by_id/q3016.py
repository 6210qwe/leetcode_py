# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3016
标题: Count Nodes That Are Great Enough
难度: hard
链接: https://leetcode.cn/problems/count-nodes-that-are-great-enough/
题目类型: 树、深度优先搜索、分治、二叉树
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2792. 计算足够大的节点数 - 备战技术面试？力扣提供海量技术面试资源，帮助你高效提升编程技能,轻松拿下世界 IT 名企 Dream Offer。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用深度优先搜索 (DFS) 来遍历二叉树，并在遍历过程中记录路径上的最大值。对于每个节点，如果它的值大于等于路径上的最大值，则计数加一。

算法步骤:
1. 定义一个递归函数 `dfs`，该函数接受当前节点和路径上的最大值作为参数。
2. 如果当前节点为空，返回 0。
3. 更新路径上的最大值为当前节点值和路径上最大值的较大者。
4. 递归调用 `dfs` 函数处理左子节点和右子节点。
5. 如果当前节点值大于等于路径上的最大值，则计数加一。
6. 返回左子树和右子树的计数总和加上当前节点的计数。

关键点:
- 使用递归进行深度优先搜索。
- 在递归过程中维护路径上的最大值。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是二叉树的节点数。每个节点只会被访问一次。
空间复杂度: O(h)，其中 h 是二叉树的高度。递归调用栈的深度最多为树的高度。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import Optional
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution

def countGreatEnoughNodes(root: Optional[TreeNode]) -> int:
    """
    计算足够大的节点数
    """
    def dfs(node: Optional[TreeNode], max_val: int) -> int:
        if not node:
            return 0
        # 更新路径上的最大值
        new_max_val = max(max_val, node.val)
        # 递归处理左子节点和右子节点
        left_count = dfs(node.left, new_max_val)
        right_count = dfs(node.right, new_max_val)
        # 当前节点是否足够大
        current_count = 1 if node.val >= max_val else 0
        return left_count + right_count + current_count

    return dfs(root, float('-inf'))

Solution = create_solution(countGreatEnoughNodes)