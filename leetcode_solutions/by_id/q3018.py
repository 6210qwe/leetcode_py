# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3018
标题: Make String a Subsequence Using Cyclic Increments
难度: medium
链接: https://leetcode.cn/problems/make-string-a-subsequence-using-cyclic-increments/
题目类型: 双指针、字符串
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2825. 循环增长使字符串子序列等于另一个字符串 - 给你一个下标从 0 开始的字符串 str1 和 str2 。 一次操作中，你选择 str1 中的若干下标。对于选中的每一个下标 i ，你将 str1[i] 循环 递增，变成下一个字符。也就是说 'a' 变成 'b' ，'b' 变成 'c' ，以此类推，'z' 变成 'a' 。 如果执行以上操作 至多一次 ，可以让 str2 成为 str1 的子序列，请你返回 true ，否则返回 false 。 注意：一个字符串的子序列指的是从原字符串中删除一些（可以一个字符也不删）字符后，剩下字符按照原本先后顺序组成的新字符串。 示例 1： 输入：str1 = "abc", str2 = "ad" 输出：true 解释：选择 str1 中的下标 2 。 将 str1[2] 循环递增，得到 'd' 。 因此，str1 变成 "abd" 且 str2 现在是一个子序列。所以返回 true 。 示例 2： 输入：str1 = "zc", str2 = "ad" 输出：true 解释：选择 str1 中的下标 0 和 1 。 将 str1[0] 循环递增得到 'a' 。 将 str1[1] 循环递增得到 'd' 。 因此，str1 变成 "ad" 且 str2 现在是一个子序列。所以返回 true 。 示例 3： 输入：str1 = "ab", str2 = "d" 输出：false 解释：这个例子中，没法在执行一次操作的前提下，将 str2 变为 str1 的子序列。 所以返回 false 。 提示： * 1 <= str1.length <= 105 * 1 <= str2.length <= 105 * str1 和 str2 只包含小写英文字母。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用双指针遍历两个字符串，检查是否可以通过一次循环递增操作使 str2 成为 str1 的子序列。

算法步骤:
1. 初始化两个指针 i 和 j 分别指向 str1 和 str2 的起始位置。
2. 遍历 str1，对于每个字符，检查它是否可以通过一次循环递增操作变为 str2[j]。
3. 如果可以，则移动 j 指针到下一个字符。
4. 如果 j 指针到达 str2 的末尾，说明 str2 是 str1 的子序列，返回 True。
5. 如果遍历完 str1 后 j 指针仍未到达 str2 的末尾，返回 False。

关键点:
- 使用双指针高效地遍历两个字符串。
- 通过计算字符差值来判断是否可以通过一次循环递增操作匹配。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n + m)，其中 n 是 str1 的长度，m 是 str2 的长度。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def can_make_subsequence(str1: str, str2: str) -> bool:
    """
    判断是否可以通过一次循环递增操作使 str2 成为 str1 的子序列。
    """
    def is_next_char(c1: str, c2: str) -> bool:
        """
        判断 c1 是否可以通过一次循环递增操作变为 c2。
        """
        return (ord(c1) - ord('a') + 1) % 26 == (ord(c2) - ord('a')) % 26

    i, j = 0, 0
    while i < len(str1) and j < len(str2):
        if str1[i] == str2[j] or is_next_char(str1[i], str2[j]):
            j += 1
        i += 1

    return j == len(str2)


Solution = create_solution(can_make_subsequence)