# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2100
标题: Minimum Non-Zero Product of the Array Elements
难度: medium
链接: https://leetcode.cn/problems/minimum-non-zero-product-of-the-array-elements/
题目类型: 贪心、递归、数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1969. 数组元素的最小非零乘积 - 给你一个正整数 p 。你有一个下标从 1 开始的数组 nums ，这个数组包含范围 [1, 2p - 1] 内所有整数的二进制形式（两端都 包含）。你可以进行以下操作 任意 次： * 从 nums 中选择两个元素 x 和 y 。 * 选择 x 中的一位与 y 对应位置的位交换。对应位置指的是两个整数 相同位置 的二进制位。 比方说，如果 x = 1101 且 y = 0011 ，交换右边数起第 2 位后，我们得到 x = 1111 和 y = 0001 。 请你算出进行以上操作 任意次 以后，nums 能得到的 最小非零 乘积。将乘积对 109 + 7 取余 后返回。 注意：答案应为取余 之前 的最小值。 示例 1： 输入：p = 1 输出：1 解释：nums = [1] 。 只有一个元素，所以乘积为该元素。 示例 2： 输入：p = 2 输出：6 解释：nums = [01, 10, 11] 。 所有交换要么使乘积变为 0 ，要么乘积与初始乘积相同。 所以，数组乘积 1 * 2 * 3 = 6 已经是最小值。 示例 3： 输入：p = 3 输出：1512 解释：nums = [001, 010, 011, 100, 101, 110, 111] - 第一次操作中，我们交换第二个和第五个元素最左边的数位。 - 结果数组为 [001, 110, 011, 100, 001, 110, 111] 。 - 第二次操作中，我们交换第三个和第四个元素中间的数位。 - 结果数组为 [001, 110, 001, 110, 001, 110, 111] 。 数组乘积 1 * 6 * 1 * 6 * 1 * 6 * 7 = 1512 是最小乘积。 提示： * 1 <= p <= 60
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过数学方法计算最小非零乘积。对于给定的 p，最大值是 2^p - 1，第二大的值是 2^p - 2。为了得到最小非零乘积，我们需要尽可能多的 1 和 (2^p - 2) 的乘积。

算法步骤:
1. 计算 2^p - 1 和 2^p - 2。
2. 计算 (2^p - 2)^(2^(p-1) - 1) % (10^9 + 7)。
3. 返回结果乘以 (2^p - 1) 并对 (10^9 + 7) 取模。

关键点:
- 使用快速幂算法来计算大指数的幂。
- 使用模运算来防止溢出。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(log(2^p)) = O(p)
空间复杂度: O(1)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution

MOD = 10**9 + 7

def fast_pow(base: int, exponent: int, mod: int) -> int:
    """快速幂算法"""
    result = 1
    while exponent > 0:
        if exponent & 1:
            result = (result * base) % mod
        base = (base * base) % mod
        exponent >>= 1
    return result

def solution_function_name(p: int) -> int:
    """
    函数式接口 - 计算最小非零乘积
    """
    max_val = (1 << p) - 1
    second_max_val = max_val - 1
    count = (1 << (p - 1)) - 1
    product = fast_pow(second_max_val, count, MOD)
    return (product * max_val) % MOD

Solution = create_solution(solution_function_name)