# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1000437
标题: 夺回据点
难度: hard
链接: https://leetcode.cn/problems/s5kipK/
题目类型: 图、数组、双连通分量
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
LCP 54. 夺回据点 - 欢迎各位勇者来到力扣城，本次试炼主题为「夺回据点」。 魔物了占领若干据点，这些据点被若干条道路相连接，`roads[i] = [x, y]` 表示编号 `x`、`y` 的两个据点通过一条道路连接。 现在勇者要将按照以下原则将这些据点逐一夺回： - 在开始的时候，勇者可以花费资源先夺回一些据点，初始夺回第 `j` 个据点所需消耗的资源数量为 `cost[j]` - 接下来，勇者在不消耗资源情况下，每次可以夺回**一个**和「已夺回据点」相连接的魔物据点，并对其进行夺回 > 注：为了防止魔物暴动，勇者在每一次夺回据点后（包括花费资源夺回据点后），需要保证剩余的所有魔物据点之间是相连通的（不经过「已夺回据点」）。 请返回勇者夺回所有据点需要消耗的最少资源数量。 **注意：** - 输入保证初始所有据点都是连通的，且不存在重边和自环 **示例 1：** >输入： >`cost = [1,2,3,4,5,6]` >`roads = [[0,1],[0,2],[1,3],[2,3],[1,2],[2,4],[2,5]]` > >输出：`6` > >解释： >勇者消耗资源 `6` 夺回据点 `0` 和 `4`，魔物据点 `1、2、3、5` 相连通； >第一次夺回据点 `1`，魔物据点 `2、3、5` 相连通； >第二次夺回据点 `3`，魔物据点 `2、5` 相连通； >第三次夺回据点 `2`，剩余魔物据点 `5`； >第四次夺回据点 `5`，无剩余魔物据点； >因此最少需要消耗资源为 `6`，可占领所有据点。 ![image.png](https://pic.leetcode.cn/1648706944-KJstUN-image.png){:height=170px} **示例 2：** >输入： >`cost = [3,2,1,4]` >`roads = [[0,2],[2,3],[3,1]]` > >输出：`2` > >解释： >勇者消耗资源 `2` 夺回据点 `1`，魔物据点 `0、2、3` 相连通； >第一次夺回据点 `3`，魔物据点 `2、0` 相连通； >第二次夺回据点 `2`，剩余魔物据点 `0`； >第三次夺回据点 `0`，无剩余魔物据点； >因此最少需要消耗资源为 `2`，可占领所有据点。 ![image.png](https://pic.leetcode.cn/1648707186-LJRwzU-image.png){:height=60px} **提示：** - `1 <= roads.length, cost.length <= 10^5` - `0 <= roads[i][0], roads[i][1] < cost.length` - `1 <= cost[i] <= 10^9`
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过 Tarjan 算法找到所有的双连通分量 (BCC)，然后选择每个 BCC 中代价最小的据点进行夺回。

算法步骤:
1. 使用 Tarjan 算法找到所有的双连通分量 (BCC)。
2. 对于每个 BCC，选择其中代价最小的据点进行夺回。
3. 计算总的最小代价。

关键点:
- 使用 Tarjan 算法高效地找到所有的双连通分量。
- 选择每个 BCC 中代价最小的据点以最小化总代价。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(V + E)，其中 V 是顶点数，E 是边数。
空间复杂度: O(V + E)，用于存储图和辅助数据结构。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(cost: List[int], roads: List[List[int]]) -> int:
    """
    函数式接口 - 通过 Tarjan 算法找到所有的双连通分量 (BCC)，然后选择每个 BCC 中代价最小的据点进行夺回。
    """
    n = len(cost)
    graph = [[] for _ in range(n)]
    for u, v in roads:
        graph[u].append(v)
        graph[v].append(u)

    def tarjan(u: int, parent: int):
        nonlocal time
        dfn[u] = low[u] = time
        time += 1
        for v in graph[u]:
            if v == parent:
                continue
            if dfn[v] == -1:
                tarjan(v, u)
                low[u] = min(low[u], low[v])
                if low[v] >= dfn[u]:
                    bcc.append(u)
            else:
                low[u] = min(low[u], dfn[v])

    time = 0
    dfn = [-1] * n
    low = [-1] * n
    bccs = []
    for i in range(n):
        if dfn[i] == -1:
            bcc = []
            tarjan(i, -1)
            bccs.append(bcc)

    # 选择每个 BCC 中代价最小的据点
    min_cost = 0
    for bcc in bccs:
        min_cost += min(cost[u] for u in bcc)

    return min_cost


Solution = create_solution(solution_function_name)