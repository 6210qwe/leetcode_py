# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1310
标题: Watering Plants
难度: medium
链接: https://leetcode.cn/problems/watering-plants/
题目类型: 数组、模拟
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2079. 给植物浇水 - 你打算用一个水罐给花园里的 n 株植物浇水。植物排成一行，从左到右进行标记，编号从 0 到 n - 1 。其中，第 i 株植物的位置是 x = i 。x = -1 处有一条河，你可以在那里重新灌满你的水罐。 每一株植物都需要浇特定量的水。你将会按下面描述的方式完成浇水： * 按从左到右的顺序给植物浇水。 * 在给当前植物浇完水之后，如果你没有足够的水 完全 浇灌下一株植物，那么你就需要返回河边重新装满水罐。 * 你 不能 提前重新灌满水罐。 最初，你在河边（也就是，x = -1），在 x 轴上每移动 一个单位 都需要 一步 。 给你一个下标从 0 开始的整数数组 plants ，数组由 n 个整数组成。其中，plants[i] 为第 i 株植物需要的水量。另有一个整数 capacity 表示水罐的容量，返回浇灌所有植物需要的 步数 。 示例 1： 输入：plants = [2,2,3,3], capacity = 5 输出：14 解释：从河边开始，此时水罐是装满的： - 走到植物 0 (1 步) ，浇水。水罐中还有 3 单位的水。 - 走到植物 1 (1 步) ，浇水。水罐中还有 1 单位的水。 - 由于不能完全浇灌植物 2 ，回到河边取水 (2 步)。 - 走到植物 2 (3 步) ，浇水。水罐中还有 2 单位的水。 - 由于不能完全浇灌植物 3 ，回到河边取水 (3 步)。 - 走到植物 3 (4 步) ，浇水。 需要的步数是 = 1 + 1 + 2 + 3 + 3 + 4 = 14 。 示例 2： 输入：plants = [1,1,1,4,2,3], capacity = 4 输出：30 解释：从河边开始，此时水罐是装满的： - 走到植物 0，1，2 (3 步) ，浇水。回到河边取水 (3 步)。 - 走到植物 3 (4 步) ，浇水。回到河边取水 (4 步)。 - 走到植物 4 (5 步) ，浇水。回到河边取水 (5 步)。 - 走到植物 5 (6 步) ，浇水。 需要的步数是 = 3 + 3 + 4 + 4 + 5 + 5 + 6 = 30 。 示例 3： 输入：plants = [7,7,7,7,7,7,7], capacity = 8 输出：49 解释：每次浇水都需要重新灌满水罐。 需要的步数是 = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 = 49 。 提示： * n == plants.length * 1 <= n <= 1000 * 1 <= plants[i] <= 106 * max(plants[i]) <= capacity <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过一次遍历，计算每个植物浇水所需的步数，并在需要时返回河边重新装满水罐。

算法步骤:
1. 初始化步数 `steps` 和当前水罐中的水量 `current_water`。
2. 遍历每株植物，如果当前水罐中的水量不足以浇灌当前植物，则返回河边重新装满水罐，并更新步数。
3. 更新当前水罐中的水量，并增加步数。
4. 返回总步数。

关键点:
- 只有在当前水罐中的水量不足以浇灌当前植物时，才返回河边重新装满水罐。
- 每次返回河边重新装满水罐时，步数会增加两倍的距离。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是植物的数量。我们需要遍历整个植物数组一次。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def watering_plants(plants: List[int], capacity: int) -> int:
    """
    函数式接口 - 计算浇灌所有植物所需的步数
    """
    steps = 0
    current_water = capacity
    
    for i, plant in enumerate(plants):
        if current_water < plant:
            # 如果当前水罐中的水量不足以浇灌当前植物，返回河边重新装满水罐
            steps += 2 * i + 1  # 返回河边再回来的步数
            current_water = capacity
        
        # 浇灌当前植物
        current_water -= plant
        steps += 1
    
    return steps


Solution = create_solution(watering_plants)