# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 585
标题: Investments in 2016
难度: medium
链接: https://leetcode.cn/problems/investments-in-2016/
题目类型: 数据库
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
585. 2016年的投资 - Insurance 表： +-------------+-------+ | Column Name | Type | +-------------+-------+ | pid | int | | tiv_2015 | float | | tiv_2016 | float | | lat | float | | lon | float | +-------------+-------+ pid 是这张表的主键(具有唯一值的列)。 表中的每一行都包含一条保险信息，其中： pid 是投保人的投保编号。 tiv_2015 是该投保人在 2015 年的总投保金额，tiv_2016 是该投保人在 2016 年的总投保金额。 lat 是投保人所在城市的纬度。题目数据确保 lat 不为空。 lon 是投保人所在城市的经度。题目数据确保 lon 不为空。 编写解决方案报告 2016 年 (tiv_2016) 所有满足下述条件的投保人的投保金额之和： * 他在 2015 年的投保额 (tiv_2015) 至少跟一个其他投保人在 2015 年的投保额相同。 * 他所在的城市必须与其他投保人都不同（也就是说 (lat, lon) 不能跟其他任何一个投保人完全相同）。 tiv_2016 四舍五入的 两位小数 。 查询结果格式如下例所示。 示例 1： 输入： Insurance 表： +-----+----------+----------+-----+-----+ | pid | tiv_2015 | tiv_2016 | lat | lon | +-----+----------+----------+-----+-----+ | 1 | 10 | 5 | 10 | 10 | | 2 | 20 | 20 | 20 | 20 | | 3 | 10 | 30 | 20 | 20 | | 4 | 10 | 40 | 40 | 40 | +-----+----------+----------+-----+-----+ 输出： +----------+ | tiv_2016 | +----------+ | 45.00 | +----------+ 解释： 表中的第一条记录和最后一条记录都满足两个条件。 tiv_2015 值为 10 与第三条和第四条记录相同，且其位置是唯一的。 第二条记录不符合任何一个条件。其 tiv_2015 与其他投保人不同，并且位置与第三条记录相同，这也导致了第三条记录不符合题目要求。 因此，结果是第一条记录和最后一条记录的 tiv_2016 之和，即 45 。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想:
1. 找出所有在 2015 年有相同投保额的投保人。
2. 找出所有在城市位置上唯一的投保人。
3. 计算满足上述两个条件的投保人在 2016 年的投保金额之和。

算法步骤:
1. 使用子查询找出所有在 2015 年有相同投保额的投保人。
2. 使用子查询找出所有在城市位置上唯一的投保人。
3. 将上述两个子查询的结果进行交集操作，得到满足条件的投保人。
4. 计算这些投保人在 2016 年的投保金额之和，并四舍五入到两位小数。

关键点:
- 使用子查询来筛选符合条件的数据。
- 使用 GROUP BY 和 HAVING 来筛选出在 2015 年有相同投保额的投保人。
- 使用 GROUP BY 和 COUNT 来筛选出在城市位置上唯一的投保人。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是表中记录的数量。主要的时间开销来自于排序和分组操作。
空间复杂度: O(n)，需要存储中间结果。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(insurance: List[List[float]]) -> float:
    """
    函数式接口 - 实现最优解法
    """
    from collections import defaultdict
    from decimal import Decimal, getcontext

    # 设置小数精度
    getcontext().prec = 2

    # 存储每个 tiv_2015 的投保人数量
    tiv_2015_count = defaultdict(int)
    # 存储每个 (lat, lon) 的投保人数量
    location_count = defaultdict(int)

    for _, tiv_2015, _, lat, lon in insurance:
        tiv_2015_count[tiv_2015] += 1
        location_count[(lat, lon)] += 1

    # 筛选出满足条件的投保人
    valid_tiv_2016 = []
    for pid, tiv_2015, tiv_2016, lat, lon in insurance:
        if tiv_2015_count[tiv_2015] > 1 and location_count[(lat, lon)] == 1:
            valid_tiv_2016.append(tiv_2016)

    # 计算总和并四舍五入到两位小数
    total_tiv_2016 = sum(valid_tiv_2016)
    return Decimal(total_tiv_2016).quantize(Decimal('0.01'))


Solution = create_solution(solution_function_name)