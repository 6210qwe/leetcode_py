# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 779
标题: Max Chunks To Make Sorted II
难度: hard
链接: https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/
题目类型: 栈、贪心、数组、排序、单调栈
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
768. 最多能完成排序的块 II - 给你一个整数数组 arr 。 将 arr 分割成若干 块 ，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。 返回能将数组分成的最多块数？ 示例 1： 输入：arr = [5,4,3,2,1] 输出：1 解释： 将数组分成2块或者更多块，都无法得到所需的结果。 例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 示例 2： 输入：arr = [2,1,3,4,4] 输出：4 解释： 可以把它分成两块，例如 [2, 1], [3, 4, 4]。 然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。 提示： * 1 <= arr.length <= 2000 * 0 <= arr[i] <= 108
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用单调栈来维护当前块的最大值，确保每个块内的最大值不超过后续块的最小值。

算法步骤:
1. 初始化一个空栈，用于存储当前块的最大值。
2. 遍历数组，对于每个元素：
   - 如果栈为空或当前元素大于等于栈顶元素，则将当前元素压入栈。
   - 否则，找到栈中第一个大于当前元素的元素，并将其替换为当前元素。
3. 最终栈的大小即为最多能分成的块数。

关键点:
- 使用单调栈来维护块的最大值，确保每个块内的最大值不超过后续块的最小值。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是数组的长度。每个元素最多只会被压入和弹出栈一次。
空间复杂度: O(n)，在最坏情况下，栈的大小可能达到 n。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def max_chunks_to_sorted(arr: List[int]) -> int:
    """
    函数式接口 - 计算最多能分成的块数
    """
    stack = []
    for num in arr:
        if not stack or num >= stack[-1]:
            stack.append(num)
        else:
            max_val = stack.pop()
            while stack and stack[-1] > num:
                stack.pop()
            stack.append(max_val)
    return len(stack)


Solution = create_solution(max_chunks_to_sorted)