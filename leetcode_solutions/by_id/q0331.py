# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 331
标题: Verify Preorder Serialization of a Binary Tree
难度: medium
链接: https://leetcode.cn/problems/verify-preorder-serialization-of-a-binary-tree/
题目类型: 栈、树、字符串、二叉树
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
331. 验证二叉树的前序序列化 - 序列化二叉树的一种方法是使用 前序遍历 。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。 [https://assets.leetcode.com/uploads/2021/03/12/pre-tree.jpg] 例如，上面的二叉树可以被序列化为字符串 "9,3,4,#,#,1,#,#,2,#,6,#,#"，其中 # 代表一个空节点。 给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。 保证 每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 '#' 。 你可以认为输入格式总是有效的 * 例如它永远不会包含两个连续的逗号，比如 "1,,3" 。 注意：不允许重建树。 示例 1: 输入: preorder = "9,3,4,#,#,1,#,#,2,#,6,#,#" 输出: true 示例 2: 输入: preorder = "1,#" 输出: false 示例 3: 输入: preorder = "9,#,#,1" 输出: false 提示: * 1 <= preorder.length <= 104 * preorder 由以逗号 “，” 分隔的 [0,100] 范围内的整数和 “#” 组成
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用栈模拟前序遍历，计算槽位

算法步骤:
1. 每个非空节点消耗1个槽位，产生2个槽位
2. 每个空节点消耗1个槽位
3. 如果槽位不够，说明序列无效

关键点:
- 槽位计数
- 时间复杂度O(n)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n) - 遍历序列一次
空间复杂度: O(1) - 只使用常数额外空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def is_valid_serialization(preorder: str) -> bool:
    """
    函数式接口 - 验证二叉树的前序序列化
    
    实现思路:
    使用槽位计数：每个非空节点消耗1个槽位，产生2个槽位。
    
    Args:
        preorder: 前序序列化字符串
        
    Returns:
        是否为有效的前序序列化
        
    Example:
        >>> is_valid_serialization("9,3,4,#,#,1,#,#,2,#,6,#,#")
        True
    """
    slots = 1  # 初始槽位为1
    nodes = preorder.split(',')
    
    for node in nodes:
        slots -= 1  # 消耗一个槽位
        if slots < 0:
            return False
        
        if node != '#':
            slots += 2  # 非空节点产生2个槽位
    
    return slots == 0


# 自动生成Solution类（无需手动编写）
Solution = create_solution(is_valid_serialization)
