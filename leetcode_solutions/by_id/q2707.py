# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2707
标题: Merge Two 2D Arrays by Summing Values
难度: easy
链接: https://leetcode.cn/problems/merge-two-2d-arrays-by-summing-values/
题目类型: 数组、哈希表、双指针
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2570. 合并两个二维数组 - 求和法 - 给你两个 二维 整数数组 nums1 和 nums2. * nums1[i] = [idi, vali] 表示编号为 idi 的数字对应的值等于 vali 。 * nums2[i] = [idi, vali] 表示编号为 idi 的数字对应的值等于 vali 。 每个数组都包含 互不相同 的 id ，并按 id 以 递增 顺序排列。 请你将两个数组合并为一个按 id 以递增顺序排列的数组，并符合下述条件： * 只有在两个数组中至少出现过一次的 id 才能包含在结果数组内。 * 每个 id 在结果数组中 只能出现一次 ，并且其对应的值等于两个数组中该 id 所对应的值求和。如果某个数组中不存在该 id ，则假定其对应的值等于 0 。 返回结果数组。返回的数组需要按 id 以递增顺序排列。 示例 1： 输入：nums1 = [[1,2],[2,3],[4,5]], nums2 = [[1,4],[3,2],[4,1]] 输出：[[1,6],[2,3],[3,2],[4,6]] 解释：结果数组中包含以下元素： - id = 1 ，对应的值等于 2 + 4 = 6 。 - id = 2 ，对应的值等于 3 。 - id = 3 ，对应的值等于 2 。 - id = 4 ，对应的值等于 5 + 1 = 6 。 示例 2： 输入：nums1 = [[2,4],[3,6],[5,5]], nums2 = [[1,3],[4,3]] 输出：[[1,3],[2,4],[3,6],[4,3],[5,5]] 解释：不存在共同 id ，在结果数组中只需要包含每个 id 和其对应的值。 提示： * 1 <= nums1.length, nums2.length <= 200 * nums1[i].length == nums2[j].length == 2 * 1 <= idi, vali <= 1000 * 数组中的 id 互不相同 * 数据均按 id 以严格递增顺序排列
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用双指针遍历两个有序数组，同时维护一个哈希表来存储每个 id 的总和。

算法步骤:
1. 初始化两个指针 i 和 j 分别指向 nums1 和 nums2 的起始位置。
2. 初始化一个字典 result 来存储每个 id 的总和。
3. 使用双指针遍历两个数组：
   - 如果 nums1[i][0] < nums2[j][0]，将 nums1[i] 加入 result 并移动 i。
   - 如果 nums1[i][0] > nums2[j][0]，将 nums2[j] 加入 result 并移动 j。
   - 如果 nums1[i][0] == nums2[j][0]，将两者相加的结果加入 result 并移动 i 和 j。
4. 将剩余的元素加入 result。
5. 将 result 转换为列表并按 id 排序。

关键点:
- 使用双指针可以高效地遍历两个有序数组。
- 使用字典来存储每个 id 的总和，避免重复计算。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n + m)，其中 n 和 m 分别是 nums1 和 nums2 的长度。
空间复杂度: O(n + m)，用于存储结果字典。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def merge_arrays(nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:
    """
    合并两个二维数组 - 求和法
    """
    i, j = 0, 0
    result = {}
    
    while i < len(nums1) and j < len(nums2):
        if nums1[i][0] < nums2[j][0]:
            result[nums1[i][0]] = nums1[i][1]
            i += 1
        elif nums1[i][0] > nums2[j][0]:
            result[nums2[j][0]] = nums2[j][1]
            j += 1
        else:
            result[nums1[i][0]] = nums1[i][1] + nums2[j][1]
            i += 1
            j += 1
    
    # Add remaining elements from nums1
    while i < len(nums1):
        result[nums1[i][0]] = nums1[i][1]
        i += 1
    
    # Add remaining elements from nums2
    while j < len(nums2):
        result[nums2[j][0]] = nums2[j][1]
        j += 1
    
    # Convert the result dictionary to a sorted list
    return sorted(result.items())

Solution = create_solution(merge_arrays)