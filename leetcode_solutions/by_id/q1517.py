# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1517
标题: Restore The Array
难度: hard
链接: https://leetcode.cn/problems/restore-the-array/
题目类型: 字符串、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1416. 恢复数组 - 某个程序本来应该输出一个整数数组。但是这个程序忘记输出空格了以致输出了一个数字字符串，我们所知道的信息只有：数组中所有整数都在 [1, k] 之间，且数组中的数字都没有前导 0 。 给你字符串 s 和整数 k 。可能会有多种不同的数组恢复结果。 按照上述程序，请你返回所有可能输出字符串 s 的数组方案数。 由于数组方案数可能会很大，请你返回它对 10^9 + 7 取余 后的结果。 示例 1： 输入：s = "1000", k = 10000 输出：1 解释：唯一一种可能的数组方案是 [1000] 示例 2： 输入：s = "1000", k = 10 输出：0 解释：不存在任何数组方案满足所有整数都 >= 1 且 <= 10 同时输出结果为 s 。 示例 3： 输入：s = "1317", k = 2000 输出：8 解释：可行的数组方案为 [1317]，[131,7]，[13,17]，[1,317]，[13,1,7]，[1,31,7]，[1,3,17]，[1,3,1,7] 示例 4： 输入：s = "2020", k = 30 输出：1 解释：唯一可能的数组方案是 [20,20] 。 [2020] 不是可行的数组方案，原因是 2020 > 30 。 [2,020] 也不是可行的数组方案，因为 020 含有前导 0 。 示例 5： 输入：s = "1234567890", k = 90 输出：34 提示： * 1 <= s.length <= 10^5. * s 只包含数字且不包含前导 0 。 * 1 <= k <= 10^9.
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。定义 dp[i] 表示以第 i 个字符结尾的子字符串的方案数。

算法步骤:
1. 初始化 dp 数组，长度为 n+1，dp[0] = 1。
2. 从左到右遍历字符串 s，对于每个位置 i，检查从 i-1 到 i-l 之间的子字符串是否在 [1, k] 之间。
3. 如果在范围内，则将 dp[i] 加上 dp[i-l]。
4. 最终结果是 dp[n] % (10^9 + 7)。

关键点:
- 使用滑动窗口来检查子字符串是否在 [1, k] 之间。
- 动态规划的状态转移方程为 dp[i] += dp[i-l]。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * log k)，其中 n 是字符串 s 的长度，log k 是每次检查子字符串是否在 [1, k] 之间的复杂度。
空间复杂度: O(n)，用于存储 dp 数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(s: str, k: int) -> int:
    """
    函数式接口 - 实现最优解法
    """
    MOD = 10**9 + 7
    n = len(s)
    dp = [0] * (n + 1)
    dp[0] = 1

    for i in range(1, n + 1):
        for l in range(1, min(i + 1, 11)):  # 最多检查 10 位数
            if i - l == 0 or (i - l > 0 and s[i - l - 1] != '0'):
                num = int(s[i - l:i])
                if 1 <= num <= k:
                    dp[i] = (dp[i] + dp[i - l]) % MOD

    return dp[n]


Solution = create_solution(solution_function_name)