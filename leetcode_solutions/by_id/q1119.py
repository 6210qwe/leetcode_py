# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1119
标题: Robot Bounded In Circle
难度: medium
链接: https://leetcode.cn/problems/robot-bounded-in-circle/
题目类型: 数学、字符串、模拟
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1041. 困于环中的机器人 - 在无限的平面上，机器人最初位于 (0, 0) 处，面朝北方。注意: * 北方向 是y轴的正方向。 * 南方向 是y轴的负方向。 * 东方向 是x轴的正方向。 * 西方向 是x轴的负方向。 机器人可以接受下列三条指令之一： * "G"：直走 1 个单位 * "L"：左转 90 度 * "R"：右转 90 度 机器人按顺序执行指令 instructions，并一直重复它们。 只有在平面中存在环使得机器人永远无法离开时，返回 true。否则，返回 false。 示例 1： 输入：instructions = "GGLLGG" 输出：true 解释：机器人最初在(0,0)处，面向北方。 “G”:移动一步。位置:(0,1)方向:北。 “G”:移动一步。位置:(0,2).方向:北。 “L”:逆时针旋转90度。位置:(0,2).方向:西。 “L”:逆时针旋转90度。位置:(0,2)方向:南。 “G”:移动一步。位置:(0,1)方向:南。 “G”:移动一步。位置:(0,0)方向:南。 重复指令，机器人进入循环:(0,0)——>(0,1)——>(0,2)——>(0,1)——>(0,0)。 在此基础上，我们返回true。 示例 2： 输入：instructions = "GG" 输出：false 解释：机器人最初在(0,0)处，面向北方。 “G”:移动一步。位置:(0,1)方向:北。 “G”:移动一步。位置:(0,2).方向:北。 重复这些指示，继续朝北前进，不会进入循环。 在此基础上，返回false。 示例 3： 输入：instructions = "GL" 输出：true 解释：机器人最初在(0,0)处，面向北方。 “G”:移动一步。位置:(0,1)方向:北。 “L”:逆时针旋转90度。位置:(0,1).方向:西。 “G”:移动一步。位置:(- 1,1)方向:西。 “L”:逆时针旋转90度。位置:(- 1,1)方向:南。 “G”:移动一步。位置:(- 1,0)方向:南。 “L”:逆时针旋转90度。位置:(- 1,0)方向:东方。 “G”:移动一步。位置:(0,0)方向:东方。 “L”:逆时针旋转90度。位置:(0,0)方向:北。 重复指令，机器人进入循环:(0,0)——>(0,1)——>(- 1,1)——>(- 1,0)——>(0,0)。 在此基础上，我们返回true。 提示： * 1 <= instructions.length <= 100 * instructions[i] 仅包含 'G', 'L', 'R'
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过一次遍历指令来判断机器人是否会在有限的步数内回到原点或改变方向。

算法步骤:
1. 初始化机器人的位置和方向。
2. 遍历指令，根据指令更新机器人的位置和方向。
3. 检查机器人是否回到了原点或改变了方向。如果回到了原点或改变了方向，则说明机器人会被困在一个环中。

关键点:
- 使用一个方向数组来表示四个方向（北、东、南、西）。
- 根据指令更新机器人的位置和方向。
- 最后检查机器人的位置和方向。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是指令的长度。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def is_robot_bounded(instructions: str) -> bool:
    """
    函数式接口 - 判断机器人是否会在有限的步数内被困在一个环中
    """
    # 方向数组，分别表示北、东、南、西
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    x, y = 0, 0  # 初始位置
    direction_index = 0  # 初始方向为北

    for instruction in instructions:
        if instruction == "G":
            dx, dy = directions[direction_index]
            x += dx
            y += dy
        elif instruction == "L":
            direction_index = (direction_index - 1) % 4
        elif instruction == "R":
            direction_index = (direction_index + 1) % 4

    # 机器人回到原点或者方向改变了
    return (x == 0 and y == 0) or (direction_index != 0)


Solution = create_solution(is_robot_bounded)