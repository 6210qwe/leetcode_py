# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2289
标题: Minimum Operations to Make the Array Alternating
难度: medium
链接: https://leetcode.cn/problems/minimum-operations-to-make-the-array-alternating/
题目类型: 贪心、数组、哈希表、计数
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2170. 使数组变成交替数组的最少操作数 - 给你一个下标从 0 开始的数组 nums ，该数组由 n 个正整数组成。 如果满足下述条件，则数组 nums 是一个 交替数组 ： * nums[i - 2] == nums[i] ，其中 2 <= i <= n - 1 。 * nums[i - 1] != nums[i] ，其中 1 <= i <= n - 1 。 在一步 操作 中，你可以选择下标 i 并将 nums[i] 更改 为 任一 正整数。 返回使数组变成交替数组的 最少操作数 。 示例 1： 输入：nums = [3,1,3,2,4,3] 输出：3 解释： 使数组变成交替数组的方法之一是将该数组转换为 [3,1,3,1,3,1] 。 在这种情况下，操作数为 3 。 可以证明，操作数少于 3 的情况下，无法使数组变成交替数组。 示例 2： 输入：nums = [1,2,2,2,2] 输出：2 解释： 使数组变成交替数组的方法之一是将该数组转换为 [1,2,1,2,1]. 在这种情况下，操作数为 2 。 注意，数组不能转换成 [2,2,2,2,2] 。因为在这种情况下，nums[0] == nums[1]，不满足交替数组的条件。 提示： * 1 <= nums.length <= 105 * 1 <= nums[i] <= 105
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过计数找出奇偶位置上出现次数最多的两个数，然后计算最小的操作数。

算法步骤:
1. 分别统计奇数和偶数位置上每个数的出现次数。
2. 找出奇数和偶数位置上出现次数最多的两个数及其出现次数。
3. 计算两种情况下的最小操作数：
   - 奇数位置和偶数位置上的最大数不同。
   - 奇数位置和偶数位置上的最大数相同，需要考虑次大数。

关键点:
- 使用计数器来统计每个位置上数的出现次数。
- 通过比较最大数和次大数来确定最小操作数。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from collections import Counter

def minimum_operations(nums: List[int]) -> int:
    """
    函数式接口 - 使数组变成交替数组的最少操作数
    """
    if len(nums) <= 1:
        return 0

    # 统计奇数和偶数位置上每个数的出现次数
    odd_counter = Counter()
    even_counter = Counter()

    for i, num in enumerate(nums):
        if i % 2 == 0:
            even_counter[num] += 1
        else:
            odd_counter[num] += 1

    # 找出奇数和偶数位置上出现次数最多的两个数及其出现次数
    (even_max, even_count), (even_second, even_second_count) = even_counter.most_common(2)
    (odd_max, odd_count), (odd_second, odd_second_count) = odd_counter.most_common(2)

    # 计算最小操作数
    if even_max != odd_max:
        return len(nums) - even_count - odd_count
    else:
        return min(len(nums) - even_count - odd_second_count, len(nums) - even_second_count - odd_count)

Solution = create_solution(minimum_operations)