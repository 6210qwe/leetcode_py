# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2759
标题: Flatten Deeply Nested Array
难度: medium
链接: https://leetcode.cn/problems/flatten-deeply-nested-array/
题目类型: 其他
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2625. 扁平化嵌套数组 - 请你编写一个函数，它接收一个 多维数组 arr 和它的深度 n ，并返回该数组的 扁平化 后的结果。 多维数组 是一种包含整数或其他 多维数组 的递归数据结构。 数组 扁平化 是对数组的一种操作，定义是将原数组部分或全部子数组删除，并替换为该子数组中的实际元素。只有当嵌套的数组深度小于 n 时，才应该执行扁平化操作。第一层数组中元素的深度被认为是 0。 请在没有使用内置方法 Array.flat 的前提下解决这个问题。 示例 1： 输入 arr = [1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]] n = 0 输出 [1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]] 解释 传递深度 n=0 的多维数组将始终得到原始数组。这是因为子数组(0)的最小可能的深度不小于 n = 0。因此，任何子数组都不应该被平面化。 示例 2： 输入 arr = [1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]] n = 1 输出 [1, 2, 3, 4, 5, 6, 7, 8, [9, 10, 11], 12, 13, 14, 15] 解释 以 4 、7 和 13 开头的子数组都被扁平化了，这是因为它们的深度为 0， 而 0 小于 1。然而 [9,10,11] 其深度为 1，所以未被扁平化。 示例 3： 输入 arr = [[1, 2, 3], [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]] n = 2 输出 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] 解释 所有子数组的最大深度都为 1。因此，它们都被扁平化了。 提示： * 0 <= arr 的元素个数 <= 105 * 0 <= arr 的子数组个数 <= 105 * maxDepth <= 1000 * -1000 <= each number <= 1000 * 0 <= n <= 1000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用递归方法来处理多维数组，根据给定的深度 n 来决定是否继续扁平化子数组。

算法步骤:
1. 定义一个递归函数 flatten，接收当前数组和当前深度。
2. 如果当前深度大于等于 n，则直接返回当前数组。
3. 否则，遍历当前数组，对于每个元素：
   - 如果元素是列表，则递归调用 flatten 函数处理该子数组，并将结果展开。
   - 如果元素不是列表，则直接添加到结果列表中。
4. 返回最终的扁平化结果。

关键点:
- 递归处理多维数组。
- 根据深度 n 决定是否继续扁平化。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是数组中所有元素的总数。每个元素最多被访问一次。
空间复杂度: O(n)，递归调用栈的深度最多为 n。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def flatten_deeply_nested_array(arr: List[any], n: int) -> List[any]:
    """
    扁平化多维数组，根据给定的深度 n。
    """
    def flatten(arr: List[any], depth: int) -> List[any]:
        if depth >= n:
            return arr
        result = []
        for item in arr:
            if isinstance(item, list):
                result.extend(flatten(item, depth + 1))
            else:
                result.append(item)
        return result

    return flatten(arr, 0)


Solution = create_solution(flatten_deeply_nested_array)