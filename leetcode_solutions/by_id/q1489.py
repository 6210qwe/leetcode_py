# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1489
标题: Pizza With 3n Slices
难度: hard
链接: https://leetcode.cn/problems/pizza-with-3n-slices/
题目类型: 贪心、数组、动态规划、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1388. 3n 块披萨 - 给你一个披萨，它由 3n 块不同大小的部分组成，现在你和你的朋友们需要按照如下规则来分披萨： * 你挑选 任意 一块披萨。 * Alice 将会挑选你所选择的披萨逆时针方向的下一块披萨。 * Bob 将会挑选你所选择的披萨顺时针方向的下一块披萨。 * 重复上述过程直到没有披萨剩下。 每一块披萨的大小按顺时针方向由循环数组 slices 表示。 请你返回你可以获得的披萨大小总和的最大值。 示例 1： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/03/21/sample_3_1723.png] 输入：slices = [1,2,3,4,5,6] 输出：10 解释：选择大小为 4 的披萨，Alice 和 Bob 分别挑选大小为 3 和 5 的披萨。然后你选择大小为 6 的披萨，Alice 和 Bob 分别挑选大小为 2 和 1 的披萨。你获得的披萨总大小为 4 + 6 = 10 。 示例 2： [https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/03/21/sample_4_1723.png] 输入：slices = [8,9,8,6,1,1] 输出：16 解释：两轮都选大小为 8 的披萨。如果你选择大小为 9 的披萨，你的朋友们就会选择大小为 8 的披萨，这种情况下你的总和不是最大的。 提示： * 1 <= slices.length <= 500 * slices.length % 3 == 0 * 1 <= slices[i] <= 1000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划解决这个问题。我们需要找到在不相邻的情况下选取 n 个元素的最大和。

算法步骤:
1. 将环形数组转换为两个线性数组，分别处理。
2. 对于每个线性数组，使用动态规划计算最大和。
3. 最后取两个结果的最大值。

关键点:
- 动态规划的状态转移方程：dp[i][j] 表示在前 i 个元素中选取 j 个不相邻元素的最大和。
- 初始化 dp 数组，并处理边界情况。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2)，其中 n 是 slices 的长度。
空间复杂度: O(n^2)，用于存储动态规划状态。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def max_pizza_sum(slices: List[int]) -> int:
    def max_sum_non_adjacent(nums: List[int], k: int) -> int:
        n = len(nums)
        dp = [[0] * (k + 1) for _ in range(n + 1)]
        
        for i in range(1, n + 1):
            for j in range(1, k + 1):
                dp[i][j] = max(dp[i - 1][j], nums[i - 1] + (dp[i - 2][j - 1] if i >= 2 else 0))
        
        return dp[n][k]
    
    n = len(slices) // 3
    # Case 1: Exclude the first slice
    case1 = max_sum_non_adjacent(slices[1:], n)
    # Case 2: Exclude the last slice
    case2 = max_sum_non_adjacent(slices[:-1], n)
    
    return max(case1, case2)

Solution = create_solution(max_pizza_sum)