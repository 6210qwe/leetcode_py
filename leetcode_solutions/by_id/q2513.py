# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2513
标题: Number of Pairs Satisfying Inequality
难度: hard
链接: https://leetcode.cn/problems/number-of-pairs-satisfying-inequality/
题目类型: 树状数组、线段树、数组、二分查找、分治、有序集合、归并排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2426. 满足不等式的数对数目 - 给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，两个数组的大小都为 n ，同时给你一个整数 diff ，统计满足以下条件的 数对 (i, j) ： * 0 <= i < j <= n - 1 且 * nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff. 请你返回满足条件的 数对数目 。 示例 1： 输入：nums1 = [3,2,5], nums2 = [2,2,1], diff = 1 输出：3 解释： 总共有 3 个满足条件的数对： 1. i = 0, j = 1：3 - 2 <= 2 - 2 + 1 。因为 i < j 且 1 <= 1 ，这个数对满足条件。 2. i = 0, j = 2：3 - 5 <= 2 - 1 + 1 。因为 i < j 且 -2 <= 2 ，这个数对满足条件。 3. i = 1, j = 2：2 - 5 <= 2 - 1 + 1 。因为 i < j 且 -3 <= 2 ，这个数对满足条件。 所以，我们返回 3 。 示例 2： 输入：nums1 = [3,-1], nums2 = [-2,2], diff = -1 输出：0 解释： 没有满足条件的任何数对，所以我们返回 0 。 提示： * n == nums1.length == nums2.length * 2 <= n <= 105 * -104 <= nums1[i], nums2[i] <= 104 * -104 <= diff <= 104
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用有序集合（SortedList）来维护已经处理过的元素，并利用二分查找来高效地计算满足条件的数对。

算法步骤:
1. 计算差值数组 `diffs`，其中 `diffs[i] = nums1[i] - nums2[i]`。
2. 初始化有序集合 `sl` 和计数器 `count`。
3. 从右向左遍历 `diffs` 数组：
   - 对于每个元素 `diffs[i]`，使用有序集合的 `bisect_left` 方法找到第一个大于等于 `diffs[i] - diff` 的位置。
   - 将该位置的索引加入计数器 `count`。
   - 将当前元素 `diffs[i]` 加入有序集合 `sl`。
4. 返回计数器 `count` 的值。

关键点:
- 使用有序集合来维护已经处理过的元素，可以高效地进行二分查找。
- 从右向左遍历数组，确保每次处理的元素不会影响后续的计算。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是数组的长度。每次插入和查找操作的时间复杂度为 O(log n)。
空间复杂度: O(n)，需要额外的空间来存储有序集合。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from sortedcontainers import SortedList

def count_pairs(nums1: List[int], nums2: List[int], diff: int) -> int:
    """
    计算满足条件的数对数目
    """
    diffs = [a - b for a, b in zip(nums1, nums2)]
    sl = SortedList()
    count = 0
    
    for i in range(len(diffs) - 1, -1, -1):
        # 找到第一个大于等于 diffs[i] - diff 的位置
        index = sl.bisect_left(diffs[i] - diff)
        count += index
        sl.add(diffs[i])
    
    return count

Solution = create_solution(count_pairs)