# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1962
标题: Single-Threaded CPU
难度: medium
链接: https://leetcode.cn/problems/single-threaded-cpu/
题目类型: 数组、排序、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1834. 单线程 CPU - 给你一个二维数组 tasks ，用于表示 n 项从 0 到 n - 1 编号的任务。其中 tasks[i] = [enqueueTimei, processingTimei] 意味着第 i 项任务将会于 enqueueTimei 时进入任务队列，需要 processingTimei 的时长完成执行。 现有一个单线程 CPU ，同一时间只能执行 最多一项 任务，该 CPU 将会按照下述方式运行： * 如果 CPU 空闲，且任务队列中没有需要执行的任务，则 CPU 保持空闲状态。 * 如果 CPU 空闲，但任务队列中有需要执行的任务，则 CPU 将会选择 执行时间最短 的任务开始执行。如果多个任务具有同样的最短执行时间，则选择下标最小的任务开始执行。 * 一旦某项任务开始执行，CPU 在 执行完整个任务 前都不会停止。 * CPU 可以在完成一项任务后，立即开始执行一项新任务。 返回 CPU 处理任务的顺序。 示例 1： 输入：tasks = [[1,2],[2,4],[3,2],[4,1]] 输出：[0,2,3,1] 解释：事件按下述流程运行： - time = 1 ，任务 0 进入任务队列，可执行任务项 = {0} - 同样在 time = 1 ，空闲状态的 CPU 开始执行任务 0 ，可执行任务项 = {} - time = 2 ，任务 1 进入任务队列，可执行任务项 = {1} - time = 3 ，任务 2 进入任务队列，可执行任务项 = {1, 2} - 同样在 time = 3 ，CPU 完成任务 0 并开始执行队列中用时最短的任务 2 ，可执行任务项 = {1} - time = 4 ，任务 3 进入任务队列，可执行任务项 = {1, 3} - time = 5 ，CPU 完成任务 2 并开始执行队列中用时最短的任务 3 ，可执行任务项 = {1} - time = 6 ，CPU 完成任务 3 并开始执行任务 1 ，可执行任务项 = {} - time = 10 ，CPU 完成任务 1 并进入空闲状态 示例 2： 输入：tasks = [[7,10],[7,12],[7,5],[7,4],[7,2]] 输出：[4,3,2,0,1] 解释：事件按下述流程运行： - time = 7 ，所有任务同时进入任务队列，可执行任务项 = {0,1,2,3,4} - 同样在 time = 7 ，空闲状态的 CPU 开始执行任务 4 ，可执行任务项 = {0,1,2,3} - time = 9 ，CPU 完成任务 4 并开始执行任务 3 ，可执行任务项 = {0,1,2} - time = 13 ，CPU 完成任务 3 并开始执行任务 2 ，可执行任务项 = {0,1} - time = 18 ，CPU 完成任务 2 并开始执行任务 0 ，可执行任务项 = {1} - time = 28 ，CPU 完成任务 0 并开始执行任务 1 ，可执行任务项 = {} - time = 40 ，CPU 完成任务 1 并进入空闲状态 提示： * tasks.length == n * 1 <= n <= 105 * 1 <= enqueueTimei, processingTimei <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用优先队列来管理任务，并按时间顺序处理任务。

算法步骤:
1. 将每个任务与它的索引绑定，以便在处理时可以知道任务的原始索引。
2. 按照任务的入队时间对任务进行排序。
3. 使用一个优先队列来存储当前可以执行的任务，优先队列的元素是 (处理时间, 索引)。
4. 初始化当前时间为第一个任务的入队时间。
5. 遍历任务列表，将所有入队时间小于等于当前时间的任务加入优先队列。
6. 从优先队列中取出处理时间最短的任务进行处理，并更新当前时间。
7. 重复步骤5和6，直到所有任务都被处理完毕。

关键点:
- 使用优先队列来高效地获取处理时间最短的任务。
- 通过维护当前时间来确保任务按时间顺序处理。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是任务的数量。排序操作的时间复杂度为 O(n log n)，而优先队列的操作时间复杂度为 O(log n)。
空间复杂度: O(n)，优先队列最多存储 n 个任务。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def single_threaded_cpu(tasks: List[List[int]]) -> List[int]:
    # 将每个任务与它的索引绑定
    tasks = [(enqueue_time, processing_time, index) for index, (enqueue_time, processing_time) in enumerate(tasks)]
    
    # 按照任务的入队时间对任务进行排序
    tasks.sort()
    
    result = []
    min_heap = []
    current_time = tasks[0][0]
    
    for enqueue_time, processing_time, index in tasks:
        # 将所有入队时间小于等于当前时间的任务加入优先队列
        while min_heap and current_time < enqueue_time:
            process_time, task_index = heapq.heappop(min_heap)
            result.append(task_index)
            current_time += process_time
        
        # 更新当前时间
        current_time = max(current_time, enqueue_time)
        
        # 将当前任务加入优先队列
        heapq.heappush(min_heap, (processing_time, index))
    
    # 处理剩余的任务
    while min_heap:
        process_time, task_index = heapq.heappop(min_heap)
        result.append(task_index)
    
    return result

Solution = create_solution(single_threaded_cpu)