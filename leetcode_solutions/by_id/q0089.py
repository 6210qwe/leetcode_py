# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 89
标题: Gray Code
难度: medium
链接: https://leetcode.cn/problems/gray-code/
题目类型: 位运算、数学、回溯
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
89. 格雷编码 - n 位格雷码序列 是一个由 2n 个整数组成的序列，其中： * 每个整数都在范围 [0, 2n - 1] 内（含 0 和 2n - 1） * 第一个整数是 0 * 一个整数在序列中出现 不超过一次 * 每对 相邻 整数的二进制表示 恰好一位不同 ，且 * 第一个 和 最后一个 整数的二进制表示 恰好一位不同 给你一个整数 n ，返回任一有效的 n 位格雷码序列 。 示例 1： 输入：n = 2 输出：[0,1,3,2] 解释： [0,1,3,2] 的二进制表示是 [00,01,11,10] 。 - 00 和 01 有一位不同 - 01 和 11 有一位不同 - 11 和 10 有一位不同 - 10 和 00 有一位不同 [0,2,3,1] 也是一个有效的格雷码序列，其二进制表示是 [00,10,11,01] 。 - 00 和 10 有一位不同 - 10 和 11 有一位不同 - 11 和 01 有一位不同 - 01 和 00 有一位不同 示例 2： 输入：n = 1 输出：[0,1] 提示： * 1 <= n <= 16
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 镜像反射法，n位格雷码可以通过n-1位格雷码生成

算法步骤:
1. n=1时，格雷码为[0, 1]
2. 对于n>1：
   - 先得到n-1位的格雷码
   - 将n-1位格雷码镜像复制
   - 前半部分在最高位加0（保持不变）
   - 后半部分在最高位加1（加上2^(n-1)）
3. 返回n位格雷码

关键点:
- 利用镜像反射的性质
- 时间复杂度O(2^n)，空间复杂度O(2^n)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(2^n) - 需要生成2^n个格雷码
空间复杂度: O(2^n) - 存储格雷码序列
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from leetcode_solutions.utils.solution import create_solution


def gray_code(n: int) -> List[int]:
    """
    函数式接口 - 镜像反射法
    
    实现思路:
    使用镜像反射法生成n位格雷码序列。
    
    Args:
        n: 格雷码的位数
        
    Returns:
        n位格雷码序列
        
    Example:
        >>> gray_code(2)
        [0, 1, 3, 2]
    """
    result = [0, 1]
    
    for i in range(2, n + 1):
        # 镜像复制并加上2^(i-1)
        for j in range(len(result) - 1, -1, -1):
            result.append(result[j] + (1 << (i - 1)))
    
    return result


# 自动生成Solution类（无需手动编写）
Solution = create_solution(gray_code)
