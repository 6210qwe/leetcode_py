# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2291
标题: Maximum AND Sum of Array
难度: hard
链接: https://leetcode.cn/problems/maximum-and-sum-of-array/
题目类型: 位运算、数组、动态规划、状态压缩
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2172. 数组的最大与和 - 给你一个长度为 n 的整数数组 nums 和一个整数 numSlots ，满足2 * numSlots >= n 。总共有 numSlots 个篮子，编号为 1 到 numSlots 。 你需要把所有 n 个整数分到这些篮子中，且每个篮子 至多 有 2 个整数。一种分配方案的 与和 定义为每个数与它所在篮子编号的 按位与运算 结果之和。 * 比方说，将数字 [1, 3] 放入篮子 1 中，[4, 6] 放入篮子 2 中，这个方案的与和为 (1 AND 1) + (3 AND 1) + (4 AND 2) + (6 AND 2) = 1 + 1 + 0 + 2 = 4 。 请你返回将 nums 中所有数放入 numSlots 个篮子中的最大与和。 示例 1： 输入：nums = [1,2,3,4,5,6], numSlots = 3 输出：9 解释：一个可行的方案是 [1, 4] 放入篮子 1 中，[2, 6] 放入篮子 2 中，[3, 5] 放入篮子 3 中。 最大与和为 (1 AND 1) + (4 AND 1) + (2 AND 2) + (6 AND 2) + (3 AND 3) + (5 AND 3) = 1 + 0 + 2 + 2 + 3 + 1 = 9 。 示例 2： 输入：nums = [1,3,10,4,7,1], numSlots = 9 输出：24 解释：一个可行的方案是 [1, 1] 放入篮子 1 中，[3] 放入篮子 3 中，[4] 放入篮子 4 中，[7] 放入篮子 7 中，[10] 放入篮子 9 中。 最大与和为 (1 AND 1) + (1 AND 1) + (3 AND 3) + (4 AND 4) + (7 AND 7) + (10 AND 9) = 1 + 1 + 3 + 4 + 7 + 8 = 24 。 注意，篮子 2 ，5 ，6 和 8 是空的，这是允许的。 提示： * n == nums.length * 1 <= numSlots <= 9 * 1 <= n <= 2 * numSlots * 1 <= nums[i] <= 15
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划和状态压缩来解决这个问题。我们使用一个三进制数来表示每个篮子的状态（0 表示没有放，1 表示放了一个数，2 表示放了两个数）。通过递归和记忆化搜索来找到最大与和。

算法步骤:
1. 将每个篮子的状态用一个三进制数表示。
2. 使用递归和记忆化搜索来计算最大与和。
3. 对于每个数，尝试将其放入每一个篮子中，并更新状态。
4. 返回最大与和。

关键点:
- 使用三进制数来表示每个篮子的状态。
- 使用递归和记忆化搜索来避免重复计算。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(3^numSlots * n)
空间复杂度: O(3^numSlots * n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution
from functools import lru_cache

def solution_function_name(nums: List[int], numSlots: int) -> int:
    """
    函数式接口 - 计算最大与和
    """
    @lru_cache(None)
    def dp(index: int, state: int) -> int:
        if index == len(nums):
            return 0
        max_sum = 0
        for slot in range(numSlots):
            slot_state = (state // (3 ** slot)) % 3
            if slot_state < 2:
                new_state = state + 3 ** slot
                max_sum = max(max_sum, (nums[index] & (slot + 1)) + dp(index + 1, new_state))
        return max_sum

    return dp(0, 0)

Solution = create_solution(solution_function_name)