# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1952
标题: Minimum Sideway Jumps
难度: medium
链接: https://leetcode.cn/problems/minimum-sideway-jumps/
题目类型: 贪心、数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1824. 最少侧跳次数 - 给你一个长度为 n 的 3 跑道道路 ，它总共包含 n + 1 个 点 ，编号为 0 到 n 。一只青蛙从 0 号点第二条跑道 出发 ，它想要跳到点 n 处。然而道路上可能有一些障碍。 给你一个长度为 n + 1 的数组 obstacles ，其中 obstacles[i] （取值范围从 0 到 3）表示在点 i 处的 obstacles[i] 跑道上有一个障碍。如果 obstacles[i] == 0 ，那么点 i 处没有障碍。任何一个点的三条跑道中 最多有一个 障碍。 * 比方说，如果 obstacles[2] == 1 ，那么说明在点 2 处跑道 1 有障碍。 这只青蛙从点 i 跳到点 i + 1 且跑道不变的前提是点 i + 1 的同一跑道上没有障碍。为了躲避障碍，这只青蛙也可以在 同一个 点处 侧跳 到 另外一条 跑道（这两条跑道可以不相邻），但前提是跳过去的跑道该点处没有障碍。 * 比方说，这只青蛙可以从点 3 处的跑道 3 跳到点 3 处的跑道 1 。 这只青蛙从点 0 处跑道 2 出发，并想到达点 n 处的 任一跑道 ，请你返回 最少侧跳次数 。 注意：点 0 处和点 n 处的任一跑道都不会有障碍。 示例 1： [https://assets.leetcode.com/uploads/2021/03/25/ic234-q3-ex1.png] 输入：obstacles = [0,1,2,3,0] 输出：2 解释：最优方案如上图箭头所示。总共有 2 次侧跳（红色箭头）。 注意，这只青蛙只有当侧跳时才可以跳过障碍（如上图点 2 处所示）。 示例 2： [https://assets.leetcode.com/uploads/2021/03/25/ic234-q3-ex2.png] 输入：obstacles = [0,1,1,3,3,0] 输出：0 解释：跑道 2 没有任何障碍，所以不需要任何侧跳。 示例 3： [https://assets.leetcode.com/uploads/2021/03/25/ic234-q3-ex3.png] 输入：obstacles = [0,2,1,0,3,0] 输出：2 解释：最优方案如上图所示。总共有 2 次侧跳。 提示： * obstacles.length == n + 1 * 1 <= n <= 5 * 105 * 0 <= obstacles[i] <= 3 * obstacles[0] == obstacles[n] == 0
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来记录每个位置在每条跑道上的最少侧跳次数。

算法步骤:
1. 初始化一个二维数组 dp，dp[i][j] 表示到达第 i 个位置第 j 条跑道的最少侧跳次数。
2. 初始化起点位置的 dp 值。
3. 从左到右遍历每个位置，更新 dp 值：
   - 如果当前跑道有障碍，则跳过。
   - 否则，更新当前跑道的 dp 值为前一个位置的最小 dp 值加 1（如果需要侧跳）或保持不变（如果不需要侧跳）。
4. 返回最后一个位置的最小 dp 值。

关键点:
- 动态规划的状态转移方程。
- 处理障碍物的方式。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)
空间复杂度: O(n)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def min_sideway_jumps(obstacles: List[int]) -> int:
    """
    计算最少侧跳次数
    """
    n = len(obstacles) - 1
    dp = [[float('inf')] * 3 for _ in range(n + 1)]
    
    # 初始化起点
    dp[0][1] = 0
    
    for i in range(1, n + 1):
        for j in range(3):
            if obstacles[i] != j + 1:
                dp[i][j] = dp[i - 1][j]
                for k in range(3):
                    if k != j and obstacles[i] != k + 1:
                        dp[i][j] = min(dp[i][j], dp[i][k] + 1)
    
    return min(dp[n])

Solution = create_solution(min_sideway_jumps)