# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 191
标题: Number of 1 Bits
难度: easy
链接: https://leetcode.cn/problems/number-of-1-bits/
题目类型: 位运算、分治
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
191. 位1的个数 - 给定一个正整数 n，编写一个函数，获取一个正整数的二进制形式并返回其二进制表达式中 设置位 的个数（也被称为汉明重量 [https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F]）。 示例 1： 输入：n = 11 输出：3 解释：输入的二进制串 1011 中，共有 3 个设置位。 示例 2： 输入：n = 128 输出：1 解释：输入的二进制串 10000000 中，共有 1 个设置位。 示例 3： 输入：n = 2147483645 输出：30 解释：输入的二进制串 1111111111111111111111111111101 中，共有 30 个设置位。 提示： * 1 <= n <= 231 - 1 进阶： * 如果多次调用这个函数，你将如何优化你的算法？
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用位运算，每次清除最低位的1

算法步骤:
1. 使用n & (n-1)清除最低位的1
2. 重复直到n为0
3. 统计清除的次数

关键点:
- n & (n-1)可以清除最低位的1
- 时间复杂度O(k)，k为1的个数，空间复杂度O(1)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(k) - k为1的个数
空间复杂度: O(1) - 只使用常数额外空间
"""

# ============================================================================
# 代码实现
# ============================================================================

from leetcode_solutions.utils.solution import create_solution


def number_of_1_bits(n: int) -> int:
    """
    函数式接口 - 计算位1的个数
    
    实现思路:
    使用位运算，每次清除最低位的1。
    
    Args:
        n: 正整数
        
    Returns:
        二进制中1的个数
        
    Example:
        >>> number_of_1_bits(11)
        3
    """
    count = 0
    while n:
        n &= n - 1  # 清除最低位的1
        count += 1
    return count


# 自动生成Solution类（无需手动编写）
Solution = create_solution(number_of_1_bits)
