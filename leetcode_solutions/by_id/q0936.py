# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 936
标题: RLE Iterator
难度: medium
链接: https://leetcode.cn/problems/rle-iterator/
题目类型: 设计、数组、计数、迭代器
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
900. RLE 迭代器 - 我们可以使用游程编码(即 RLE )来编码一个整数序列。在偶数长度 encoding ( 从 0 开始 )的游程编码数组中，对于所有偶数 i ，encoding[i] 告诉我们非负整数 encoding[i + 1] 在序列中重复的次数。 * 例如，序列 arr = [8,8,8,5,5] 可以被编码为 encoding =[3,8,2,5] 。encoding =[3,8,0,9,2,5] 和 encoding =[2,8,1,8,2,5] 也是 arr 有效的 RLE 。 给定一个游程长度的编码数组，设计一个迭代器来遍历它。 实现 RLEIterator 类: * RLEIterator(int[] encoded) 用编码后的数组初始化对象。 * int next(int n) 以这种方式耗尽后 n 个元素并返回最后一个耗尽的元素。如果没有剩余的元素要耗尽，则返回 -1 。 示例 1： 输入： ["RLEIterator","next","next","next","next"] [[[3,8,0,9,2,5]],[2],[1],[1],[2]] 输出： [null,8,8,5,-1] 解释： RLEIterator rLEIterator = new RLEIterator([3, 8, 0, 9, 2, 5]); // 这映射到序列 [8,8,8,5,5]。 rLEIterator.next(2); // 耗去序列的 2 个项，返回 8。现在剩下的序列是 [8, 5, 5]。 rLEIterator.next(1); // 耗去序列的 1 个项，返回 8。现在剩下的序列是 [5, 5]。 rLEIterator.next(1); // 耗去序列的 1 个项，返回 5。现在剩下的序列是 [5]。 rLEIterator.next(2); // 耗去序列的 2 个项，返回 -1。 这是由于第一个被耗去的项是 5， 但第二个项并不存在。由于最后一个要耗去的项不存在，我们返回 -1。 提示： * 2 <= encoding.length <= 1000 * encoding.length 为偶 * 0 <= encoding[i] <= 109 * 1 <= n <= 109 * 每个测试用例调用next 不高于 1000 次
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用两个指针分别指向当前处理的频次和值，并在每次调用 next 时更新这两个指针。

算法步骤:
1. 初始化两个指针 index 和 count，分别指向当前处理的频次和值。
2. 在 next 方法中，根据 n 更新 index 和 count，直到消耗完 n 个元素或没有剩余元素。
3. 返回最后一个消耗的元素或 -1。

关键点:
- 使用两个指针简化对编码数组的遍历。
- 在 next 方法中逐步更新指针，确保每次操作的时间复杂度为 O(1)。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(1) - 每次调用 next 的时间复杂度为 O(1)。
空间复杂度: O(1) - 只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List


class RLEIterator:

    def __init__(self, encoding: List[int]):
        self.encoding = encoding
        self.index = 0
        self.count = 0

    def next(self, n: int) -> int:
        while self.index < len(self.encoding):
            if self.count + n > self.encoding[self.index]:
                n -= self.encoding[self.index] - self.count
                self.index += 2
                self.count = 0
            else:
                self.count += n
                return self.encoding[self.index + 1]
        return -1


# 示例用法
if __name__ == "__main__":
    rLEIterator = RLEIterator([3, 8, 0, 9, 2, 5])
    print(rLEIterator.next(2))  # 输出 8
    print(rLEIterator.next(1))  # 输出 8
    print(rLEIterator.next(1))  # 输出 5
    print(rLEIterator.next(2))  # 输出 -1