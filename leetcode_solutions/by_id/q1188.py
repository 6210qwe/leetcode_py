# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1188
标题: Brace Expansion II
难度: hard
链接: https://leetcode.cn/problems/brace-expansion-ii/
题目类型: 栈、广度优先搜索、哈希表、字符串、回溯、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1096. 花括号展开 II - 如果你熟悉 Shell 编程，那么一定了解过花括号展开，它可以用来生成任意字符串。 花括号展开的表达式可以看作一个由 花括号、逗号 和 小写英文字母 组成的字符串，定义下面几条语法规则： * 如果只给出单一的元素 x，那么表达式表示的字符串就只有 "x"。R(x) = {x} * 例如，表达式 "a" 表示字符串 "a"。 * 而表达式 "w" 就表示字符串 "w"。 * 当两个或多个表达式并列，以逗号分隔，我们取这些表达式中元素的并集。R({e_1,e_2,...}) = R(e_1) ∪ R(e_2) ∪ ... * 例如，表达式 "{a,b,c}" 表示字符串 "a","b","c"。 * 而表达式 "{{a,b},{b,c}}" 也可以表示字符串 "a","b","c"。 * 要是两个或多个表达式相接，中间没有隔开时，我们从这些表达式中各取一个元素依次连接形成字符串。R(e_1 + e_2) = {a + b for (a, b) in R(e_1) × R(e_2)} * 例如，表达式 "{a,b}{c,d}" 表示字符串 "ac","ad","bc","bd"。 * 表达式之间允许嵌套，单一元素与表达式的连接也是允许的。 * 例如，表达式 "a{b,c,d}" 表示字符串 "ab","ac","ad" 。 * 例如，表达式 "a{b,c}{d,e}f{g,h}" 可以表示字符串 "abdfg", "abdfh", "abefg", "abefh", "acdfg", "acdfh", "acefg", "acefh"。 给出表示基于给定语法规则的表达式 expression，返回它所表示的所有字符串组成的有序列表。 假如你希望以「集合」的概念了解此题，也可以通过点击 “显示英文描述” 获取详情。 示例 1： 输入：expression = "{a,b}{c,{d,e}}" 输出：["ac","ad","ae","bc","bd","be"] 示例 2： 输入：expression = "{{a,z},a{b,c},{ab,z}}" 输出：["a","ab","ac","z"] 解释：输出中 不应 出现重复的组合结果。 提示： * 1 <= expression.length <= 60 * expression[i] 由 '{'，'}'，',' 或小写英文字母组成 * 给出的表达式 expression 用以表示一组基于题目描述中语法构造的字符串
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用栈来处理嵌套的表达式，并使用集合来去重。

算法步骤:
1. 初始化一个栈，用于存储当前处理的表达式。
2. 遍历输入的表达式，根据不同的字符进行处理：
   - 如果遇到字母，则将其添加到当前的子表达式中。
   - 如果遇到左括号 `{`，则将当前的子表达式压入栈，并开始一个新的子表达式。
   - 如果遇到右括号 `}`，则将当前的子表达式与栈顶的子表达式进行笛卡尔积运算，并将结果压入栈。
   - 如果遇到逗号 `,`，则将当前的子表达式压入栈，并开始一个新的子表达式。
3. 最终栈中的所有子表达式进行并集运算，并返回结果。

关键点:
- 使用栈来处理嵌套的表达式。
- 使用集合来去重。
- 使用笛卡尔积和并集运算来生成最终的结果。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2)，其中 n 是表达式的长度。最坏情况下，每个字符都需要进行笛卡尔积运算。
空间复杂度: O(n^2)，在最坏情况下，栈中存储的子表达式数量可能达到 n^2。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Set
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def brace_expansion_ii(expression: str) -> List[str]:
    def cartesian_product(set1: Set[str], set2: Set[str]) -> Set[str]:
        return {a + b for a in set1 for b in set2}

    stack = [set()]
    current_set = set()

    i = 0
    while i < len(expression):
        if expression[i].isalpha():
            current_set = {s + expression[i] for s in current_set or ['']}
        elif expression[i] == '{':
            stack.append(current_set)
            current_set = set()
        elif expression[i] == '}':
            current_set = cartesian_product(stack.pop(), current_set)
        elif expression[i] == ',':
            stack[-1] |= current_set
            current_set = set()
        i += 1

    stack[-1] |= current_set
    return sorted(stack[-1])


Solution = create_solution(brace_expansion_ii)