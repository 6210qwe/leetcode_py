# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 130
标题: Surrounded Regions
难度: medium
链接: https://leetcode.cn/problems/surrounded-regions/
题目类型: 深度优先搜索、广度优先搜索、并查集、数组、矩阵
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
130. 被围绕的区域 - 给你一个 m x n 的矩阵 board ，由若干字符 'X' 和 'O' 组成，捕获 所有 被围绕的区域： * 连接：一个单元格与水平或垂直方向上相邻的单元格连接。 * 区域：连接所有 'O' 的单元格来形成一个区域。 * 围绕：如果您可以用 'X' 单元格 连接这个区域，并且区域中没有任何单元格位于 board 边缘，则该区域被 'X' 单元格围绕。 通过 原地 将输入矩阵中的所有 'O' 替换为 'X' 来 捕获被围绕的区域。你不需要返回任何值。 示例 1： 输入：board = [['X','X','X','X'],['X','O','O','X'],['X','X','O','X'],['X','O','X','X']] 输出：[['X','X','X','X'],['X','X','X','X'],['X','X','X','X'],['X','O','X','X']] 解释： [https://pic.leetcode.cn/1718167191-XNjUTG-image.png] 在上图中，底部的区域没有被捕获，因为它在 board 的边缘并且不能被围绕。 示例 2： 输入：board = [['X']] 输出：[['X']] 提示： * m == board.length * n == board[i].length * 1 <= m, n <= 200 * board[i][j] 为 'X' 或 'O'
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 从边界开始DFS，标记所有与边界相连的'O'，然后将其余'O'改为'X'

算法步骤:
1. 从四个边界开始DFS，标记所有与边界相连的'O'为特殊标记
2. 遍历整个矩阵，将'O'改为'X'，将特殊标记改回'O'

关键点:
- 从边界开始DFS，标记相连的'O'
- 时间复杂度O(m*n)，空间复杂度O(m*n)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(m*n) - 需要遍历矩阵
空间复杂度: O(m*n) - 递归栈深度
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
from leetcode_solutions.utils.solution import create_solution


def surrounded_regions(board: List[List[str]]) -> None:
    """
    函数式接口 - 被围绕的区域
    
    实现思路:
    从边界开始DFS，标记所有与边界相连的'O'，然后将其余'O'改为'X'。
    
    Args:
        board: m×n的矩阵（原地修改）
        
    Returns:
        None（直接修改矩阵）
        
    Example:
        >>> board = [['X','X','X','X'],['X','O','O','X'],['X','X','O','X'],['X','O','X','X']]
        >>> surrounded_regions(board)
    """
    if not board or not board[0]:
        return
    
    m, n = len(board), len(board[0])
    
    def dfs(i: int, j: int):
        """DFS标记与边界相连的'O'"""
        if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':
            return
        
        board[i][j] = '#'
        dfs(i + 1, j)
        dfs(i - 1, j)
        dfs(i, j + 1)
        dfs(i, j - 1)
    
    # 从四个边界开始DFS
    for i in range(m):
        dfs(i, 0)
        dfs(i, n - 1)
    for j in range(n):
        dfs(0, j)
        dfs(m - 1, j)
    
    # 将'O'改为'X'，将'#'改回'O'
    for i in range(m):
        for j in range(n):
            if board[i][j] == 'O':
                board[i][j] = 'X'
            elif board[i][j] == '#':
                board[i][j] = 'O'


# 自动生成Solution类（无需手动编写）
Solution = create_solution(surrounded_regions)
