# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2165
标题: Plates Between Candles
难度: medium
链接: https://leetcode.cn/problems/plates-between-candles/
题目类型: 数组、字符串、二分查找、前缀和
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2055. 蜡烛之间的盘子 - 给你一个长桌子，桌子上盘子和蜡烛排成一列。给你一个下标从 0 开始的字符串 s ，它只包含字符 '*' 和 '|' ，其中 '*' 表示一个 盘子 ，'|' 表示一支 蜡烛 。 同时给你一个下标从 0 开始的二维整数数组 queries ，其中 queries[i] = [lefti, righti] 表示 子字符串 s[lefti...righti] （包含左右端点的字符）。对于每个查询，你需要找到 子字符串中 在 两支蜡烛之间 的盘子的 数目 。如果一个盘子在 子字符串中 左边和右边 都 至少有一支蜡烛，那么这个盘子满足在 两支蜡烛之间 。 * 比方说，s = "||**||**|*" ，查询 [3, 8] ，表示的是子字符串 "*||**|" 。子字符串中在两支蜡烛之间的盘子数目为 2 ，子字符串中右边两个盘子在它们左边和右边 都 至少有一支蜡烛。 请你返回一个整数数组 answer ，其中 answer[i] 是第 i 个查询的答案。 示例 1: ex-1 [https://assets.leetcode.com/uploads/2021/10/04/ex-1.png] 输入：s = "**|**|***|", queries = [[2,5],[5,9]] 输出：[2,3] 解释： - queries[0] 有两个盘子在蜡烛之间。 - queries[1] 有三个盘子在蜡烛之间。 示例 2: ex-2 [https://assets.leetcode.com/uploads/2021/10/04/ex-2.png] 输入：s = "***|**|*****|**||**|*", queries = [[1,17],[4,5],[14,17],[5,11],[15,16]] 输出：[9,0,0,0,0] 解释： - queries[0] 有 9 个盘子在蜡烛之间。 - 另一个查询没有盘子在蜡烛之间。 提示： * 3 <= s.length <= 105 * s 只包含字符 '*' 和 '|' 。 * 1 <= queries.length <= 105 * queries[i].length == 2 * 0 <= lefti <= righti < s.length
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用前缀和和二分查找来高效地解决这个问题。

算法步骤:
1. 计算所有蜡烛的位置。
2. 计算前缀和数组，记录每个位置之前有多少个盘子。
3. 对于每个查询，使用二分查找找到最近的左侧和右侧蜡烛位置。
4. 通过前缀和数组计算在两支蜡烛之间的盘子数量。

关键点:
- 前缀和数组可以快速计算任意区间内的盘子数量。
- 二分查找可以快速找到最近的蜡烛位置。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n + q log n)，其中 n 是字符串 s 的长度，q 是查询的数量。
空间复杂度: O(n)，用于存储前缀和数组和蜡烛位置。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import bisect

def plates_between_candles(s: str, queries: List[List[int]]) -> List[int]:
    n = len(s)
    prefix_sum = [0] * (n + 1)
    candles = []
    
    # 计算前缀和数组和蜡烛位置
    for i in range(n):
        if s[i] == '*':
            prefix_sum[i + 1] = prefix_sum[i] + 1
        else:
            prefix_sum[i + 1] = prefix_sum[i]
            candles.append(i)
    
    result = []
    for left, right in queries:
        # 使用二分查找找到最近的左侧和右侧蜡烛位置
        left_candle = bisect.bisect_left(candles, left)
        right_candle = bisect.bisect_right(candles, right) - 1
        
        if left_candle < len(candles) and right_candle >= 0 and left_candle <= right_candle:
            # 计算在两支蜡烛之间的盘子数量
            result.append(prefix_sum[candles[right_candle] + 1] - prefix_sum[candles[left_candle]])
        else:
            result.append(0)
    
    return result

Solution = create_solution(plates_between_candles)