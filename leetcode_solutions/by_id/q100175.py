# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 100175
标题: List of Depth LCCI
难度: medium
链接: https://leetcode.cn/problems/list-of-depth-lcci/
题目类型: 树、广度优先搜索、链表、二叉树
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
面试题 04.03. 特定深度节点链表 - 给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 D，则会创建出 D 个链表）。返回一个包含所有深度的链表的数组。 示例： 输入：[1,2,3,4,5,null,7,8] 1 / \ 2 3 / \ \ 4 5 7 / 8 输出：[[1],[2,3],[4,5,7],[8]]
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用广度优先搜索 (BFS) 来遍历每一层的节点，并将每一层的节点构造成链表。

算法步骤:
1. 初始化一个队列，将根节点加入队列。
2. 进行 BFS 遍历，每次处理一层的所有节点。
3. 对于每一层的节点，构造一个链表，并将链表头节点加入结果列表。
4. 将当前层的所有子节点加入队列，继续处理下一层。
5. 返回结果列表。

关键点:
- 使用队列进行层次遍历。
- 每一层的节点构造成链表。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是二叉树的节点数。每个节点只会被访问一次。
空间复杂度: O(n)，队列中最多存储 n/2 个节点（完全二叉树的最后一层）。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def list_of_depth(root: Optional[TreeNode]) -> List[ListNode]:
    """
    函数式接口 - 创建含有某一深度上所有节点的链表
    """
    if not root:
        return []

    result = []
    queue = [root]

    while queue:
        level_size = len(queue)
        dummy = ListNode(0)
        current = dummy

        for _ in range(level_size):
            node = queue.pop(0)
            current.next = ListNode(node.val)
            current = current.next

            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

        result.append(dummy.next)

    return result


Solution = create_solution(list_of_depth)