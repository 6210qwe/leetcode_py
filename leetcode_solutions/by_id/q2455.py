# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2455
标题: Node With Highest Edge Score
难度: medium
链接: https://leetcode.cn/problems/node-with-highest-edge-score/
题目类型: 图、哈希表
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2374. 边积分最高的节点 - 给你一个有向图，图中有 n 个节点，节点编号从 0 到 n - 1 ，其中每个节点都 恰有一条 出边。 图由一个下标从 0 开始、长度为 n 的整数数组 edges 表示，其中 edges[i] 表示存在一条从节点 i 到节点 edges[i] 的 有向 边。 节点 i 的 边积分 定义为：所有存在一条指向节点 i 的边的节点的 编号 总和。 返回 边积分 最高的节点。如果多个节点的 边积分 相同，返回编号 最小 的那个。 示例 1： [https://assets.leetcode.com/uploads/2022/06/20/image-20220620195403-1.png] 输入：edges = [1,0,0,0,0,7,7,5] 输出：7 解释： - 节点 1、2、3 和 4 都有指向节点 0 的边，节点 0 的边积分等于 1 + 2 + 3 + 4 = 10 。 - 节点 0 有一条指向节点 1 的边，节点 1 的边积分等于 0 。 - 节点 7 有一条指向节点 5 的边，节点 5 的边积分等于 7 。 - 节点 5 和 6 都有指向节点 7 的边，节点 7 的边积分等于 5 + 6 = 11 。 节点 7 的边积分最高，所以返回 7 。 示例 2： [https://assets.leetcode.com/uploads/2022/06/20/image-20220620200212-3.png] 输入：edges = [2,0,0,2] 输出：0 解释： - 节点 1 和 2 都有指向节点 0 的边，节点 0 的边积分等于 1 + 2 = 3 。 - 节点 0 和 3 都有指向节点 2 的边，节点 2 的边积分等于 0 + 3 = 3 。 节点 0 和 2 的边积分都是 3 。由于节点 0 的编号更小，返回 0 。 提示： * n == edges.length * 2 <= n <= 105 * 0 <= edges[i] < n * edges[i] != i
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用一个哈希表来记录每个节点的边积分，然后遍历哈希表找到边积分最高的节点。

算法步骤:
1. 初始化一个哈希表 `edge_scores`，用于存储每个节点的边积分。
2. 遍历 `edges` 数组，对于每个节点 `i`，将其编号 `i` 加到 `edges[i]` 对应的边积分中。
3. 遍历 `edge_scores` 哈希表，找到边积分最高的节点。如果有多个节点的边积分相同，选择编号最小的那个。

关键点:
- 使用哈希表来高效地记录和查找每个节点的边积分。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是 `edges` 的长度。我们需要遍历 `edges` 数组一次，并遍历哈希表一次。
空间复杂度: O(n)，哈希表 `edge_scores` 在最坏情况下需要存储 n 个节点的边积分。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def solution_function_name(edges: List[int]) -> int:
    """
    函数式接口 - 找到边积分最高的节点
    """
    # 初始化哈希表来记录每个节点的边积分
    edge_scores = {}
    
    # 遍历 edges 数组，计算每个节点的边积分
    for i, edge in enumerate(edges):
        if edge not in edge_scores:
            edge_scores[edge] = 0
        edge_scores[edge] += i
    
    # 找到边积分最高的节点
    max_score = -1
    max_node = -1
    for node, score in edge_scores.items():
        if score > max_score or (score == max_score and node < max_node):
            max_score = score
            max_node = node
    
    return max_node


Solution = create_solution(solution_function_name)