# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 87
标题: Scramble String
难度: hard
链接: https://leetcode.cn/problems/scramble-string/
题目类型: 字符串、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
87. 扰乱字符串 - 使用下面描述的算法可以扰乱字符串 s 得到字符串 t ： 1. 如果字符串的长度为 1 ，算法停止 2. 如果字符串的长度 > 1 ，执行下述步骤： * 在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 s ，则可以将其分成两个子字符串 x 和 y ，且满足 s = x + y 。 * 随机 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，s 可能是 s = x + y 或者 s = y + x 。 * 在 x 和 y 这两个子字符串上继续从步骤 1 开始递归执行此算法。 给你两个 长度相等 的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。如果是，返回 true ；否则，返回 false 。 示例 1： 输入：s1 = "great", s2 = "rgeat" 输出：true 解释：s1 上可能发生的一种情形是： "great" --> "gr/eat" // 在一个随机下标处分割得到两个子字符串 "gr/eat" --> "gr/eat" // 随机决定：「保持这两个子字符串的顺序不变」 "gr/eat" --> "g/r / e/at" // 在子字符串上递归执行此算法。两个子字符串分别在随机下标处进行一轮分割 "g/r / e/at" --> "r/g / e/at" // 随机决定：第一组「交换两个子字符串」，第二组「保持这两个子字符串的顺序不变」 "r/g / e/at" --> "r/g / e/ a/t" // 继续递归执行此算法，将 "at" 分割得到 "a/t" "r/g / e/ a/t" --> "r/g / e/ a/t" // 随机决定：「保持这两个子字符串的顺序不变」 算法终止，结果字符串和 s2 相同，都是 "rgeat" 这是一种能够扰乱 s1 得到 s2 的情形，可以认为 s2 是 s1 的扰乱字符串，返回 true 示例 2： 输入：s1 = "abcde", s2 = "caebd" 输出：false 示例 3： 输入：s1 = "a", s2 = "a" 输出：true 提示： * s1.length == s2.length * 1 <= s1.length <= 30 * s1 和 s2 由小写英文字母组成
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 动态规划，dp[i][j][len]表示s1从i开始、s2从j开始、长度为len的子串是否匹配

算法步骤:
1. 如果s1 == s2，返回True
2. 如果s1和s2的字符组成不同，返回False
3. 对于每个分割点k（1到n-1）：
   - 不交换：s1[0:k]匹配s2[0:k]且s1[k:]匹配s2[k:]
   - 交换：s1[0:k]匹配s2[n-k:]且s1[k:]匹配s2[0:n-k]
4. 如果任一情况匹配，返回True

关键点:
- 使用记忆化搜索避免重复计算
- 先检查字符组成，快速剪枝
- 时间复杂度O(n^4)，空间复杂度O(n^3)
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^4) - 需要检查所有可能的分割和子串
空间复杂度: O(n^3) - 记忆化数组的大小
"""

# ============================================================================
# 代码实现
# ============================================================================

from functools import lru_cache
from leetcode_solutions.utils.solution import create_solution


def is_scramble(s1: str, s2: str) -> bool:
    """
    函数式接口 - 动态规划（记忆化搜索）
    
    实现思路:
    使用动态规划和记忆化搜索，检查s2是否是s1的扰乱字符串。
    
    Args:
        s1: 第一个字符串
        s2: 第二个字符串
        
    Returns:
        如果s2是s1的扰乱字符串返回True，否则返回False
        
    Example:
        >>> is_scramble("great", "rgeat")
        True
    """
    @lru_cache(maxsize=None)
    def dp(i1: int, i2: int, length: int) -> bool:
        """检查s1[i1:i1+length]和s2[i2:i2+length]是否匹配"""
        # 如果长度为1，直接比较
        if length == 1:
            return s1[i1] == s2[i2]
        
        # 检查字符组成是否相同
        if sorted(s1[i1:i1+length]) != sorted(s2[i2:i2+length]):
            return False
        
        # 尝试所有可能的分割点
        for k in range(1, length):
            # 不交换：s1的前k个匹配s2的前k个，s1的后length-k个匹配s2的后length-k个
            if dp(i1, i2, k) and dp(i1 + k, i2 + k, length - k):
                return True
            # 交换：s1的前k个匹配s2的后k个，s1的后length-k个匹配s2的前length-k个
            if dp(i1, i2 + length - k, k) and dp(i1 + k, i2, length - k):
                return True
        
        return False
    
    if len(s1) != len(s2):
        return False
    
    return dp(0, 0, len(s1))


# 自动生成Solution类（无需手动编写）
Solution = create_solution(is_scramble)
