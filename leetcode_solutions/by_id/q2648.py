# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2648
标题: Number of Ways to Earn Points
难度: hard
链接: https://leetcode.cn/problems/number-of-ways-to-earn-points/
题目类型: 数组、动态规划
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2585. 获得分数的方法数 - 考试中有 n 种类型的题目。给你一个整数 target 和一个下标从 0 开始的二维整数数组 types ，其中 types[i] = [counti, marksi] 表示第 i 种类型的题目有 counti 道，每道题目对应 marksi 分。 返回你在考试中恰好得到 target 分的方法数。由于答案可能很大，结果需要对 109 +7 取余。 注意，同类型题目无法区分。 * 比如说，如果有 3 道同类型题目，那么解答第 1 和第 2 道题目与解答第 1 和第 3 道题目或者第 2 和第 3 道题目是相同的。 示例 1： 输入：target = 6, types = [[6,1],[3,2],[2,3]] 输出：7 解释：要获得 6 分，你可以选择以下七种方法之一： - 解决 6 道第 0 种类型的题目：1 + 1 + 1 + 1 + 1 + 1 = 6 - 解决 4 道第 0 种类型的题目和 1 道第 1 种类型的题目：1 + 1 + 1 + 1 + 2 = 6 - 解决 2 道第 0 种类型的题目和 2 道第 1 种类型的题目：1 + 1 + 2 + 2 = 6 - 解决 3 道第 0 种类型的题目和 1 道第 2 种类型的题目：1 + 1 + 1 + 3 = 6 - 解决 1 道第 0 种类型的题目、1 道第 1 种类型的题目和 1 道第 2 种类型的题目：1 + 2 + 3 = 6 - 解决 3 道第 1 种类型的题目：2 + 2 + 2 = 6 - 解决 2 道第 2 种类型的题目：3 + 3 = 6 示例 2： 输入：target = 5, types = [[50,1],[50,2],[50,5]] 输出：4 解释：要获得 5 分，你可以选择以下四种方法之一： - 解决 5 道第 0 种类型的题目：1 + 1 + 1 + 1 + 1 = 5 - 解决 3 道第 0 种类型的题目和 1 道第 1 种类型的题目：1 + 1 + 1 + 2 = 5 - 解决 1 道第 0 种类型的题目和 2 道第 1 种类型的题目：1 + 2 + 2 = 5 - 解决 1 道第 2 种类型的题目：5 示例 3： 输入：target = 18, types = [[6,1],[3,2],[2,3]] 输出：1 解释：只有回答所有题目才能获得 18 分。 提示： * 1 <= target <= 1000 * n == types.length * 1 <= n <= 50 * types[i].length == 2 * 1 <= counti, marksi <= 50
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。我们定义 dp[i][j] 为前 i 种题目中恰好得到 j 分的方法数。对于每种题目，我们可以选择做 0 到 counti 道题目，更新 dp 数组。

算法步骤:
1. 初始化 dp 数组，dp[0][0] = 1，表示没有题目时，得分为 0 的方法数为 1。
2. 遍历每种题目，对于每种题目，遍历当前得分 j 从 target 到 0，更新 dp 数组。
3. 对于每种题目，遍历可以做的题目数量 k，更新 dp 数组。
4. 最终结果为 dp[n][target]。

关键点:
- 动态规划的状态转移方程为 dp[i][j] = (dp[i][j] + dp[i-1][j - k * marks]) % MOD，其中 k 是可以选择的题目数量。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * target * max_count)，其中 n 是题目的种类数，target 是目标分数，max_count 是每种题目最多可以做的题目数量。
空间复杂度: O(n * target)，用于存储 dp 数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def ways_to_earn_points(target: int, types: List[List[int]]) -> int:
    MOD = 10**9 + 7
    n = len(types)
    dp = [[0] * (target + 1) for _ in range(n + 1)]
    dp[0][0] = 1

    for i in range(1, n + 1):
        count, marks = types[i - 1]
        for j in range(target + 1):
            dp[i][j] = dp[i - 1][j]
            for k in range(1, count + 1):
                if j >= k * marks:
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - k * marks]) % MOD

    return dp[n][target]

Solution = create_solution(ways_to_earn_points)