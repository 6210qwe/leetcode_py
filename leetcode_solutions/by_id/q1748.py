# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1748
标题: Best Team With No Conflicts
难度: medium
链接: https://leetcode.cn/problems/best-team-with-no-conflicts/
题目类型: 数组、动态规划、排序
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1626. 无矛盾的最佳球队 - 假设你是球队的经理。对于即将到来的锦标赛，你想组合一支总体得分最高的球队。球队的得分是球队中所有球员的分数 总和 。 然而，球队中的矛盾会限制球员的发挥，所以必须选出一支 没有矛盾 的球队。如果一名年龄较小球员的分数 严格大于 一名年龄较大的球员，则存在矛盾。同龄球员之间不会发生矛盾。 给你两个列表 scores 和 ages，其中每组 scores[i] 和 ages[i] 表示第 i 名球员的分数和年龄。请你返回 所有可能的无矛盾球队中得分最高那支的分数 。 示例 1： 输入：scores = [1,3,5,10,15], ages = [1,2,3,4,5] 输出：34 解释：你可以选中所有球员。 示例 2： 输入：scores = [4,5,6,5], ages = [2,1,2,1] 输出：16 解释：最佳的选择是后 3 名球员。注意，你可以选中多个同龄球员。 示例 3： 输入：scores = [1,2,3,5], ages = [8,9,10,1] 输出：6 解释：最佳的选择是前 3 名球员。 提示： * 1 <= scores.length, ages.length <= 1000 * scores.length == ages.length * 1 <= scores[i] <= 106 * 1 <= ages[i] <= 1000
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用动态规划来解决这个问题。首先将球员按年龄和分数排序，然后使用动态规划来计算最大得分。

算法步骤:
1. 将球员按年龄升序排序，如果年龄相同则按分数升序排序。
2. 初始化一个动态规划数组 dp，dp[i] 表示以第 i 个球员为结尾的最大得分。
3. 遍历每个球员，对于每个球员 j，遍历其之前的所有球员 i，如果球员 j 的分数大于等于球员 i 的分数，则更新 dp[j]。
4. 最后返回 dp 数组中的最大值。

关键点:
- 排序确保了年龄较小的球员在前面，这样可以避免矛盾。
- 动态规划数组 dp 用于记录以每个球员为结尾的最大得分。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n^2)，其中 n 是球员的数量。排序的时间复杂度是 O(n log n)，动态规划的时间复杂度是 O(n^2)。
空间复杂度: O(n)，需要一个长度为 n 的动态规划数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def best_team_score(scores: List[int], ages: List[int]) -> int:
    """
    返回所有可能的无矛盾球队中得分最高那支的分数。
    """
    # 将球员按年龄升序排序，如果年龄相同则按分数升序排序
    players = sorted(zip(ages, scores))
    
    n = len(players)
    dp = [0] * n
    
    for i in range(n):
        dp[i] = players[i][1]
        for j in range(i):
            if players[i][1] >= players[j][1]:
                dp[i] = max(dp[i], dp[j] + players[i][1])
    
    return max(dp)

Solution = create_solution(best_team_score)