# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2723
标题: Find the Longest Balanced Substring of a Binary String
难度: easy
链接: https://leetcode.cn/problems/find-the-longest-balanced-substring-of-a-binary-string/
题目类型: 字符串
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2609. 最长平衡子字符串 - 给你一个仅由 0 和 1 组成的二进制字符串 s 。 如果子字符串中 所有的 0 都在 1 之前 且其中 0 的数量等于 1 的数量，则认为 s 的这个子字符串是平衡子字符串。请注意，空子字符串也视作平衡子字符串。 返回 s 中最长的平衡子字符串长度。 子字符串是字符串中的一个连续字符序列。 示例 1： 输入：s = "01000111" 输出：6 解释：最长的平衡子字符串是 "000111" ，长度为 6 。 示例 2： 输入：s = "00111" 输出：4 解释：最长的平衡子字符串是 "0011" ，长度为 4 。 示例 3： 输入：s = "111" 输出：0 解释：除了空子字符串之外不存在其他平衡子字符串，所以答案为 0 。 提示： * 1 <= s.length <= 50 * '0' <= s[i] <= '1'
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用双指针法遍历字符串，记录每个平衡子字符串的长度，并更新最大长度。

算法步骤:
1. 初始化两个指针 `i` 和 `j`，分别指向当前子字符串的起始和结束位置。
2. 遍历字符串，当遇到 '0' 时，继续向前移动 `i` 指针，直到遇到 '1' 或到达字符串末尾。
3. 当遇到 '1' 时，继续向前移动 `j` 指针，直到遇到 '0' 或到达字符串末尾。
4. 计算当前平衡子字符串的长度，并更新最大长度。
5. 重复上述步骤，直到遍历完整个字符串。

关键点:
- 使用双指针法可以有效地找到所有可能的平衡子字符串。
- 在每次找到平衡子字符串后，更新最大长度。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是字符串 s 的长度。我们只需要一次遍历字符串。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def find_longest_balanced_substring(s: str) -> int:
    """
    函数式接口 - 找到最长的平衡子字符串长度
    """
    max_length = 0
    i = 0
    
    while i < len(s):
        # 跳过所有的 '0'
        zeros = 0
        while i < len(s) and s[i] == '0':
            zeros += 1
            i += 1
        
        # 跳过所有的 '1'
        ones = 0
        while i < len(s) and s[i] == '1':
            ones += 1
            i += 1
        
        # 更新最大长度
        balanced_length = min(zeros, ones) * 2
        max_length = max(max_length, balanced_length)
    
    return max_length


Solution = create_solution(find_longest_balanced_substring)