# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 100163
标题: Remove Duplicate Node LCCI
难度: easy
链接: https://leetcode.cn/problems/remove-duplicate-node-lcci/
题目类型: 哈希表、链表、双指针
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
面试题 02.01. 移除重复节点 - 编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。 示例1： 输入：[1, 2, 3, 3, 2, 1] 输出：[1, 2, 3] 示例2： 输入：[1, 1, 1, 1, 2] 输出：[1, 2] 提示： 1. 链表长度在[0, 20000]范围内。 2. 链表元素在[0, 20000]范围内。 进阶： 如果不得使用临时缓冲区，该怎么解决？
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用哈希表记录已经访问过的节点值，以便在遍历时快速判断是否为重复节点。

算法步骤:
1. 初始化一个哈希表 `seen` 用于存储已访问的节点值。
2. 使用两个指针 `prev` 和 `curr` 分别指向当前节点的前一个节点和当前节点。
3. 遍历链表：
   - 如果当前节点的值不在 `seen` 中，将其值加入 `seen`，并移动 `prev` 和 `curr` 指针。
   - 如果当前节点的值已经在 `seen` 中，删除当前节点，并移动 `curr` 指针。
4. 返回处理后的链表头节点。

关键点:
- 使用哈希表来记录已访问的节点值，确保时间复杂度为 O(n)。
- 使用双指针遍历链表，方便删除重复节点。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是链表的长度。每个节点最多被访问一次。
空间复杂度: O(n)，哈希表 `seen` 在最坏情况下需要存储所有节点的值。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def remove_duplicate_nodes(head: Optional[ListNode]) -> Optional[ListNode]:
    """
    函数式接口 - 移除未排序链表中的重复节点
    """
    if not head:
        return None

    seen = set()
    seen.add(head.val)
    prev = head
    curr = head.next

    while curr:
        if curr.val in seen:
            # 删除当前节点
            prev.next = curr.next
        else:
            seen.add(curr.val)
            prev = curr
        curr = curr.next

    return head


Solution = create_solution(remove_duplicate_nodes)