# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3610
标题: Find X-Sum of All K-Long Subarrays I
难度: easy
链接: https://leetcode.cn/problems/find-x-sum-of-all-k-long-subarrays-i/
题目类型: 数组、哈希表、滑动窗口、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
3318. 计算子数组的 x-sum I - 给你一个由 n 个整数组成的数组 nums，以及两个整数 k 和 x。 数组的 x-sum 计算按照以下步骤进行： * 统计数组中所有元素的出现次数。 * 仅保留出现频率最高的前 x 种元素。如果两种元素的出现次数相同，则数值 较大 的元素被认为出现次数更多。 * 计算结果数组的和。 注意，如果数组中的不同元素少于 x 个，则其 x-sum 是数组的元素总和。 返回一个长度为 n - k + 1 的整数数组 answer，其中 answer[i] 是 子数组 nums[i..i + k - 1] 的 x-sum。 子数组 是数组内的一个连续 非空 的元素序列。 示例 1： 输入：nums = [1,1,2,2,3,4,2,3], k = 6, x = 2 输出：[6,10,12] 解释： * 对于子数组 [1, 1, 2, 2, 3, 4]，只保留元素 1 和 2。因此，answer[0] = 1 + 1 + 2 + 2。 * 对于子数组 [1, 2, 2, 3, 4, 2]，只保留元素 2 和 4。因此，answer[1] = 2 + 2 + 2 + 4。注意 4 被保留是因为其数值大于出现其他出现次数相同的元素（3 和 1）。 * 对于子数组 [2, 2, 3, 4, 2, 3]，只保留元素 2 和 3。因此，answer[2] = 2 + 2 + 2 + 3 + 3。 示例 2： 输入：nums = [3,8,7,8,7,5], k = 2, x = 2 输出：[11,15,15,15,12] 解释： 由于 k == x，answer[i] 等于子数组 nums[i..i + k - 1] 的总和。 提示： * 1 <= n == nums.length <= 50 * 1 <= nums[i] <= 50 * 1 <= x <= k <= nums.length
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用滑动窗口和最大堆来维护每个子数组的 x-sum。

算法步骤:
1. 初始化一个滑动窗口和一个最大堆。
2. 滑动窗口从左到右遍历数组，更新窗口内的元素频率。
3. 使用最大堆来维护频率最高的前 x 个元素。
4. 对于每个窗口，计算 x-sum 并将其添加到结果数组中。
5. 更新滑动窗口时，移除左侧元素并添加右侧元素，同时更新最大堆。

关键点:
- 使用滑动窗口来高效地处理子数组。
- 使用最大堆来维护频率最高的前 x 个元素。
- 在滑动窗口移动时，动态更新最大堆。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log x)，其中 n 是数组长度，x 是需要保留的元素数量。每次插入和删除堆的操作时间复杂度为 O(log x)。
空间复杂度: O(k)，其中 k 是子数组的长度。滑动窗口和最大堆的空间复杂度为 O(k)。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def find_x_sum_subarrays(nums: List[int], k: int, x: int) -> List[int]:
    def get_x_sum(freq):
        # 获取频率最高的前 x 个元素的和
        max_heap = [(-freq[num], num) for num in freq]
        heapq.heapify(max_heap)
        x_sum = 0
        for _ in range(x):
            if not max_heap:
                break
            _, num = heapq.heappop(max_heap)
            x_sum += num
        return x_sum

    n = len(nums)
    result = []
    freq = {}
    
    # 初始化滑动窗口
    for i in range(k):
        freq[nums[i]] = freq.get(nums[i], 0) + 1
    
    # 计算第一个窗口的 x-sum
    result.append(get_x_sum(freq))
    
    # 滑动窗口
    for i in range(k, n):
        # 移除左侧元素
        freq[nums[i - k]] -= 1
        if freq[nums[i - k]] == 0:
            del freq[nums[i - k]]
        
        # 添加右侧元素
        freq[nums[i]] = freq.get(nums[i], 0) + 1
        
        # 计算当前窗口的 x-sum
        result.append(get_x_sum(freq))
    
    return result

Solution = create_solution(find_x_sum_subarrays)