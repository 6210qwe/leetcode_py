# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 764
标题: N-ary Tree Level Order Traversal
难度: medium
链接: https://leetcode.cn/problems/n-ary-tree-level-order-traversal/
题目类型: 树、广度优先搜索
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
429. N 叉树的层序遍历 - 给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。 树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。 示例 1： [https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png] 输入：root = [1,null,3,2,4,null,5,6] 输出：[[1],[3,2,4],[5,6]] 示例 2： [https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png] 输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] 输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]] 提示： * 树的高度不会超过 1000 * 树的节点总数在 [0, 104] 之间
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用广度优先搜索（BFS）进行层序遍历。

算法步骤:
1. 初始化一个队列，将根节点加入队列。
2. 当队列不为空时，依次处理每一层的节点：
   - 记录当前层的节点数。
   - 遍历当前层的所有节点，将它们的值加入当前层的结果列表中，并将它们的子节点加入队列。
   - 将当前层的结果列表加入最终结果列表。
3. 返回最终结果列表。

关键点:
- 使用队列进行层次遍历。
- 每次处理一层节点，确保按层顺序输出。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中 n 是节点总数。每个节点都被访问一次。
空间复杂度: O(n)，队列在最坏情况下需要存储所有节点。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.tree import Node
from leetcode_solutions.utils.solution import create_solution


def levelOrder(root: 'Node') -> List[List[int]]:
    """
    函数式接口 - 返回 N 叉树的层序遍历结果
    """
    if not root:
        return []

    result = []
    queue = [root]

    while queue:
        level_size = len(queue)
        level_nodes = []

        for _ in range(level_size):
            node = queue.pop(0)
            level_nodes.append(node.val)
            queue.extend(node.children)

        result.append(level_nodes)

    return result


Solution = create_solution(levelOrder)