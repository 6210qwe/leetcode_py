# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 907
标题: Koko Eating Bananas
难度: medium
链接: https://leetcode.cn/problems/koko-eating-bananas/
题目类型: 数组、二分查找
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
875. 爱吃香蕉的珂珂 - 珂珂喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 h 小时后回来。 珂珂可以决定她吃香蕉的速度 k （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。 珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。 返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。 示例 1： 输入：piles = [3,6,7,11], h = 8 输出：4 示例 2： 输入：piles = [30,11,23,4,20], h = 5 输出：30 示例 3： 输入：piles = [30,11,23,4,20], h = 6 输出：23 提示： * 1 <= piles.length <= 104 * piles.length <= h <= 109 * 1 <= piles[i] <= 109
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用二分查找来找到最小的吃香蕉速度 k，使得珂珂能在 h 小时内吃完所有香蕉。

算法步骤:
1. 初始化二分查找的左右边界，left 为 1，right 为 piles 中的最大值。
2. 在每次迭代中，计算中间值 mid，并计算以速度 mid 吃完所有香蕉所需的总时间。
3. 如果总时间小于等于 h，则说明速度可以更慢，更新 right 为 mid。
4. 否则，更新 left 为 mid + 1。
5. 当 left 等于 right 时，返回 left 作为结果。

关键点:
- 使用二分查找来缩小搜索范围，从而找到最小的吃香蕉速度。
- 计算以某个速度吃香蕉所需的时间时，使用 (pile - 1) // speed + 1 来计算每堆香蕉所需的时间。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log m)，其中 n 是 piles 的长度，m 是 piles 中的最大值。
空间复杂度: O(1)，只使用了常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def minEatingSpeed(piles: List[int], h: int) -> int:
    """
    函数式接口 - 返回珂珂在 h 小时内吃掉所有香蕉的最小速度 k
    """
    # 初始化二分查找的左右边界
    left, right = 1, max(piles)
    
    while left < right:
        mid = (left + right) // 2
        total_hours = sum((pile - 1) // mid + 1 for pile in piles)
        
        if total_hours <= h:
            right = mid
        else:
            left = mid + 1
    
    return left

Solution = create_solution(minEatingSpeed)