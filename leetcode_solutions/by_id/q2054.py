# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 2054
标题: The Number of the Smallest Unoccupied Chair
难度: medium
链接: https://leetcode.cn/problems/the-number-of-the-smallest-unoccupied-chair/
题目类型: 数组、哈希表、堆（优先队列）
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1942. 最小未被占据椅子的编号 - 有 n 个朋友在举办一个派对，这些朋友从 0 到 n - 1 编号。派对里有 无数 张椅子，编号为 0 到 infinity 。当一个朋友到达派对时，他会占据 编号最小 且未被占据的椅子。 * 比方说，当一个朋友到达时，如果椅子 0 ，1 和 5 被占据了，那么他会占据 2 号椅子。 当一个朋友离开派对时，他的椅子会立刻变成未占据状态。如果同一时刻有另一个朋友到达，可以立即占据这张椅子。 给你一个下标从 0 开始的二维整数数组 times ，其中 times[i] = [arrivali, leavingi] 表示第 i 个朋友到达和离开的时刻，同时给你一个整数 targetFriend 。所有到达时间 互不相同 。 请你返回编号为 targetFriend 的朋友占据的 椅子编号 。 示例 1： 输入：times = [[1,4],[2,3],[4,6]], targetFriend = 1 输出：1 解释： - 朋友 0 时刻 1 到达，占据椅子 0 。 - 朋友 1 时刻 2 到达，占据椅子 1 。 - 朋友 1 时刻 3 离开，椅子 1 变成未占据。 - 朋友 0 时刻 4 离开，椅子 0 变成未占据。 - 朋友 2 时刻 4 到达，占据椅子 0 。 朋友 1 占据椅子 1 ，所以返回 1 。 示例 2： 输入：times = [[3,10],[1,5],[2,6]], targetFriend = 0 输出：2 解释： - 朋友 1 时刻 1 到达，占据椅子 0 。 - 朋友 2 时刻 2 到达，占据椅子 1 。 - 朋友 0 时刻 3 到达，占据椅子 2 。 - 朋友 1 时刻 5 离开，椅子 0 变成未占据。 - 朋友 2 时刻 6 离开，椅子 1 变成未占据。 - 朋友 0 时刻 10 离开，椅子 2 变成未占据。 朋友 0 占据椅子 2 ，所以返回 2 。 提示： * n == times.length * 2 <= n <= 104 * times[i].length == 2 * 1 <= arrivali < leavingi <= 105 * 0 <= targetFriend <= n - 1 * 每个 arrivali 时刻 互不相同 。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用两个优先队列（堆）来分别管理可用的椅子和正在使用的椅子。通过排序事件（到达和离开）来模拟整个过程。

算法步骤:
1. 将所有事件（到达和离开）按时间顺序排序。
2. 初始化两个优先队列：一个用于存储可用的椅子，一个用于存储正在使用的椅子及其离开时间。
3. 遍历排序后的事件：
   - 如果是到达事件，从可用椅子队列中取出最小编号的椅子，并将其加入正在使用的椅子队列。
   - 如果是离开事件，将椅子从正在使用的椅子队列中移除，并将其加入可用椅子队列。
4. 在遍历过程中，记录目标朋友占据的椅子编号。

关键点:
- 使用优先队列高效管理椅子的状态。
- 通过排序事件来模拟时间线上的变化。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log n)，其中 n 是 times 的长度。排序操作的时间复杂度为 O(n log n)，而后续的遍历操作为 O(n)。
空间复杂度: O(n)，需要额外的空间来存储事件和优先队列。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq

def smallest_chair(times: List[List[int]], target_friend: int) -> int:
    events = []
    for i, (arrival, leaving) in enumerate(times):
        events.append((arrival, 'arrive', i))
        events.append((leaving, 'leave', i))
    
    events.sort()
    
    available_chairs = []
    used_chairs = []
    chair_assignment = {}
    
    for time, event_type, friend in events:
        if event_type == 'arrive':
            if available_chairs:
                chair = heapq.heappop(available_chairs)
            else:
                chair = len(used_chairs)
                heapq.heappush(used_chairs, (time, chair))
            
            chair_assignment[friend] = chair
            if friend == target_friend:
                return chair
        else:
            _, chair = heapq.heappop(used_chairs)
            heapq.heappush(available_chairs, chair)

Solution = create_solution(smallest_chair)