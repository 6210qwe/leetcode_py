# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1605
标题: Minimum Number of Days to Make m Bouquets
难度: medium
链接: https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets/
题目类型: 数组、二分查找
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1482. 制作 m 束花所需的最少天数 - 给你一个整数数组 bloomDay，以及两个整数 m 和 k 。 现需要制作 m 束花。制作花束时，需要使用花园中 相邻的 k 朵花 。 花园中有 n 朵花，第 i 朵花会在 bloomDay[i] 时盛开，恰好 可以用于 一束 花中。 请你返回从花园中摘 m 束花需要等待的最少的天数。如果不能摘到 m 束花则返回 -1 。 示例 1： 输入：bloomDay = [1,10,3,10,2], m = 3, k = 1 输出：3 解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。 现在需要制作 3 束花，每束只需要 1 朵。 1 天后：[x, _, _, _, _] // 只能制作 1 束花 2 天后：[x, _, _, _, x] // 只能制作 2 束花 3 天后：[x, _, x, _, x] // 可以制作 3 束花，答案为 3 示例 2： 输入：bloomDay = [1,10,3,10,2], m = 3, k = 2 输出：-1 解释：要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1 。 示例 3： 输入：bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3 输出：12 解释：要制作 2 束花，每束需要 3 朵。 花园在 7 天后和 12 天后的情况如下： 7 天后：[x, x, x, x, _, x, x] 可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。 12 天后：[x, x, x, x, x, x, x] 显然，我们可以用不同的方式制作两束花。 示例 4： 输入：bloomDay = [1000000000,1000000000], m = 1, k = 1 输出：1000000000 解释：需要等 1000000000 天才能采到花来制作花束 示例 5： 输入：bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2 输出：9 提示： * bloomDay.length == n * 1 <= n <= 10^5 * 1 <= bloomDay[i] <= 10^9 * 1 <= m <= 10^6 * 1 <= k <= n
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用二分查找来确定最少的天数。通过二分查找在天数范围内找到最小的天数，使得在该天数内可以制作出 m 束花。

算法步骤:
1. 初始化二分查找的左右边界，left 为 1，right 为 bloomDay 中的最大值。
2. 在 left <= right 的条件下进行二分查找：
   - 计算中间值 mid。
   - 检查在 mid 天内是否可以制作出 m 束花。
   - 如果可以，则将 right 更新为 mid - 1。
   - 如果不可以，则将 left 更新为 mid + 1。
3. 最终返回 left，即为最少的天数。如果 left 超过了 bloomDay 中的最大值，则返回 -1。

关键点:
- 使用二分查找来缩小天数范围。
- 检查在给定天数内是否可以制作出 m 束花。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n log(max(bloomDay)))
空间复杂度: O(1)
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def can_make_bouquets(bloomDay: List[int], days: int, m: int, k: int) -> bool:
    bouquets = 0
    flowers = 0
    for day in bloomDay:
        if day <= days:
            flowers += 1
            if flowers == k:
                bouquets += 1
                flowers = 0
        else:
            flowers = 0
        if bouquets >= m:
            return True
    return False

def min_days_to_make_m_bouquets(bloomDay: List[int], m: int, k: int) -> int:
    if m * k > len(bloomDay):
        return -1
    
    left, right = 1, max(bloomDay)
    
    while left <= right:
        mid = (left + right) // 2
        if can_make_bouquets(bloomDay, mid, m, k):
            right = mid - 1
        else:
            left = mid + 1
    
    return left if left <= max(bloomDay) else -1

Solution = create_solution(min_days_to_make_m_bouquets)