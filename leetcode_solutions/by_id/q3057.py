# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 3057
标题: Count K-Subsequences of a String With Maximum Beauty
难度: hard
链接: https://leetcode.cn/problems/count-k-subsequences-of-a-string-with-maximum-beauty/
题目类型: 贪心、哈希表、数学、字符串、组合数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
2842. 统计一个字符串的 k 子序列美丽值最大的数目 - 给你一个字符串 s 和一个整数 k 。 k 子序列指的是 s 的一个长度为 k 的 子序列 ，且所有字符都是 唯一 的，也就是说每个字符在子序列里只出现过一次。 定义 f(c) 为字符 c 在 s 中出现的次数。 k 子序列的 美丽值 定义为这个子序列中每一个字符 c 的 f(c) 之 和 。 比方说，s = "abbbdd" 和 k = 2 ，我们有： * f('a') = 1, f('b') = 3, f('d') = 2 * s 的部分 k 子序列为： * "abbbdd" -> "ab" ，美丽值为 f('a') + f('b') = 4 * "abbbdd" -> "ad" ，美丽值为 f('a') + f('d') = 3 * "abbbdd" -> "bd" ，美丽值为 f('b') + f('d') = 5 请你返回一个整数，表示所有 k 子序列 里面 美丽值 是 最大值 的子序列数目。由于答案可能很大，将结果对 109 + 7 取余后返回。 一个字符串的子序列指的是从原字符串里面删除一些字符（也可能一个字符也不删除），不改变剩下字符顺序连接得到的新字符串。 注意： * f(c) 指的是字符 c 在字符串 s 的出现次数，不是在 k 子序列里的出现次数。 * 两个 k 子序列如果有任何一个字符在原字符串中的下标不同，则它们是两个不同的子序列。所以两个不同的 k 子序列可能产生相同的字符串。 示例 1： 输入：s = "bcca", k = 2 输出：4 解释：s 中我们有 f('a') = 1 ，f('b') = 1 和 f('c') = 2 。 s 的 k 子序列为： bcca ，美丽值为 f('b') + f('c') = 3 bcca ，美丽值为 f('b') + f('c') = 3 bcca ，美丽值为 f('b') + f('a') = 2 bcca ，美丽值为 f('c') + f('a') = 3 bcca ，美丽值为 f('c') + f('a') = 3 总共有 4 个 k 子序列美丽值为最大值 3 。 所以答案为 4 。 示例 2： 输入：s = "abbcd", k = 4 输出：2 解释：s 中我们有 f('a') = 1 ，f('b') = 2 ，f('c') = 1 和 f('d') = 1 。 s 的 k 子序列为： abbcd ，美丽值为 f('a') + f('b') + f('c') + f('d') = 5 abbcd ，美丽值为 f('a') + f('b') + f('c') + f('d') = 5 总共有 2 个 k 子序列美丽值为最大值 5 。 所以答案为 2 。 提示： * 1 <= s.length <= 2 * 105 * 1 <= k <= s.length * s 只包含小写英文字母。
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过贪心算法选择频率最高的字符来构建子序列，并使用组合数学计算这些子序列的数量。

算法步骤:
1. 统计每个字符的频率。
2. 选择频率最高的 k 个字符。
3. 计算这些字符的所有可能组合的数量。
4. 如果剩余字符数量不足以构成 k 个字符的子序列，则返回 0。

关键点:
- 使用优先队列（堆）来高效地选择频率最高的 k 个字符。
- 使用组合数学公式来计算子序列的数量。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n + k log n)，其中 n 是字符串 s 的长度，k 是子序列的长度。统计字符频率的时间复杂度为 O(n)，选择频率最高的 k 个字符的时间复杂度为 O(k log n)。
空间复杂度: O(n)，用于存储字符频率和中间结果。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List
import heapq
from math import comb

def count_k_subsequences(s: str, k: int) -> int:
    MOD = 10**9 + 7
    if k > 26 or len(s) < k:
        return 0
    
    # 统计每个字符的频率
    freq = [0] * 26
    for char in s:
        freq[ord(char) - ord('a')] += 1
    
    # 选择频率最高的 k 个字符
    max_heap = []
    for i in range(26):
        if freq[i] > 0:
            heapq.heappush(max_heap, (-freq[i], chr(i + ord('a'))))
    
    if len(max_heap) < k:
        return 0
    
    # 计算这些字符的所有可能组合的数量
    result = 1
    for _ in range(k):
        freq, char = heapq.heappop(max_heap)
        result = (result * -freq) % MOD
    
    return result

Solution = create_solution(count_k_subsequences)