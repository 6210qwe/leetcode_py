# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1329
标题: Minimum Cost to Move Chips to The Same Position
难度: easy
链接: https://leetcode.cn/problems/minimum-cost-to-move-chips-to-the-same-position/
题目类型: 贪心、数组、数学
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1217. 玩筹码 - 有 n 个筹码。第 i 个筹码的位置是 position[i] 。 我们需要把所有筹码移到同一个位置。在一步中，我们可以将第 i 个筹码的位置从 position[i] 改变为: * position[i] + 2 或 position[i] - 2 ，此时 cost = 0 * position[i] + 1 或 position[i] - 1 ，此时 cost = 1 返回将所有筹码移动到同一位置上所需要的 最小代价 。 示例 1： [https://assets.leetcode.com/uploads/2020/08/15/chips_e1.jpg] 输入：position = [1,2,3] 输出：1 解释：第一步:将位置3的筹码移动到位置1，成本为0。 第二步:将位置2的筹码移动到位置1，成本= 1。 总成本是1。 示例 2： [https://assets.leetcode.com/uploads/2020/08/15/chip_e2.jpg] 输入：position = [2,2,2,3,3] 输出：2 解释：我们可以把位置3的两个筹码移到位置2。每一步的成本为1。总成本= 2。 示例 3: 输入：position = [1,1000000000] 输出：1 提示： * 1 <= position.length <= 100 * 1 <= position[i] <= 10^9
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 通过计算奇数位置和偶数位置的筹码数量，选择最小的移动代价。

算法步骤:
1. 初始化奇数位置和偶数位置的筹码计数器。
2. 遍历位置数组，更新奇数和偶数位置的筹码计数。
3. 返回奇数位置和偶数位置筹码数量的最小值作为最小移动代价。

关键点:
- 奇数位置和偶数位置的移动代价分别为0和1。
- 选择奇数位置和偶数位置中较小的一个作为最终移动代价。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n)，其中n是position的长度，因为我们需要遍历整个位置数组。
空间复杂度: O(1)，只需要常数级的额外空间。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List, Optional
from leetcode_solutions.utils.linked_list import ListNode
from leetcode_solutions.utils.tree import TreeNode
from leetcode_solutions.utils.solution import create_solution


def min_cost_to_move_chips(position: List[int]) -> int:
    """
    计算将所有筹码移动到同一位置上的最小代价。
    """
    odd_count = 0
    even_count = 0
    
    for pos in position:
        if pos % 2 == 0:
            even_count += 1
        else:
            odd_count += 1
    
    return min(odd_count, even_count)


Solution = create_solution(min_cost_to_move_chips)