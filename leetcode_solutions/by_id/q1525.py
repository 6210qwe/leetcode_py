# -*- coding:utf-8 -*-
# ============================================================================
# 题目信息
# ============================================================================
"""
题号: 1525
标题: Queries on a Permutation With Key
难度: medium
链接: https://leetcode.cn/problems/queries-on-a-permutation-with-key/
题目类型: 树状数组、数组、模拟
"""

# ============================================================================
# 问题描述
# ============================================================================
"""
1409. 查询带键的排列 - 给定一个正整数数组 queries ，其取值范围在 1 到 m 之间。 请你根据以下规则按顺序处理所有 queries[i]（从 i=0 到 i=queries.length-1）： * 首先，你有一个排列 P=[1,2,3,...,m]。 * 对于当前的 i ，找到 queries[i] 在排列 P 中的位置（从 0 开始索引），然后将它移到排列 P 的开头（即下标为 0 处）。注意， queries[i] 的查询结果是 queries[i] 在 P 中移动前的位置。 返回一个数组，包含从给定 queries 中查询到的结果。 示例 1： 输入：queries = [3,1,2,1], m = 5 输出：[2,1,2,1] 解释：处理 queries 的过程如下： 对于 i=0: queries[i]=3, P=[1,2,3,4,5], 3 在 P 中的位置是 2，然后我们把 3 移动到 P 的开头，得到 P=[3,1,2,4,5] 。 对于 i=1: queries[i]=1, P=[3,1,2,4,5], 1 在 P 中的位置是 1，然后我们把 1 移动到 P 的开头，得到 P=[1,3,2,4,5] 。 对于 i=2: queries[i]=2, P=[1,3,2,4,5], 2 在 P 中的位置是 2，然后我们把 2 移动到 P 的开头，得到 P=[2,1,3,4,5] 。 对于 i=3: queries[i]=1, P=[2,1,3,4,5], 1 在 P 中的位置是 1，然后我们把 1 移动到 P 的开头，得到 P=[1,2,3,4,5] 。 因此，包含结果的数组为 [2,1,2,1] 。 示例 2： 输入：queries = [4,1,2,2], m = 4 输出：[3,1,2,0] 示例 3： 输入：queries = [7,5,5,8,3], m = 8 输出：[6,5,0,7,5] 提示： * 1 <= m <= 10^3 * 1 <= queries.length <= m * 1 <= queries[i] <= m
"""

# ============================================================================
# 实现思路
# ============================================================================
"""
核心思想: 使用列表来表示排列 P，并通过索引操作来实现元素的查找和移动。

算法步骤:
1. 初始化排列 P 为 [1, 2, ..., m]。
2. 初始化结果数组 result。
3. 遍历 queries 数组：
   - 找到当前 query 在 P 中的位置。
   - 将该位置添加到结果数组中。
   - 将当前 query 移动到 P 的开头。
4. 返回结果数组。

关键点:
- 使用列表索引来快速查找和移动元素。
"""

# ============================================================================
# 复杂度分析
# ============================================================================
"""
时间复杂度: O(n * m)，其中 n 是 queries 的长度，m 是排列 P 的长度。每次查询需要 O(m) 时间来查找和移动元素。
空间复杂度: O(m)，用于存储排列 P 和结果数组。
"""

# ============================================================================
# 代码实现
# ============================================================================

from typing import List

def process_queries(queries: List[int], m: int) -> List[int]:
    """
    函数式接口 - 处理带键的排列查询
    """
    # 初始化排列 P
    P = list(range(1, m + 1))
    
    # 初始化结果数组
    result = []
    
    # 遍历 queries 数组
    for query in queries:
        # 找到当前 query 在 P 中的位置
        index = P.index(query)
        
        # 将该位置添加到结果数组中
        result.append(index)
        
        # 将当前 query 移动到 P 的开头
        P.insert(0, P.pop(index))
    
    return result

Solution = create_solution(process_queries)